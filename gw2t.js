/*
	GW2Timer.com timer, map, and misc single-page application driver.
	jQuery-dependent (v1.11.0), with other plugins in plugins.js.
	Coded in NetBeans; debugged in Chrome Developer Tools.
	IDE recommended for viewing and collapsing code sections.
	Version: see int_utlProgramVersion - 2014.04.18 created

	LIBRARIES:
	Below are inline libraries, for the rest, see https://gw2timer.com/plugins.js
	Vladimir Agafonkin - LeafletJS map library
	Craig Erskine - qTip tooltip
	David Flanagan - SVG clock based on example from "JavaScript The Definitive Guide 6e"
	Cliff Spradlin - GW2 API Documentation
	Google, ResponsiveVoice.JS, and meSpeak.js - Text-To-Speech service and engine

	CONVENTIONS:
	Local variables are all lower case: examplevariable.
	Instance variables are lower camel case: exampleVariable.
	Global variables are all caps spaced by underscore: EXAMPLE_VARIABLE.
	Constants are camel case and starts with "c": cExampleVariable.
	Objects are camel case: ExampleObject.
	Array names are plural (end with s or es): exampleElements.
	Functions are lower camel case and starts with a verb: getExample().
	Functions that are repeated in milliseconds should use core JS instead of jQuery.
	Arguments in double quotes: $("argument"), single quotes for HTML generation.
	Parameters are camel case and start with "p": function(pExampleParameter).
	Settings inside an object used as a function argument starts with "a", like parameters.
	Properties of returned template objects start with "o", like parameters.
	Parameters inside loops start with "i": forEach(function(iExampleParameter){}).
	CSS classes and IDs are named like instance variables: exampleID.
	Allman indentation (braces align vertically) unless it is repetitive code.
	4 space-size tabs, you are free to Replace All tab characters with spaces.

	TABLE OF CONTENTS (Ctrl+F "AtsignAtsignLetter" to jump to section)

	O - Options for user
	X - Checklists
	U - URL management
	Z - Console commands
	A - Account management
	V - View account information
	B - Bank generation
	Q - Quantity items
	E - Economy Trading Post
	D - Dictionary for translations and speech
	C - Chains events
	M - Map Leaflet
	P - Populate map and GPS
	G - Generated map page content
	W - World vs World
	J - 3D overlay projection
	T - Time utilities and schedule
	H - Dashboard and timeline
	K - Clock ticker
	I - Interface UI

*/

$(window).on("load", function() { "use strict";

/* =============================================================================
 * Single letter objects serve as namespaces.
 * ========================================================================== */
var A, B, C, D, E, G, H, I, J, K, M, O, P, Q, T, U, V, W, X, Z;

O = {
/* =============================================================================
 * @@Options for the user
 * ========================================================================== */

	cLengthOfPrefixes: 3,
	cPrefixOption: "opt_",
	cPrefixLabel: "lbl_",
	legalLocalStorageKeys: {},
	isServerReset: false,

	/*
	 * These utility variables will also be stored in localStorage.
	 * O.Utilities, O.Options, and X.Checklists/Textlists share a namespace in
	 * localStorage and must together have unique variable names.
	 */
	Utilities:
	{
		programVersion: {key: "int_utlProgramVersion", value: 180721}, // 171202 is before https transition
		buildVersion: {key: "int_utlBuildVersion", value: 0},
		timestampDaily: {key: "int_utlTimestampDaily", value: 0},
		timestampWeekly: {key: "int_utlTimestampWeekly", value: 0},
		APITokens: {key: "obj_utlAPITokens", value: []},
		APICache: {key: "obj_utlAPICache", value: {}},
		AuditHistory: {key: "obj_utlAuditHistory", value: {}},
		CustomCatalog: {key: "obj_utlCustomCatalog", value: []},
		GemSubscription: {key: "obj_utlGemSubscription", value: {}},
		BackupPins: {key: "obj_utlBackupPins", value: []},
		BackupPinsWvW: {key: "obj_utlBackupPinsWvW", value: []},
		BackupCompasses: {key: "obj_utlBackupCompasses", value: []},
		BackupCompassesWvW: {key: "obj_utlBackupCompassesWvW", value: []},
		StoredPins: {key: "obj_utlStoredPins", value: []},
		StoredPinsWvW: {key: "obj_utlStoredPinsWvW", value: []},
		StoredCompasses: {key: "obj_utlStoredCompasses", value: []},
		StoredCompassesWvW: {key: "obj_utlStoredCompassesWvW", value: []}
	},
	
	/*
	 * Updates and notifies user of version change.
	 */
	enforceProgramVersion: function()
	{
		var currentversion = O.Utilities.programVersion.value;
		var usersversion = parseInt(localStorage[O.Utilities.programVersion.key]);
		// If is a major version, not first visit, and version is mismatch, then notify new version
		if (isFinite(usersversion) && usersversion !== currentversion)
		{
			var wait = (I.ModeCurrent === I.ModeEnum.Overlay) ? 15 : 30;
			I.clear();
			I.greet(I.cSiteName + " was updated since your last visit.<br />"
				+ "This version: " + currentversion + "<br />"
				+ "Your version: " + usersversion + "<br />"
				+ "Would you like to see the <a class='urlUpdates' href='" + U.URL_META.News + "'>changes</a>?<br />", wait);
			U.convertExternalLink(".urlUpdates");
		}
		
		localStorage[O.Utilities.programVersion.key] = O.Utilities.programVersion.value;
	},
	
	/*
	 * Checks the game build ID API to alert when a new patch is released.
	 */
	enforceBuildVersion: function()
	{
		$.getJSON(U.URL_API.Build, function(pData)
		{
			if (pData && pData.id)
			{
				var key = O.Utilities.buildVersion.key;
				var valA = parseInt(pData.id);
				var valB = localStorage[key];
				O.Utilities.buildVersion.value = valA;
				if (valB !== undefined && parseInt(valB) !== valA)
				{
					var message = "New game build available";
					I.print("<a" + U.convertExternalAnchor(U.URL_META.BuildNotes) + ">" + message + "!</a> "
						+ "GW2 Build ID: " + valA + " " + I.Symbol.ArrowLeft + " " + valB + " Diff: " + (valA - parseInt(valB)) + "<br />"
						+ T.formatWeektime(new Date(), true) + " - <a href='./?bol_alertBuild=false'>Turn off patch alarm?</a>");
					D.speak("Alert! " + message);
					I.notify({
						aTitle: "New Patch",
						aBody: message,
						aIcon: "img/notification/game.png"
					});
					localStorage[key] = valA;
				}
				else if (valB === undefined || parseInt(valB) !== valA)
				{
					localStorage[key] = valA;
				}
			}
		});
	},
	
	/*
	 * All of these URL overridable options should have an associated input tag
	 * in the HTML that users interact with, and their IDs are in the form
	 * prefixOption + optionkey, where prefix is the option's data type.
	 * "str_" and "int_num" are protected from URL override.
	 */
	Options:
	{
		// Enumeration is an exception, being set by URL or special functions only
		enu_Language: "en",
		enu_Server: "1008",
		// Timer
		bol_showSecondHand: true,
		bol_hideChecked: false,
		bol_expandWB: true,
		bol_collapseChains: true,
		int_setClock: 0,
		int_setDimming: 0,
		int_setPredictor: 0,
		// Panel
		bol_alignPanelRight: true,
		bol_ignoreTouch: false,
		bol_showPanel: true,
		bol_showHUD: true,
		bol_showHUDWvW: true,
		bol_showDashboard: true,
		bol_showTimeline: true,
		bol_opaqueTimeline: false,
		bol_condenseTimelineLine: true,
		bol_condenseTimelineHeader: true,
		bol_hideHUD: true,
		// Map
		int_setFloor: 1,
		int_setFloorWvW: 1,
		int_setInitialZoom: 3,
		int_setInitialZoomWvW: 4,
		bol_showCoordinatesBar: true,
		bol_showZoneBorders: false,
		bol_showZoneGateways: false,
		bol_showChainPaths: true,
		bol_tourPrediction: true,
		bol_showWorldCompletion: false,
		bol_showZoneOverview: true,
		bol_displaySectors: true,
		bol_displayWaypoints: true,
		bol_displayPOIs: true,
		bol_displayVistas: true,
		bol_displayChallenges: true,
		bol_displayMasteries: true,
		bol_displayHearts: true,
		bol_displayHeartsArea: false,
		bol_displaySectorsArea: false,
		bol_displayEvents: false,
		bol_showWorldCompletionWvW: false,
		bol_showZoneOverviewWvW: true,
		bol_displaySectorsWvW: true,
		bol_displayWaypointsWvW: true,
		bol_displayPOIsWvW: true,
		bol_displayVistasWvW: true,
		bol_displayChallengesWvW: true,
		bol_displaySectorsAreaWvW: true,
		str_colorPersonalPath: "#ffffff",
		int_opacityPersonalPath: 40,
		// WvW
		int_secWvWRefresh: 10,
		int_numLogEntries: 128,
		bol_showLog: true,
		bol_opaqueLog: false,
		bol_maximizeLog: false,
		bol_logRedHome: true,
		bol_logBlueHome: true,
		bol_logGreenHome: true,
		bol_logCenter: true,
		bol_logNarrate: false,
		bol_narrateRedHome: true,
		bol_narrateBlueHome: true,
		bol_narrateGreenHome: true,
		bol_narrateCenter: true,
		bol_narrateClaimed: false,
		bol_narrateRuins: false,
		bol_narrateCamp: true,
		bol_narrateTower: true,
		bol_narrateKeep: true,
		bol_narrateCastle: true,
		bol_showLeaderboard: true,
		bol_opaqueLeaderboard: false,
		bol_condenseLeaderboard: false,
		bol_showDestructibles: false,
		bol_showObjectiveLabels: true,
		bol_showSecondaries: false,
		// GPS
		int_setFollow: 1,
		bol_displayCharacter: true,
		bol_switchMap: true,
		int_setFollowWvW: 2,
		bol_displayCharacterWvW: true,
		int_msecGPSRefresh: 50,
		// Alarm
		int_setAlarm: 0,
		int_setVolume: 75,
		int_secAlertDesktop: 10,
		bol_alertSpeech: true,
		bol_alertDesktop: false,
		bol_alertConsole: false,
		bol_alertArrival: true,
		bol_alertAtStart: true,
		bol_alertAtEnd: true,
		bol_alertChecked: false,
		int_alertSubscribedFirst: 1,
		int_alertSubscribedSecond: 15,
		bol_alertAutosubscribe: true,
		bol_alertUnsubscribe: true,
		bol_alertBuild: false,
		bol_alertDaylight: false,
		bol_alertMystic: false,
		bol_alertGem: false,
		// Account
		bol_showRarity: false,
		bol_condenseBank: false,
		bol_auditTransactions: true,
		bol_auditVault: true,
		bol_auditAccountOnReset: false,
		bol_auditHistoryConverted: false,
		int_numAuditReports: 4096,
		// Trading
		bol_refreshPrices: true,
		int_numTradingCalculators: 25,
		int_numTradingResults: 50,
		int_secTradingRefresh: 60,
		// Tools
		int_minStopwatchAlert: 5,
		str_textStopwatchAlert: "Alert, alert, alert!",
		bol_repeatStopwatchAlert: false,
		int_sizeStopwatchFont: 64,
		int_sizeNotepadFont: 12,
		int_sizeNotepadHeight: 400,
		// Daily
		bol_clearChainChecklistOnReset: true,
		bol_clearPersonalChecklistOnReset: true,
		int_numChecklistDaily: 12,
		int_numChecklistWeekly: 12,
		// Advanced
		bol_use24Hour: true,
		bol_detectDST: true,
		bol_useSiteTag: true
	},
	/*
	 * All Options of a numeric type must have an associated legal range to be
	 * used in sanitation of user submitted ones. This object is updated by the
	 * function O.initializeOptions() that initializes HTML input tags.
	 */
	OptionRange: {},
	LanguageMeta:
	{
		ISOCode:
		{
			// This enum corresponds to the language enum and is used for Google TTS
			en: "en-US",
			de: "de-DE",
			es: "es-ES",
			fr: "fr-FR",
			cs: "cs-CZ", // Unsupported
			it: "it-IT",
			pl: "pl-PL", // Unsupported
			pt: "pt-BR", // Unsupported
			ru: "ru-RU", // Unsupported
			zh: "zh-CN",
			tw: "zh-CN"
		},
		VoiceCode:
		{
			// This enum corresponds to the voices available from window.speechSynthesis.getVoices() array
			en: "Google US English",
			de: "Google Deutsch",
			es: "Google español",
			fr: "Google français",
			cs: "native",
			it: "Google italiano",
			pl: "Google polski",
			pt: "Google português do Brasil",
			ru: "Google русский",
			zh: "Google 國語（臺灣）",
			tw: "Google 國語（臺灣）"
		},
		isFullySupported:
		{
			en: true,
			es: true,
			fr: true,
			de: true
		},
		isModifierFirst:
		{
			// If adjective-noun or adverb-verb modifier is before the modified
			en: true,
			de: true,
			cs: true,
			pl: true,
			ru: true,
			zh: true,
			tw: true
		},
		isLogographic:
		{
			// If logograms instead of letters
			zh: true,
			tw: true
		}
	},
	/*
	 * All Options of an enumerated type ("enu") must have a matching named
	 * object of enums here.
	 */
	OptionEnum:
	{
		Language:
		{
			Default: "en",
			English: "en",
			German: "de",
			Spanish: "es",
			French: "fr",
			Czech: "cs",
			Italian: "it",
			Polish: "pl",
			Portuguese: "pt",
			Russian: "ru",
			ChineseSimplified: "zh",
			ChineseTraditional: "tw"
		},
		Server:
		{
			AnvilRock: "1001",
			BorlisPass: "1002",
			YaksBend: "1003",
			HengeofDenravi: "1004",
			Maguuma: "1005",
			SorrowsFurnace: "1006",
			GateofMadness: "1007",
			JadeQuarry: "1008",
			FortAspenwood: "1009",
			EhmryBay: "1010",
			StormbluffIsle: "1011",
			Darkhaven: "1012",
			SanctumofRall: "1013",
			CrystalDesert: "1014",
			IsleofJanthir: "1015",
			SeaofSorrows: "1016",
			TarnishedCoast: "1017",
			NorthernShiverpeaks: "1018",
			Blackgate: "1019",
			FergusonsCrossing: "1020",
			Dragonbrand: "1021",
			Kaineng: "1022",
			DevonasRest: "1023",
			EredonTerrace: "1024",
			FissureofWoe: "2001",
			Desolation: "2002",
			Gandara: "2003",
			Blacktide: "2004",
			RingofFire: "2005",
			Underworld: "2006",
			FarShiverpeaks: "2007",
			WhitesideRidge: "2008",
			RuinsofSurmia: "2009",
			SeafarersRest: "2010",
			Vabbi: "2011",
			PikenSquare: "2012",
			AuroraGlade: "2013",
			GunnarsHold: "2014",
			JadeSea: "2101",
			FortRanik: "2102",
			AuguryRock: "2103",
			VizunahSquare: "2104",
			Arborstone: "2105",
			Kodash: "2201",
			Riverside: "2202",
			ElonaReach: "2203",
			AbaddonsMouth: "2204",
			DrakkarLake: "2205",
			MillersSound: "2206",
			Dzagonur: "2207",
			BaruchBay: "2301"
		}
	},
	/*
	 * These enums correspond to radio buttons.
	 */
	IntEnum:
	{
		Predictor:
		{
			Auto: 0,
			Min: 1,
			MinAvg: 2,
			Avg: 3
		},
		Clock:
		{
			Compact: 0,
			Full: 1,
			Bar: 2,
			None: 3
		},
		Alarm:
		{
			Off: 0,
			Checklist: 1,
			Subscription: 2
		},
		Follow:
		{
			Off: 0,
			Character: 1,
			Zone: 2
		}
	},
	
	/*
	 * Checks if the specified value is in the enum object, and returns it
	 * if found, or returns the default if not.
	 * @param string pEnumName of the enum object.
	 * @param string pEnumValue to check.
	 * @returns string valid enum or the default.
	 */
	validateEnum: function(pEnumName, pValue)
	{
		var i;
		var enumobject = O.OptionEnum[U.getVariableSuffix(pEnumName)];
		for (i in enumobject)
		{
			if (enumobject[i] === pValue)
			{
				return pValue;
			}
		}
		return O.Options[pEnumName];
	},
	
	/*
	 * Initializes the associative array of strings of legal localStorage
	 * variable keys so other functions can erase all unrecognized variables.
	 * @pre All legal variable keys are unique.
	 */
	initializeLegalLocalStorageKeys: function()
	{
		var i;
		for (i in O.Utilities)
		{
			O.legalLocalStorageKeys[O.Utilities[i].key] = true;
		}
		for (i in O.Options)
		{
			O.legalLocalStorageKeys[i] = true;
		}
		for (i in X.Checklists)
		{
			O.legalLocalStorageKeys[X.Checklists[i].key] = true;
		}
		for (i in X.Collectibles)
		{
			O.legalLocalStorageKeys[X.Collectibles[i].key] = true;
		}
		for (i in X.Textlists)
		{
			O.legalLocalStorageKeys[X.Textlists[i].key] = true;
		}
	},
	
	/*
	 * Checks localStorage for unrecognized variables and removes them.
	 */
	cleanLocalStorage: function()
	{
		var key;
		for (var i = 0; i < localStorage.length; i++)
		{
			key = localStorage.key(i);
			if (O.legalLocalStorageKeys[key] === undefined)
			{
				localStorage.removeItem(key);
			}
		}
	},
	
	/*
	 * localStorage stores everything as string. This function converts the
	 * data back to the proper type.
	 * @param string pString localStorage value.
	 * @returns proper type of value.
	 */
	convertLocalStorageDataType: function(pString)
	{
		var s = pString.toLowerCase();
		if (s === "true")
		{
			return true;
		}
		if (s === "false")
		{
			return false;
		}
		if (isFinite(s)) // Is a number
		{
			if (s % 0 === 0) // Integer shouldn't have a remainder
			{
				return parseInt(s);
			}
			return parseFloat(s);
		}
		return pString;
	},
	
	/*
	 * Loads a compressed JSON object from localStorage.
	 * @param string pKey name of storage entry.
	 * @returns object that was parsed.
	 */
	loadCompressedObject: function(pKey)
	{
		var obj = localStorage[pKey];
		if (obj)
		{
			// See if the string is already an uncompressed object (legacy code)
			try
			{
				return JSON.parse(obj);
			}
			catch (e)
			{
				try
				{
					return JSON.parse(LZString.decompressFromUTF16(obj));
				}
				catch (e) {}
			}
		}
		return null;
	},
	saveCompressedObject: function(pKey, pObject)
	{
		localStorage[pKey] = LZString.compressToUTF16(JSON.stringify(pObject));
	},
	
	/*
	 * Loads a stored timestamp if it exists, is a number, and not from the
	 * future, else initializes it.
	 * @param object pTimestamp from options' Utilities object.
	 */
	initializeTimestamp: function(pTimestamp)
	{
		var currenttimestamp = T.getUNIXSeconds();
		var storedtimestamp = parseInt(localStorage[pTimestamp.key]);
		if (localStorage[pTimestamp.key] === undefined
			|| isFinite(storedtimestamp) === false
			|| storedtimestamp > currenttimestamp)
		{
			pTimestamp.value = currenttimestamp;
			localStorage[pTimestamp.key] = pTimestamp.value;
		}
		else
		{
			pTimestamp.value = storedtimestamp;
		}
	},
	
	/*
	 * Sets a timestamp to the current time.
	 * @param object pTimestamp from options' Utilities object
	 */
	updateResetTimestamp: function(pTimestamp)
	{
		pTimestamp.value = T.getUNIXSeconds();
		localStorage[pTimestamp.key] = pTimestamp.value;
	},
	
	/*
	 * Checks if the reset timestamps expired or is expiring, and do clearings if so.
	 * @param Date pDate.
	 */
	checkResetTimestamps: function()
	{
		// Initialize time values
		var currenttimestamp = T.getUNIXSeconds();
		var secondssincemidnight = T.getTimeSinceMidnight();
		var secondssinceweekstart = T.getSecondsSinceWeekstart(secondssincemidnight);
		// Get yesterday's reset timestamp
		var yesterdaysresettime = currenttimestamp - secondssincemidnight;
		// Get last week's reset timestamp
		var lastweeksresettime = (secondssinceweekstart > T.cWEEKLY_RESET_SECONDS) ?
			(currenttimestamp - (secondssinceweekstart - T.cWEEKLY_RESET_SECONDS)) :
			((currenttimestamp - T.cSECONDS_IN_WEEK) + (T.cWEEKLY_RESET_SECONDS - secondssinceweekstart));
		// If the reset happens while the program is running
		var isdailyreset = (secondssincemidnight === 0);
		var isweeklyreset = (secondssinceweekstart === T.cWEEKLY_RESET_SECONDS);
		
		// Execute clear functions if the timestamp expired or on exact reset time
		if (O.Utilities.timestampDaily.value < yesterdaysresettime || isdailyreset)
		{
			O.clearDailySensitiveOptions(isdailyreset);
			O.updateResetTimestamp(O.Utilities.timestampDaily);
		}
		if (O.Utilities.timestampWeekly.value < lastweeksresettime || isweeklyreset)
		{
			O.clearWeeklySensitiveOptions(isweeklyreset);
			O.updateResetTimestamp(O.Utilities.timestampWeekly);
		}
		
		// Update reset Date objects
		var secondstoday = T.getUNIXSeconds() - secondssincemidnight;
		var secondstomorrow = secondstoday + T.cSECONDS_IN_DAY;
		T.ResetToday = new Date(secondstoday * T.cMSECONDS_IN_SECOND);
		T.ResetTomorrow = new Date(secondstomorrow * T.cMSECONDS_IN_SECOND);
		$("#optTimestampLocalReset").text(O.Utilities.timestampDaily.value);
		$("#optTimestampServerReset").text(secondstomorrow);
	},
	
	/*
	 * Gets the index of a checked radio button within a fieldset of radio buttons.
	 * @pre Radio buttons are inside a fieldset with the same "name" attribute.
	 * @returns int 0-based index of radio button.
	 */
	getIndexOfSelectedRadioButton: function(pName)
	{
		var radiobuttons = $("fieldset[name=" + pName + "] " + "input:radio[name=" + pName + "]");
		return radiobuttons.index(radiobuttons.filter(":checked"));
	},
	
	/*
	 * Sets the HTML input tag values to the localStorage's or the defaults here.
	 * URLArguments with same Options object's keys (if available) will override both.
	 * @pre The tags are preloaded (not AJAX) and URLArguments was initialized.
	 */
	initializeOptions: function()
	{
		O.initializeLegalLocalStorageKeys();

		var optionkey;
		var inputtype;
		var inputelm;
		
		var isURLOptionLegal = function(pOptionKey)
		{
			if (U.Args[pOptionKey] !== undefined
				&& pOptionKey.lastIndexOf("int_num", 0) !== 0
				&& pOptionKey.lastIndexOf("str_", 0) !== 0)
			{
				return true;
			}
			return false;
		};
		
		// Load or initialize input options
		for (optionkey in O.Options)
		{
			inputelm = $("#" + O.cPrefixOption + optionkey);
			inputtype = inputelm.attr("type");
			
			/*
			 * Initialize legal numeric values by looking up the associated
			 * input tag.
			 */
			if (inputtype === "radio")
			{
				// Range shall be 0 to how many radio buttons there are minus one
				O.OptionRange[optionkey] = new Array(0, $("fieldset[name=" + optionkey + "] input").length - 1);
			}
			else if (inputtype === "number" || inputtype === "range")
			{
				O.OptionRange[optionkey] = new Array(inputelm.prop("min"), inputelm.prop("max"));
			}
			else if (inputtype === "checkbox")
			{
				// Custom checkbox image
				X.wrapCheckbox(inputelm);
			}
			
			/*
			 * URLArguments overrides localStorage, which overrides Options here
			 * only if such an Options variable exists. If program is embedded
			 * then URLArguments overrides Options only, and user preferences
			 * (localStorage) will not modified. Strings may not be overriden by URL.
			 */
			if (I.isProgramEmbedded)
			{
				// Use stored options if self embedded
				if (I.isProgramExternal === false)
				{
					if (localStorage[optionkey] !== undefined)
					{
						O.Options[optionkey] = O.convertLocalStorageDataType(localStorage[optionkey]);
					}
				}
				
				// URL options override localStorage, but do not overwrite
				if (isURLOptionLegal(optionkey))
				{
					O.Options[optionkey] = O.convertLocalStorageDataType(U.sanitizeURLOptionsValue(optionkey, U.Args[optionkey]));
				}
			}
			else
			{
				// Overwrite localStorage with URL's options if available
				if (isURLOptionLegal(optionkey))
				{
					localStorage[optionkey] = U.sanitizeURLOptionsValue(optionkey, U.Args[optionkey]);
				}
				
				// Assign default values to localStorage if they are empty
				if (localStorage[optionkey] === undefined)
				{
					localStorage[optionkey] = O.Options[optionkey];
				}
				// Else user set options from localStorage become the new options
				else
				{
					O.Options[optionkey] = O.convertLocalStorageDataType(localStorage[optionkey]);
				}
			}
			
			// Assign the retrieved values to the input tags
			O.setInputValue(inputelm, O.Options[optionkey]);

			/*
			 * Bind simple event handlers to each input tags that writes
			 * the value of the input to the options and localStorage.
			 * Note that the optionkey local variable was not reused here
			 * because this is the scope of the input's event! Have to use
			 * separate variables.
			 */
			if (inputtype === "radio")
			{
				/*
				 * Radio buttons are a special case because they are multiple
				 * input tags. They must be wrapped in a fieldset and all be
				 * given the same name attribute. One button shall hold the
				 * unique ID so the group will only be iterated once.
				 */
				$("fieldset[name=" + optionkey + "]").change(function()
				{
					var thisoptionkey = $(this).attr("name");
					O.Options[thisoptionkey] = O.getIndexOfSelectedRadioButton(thisoptionkey);
					localStorage[thisoptionkey] = O.Options[thisoptionkey];
				});
			}
			else
			{
				inputelm.change(function()
				{
					var thisoptionkey = $(this).attr("id").slice(O.cPrefixOption.length);
					O.Options[thisoptionkey] = O.getInputValue($(this), thisoptionkey);
					localStorage[thisoptionkey] = O.Options[thisoptionkey];
				}).click(function()
				{
					$(this).select();
				});
			}
		}
		
		// Supplementary event handlers for some inputs
		O.bindOptionsInputs();
		D.initializeLanguage();
	},
	
	/*
	 * Sets the value of an input tag.
	 * @param string pInput to read.
	 * @param polymorphic pValue.
	 */
	setInputValue: function(pInput, pValue)
	{
		var inputelm = $(pInput);
		var inputtype = inputelm.attr("type");

		// Assign the retrieved values to the cloned input
		if (inputtype === "checkbox")
		{
			inputelm.prop("checked", pValue);
		}
		else if (inputtype === "number" || inputtype === "range")
		{
			inputelm.val(pValue);
		}
		else if (inputtype === "radio")
		{
			// Check the radio button of that index (int)
			$("input:radio[name=" + inputelm.attr("name") + "]:eq(" + pValue + ")")
				.prop("checked", true);
		}
		else
		{
			inputelm.val(pValue);
		}
	},
	
	/*
	 * Gets the value of an input tag.
	 * @param string pInput to read.
	 * @param string pOptionKey name of an option for range validation.
	 */
	getInputValue: function(pInput, pOptionKey)
	{
		var inputelm = $(pInput);
		var inputtype = inputelm.attr("type");
		var value;

		if (inputtype === "checkbox")
		{
			value = inputelm.prop("checked");
		}
		else if (inputtype === "number" || inputtype === "range")
		{
			// These inputs can have custom text, so sanitize them first
			var value = inputelm.val();
			var integer = parseInt(value);
			if (isFinite(value) && integer >= O.OptionRange[pOptionKey][0]
				&& integer <= O.OptionRange[pOptionKey][1])
			{
				value = integer;
			}
			else
			{
				// Load default value if not an integer within range
				value = O.OptionRange[pOptionKey][0];
			}
			inputelm.val(value);
		}
		else if (inputtype === "text")
		{
			value = inputelm.val();
			var maxlength = inputelm.attr("maxlength");
			if (value.length > maxlength)
			{
				value = value.substring(0, maxlength);
			}
		}
		else
		{
			value = inputelm.val();
		}

		return value;
	},
	
	/*
	 * Makes an input tag behave the same as an Options input tag.
	 * @param jqobject pCloneInput input tag.
	 * @param string pOptionKey name of an option.
	 */
	mimicInput: function(pCloneInput, pOptionKey)
	{
		var inputclone = $(pCloneInput);
		// Initialize the value of the clone
		O.setInputValue(inputclone, O.Options[pOptionKey]);
		
		// If the cloned input value has changed then mimic that to the original
		var inputelm = $("#" + O.cPrefixOption + pOptionKey);
		inputclone.change(function()
		{
			var value = O.getInputValue($(this), pOptionKey);
			O.setInputValue(inputelm, value);
			inputelm.trigger("change");
		});
		// If the original input value has changed, then superficially change the cloned input
		inputelm.change(function()
		{
			O.setInputValue(inputclone, O.Options[pOptionKey]);
		});
		return inputclone;
	},
	
	/*
	 * Unchecks the time sensitive checklists and clear variables, ignoring
	 * the disabled/deleted ones by the user.
	 * @param boolean pIsDaily whether the program was running during reset.
	 */
	clearDailySensitiveOptions: function(pIsDuring)
	{
		O.isServerReset = true;
		// Notify of the reset in console
		var messagetime = 5;
		var dailymessage = pIsDuring ? "Daily Reset!" : "Expired daily checklists cleared.";
		// Update the daily object
		T.getDaily({aIsReset: true});
		
		// Chains checklist
		var i;
		var chain;
		if (O.Options.bol_clearChainChecklistOnReset)
		{
			I.greet(dailymessage, messagetime);
			for (i in C.Chains)
			{
				chain = C.Chains[i];
				$("#chnCheck_" + chain.nexus).removeClass("chnChecked");
				$("#chnBar_" + chain.nexus).removeClass("chnFaded");
				if (X.getChecklistItem(X.Checklists.Chain, chain.nexus) !== X.ChecklistEnum.Disabled)
				{
					$("#chnBar_" + chain.nexus).show();
				}
			}
			X.clearChecklist(X.Checklists.Chain, X.ChecklistJob.UncheckTheChecked);
		}
		
		// Dungeon and Personal Checklists
		if (O.Options.bol_clearPersonalChecklistOnReset)
		{
			X.clearCustomChecklistDaily();
		}
		// Daily achievements
		var resetgraceperiodms = 10000;
		if (I.isSectionLoaded_Daily)
		{
			setTimeout(function()
			{
				G.generateAndInitializeDailies();
			}, resetgraceperiodms);
		}
		// Load the audit page in a hidden iframe, which is set to close itself when the audit finishes
		if (O.Options.bol_auditAccountOnReset && U.Args[(U.KeyEnum.AutoAudit)] === undefined)
		{
			document.getElementById("jsAuditFrame").src = "./?page=Audit&" + U.KeyEnum.AutoAudit + "=true";
			I.greet("Automatic account audit started.", messagetime);
		}
		
		// Finally
		I.write("", messagetime);
	},
	clearWeeklySensitiveOptions: function(pIsDuring)
	{
		var messagetime = 5;
		var weeklymessage = pIsDuring ? "Weekly Reset!" : "Expired weekly checklists cleared.";
		if (O.Options.bol_clearPersonalChecklistOnReset)
		{
			I.greet(weeklymessage, messagetime);
			X.clearCustomChecklistWeekly();
		}
	},
	
	/*
	 * Binds custom event handlers for options that need immediate visual effect.
	 */
	bindOptionsInputs: function()
	{
		var i;
		// The Enact object has functions with the same name as the Options variables
		for (i in O.Enact)
		{
			(function(iFunction){
				var query;
				var htmlid = O.cPrefixOption + iFunction;
				var thisinputtype = $("#" + htmlid).attr("type");
				if (thisinputtype === "radio")
				{
					query = "fieldset[name=" + iFunction + "]";
				}
				else
				{
					query = "#" + htmlid;
				}
				
				$(query).change(function()
				{
					O.Enact[iFunction]();
				});
			})(i);
		}
		// POIs are created on site load
		$("#opt_bol_showWorldCompletion").change(function()
		{
			if (O.Options.bol_showWorldCompletion === true
				&& M.isMappingIconsGenerated === false)
			{
				document.location.reload();
			}
			
			$("#mapDisplayCompletion label input").not(".jsIgnore").each(function()
			{
				X.setCheckboxEnumState($(this), X.boolToChecklistEnum(O.Options.bol_showWorldCompletion));
			});
		});
		$("#opt_bol_showWorldCompletionWvW").change(function()
		{
			if (O.Options.bol_showWorldCompletionWvW === true
				&& W.isMappingIconsGenerated === false)
			{
				location.reload();
			}
			
			$("#wvwDisplayCompletion label input").each(function()
			{
				X.setCheckboxEnumState($(this), X.boolToChecklistEnum(O.Options.bol_showWorldCompletionWvW));
			});
		});
		$("#opt_bol_displayEvents").change(function()
		{
			if (O.Options.bol_displayEvents === true
				&& M.isEventIconsGenerated === false)
			{
				location.reload();
			}
			if (M.isEventIconsGenerated)
			{
				M.refreshCurrentZone();
			}
		});
		// Trigger zone in and out of current zone to toggle the icon's display
		$("#mapDisplayCompletion label input").each(function()
		{
			$(this).change(function()
			{
				if (M.isAPIRetrieved_MAPFLOOR)
				{
					M.refreshCurrentZone();
				}
			});
		});
		$("#wvwDisplayCompletion label input").each(function()
		{
			$(this).change(function()
			{
				if (W.isAPIRetrieved_MAPFLOOR)
				{
					W.refreshCurrentZone();
				}
			});
		});
		/*
		 * Run some enactors when the site loads (because this an initializer function).
		 * Will have to place it elsewhere if it requires data to be loaded first.
		 */
		O.Enact.bol_showSecondHand();
		O.Enact.int_setAlarm();
		O.Enact.bol_detectDST();
		O.Enact.bol_useSiteTag();
		O.Enact.bol_alignPanelRight(true);
		O.Enact.bol_showPanel();
		if (I.ModeCurrent !== I.ModeEnum.Simple & I.ModeCurrent !== I.ModeEnum.Tile)
		{
			O.Enact.int_setClock();
			O.Enact.int_setDimming();
		}
		
		/*
		 * Button event handlers bindings (buttons don't have stored values).
		 * ---------------------------------------------------------------------
		 */
		
		/*
		 * Clears the checklist including the deleted chain.
		 */
		$("#optRestoreAllChains").click(function()
		{
			U.interpretPage(I.PlateEnum.Chains);
			var chain;
			var display = (I.ModeCurrent === I.ModeEnum.Tile) ? "inline-block" : "block";
			for (var i in C.Chains)
			{
				chain = C.Chains[i];
				$("#chnCheck_" + chain.nexus).removeClass("chnChecked");
				$("#chnBar_" + chain.nexus).show().removeClass("chnFaded").css({display: display});
				$(".chnSlot_" + chain.nexus).each(function()
				{
					$(this).show().css({display: display}).removeClass("chnFaded")
						.find(".chnCheck").removeClass("chnChecked");
					if ($(this).hasClass("tmlIcon"))
					{
						$(this).css({display: "inline-block"});
					}
				});
			}
			X.clearChecklist(X.Checklists.Chain);
			// Also unfade the clock icons, which are the current first four bosses
			for (i = 0; i < T.cNUM_TIMEFRAMES_IN_HOUR; i++)
			{
				K.checkoffChainIcon(T.getStandardChain(i).nexus);
				var chainhardcore = T.getHardcoreChain(i);
				if (chainhardcore)
				{
					K.checkoffChainIcon(chainhardcore.nexus);
				}
			}
		});
		$("#optChainsExpand").click(function()
		{
			U.interpretPage(I.PlateEnum.Chains);
			$(".chnDetails").show();
		});
		$("#optChainsCollapse").click(function()
		{
			U.interpretPage(I.PlateEnum.Chains);
			$(".chnDetails").hide();
			I.scrollToElement("#plateChains");
		});
		
		/*
		 * Clears the browser storage.
		 */
		$("#optClearLocalStorage").click(function()
		{
			if (confirm(I.cSiteName + " Reset: This will clear all options and everything you have written in this website. Continue?"))
			{
				localStorage.clear();
				location.reload();
			}
		});
		
		/*
		 * Prints the browser storage to HTML console.
		 */
		$("#optPrintLocalStorage").click(function()
		{
			var i;
			var keys = [];
			// Gather the keys
			for (i = 0; i < localStorage.length; i++)
			{
				var key = U.escapeHTML(localStorage.key(i));
				keys.push(key);
			}
			// Sort them alphabetically
			keys.sort();
			
			var htmlstr = "";
			var filestr = "";
			// Print the key-value pairs by the key's order
			for (i in keys)
			{
				var value = localStorage.getItem(keys[i]);
				// Convert newline to substitute
				htmlstr += keys[i] + I.cOptionsDelimiter + U.escapeHTML(value) + "<br />";
				filestr += keys[i] + I.cOptionsDelimiter + value.replace(/(?:\r\n|\r|\n)/g, "\\r\\n") + "\r\n";
			}
			
			I.print("Please click the link below to save the options file.<br />Or copy and paste all the text below to a text file.", true);
			Z.createFile(filestr, "gw2t_options_" + T.getLocalTimestamp() + ".txt");
			I.print(htmlstr);
		});
		/*
		 * Imports the new-line separated options.
		 */
		Z.bindFileInput("#optImportLocalStorage", function(pString)
		{
			var counter = 0;
			var arr = pString.split(/\r\n/);
			var line, key, value, datatype;
			for (var i in arr)
			{
				line = U.toHalf(arr[i], I.cOptionsDelimiter);
				key = line[0];
				value = line[1];
				if (O.legalLocalStorageKeys[key]) // Make sure key exists
				{
					datatype = key.substring(0, O.cLengthOfPrefixes);
					if (datatype === U.TypeEnum.isString)
					{
						// Convert newline substitute to actual newline
						value = value.replace(/\\r\\n/g, "\r\n");
					}
					localStorage[key] = value;
					counter++;
				}
			}
			if (counter > 0)
			{
				I.print(counter + " options loaded. Please refresh your browser.");
			}
			else
			{
				I.print("No options loaded. Please make sure the file is properly formatted.");
			}
		});
	},
	
	/*
	 * Functions to enact the options, for which a simple variable change is
	 * not enough. Placed inside an object so they can be iterated.
	 * -------------------------------------------------------------------------
	 */
	Enact:
	{
		bol_showSecondHand: function()
		{
			$("#clkSecondHand").toggle(O.Options.bol_showSecondHand);
		},
		bol_alertDesktop: function()
		{
			I.askNotifications();
		},
		int_setAlarm: function()
		{
			var icon = U.URL_IMG.Placeholder;
			switch (O.Options.int_setAlarm)
			{
				case O.IntEnum.Alarm.Checklist: icon = "img/ui/check.png"; break;
				case O.IntEnum.Alarm.Subscription: icon = "img/ui/subscription.png"; break;
			}
			if (O.Options.int_setAlarm === O.IntEnum.Alarm.Off)
			{
				D.stopSpeech();
			}
			else
			{
				D.verifyNativeTTS();
			}
			$("#optAlarmIcon").attr("src", icon);
		},
		int_setVolume: function()
		{
			if (D.isSpeaking() === false)
			{
				D.speak(D.getWord("alarm"));
			}
		},
		bol_logNarrate: function()
		{
			if (O.Options.bol_logNarrate)
			{
				D.verifyNativeTTS();
			}
			else
			{
				D.stopSpeech();
			}
		},
		bol_hideChecked: function()
		{
			$(".chnBar").each(function()
			{
				X.hideCheckedChainBar(U.getSubintegerFromHTMLID($(this)));
			});
		},
		bol_expandWB: function()
		{
			var chains = (I.ModeCurrent === I.ModeEnum.Tile) ? C.RegularChains : C.CurrentChains;
			for (var i in chains)
			{
				if (C.isChainRegular(chains[i]))
				{
					var elm = $("#chnDetails_" + chains[i].nexus);
					if (O.Options.bol_expandWB)
					{
						elm.show("fast");
					}
					else
					{
						elm.hide("fast");
					}
				}
			}
		},
		bol_use24Hour: function()
		{
			C.initializeTimetableHTML();
			C.updateChainsTimeHTML();
			K.updateDigitalClockMinutely();
			H.updateTimelineHeader();
			H.updateTimelineSegments();
		},
		bol_detectDST: function()
		{
			T.checkDST();
		},
		int_setClock: function()
		{
			K.setClock();
		},
		int_setDimming: function()
		{
			switch (O.Options.int_setDimming)
			{
				case 1: $("#paneClockBackground").css({opacity: 1}); break;
				case 2: $("#paneClockBackground").css({opacity: 0}); break;
			}
		},
		int_setFloor: function()
		{
			M.changeFloor();
		},
		int_setFloorWvW: function()
		{
			W.changeFloor();
		},
		int_setInitialZoom: function()
		{
			M.Map.setZoom(O.Options.int_setInitialZoom);
		},
		int_setInitialZoomWvW: function()
		{
			W.Map.setZoom(O.Options.int_setInitialZoomWvW);
		},
		bol_showZoneBorders: function()
		{
			P.drawZoneBorders();
		},
		bol_showZoneGateways: function()
		{
			P.drawZoneGateways();
		},
		str_colorPersonalPath: function()
		{
			P.refreshPersonalPath();
		},
		int_opacityPersonalPath: function()
		{
			P.refreshPersonalPath();
		},
		bol_showChainPaths: function()
		{
			M.toggleLayerArray(P.LayerArray.ChainPath, O.Options.bol_showChainPaths);
		},
		bol_tourPrediction: function()
		{
			C.isTouringAuto = O.Options.bol_tourPrediction;
			if (O.Options.bol_tourPrediction)
			{
				C.isTouringManual = false;
			}
		},
		int_setFollow: function()
		{
			if (O.Options.int_setFollow !== O.IntEnum.Follow.Off)
			{
				M.GPSPreviousZoneID = "";
				P.updateCharacter(0);
			}
		},
		int_setFollowWvW: function()
		{
			if (O.Options.int_setFollowWvW !== O.IntEnum.Follow.Off)
			{
				W.GPSPreviousZoneID = "";
				P.updateCharacter(0);
			}
		},
		bol_displayCharacter: function()
		{
			if ( ! O.Options.bol_displayCharacter)
			{
				M.movePin(M.Pin.Character);
				M.movePin(M.Pin.Camera);
			}
			else
			{
				P.tickGPS();
				P.updateCharacter(0);
			}
		},
		bol_displayCharacterWvW: function()
		{
			if ( ! O.Options.bol_displayCharacterWvW)
			{
				W.movePin(W.Pin.Character);
				W.movePin(W.Pin.Camera);
			}
			else
			{
				P.tickGPS();
				P.updateCharacter(0);
			}
		},
		bol_showPanel: function()
		{
			if (I.isMapEnabled) // Only hide panel if map is visible
			{
				$("#panelApp").toggle(O.Options.bol_showPanel);
				$("#mapDisplayButton, #wvwDisplayButton, #accDisplayButton").toggle(!O.Options.bol_showPanel);
				M.refreshMap();
				if (W.isMapInitialized)
				{
					W.refreshMap();
				}
				if (A.isAccountInitialized)
				{
					A.adjustAccountPanel();
				}
			}
		},
		bol_alignPanelRight: function(pIsInitial)
		{
			if (I.isMapEnabled)
			{
				if (O.Options.bol_alignPanelRight)
				{
					// Don't realign if this function is called initially, because this is the default alignment
					if (pIsInitial !== true)
					{
						$("#panelApp").insertAfter("#panelMap");
						$(".paneApp").css({
							right: "0px",
							borderLeft: "1px solid #444",
							borderRight: "none",
							boxShadow: "-5px 0px 5px #223"
						});
						$(".mapDisplayButton").css({right: 0, left: "auto"});
						$("#itemDisplayButton").css({right: "auto", left: "auto", "margin-left": "-16px"});
						$("#prjController").css({right: "auto"});
					}
				}
				else
				{
					$("#panelApp").insertBefore("#panelMap");
					$(".paneApp").css({
						right: "auto",
						borderLeft: "none",
						borderRight: "1px solid #444",
						boxShadow: "5px 0px 5px #223"
					});
					$(".mapDisplayButton").css({right: "auto", left: 0});
					$("#itemDisplayButton").css({right: "auto", left: "auto", "margin-left": (I.cPANEL_WIDTH - 16) + "px"});
					$("#prjController").css({right: 0});
				}
			}
		},
		bol_showHUD: function()
		{
			$("#mapHUDContainer, #mapHUDContainerInner").toggle(O.Options.bol_showHUD);
		},
		bol_showHUDWvW: function()
		{
			$("#wvwHUDContainer, #wvwHUDContainerInner").toggle(O.Options.bol_showHUDWvW);
		},
		bol_showCoordinatesBar: function()
		{
			M.toggleCoordinatesBar();
		},
		bol_hideHUD: function()
		{
			if (O.Options.bol_hideHUD === false)
			{
				$("#mapHUDContainerInner").show();
			}
		},
		bol_showDashboard: function()
		{
			H.toggleDashboard();
		},
		bol_showTimeline: function()
		{
			H.toggleTimeline();
		},
		bol_opaqueTimeline: function()
		{
			H.opaqueTimeline();
		},
		bol_condenseTimelineLine: function(pIsInitial)
		{
			if (pIsInitial === undefined || (pIsInitial && O.Options.bol_condenseTimelineLine === false))
			{
				$(".tmlLineWB").show();
				I.toggleElement(".tmlLineStandard", O.Options.bol_condenseTimelineLine);
				if (O.Options.bol_condenseTimelineLine === false)
				{
					X.clearChecklist(X.Checklists.Timeline);
				}
			}
		},
		bol_condenseTimelineHeader: function(pIsInitial)
		{
			H.minutesInTimelineSpacing = (O.Options.bol_condenseTimelineHeader) ? T.cMINUTES_IN_TIMEFRAME : T.cMINUTES_IN_MINIFRAME;
			H.updateTimelineHeader();
			if (pIsInitial !== true)
			{
				H.updateTimelineSegments();
			}
		},
		bol_refreshPrices: function()
		{
			if (O.Options.bol_refreshPrices && E.isTradingCalculatorsInitialized)
			{
				E.loopRefresh();
			}
			else
			{
				E.cancelLoopRefresh();
			}
		},
		bol_useSiteTag: function()
		{
			if (O.Options.bol_useSiteTag)
			{
				I.siteTagCurrent = I.siteTagDefault;
			}
			else
			{
				I.siteTagCurrent = "";
			}
		},
		bol_showLog: function()
		{
			W.toggleLog();
		},
		bol_opaqueLog: function()
		{
			W.opaqueLog();
		},
		bol_maximizeLog: function()
		{
			W.toggleLogHeight();
		},
		bol_showLeaderboard: function()
		{
			W.toggleLeaderboard();
		},
		bol_opaqueLeaderboard: function()
		{
			W.opaqueLeaderboard();
		},
		bol_condenseLeaderboard: function()
		{
			W.toggleLeaderboardWidth(true);
		},
		bol_showSecondaries: function()
		{
			W.toggleSecondaries(true);
		},
		bol_showDestructibles: function()
		{
			W.toggleWalls(true);
		},
		bol_showObjectiveLabels: function()
		{
			W.toggleObjectiveLabels();
		}
	}
};
X = {
/* =============================================================================
 * @@Checklist management and generation
 * ========================================================================== */

	/*
	 * A checklist is a set of checkboxes that can have the usual unchecked,
	 * checked, and disabled states. These states are recorded as a single
	 * character in a string of numbers representing those states, and the index
	 * of a character is that checkbox's "ID". The Checklists object stores
	 * checklists with such a string and a key for localStorage, along with
	 * supplementary attributes.
	 */
	Checklists:
	{
		// localStorage key-value pairs (key is required)
		Directory: { key: "str_chlDirectory" },
		Chain: { key: "str_chlChain" },
		ChainSubscription: { key: "str_chlChainSubscription" },
		Timeline: { key: "str_chlTimeline" },
		JP: { key: "str_chlJP" },
		Chest: { key: "str_chlChest" },
		ResourceRich: { key: "str_chlResourceRich" },
		ResourcePermanent: { key: "str_chlResourcePermanent" },
		ResourceRegular: { key: "str_chlResourceRegular" },
		ResourceHotspot: { key: "str_chlResourceHotspot" },
		Dungeon: { key: "str_chlDungeon", money: 0 },
		Raid: { key: "str_chlRaid", money: 0 },
		CustomDaily: { key: "str_chlCustomDaily" },
		CustomWeekly: { key: "str_chlCustomWeekly" },
		// Individual calculator's settings
		TradingOverwrite: { key: "str_chlTradingOverwrite" },
		TradingNotify: { key: "str_chlTradingNotify" }
	},
	/*
	 * Collectible checklists must have the same variable name as in the map page's data.
	 * The urlkey properties must be unique from the global KeyEnum.
	 */
	Collectibles:
	{
		// Chests
		BuriedTreasures: { key: "str_chlBuriedTreasures", urlkey: "buriedtreasures"},
		WaterloggedChests: { key: "str_chlWaterloggedChests", urlkey: "waterloggedchests"},
		HarathiStrongboxes: { key: "str_chlHarathiStrongboxes", urlkey: "harathistrongboxes"},
		IceboundChests: { key: "str_chlIceboundChests", urlkey: "iceboundchests"},
		SkrittStashes: { key: "str_chlSkrittStashes", urlkey: "skrittstashes"},
		NoxiousPods: { key: "str_chlNoxiousPods", urlkey: "noxiouspods"},
		CrystallizedCaches: { key: "str_chlCrystallizedCaches", urlkey: "crystallizedcaches"},
		ExaltedChests: { key: "str_chlExaltedChests", urlkey: "exaltedchests"},
		AirshipCargo: { key: "str_chlAirshipCargo", urlkey: "airshipcargo"},
		BuriedChests: { key: "str_chlBuriedChests", urlkey: "chests"},
		BanditChests: { key: "str_chlBanditChests", urlkey: "banditchests"},
		MatrixCubeKey: { key: "str_chlMatrixCubeKey", urlkey: "matrixcubekey"},
		SkrittBurglar: { key: "str_chlSkrittBurglar", urlkey: "skrittburglar"},
		// Festival
		PumpkinCarving: { key: "str_chlPumpkinCarving", urlkey: "pumpkins"},
		DonationDrive: { key: "str_chlDonationDrive", urlkey: "orphans"},
		// Achievements: Heart of Thorns Living Story
		LessonsLearned: { key: "str_chlLessonsLearned", urlkey: "lessonslearned"},
		PeopleWatching: { key: "str_chlPeopleWatching", urlkey: "peoplewatching"},
		RockCollector: { key: "str_chlRockCollector", urlkey: "rockcollector"},
		CinsGoods: { key: "str_chlCinsGoods", urlkey: "cinsgoods"},
		LettersFromE: { key: "str_chlLettersFromE", urlkey: "lettersfrome"},
		CaudecusLetters: { key: "str_chlCaudecusLetters", urlkey: "caudecusletters"},
		ThoroughSampling: { key: "str_chlThoroughSampling", urlkey: "thoroughsampling"},
		MursaatTokens: { key: "str_chlMursaatTokens", urlkey: "mursaattokens"},
		MursaatTablets: { key: "str_chlMursaatTablets", urlkey: "mursaattablets"},
		CamiJournals: { key: "str_chlCamiJournals", urlkey: "camijournals"},
		RiftStabilizer: { key: "str_chlRiftStabilizer", urlkey: "riftstabilizer"},
		BloodstoneCreatures: { key: "str_chlBloodstoneCreatures", urlkey: "creatures"},
		BloodstoneSlivers: { key: "str_chlBloodstoneSlivers", urlkey: "slivers"},
		// Achievements: Heart of Thorns
		PaperScraps: { key: "str_chlPaperScraps", urlkey: "paperscraps"},
		TigerSpirit: { key: "str_chlTigerSpirit", urlkey: "tigerspirit"},
		ItzelTotems: { key: "str_chlItzelTotems", urlkey: "itzeltotems"},
		PriorySeals: { key: "str_chlPriorySeals", urlkey: "prioryseals"},
		AuricTablets: { key: "str_chlAuricTablets", urlkey: "aurictablets"},
		ExaltedMasks: { key: "str_chlExaltedMasks", urlkey: "exaltedmasks"},
		// Achievements: Pre-expansion
		LionsArchExterminator: { key: "str_chlLionsArchExterminator", urlkey: "lionsarchexterminator"},
		CoinProspect: { key: "str_chlCoinProspect", urlkey: "coinprospect"},
		CoinUplands: { key: "str_chlCoinUplands", urlkey: "coinuplands"},
		CoinChallenger: { key: "str_chlCoinChallenger", urlkey: "coinchallenger"},
		LostBadges: { key: "str_chlLostBadges", urlkey: "lostbadges"},
		GoldenLostBadges: { key: "str_chlGoldenLostBadges", urlkey: "goldenlostbadges"},
		DiveMaster: { key: "str_chlDiveMaster", urlkey: "divemaster"},
		SpeedyReader: { key: "str_chlSpeedyReader", urlkey: "speedyreader"},
		CleaningUp: { key: "str_chlCleaningUp", urlkey: "cleaningup"},
		HistoryBuff: { key: "str_chlHistoryBuff", urlkey: "historybuff"},
		// Unlocks
		HungryCats: { key: "str_chlHungryCats", urlkey: "hungrycats"},
		Strongboxes: { key: "str_chlStrongboxes", urlkey: "strongboxes"},
		MasteryInsight: { key: "str_chlMasteryInsight", urlkey: "masteryinsight"},
		HeroChallenge: { key: "str_chlHeroChallenge", urlkey: "herochallenge"},
		ImportantWaypoints: { key: "str_chlImportantWaypoints", urlkey: "importantwaypoints"},
		RangerPets: { key: "str_chlRangerPets", urlkey: "pets"}
	},
	ChecklistEnum:
	{
		// Must be 1 character long
		Unchecked: "0",
		Checked: "1",
		Disabled: "2",
		
		Unfound: "0",
		Tracked: "1",
		Found: "2"
	},
	ChecklistJob:
	{
		UncheckAll: 0,
		CheckAll: 1,
		UncheckTheChecked: 2
	},
	
	/*
	 * A textlist is a set of text inputs or textareas that user writes in.
	 * These are stored as substrings separated by "|" in a single long string.
	 * The index between the separators represent the substring's (textarea's
	 * content) ID. Other than that, its working is similar to checklists.
	 */
	Textlists:
	{
		SlotPins: { key: "str_txlSlotPins"},
		SlotPinsWvW: { key: "str_txlSlotPinsWvW"},
		SlotCompasses: { key: "str_txlSlotCompasses"},
		SlotCompassesWvW: { key: "str_txlSlotCompassesWvW"},
		CustomTextDaily: { key: "str_txlCustomTextDaily", valueDefault: [] },
		CustomTextWeekly: { key: "str_txlCustomTextWeekly", valueDefault: [] },
		NotepadText: { key: "str_txlNotepadText", valueDefault: [] },
		TradingItem: { key: "str_txlTradingItem"},
		TradingName: { key: "str_txlTradingName"},
		TradingBuy: { key: "str_txlTradingBuy"},
		TradingSell: { key: "str_txlTradingSell"},
		TradingQuantity: { key: "str_txlTradingQuantity"},
		NotifyBuyLow: { key: "str_txlNotifyBuyLow"},
		NotifyBuyHigh: { key: "str_txlNotifyBuyHigh"},
		NotifySellLow: { key: "str_txlNotifySellLow"},
		NotifySellHigh: { key: "str_txlNotifySellHigh"},
		ExchangeUnit: { key: "str_txlExchangeUnit"}
	},
	
	/*
	 * Converts a boolean to a checklist enum.
	 * @param string pBoolean to convert.
	 * @returns enum.
	 */
	boolToChecklistEnum: function(pBoolean)
	{
		if (pBoolean)
		{
			return X.ChecklistEnum.Checked;
		}
		return X.ChecklistEnum.Unchecked;
	},
	
	/*
	 * Creates a string for a checklist object with each character representing
	 * a state, and each index representing a check item. Also initializes the
	 * localStorage or load it as the checklist if already stored.
	 * @param object pChecklist to initialize.
	 * @param int pLength of the checklist string to construct.
	 * @param string pCustomList comma separated list of indexes (1-indexed) to be set as checked.
	 * @param enum pJob for clear function, optional.
	 * @param object pAssoc for custom named indexes, optional.
	 * @returns string new checklist to be assigned to a checklist variable.
	 */
	initializeChecklist: function(pChecklist, pLength, pCustomList, pJob, pAssoc)
	{
		var i;
		var indexes;
		var index;
		var storedlist = localStorage[pChecklist.key];
		pChecklist.value = "";
		pChecklist.length = pLength;
		
		if (pCustomList)
		{
			X.clearChecklist(pChecklist);
			indexes = pCustomList.split(",");
			if (pAssoc)
			{
				for (var i = 0; i < indexes.length; i++)
				{
					indexes[i] = pAssoc[(indexes[i])];
				}
			}

			for (i in indexes)
			{
				index = parseInt(indexes[i]);
				if (isFinite(index))
				{
					X.setChecklistItem(pChecklist, index - 1, X.ChecklistEnum.Checked);
				}
			}
		}
		// If no checklist exists then it create one with a string of 0s
		else if (storedlist === undefined)
		{
			X.clearChecklist(pChecklist, pJob);
		}
		// If stored list is longer than requested, then cut off the right portion
		else if (storedlist.length > pLength)
		{
			localStorage[pChecklist.key] = storedlist.substring(0, pLength);
		}
		// If stored list is shorter than requested, then concatenate it with 0s so its new length equals so
		else if (storedlist.length < pLength)
		{
			var padding = U.repeatChar(X.ChecklistEnum.Unchecked, pLength - storedlist.length);
			localStorage[pChecklist.key] = storedlist + padding;
		}
		
		// Either way, the stored list becomes the program's list
		pChecklist.value = localStorage[pChecklist.key];
	},
	
	/*
	 * Replaces a character in a checklist string and updates the localStorage.
	 * @param object pChecklist to modify.
	 * @param int pIndex of the character in the string.
	 * @param string pCharacter to replace the current.
	 */
	setChecklistItem: function(pChecklist, pIndex, pCharacter)
	{
		pIndex = parseInt(pIndex);
		var thechar = pCharacter.toString();
		// A character must be length 1 and different from the current
		if (thechar.length === 1 && pChecklist.value[pIndex] !== thechar
			&& pIndex >= 0
			&& pIndex < pChecklist.value.length)
		{
			var checklist = U.replaceCharAt(pChecklist.value, pIndex, thechar);
			localStorage[pChecklist.key] = checklist;
			pChecklist.value = checklist;
		}
	},
	
	/*
	 * Toggles a character in a checklist string and updates the localStorage
	 * between three possible states.
	 * @param object pChecklist to modify.
	 * @param int pIndex of the character in the string.
	 * @returns enum the new state.
	 */
	trackChecklistItem: function(pChecklist, pIndex)
	{
		pIndex = parseInt(pIndex);
		var thechar = pChecklist.value.charAt(pIndex);
		switch (thechar)
		{
			case X.ChecklistEnum.Unfound: thechar = X.ChecklistEnum.Tracked; break;
			case X.ChecklistEnum.Tracked: thechar = X.ChecklistEnum.Found; break;
			case X.ChecklistEnum.Found: thechar = X.ChecklistEnum.Unfound; break;
			default: thechar = X.ChecklistEnum.Unfound;
		}
		
		var checklist = U.replaceCharAt(pChecklist.value, pIndex, thechar);
		localStorage[pChecklist.key] = checklist;
		pChecklist.value = checklist;
		
		return thechar;
	},
	
	/*
	 * Gets the character in a checklist string at specified index.
	 * @param object pChecklist to extract.
	 * @param int pIndex of the character.
	 * @param string pConversion to convert that character to a type.
	 * @returns dynamic depending on conversion param.
	 */
	getChecklistItem: function(pChecklist, pIndex, pConversion)
	{
		var thechar = pChecklist.value.charAt(pIndex);
		
		if (pConversion === undefined)
		{
			return thechar;
		}
		if (pConversion === U.TypeEnum.isInteger)
		{
			return parseInt(thechar);
		}
		if (pConversion === U.TypeEnum.isBoolean)
		{
			// Returns false only if unchecked
			return U.intToBool(parseInt(thechar));
		}
		return thechar;
	},
	
	/*
	 * Tells if an element with a checkbox has checked state.
	 * @param object pChecklist to lookup.
	 * @param jqobject pEntry to extract checkbox index in checklist.
	 * @returns boolean true if checked.
	 */
	isChecked: function(pChecklist, pEntry)
	{
		var index = U.getSubintegerFromHTMLID(pEntry);
		if (X.getChecklistItem(pChecklist, index) === X.ChecklistEnum.Checked)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Gets indexes in a checklist that has its value as "checked".
	 * @param object pChecklist to extract.
	 * @param object pAssoc for custom named indexes, optional.
	 * @returns string comma separated string of index numbers (1-indexed).
	 */
	getCheckedIndexes: function(pChecklist, pAssoc)
	{
		var i;
		var indexes = "";
		var list = pChecklist.value;
		for (i = 0; i < list.length; i++)
		{
			if (list[i] === X.ChecklistEnum.Checked)
			{
				if (pAssoc)
				{
					indexes += pAssoc[i] + ",";
				}
				else
				{
					indexes += (i+1) + ",";
				}
			}
		}
		indexes = indexes.slice(0, -1); // Trim last extra comma
		return indexes;
	},
	
	/*
	 * Sets a checklist object's list a desired mass state.
	 * @param object pChecklist to clear.
	 * @param enum pJob to check or uncheck the checklist.
	 * @pre Checklist length attribute was initialized.
	 */
	clearChecklist: function(pChecklist, pJob)
	{
		var i;
		var checklist = "";
		var value = "";
		
		switch (pJob)
		{
			case X.ChecklistJob.CheckAll:
			{
				for (i = 0; i < pChecklist.length; i++)
				{
					checklist += X.ChecklistEnum.Checked;
				}
			} break;
			case X.ChecklistJob.UncheckTheChecked:
			{
				// Only sets unchecked state on checked ones
				if (localStorage[pChecklist.key])
				{
					value = localStorage[pChecklist.key];
				}
				else
				{
					value = pChecklist.value;
				}
				
				if (value && value.length)
				{
					for (i = 0; i < value.length; i++)
					{
						if (value[i] === X.ChecklistEnum.Checked)
						{
							checklist += X.ChecklistEnum.Unchecked;
						}
						else
						{
							checklist += value[i];
						}
					}
				}
			} break;
			default:
			{
				for (i = 0; i < pChecklist.length; i++)
				{
					checklist += X.ChecklistEnum.Unchecked;
				}
			}
		}
		
		pChecklist.value = checklist;
		localStorage[pChecklist.key] = checklist;
	},
	
	/*
	 * Counts the checked type in a checklist.
	 * @param object pChecklist to look in.
	 * @param enum pCheckType to look for.
	 * @returns int count.
	 */
	countChecklist: function(pChecklist, pCheckType)
	{
		return U.countOccurrence(pChecklist.value, pCheckType);
	},
	
	/*
	 * Reads a checkbox element and return its checklist enum state.
	 * @param jqobject pElement to read.
	 * @returns int checklist enum.
	 */
	getCheckboxEnumState: function(pElement)
	{
		if (pElement.prop("disabled") === true)
		{
			return X.ChecklistEnum.Disabled;
		}
		if (pElement.prop("checked") === true)
		{
			return X.ChecklistEnum.Checked;
		}
		return X.ChecklistEnum.Unchecked;
	},
	
	/*
	 * Sets an input tag checkbox checked/disabled states based on specified enum.
	 * @param jqobject pElement checkbox to change.
	 * @param int pChecklistEnum to apply.
	 */
	setCheckboxEnumState: function(pElement, pChecklistEnum)
	{
		switch (pChecklistEnum)
		{
			case X.ChecklistEnum.Disabled:
			{
				pElement.prop("disabled", true);
				pElement.prop("checked", false);
			} break;
			case X.ChecklistEnum.Checked:
			{
				pElement.prop("checked", true);
			} break;
			default: pElement.prop("checked", false);
		}
		pElement.trigger("change");
	},
	
	/*
	 * Programmatically selects an option in a fieldset input.
	 * @param string pName ID of element.
	 * @param int pOrder in the fieldset.
	 */
	setFieldsetState: function(pName, pOrder)
	{
		$("fieldset[name='" + pName + "'] input:eq(" + pOrder + ")").trigger("click");
	},
	
	/*
	 * Sets a checkbox to a desired state by reading it then manually triggering it.
	 * @param jqobject pElement checkbox to manipulate.
	 * @param int pState checkbox enum.
	 */
	triggerCheckbox: function(pElement, pState)
	{
		var checkboxstate = X.getCheckboxEnumState(pElement);
		
		if ( (pState === X.ChecklistEnum.Checked && (checkboxstate === X.ChecklistEnum.Unchecked))
			|| (pState === X.ChecklistEnum.Unchecked && (checkboxstate === X.ChecklistEnum.Checked)) )
		{
			pElement.trigger("click");
		}
		else if (pState === X.ChecklistEnum.Disabled && checkboxstate !== X.ChecklistEnum.Disabled)
		{
			pElement.trigger("dblclick");
		}
	},
	
	/*
	 * Triggers a checkbox based on associated state in a checklist.
	 * @param object pChecklist as target state.
	 * @param int pIndex of a state in checklist.
	 * @param jqobject pElement checkbox to manipulate.
	 */
	triggerCheckboxEnumState: function(pChecklist, pIndex, pElement)
	{
		var checkliststate = X.getChecklistItem(pChecklist, pIndex);
		X.triggerCheckbox(pElement, checkliststate);
	},
	
	/*
	 * Adds style classes to a label that wraps a checkbox depending on its state.
	 * @param object pChecklist to get state.
	 * @param int pIndex of state.
	 * @param jqobject pElement checkbox to style its label.
	 * @pre In format <label><input type="checkbox" />ExampleLabel</label>.
	 */
	setCheckboxStyle: function(pChecklist, pIndex, pElement)
	{
		var state = X.getChecklistItem(pChecklist, pIndex);
		var label = X.getCheckboxLabel(pElement);
		switch (state)
		{
			case X.ChecklistEnum.Disabled:
			{
				label.removeClass("chlCheckboxChecked").addClass("chlCheckboxDisabled");
			} break;
			case X.ChecklistEnum.Checked:
			{
				label.removeClass("chlCheckboxDisabled").addClass("chlCheckboxChecked");
			} break;
			default:
			{
				label.removeClass("chlCheckboxDisabled").removeClass("chlCheckboxChecked");
			}
		}
	},
	
	/*
	 * Adds custom checkbox image to a checkbox element.
	 * @param jqobject pElm
	 * @pre Checkbox is enclosed by a label tag.
	 */
	wrapCheckbox: function(pElement)
	{
		$(pElement).addClass("jsCheckbox").wrap("<span class='cssCheckbox'></span>").after("<kbd class='cssCheckboxImage'></kbd>");
	},
	rewrapCheckboxes: function()
	{
		$("input[type='checkbox']").not(".jsCheckbox").each(function()
		{
			X.wrapCheckbox($(this));
		});
	},
	getCheckboxLabel: function(pCheckbox)
	{
		return $(pCheckbox).closest("label");
	},
	
	/*
	 * Sets a checkbox's label text. Also assigns ID of checkbox to label.
	 * @param jqobject pElement
	 * @param string pHTML
	 */
	relabelCheckbox: function(pElement, pHTML)
	{
		var elm = $(pElement);
		var parent = X.getCheckboxLabel(elm).attr("id", elm.attr("id").replace(O.cPrefixOption, O.cPrefixLabel));
		parent.find(".jsCheckboxText").remove();
		parent.append("<var class='jsCheckboxText'> " + pHTML + "</var>");
	},
	
	/*
	 * Initializes the checklist for a set of checkboxes and bind their standard storage behavior.
	 * @param object pChecklist for storing state.
	 * @param jqobject pCheckboxes input to bind behavior.
	 * @param enum pJob initial checkbox state.
	 * @pre These checkboxes can only have a checked and unchecked state only.
	 */
	initializeCheckboxlist: function(pChecklist, pCheckboxes, pJob, pRestoreButton, pWantStyle)
	{
		X.initializeChecklist(pChecklist, pCheckboxes.length, null, pJob);

		pCheckboxes.each(function(iIndex)
		{
			$(this).change(function()
			{
				var state = X.getCheckboxEnumState($(this));
				X.setChecklistItem(pChecklist, iIndex, state);
				if (pWantStyle !== false)
				{
					X.setCheckboxStyle(pChecklist, iIndex, $(this));
				}
			});
			
			// Now that this checkbox is bound, trigger it as the state in checklist
			X.triggerCheckboxEnumState(pChecklist, iIndex, $(this));
			if (pWantStyle !== false)
			{
				X.setCheckboxStyle(pChecklist, iIndex, $(this));
			}
		});
		
		// Bind restore default values button
		if (pRestoreButton)
		{
			pRestoreButton.click(function()
			{
				X.clearCheckboxes(pCheckboxes);
			});
		}
	},
	clearCheckboxes: function(pCheckboxes)
	{
		pCheckboxes.each(function()
		{
			X.setCheckboxEnumState($(this), X.ChecklistEnum.Unchecked);
			$(this).trigger("change");
		});
	},
	
	/*
	 * Stores text and binds default behavior for a standard set of text fields.
	 * @param object pChecklistText for storing text in memory and storage.
	 * @param jqobject pTextFields input or textarea elements to iterate and read text,
	 * if the textlists are swappable then provide a string for fresh queries.
	 * @param string pFieldName name of the text fields for notifying of change.
	 * @param int pMaxLength of characters in a text field.
	 * @param jqobject pRestoreButton to reset all text fields, optional.
	 */
	initializeTextlist: function(pTextlist, pTextFields, pFieldName, pMaxLength, pRestoreButton)
	{
		// Initialize the pre-written text in the text fields
		pTextlist.value = [];
		$(pTextFields).each(function()
		{
			var text = $(this).val();
			pTextlist.value.push(text);
			if (pTextlist.valueDefault)
			{
				pTextlist.valueDefault.push(text);
			}
		});
		
		/*
		 * Each text fields' value will become a delimited substring in one
		 * single string to be stored in localStorage.
		 */
		var i;
		if (localStorage[pTextlist.key] === undefined)
		{
			// If localStorage value is empty, replace with original values in text field
			localStorage[pTextlist.key] = pTextlist.value.join(I.cTextDelimiterChar);
		}
		else
		{
			var storedtextarray = localStorage[pTextlist.key].split(I.cTextDelimiterChar);
			// Load the stored text and regard missing entries
			for (i = 0; i < pTextlist.value.length; i++)
			{
				if (storedtextarray[i])
				{
					pTextlist.value[i] = storedtextarray[i];
				}
				else
				{
					pTextlist.value[i] = "";
				}
			}
			localStorage[pTextlist.key] = pTextlist.value.join(I.cTextDelimiterChar);
		}
		
		var updateStoredText = function()
		{
			// Read every text fields and rewrite the string of substrings again
			$(pTextFields).each(function(iIndex)
			{
				// Do not allow delimiter in the string to be stored
				pTextlist.value[iIndex] = $(this).val().replace(I.cTextDelimiterRegex, "");
			});
			localStorage[pTextlist.key] = pTextlist.value.join(I.cTextDelimiterChar);
		};
		
		// Bind text fields behavior
		$(pTextFields).each(function(iIndex)
		{
			$(this).attr("maxlength", pMaxLength); // Set number of characters allowed in the text field
			$(this).val(pTextlist.value[iIndex]); // Load initialized text
			
			$(this).change(function()
			{
				if (pFieldName)
				{
					I.write(pFieldName + " #" + (iIndex + 1) + " updated.");
				}
				updateStoredText();
			});
		});
		
		// Bind restore default values button
		if (pRestoreButton)
		{
			pRestoreButton.click(function()
			{
				if (confirm("Reset texts to default?"))
				{
					$(pTextFields).each(function(iIndex)
					{
						$(this).val(pTextlist.valueDefault[iIndex]).trigger("change");
					});
				}
			});
		}
	},
	
	/*
	 * Binds the buttons for swapping text list items.
	 * @param jqobject pListContainer the list.
	 * @param jqobject pSwapContainer to append the swap buttons.
	 * @param boolean pWantButtons whether to append the swap buttons if haven't created, optional.
	 * @param function pSaveFunction to execute after swapping.
	 * @pre Container's list items must be sole elements in the hierarchy.
	 */
	bindTextlistSwap: function(pListContainer, pSwapContainer, pSaveFunction)
	{
		var container = $(pListContainer);
		var listitems = container.children();
		var getListItem = function(pChild)
		{
			return pChild.closest(".jsSwappable");
		};
		
		// Insert swap buttons
		var swapcontainer = (pSwapContainer) ? $(pSwapContainer) : listitems;
		swapcontainer.each(function()
		{
			$(this).append("<span class='btnSwap'><button class='btnSwapUp'></button><button class='btnSwapDown'></button></span>");
		});
		listitems.each(function()
		{
			$(this).addClass("jsSwappable");
		});
		
		// Hovering over the swap buttons highlight the input elements of the swappable row
		container.find(".btnSwap").each(function()
		{
			$(this).hover(
				function()
				{
					getListItem($(this)).find("input[type='text']").addClass("cssInputFocused");
				},
				function()
				{
					getListItem($(this)).find("input[type='text']").removeClass("cssInputFocused");
				}
			);
		});
		
		// Bind swap behavior
		container.find(".btnSwapUp, .btnSwapDown").click(function()
		{
			var listitem = getListItem($(this));
			if ($(this).hasClass("btnSwapUp"))
			{
				var prev = listitem.prev();
				if (prev.length)
				{
					listitem.insertBefore(prev);
				}
				else
				{
					listitem.insertAfter(container.find(".jsSwappable").last());
				}
			}
			else
			{
				var next = listitem.next();
				if (next.length)
				{
					listitem.insertAfter(next);
				}
				else
				{
					listitem.insertBefore(container.find(".jsSwappable").first());
				}
			}
			// Save after swapping
			if (pSaveFunction)
			{
				pSaveFunction();
			}
			else
			{
				// Assume the change event was bound for saving
				listitem.find("input").trigger("change");
			}
		});
	},
	
	/*
	 * Loads chain checklist state as recorded in localStorage, and binds
	 * clicking behavior to the div simulated checkboxes.
	 * @param object pChain to initialize.
	 * @pre Chains HTML have been initialized.
	 */
	initializeChainChecklist: function(pChain)
	{
		var bar = $("#chnBar_" + pChain.nexus);
		var check = $("#chnCheck_" + pChain.nexus);
		var time = $("#chnTime_" + pChain.nexus);

		// Set the checkbox visual state as stored
		X.reapplyChainBarState(pChain.nexus, bar, check, time);
		
		if (C.isChainRegular(pChain))
		{
			/*
			 * Bind event handler for the time clickable for subscription.
			 */
			time.click(function()
			{
				var nexus = U.getSubintegerFromHTMLID($(this));
				var slottimes = $(".chnSlot_" + nexus).find("time");

				if (X.getChecklistItem(X.Checklists.ChainSubscription, nexus) === X.ChecklistEnum.Checked)
				{
					$(this).removeClass("chnTimeSubscribed");
					slottimes.removeClass("chnTimeSubscribed");
					X.setChecklistItem(X.Checklists.ChainSubscription, nexus, X.ChecklistEnum.Unchecked);
				}
				else
				{
					$(this).addClass("chnTimeSubscribed");
					slottimes.addClass("chnTimeSubscribed");
					X.setChecklistItem(X.Checklists.ChainSubscription, nexus, X.ChecklistEnum.Checked);
					// Set the alarm mode to subscription if not already
					if (O.Options.int_setAlarm !== O.IntEnum.Alarm.Subscription)
					{
						X.setFieldsetState("int_setAlarm", O.IntEnum.Alarm.Subscription);
					}
				}
			});
		}

		/*
		 * Bind event handler for the div "checkboxes".
		 */
		check.click(function()
		{
			// The ID was named so by the chain initializer, get the chain nexus
			var nexus = U.getSubintegerFromHTMLID($(this));
			var thisbar = $("#chnBar_" + nexus);
			var theseslots = $(".chnSlot_" + nexus);
			var display = (I.ModeCurrent === I.ModeEnum.Tile) ? "inline-block" : "block";
			// State of the div is stored in the Checklist object rather in the element itself
			switch (X.getChecklistItem(X.Checklists.Chain, nexus))
			{
				case X.ChecklistEnum.Unchecked:
				{
					thisbar.addClass("chnFaded");
					if (I.ModeCurrent !== I.ModeEnum.Tile)
					{
						$("#chnDetails_" + nexus).hide("fast");
					}
					$(this).addClass("chnChecked");
					X.setChecklistItem(X.Checklists.Chain, nexus, X.ChecklistEnum.Checked);
					theseslots.addClass("chnFaded")
						.find(".chnCheck").addClass("chnChecked");
				} break;
				case X.ChecklistEnum.Checked:
				{
					thisbar.removeClass("chnFaded").show("fast").css({display: display});
					if (I.ModeCurrent !== I.ModeEnum.Tile)
					{
						$("#chnDetails_" + nexus).show("fast").css({display: display});
					}
					$(this).removeClass("chnChecked");
					X.setChecklistItem(X.Checklists.Chain, nexus, X.ChecklistEnum.Unchecked);
					theseslots.show("fast").each(function()	
					{
						$(this).css({display: display}).removeClass("chnFaded")
							.find(".chnCheck").removeClass("chnChecked");
						if ($(this).hasClass("tmlIcon"))
						{
							$(this).css({display: "inline-block"});
						}
					});
				} break;
				case X.ChecklistEnum.Disabled:
				{
					thisbar.removeClass("chnFaded").show("fast").css({display: display});
					if (I.ModeCurrent !== I.ModeEnum.Tile)
					{
						$("#chnDetails_" + nexus).show("fast").css({display: display});
					}
					$(this).removeClass("chnChecked");
					X.setChecklistItem(X.Checklists.Chain, nexus, X.ChecklistEnum.Unchecked);
					theseslots.hide().removeClass("chnFaded")
						.find(".chnCheck").removeClass("chnChecked");
				} break;
			}
			X.hideCheckedChainBar(nexus);
			// Update the icons on the clock too
			K.checkoffChainIcon(nexus);
		});

		// Bind the delete chain text button [x]
		$("#chnDelete_" + pChain.nexus).click(function()
		{
			var nexus = U.getSubintegerFromHTMLID($(this));
			$("#chnBar_" + nexus).hide("slow");
			$(".chnSlot_" + nexus).hide("slow");
			X.setChecklistItem(X.Checklists.Chain, nexus, X.ChecklistEnum.Disabled);

			// Also update the clock icon
			K.checkoffChainIcon(nexus);
		});
	},
	reapplyChainBarState: function(pIndex, pBar, pCheck, pTime)
	{
		// Chain check
		switch (X.getChecklistItem(X.Checklists.Chain, pIndex))
		{
			case X.ChecklistEnum.Unchecked:
			{
				// Bar is not checked off, so don't do anything
			} break;
			case X.ChecklistEnum.Checked:
			{
				pBar.addClass("chnFaded");
				pCheck.addClass("chnChecked");
				if (O.Options.bol_hideChecked)
				{
					pBar.hide();
				}
			} break;
			case X.ChecklistEnum.Disabled:
			{
				pBar.hide();
			} break;
		}
		
		// Chain time
		if (C.isChainRegular(C.Chains[pIndex]) &&
			X.getChecklistItem(X.Checklists.ChainSubscription, pIndex) === X.ChecklistEnum.Checked)
		{
			pTime.addClass("chnTimeSubscribed");
		}
	},
	reapplyChainIconState: function(pChain, pIcon, pWantHide)
	{
		switch (X.getChecklistItem(X.Checklists.Chain, pChain.nexus))
		{
			case X.ChecklistEnum.Unchecked:
			{
				pIcon.removeClass("chnFaded");
			} break;
			case X.ChecklistEnum.Checked:
			{
				pIcon.addClass("chnFaded");
			} break;
			case X.ChecklistEnum.Disabled:
			{
				if (pWantHide)
				{
					pIcon.hide();
				}
				else
				{
					pIcon.addClass("chnFaded");
				}
			} break;
		}
	},
	hideCheckedChainBar: function(pIndex)
	{
		var display = (I.ModeCurrent === I.ModeEnum.Tile) ? "inline-block" : "block";
		// Hide the chain bar if opted
		if (X.getChecklistItem(X.Checklists.Chain, pIndex) === X.ChecklistEnum.Checked)
		{
			if (O.Options.bol_hideChecked)
			{
				$("#chnBar_" + pIndex).hide("fast");
				$(".chnSlot_" + pIndex).hide("fast");
			}
			else
			{
				$("#chnBar_" + pIndex).show("fast").css({display: display});
				$(".chnSlot_" + pIndex).each(function()
				{
					$(this).show("fast").css({display: display});
					if ($(this).hasClass("tmlIcon"))
					{
						$(this).css({display: "inline-block"});
					}
				});
			}
		}
	},
	
	/*
	 * Gets the checklist state of a chain.
	 * @param object pChain chain to test.
	 * @returns int state (use enum).
	 */
	getChainChecklistState: function(pChain)
	{
		return X.getChecklistItem(X.Checklists.Chain, pChain.nexus);
	},
	
	/*
	 * Prepares the personal checklist presentation.
	 */
	initializePersonalChecklist: function()
	{
		/*
		 * Setting this boolean will tell the clock ticker function to call the
		 * HTML timer update function.
		 */
		T.isChecklistCountdownsStarted = true;
		T.updateChecklistCountdowns();
		
		// Initially, only show the daily checklist; user clicks the buttons to toggle the various checklists
		$("#chlDungeon, #chlCustomWeekly").hide();
		
		// Buttons to toggle view between daily and weekly checklist
		var tabs = $("#chlCustomTabs button");
		var contcust = $("#chlCustom");
		var contdung = $("#chlDungeon");
		var contraid = $("#chlRaid");
		var chldaily = $("#chlCustomDaily");
		var chlweekly = $("#chlCustomWeekly");
		var clkdaily = $("#chlCountdownToDaily").hide();
		var clkweekly = $("#chlCountdownToWeekly").hide();
		var showChecklist = function(pTab, pContainer, pChecklist, pClock)
		{
			tabs.removeClass("btnActive");
			pTab.addClass("btnActive");
			contcust.hide();
			contdung.hide();
			contraid.hide();
			chldaily.hide();
			chlweekly.hide();
			clkdaily.hide();
			clkweekly.hide();
			pClock.show();
			pContainer.show();
			pChecklist.show().css({opacity: 0.5}).animate({opacity: 1}, 400);
		};
		
		$("#chlDungeonButton").click(function()
		{
			showChecklist($(this), contdung, contdung, clkdaily);
		});
		$("#chlCustomDailyButton").click(function()
		{
			showChecklist($(this), contcust, chldaily, clkdaily);
		}).trigger("click");
		$("#chlCustomWeeklyButton").click(function()
		{
			showChecklist($(this), contcust, chlweekly, clkweekly);
		});
		$("#chlRaidButton").click(function()
		{
			showChecklist($(this), contraid, contraid, clkweekly);
		});
		
		// Initialize the checklists
		X.initializeDungeonChecklist();
		X.initializeCustomChecklist();
		X.initializeRaidChecklist();
		X.rewrapCheckboxes();
	},
	
	/*
	 * Binds dungeon checkbox storage and calculator behavior.
	 */
	initializeDungeonChecklist: function()
	{
		X.initializeChecklist(X.Checklists.Dungeon, $("#chlDungeon input").length);
		// Load icons
		$("#chlDungeon .chlDungeonBar").each(function()
		{
			$(this).prepend("<ins class='chl_dungeon chl_" + $(this).data("name").toLowerCase() + "'></ins>");
		});
		
		var updateCalculator = function()
		{
			var money = X.Checklists.Dungeon.money;
			var gold = Math.floor(money / E.Exchange.COPPER_IN_GOLD);
			var silver = Math.floor(money / E.Exchange.SILVER_IN_GOLD) % E.Exchange.COPPER_IN_SILVER;
			var copper = money % E.Exchange.COPPER_IN_SILVER;
			$("#chlDungeonCalculator_Gold").text(gold);
			$("#chlDungeonCalculator_Silver").text(silver);
			$("#chlDungeonCalculator_Copper").text(copper);
		};
		
		// Update checkbox visual and do the calculation when clicked
		$("#chlDungeon input").each(function(iIndex)
		{
			// Bind checkbox behavior
			$(this).change(function()
			{
				var state = X.getCheckboxEnumState($(this));
				X.setChecklistItem(X.Checklists.Dungeon, iIndex, state);
				X.setCheckboxStyle(X.Checklists.Dungeon, iIndex, $(this));
				
				// Sum the checkbox's path money
				var calc = $("#chlDungeonCalculator");
				var money = X.Checklists.Dungeon.money;
				var sum = $(this).data("money");
				
				switch ($(this).data("mode"))
				{
					case "E": sum += calc.data("moneyaddexp"); break;
				}
				
				switch (state)
				{
					case X.ChecklistEnum.Disabled:
					{
						X.Checklists.Dungeon.money = money - sum;
					} break;
					case X.ChecklistEnum.Checked:
					{
						X.Checklists.Dungeon.money = money + sum;
					} break;
					default:
					{
						X.Checklists.Dungeon.money = money - sum;
					}
				}
				updateCalculator();
			});
		});
		// Double click a label (which wraps an input tag) to en/disable the checkbox
		$("#chlDungeon label").each(function(iIndex)
		{
			$(this).dblclick(function()
			{
				var checkbox = $(this).find("input:first-child");

				if (checkbox.prop("disabled") === false)
				{
					/*
					 * The double click triggers the click event, which causes
					 * the calculator to count the disabled checkbox, so trigger
					 * the unchecking of it first before disabling.
					 */
					if (checkbox.prop("checked") === true)
					{
						X.triggerCheckbox(checkbox, X.ChecklistEnum.Unchecked);
					}
					checkbox.prop("disabled", true).prop("checked", false);
				}
				else
				{
					checkbox.prop("disabled", false);
				}
				X.setChecklistItem(X.Checklists.Dungeon, iIndex, X.getCheckboxEnumState(checkbox));
				X.setCheckboxStyle(X.Checklists.Dungeon, iIndex, checkbox);
			});
		});
		
		// Restore checklist state from stored by triggering the checkboxes (behaviors already bound)
		$("#chlDungeon input").each(function(iIndex)
		{
			X.triggerCheckboxEnumState(X.Checklists.Dungeon, iIndex, $(this));
		});
		
		// Bind uncheck all button
		$("#chlDungeonUncheck").click(function()
		{
			X.clearChecklist(X.Checklists.Dungeon, X.ChecklistJob.UncheckTheChecked);
			$("#chlDungeon input").each(function(iIndex)
			{
				if ($(this).prop("checked") === true)
				{
					$(this).trigger("click");
				};
				X.setCheckboxStyle(X.Checklists.Dungeon, iIndex, $(this));
			});
		});
	},
	
	/*
	 * Binds raid checkbox storage.
	 */
	initializeRaidChecklist: function()
	{
		X.initializeCheckboxlist(X.Checklists.Raid, $("#chlRaid input"), X.ChecklistJob.UncheckAll, $("#chlRaidUncheck"));
		// Load icons
		$("#chlRaid input").each(function()
		{
			$(this).before("<ins class='chl_raid chl_" + $(this).data("name") + "'></ins>");
		});
	},
	
	/*
	 * Binds checkbox and text field joined behavior.
	 */
	initializeCustomChecklist: function()
	{
		// Generate initial set of checkboxes and textboxes
		var checkitemhtml = "<li><label><input type='checkbox' />" + I.Symbol.Filler + "</label><input class='cssInputTextLine' type='text' /></li>";
		var dailylist = $("#chlCustomListDaily");
		var weeklylist = $("#chlCustomListWeekly");
		for (var i = 0; i < O.Options.int_numChecklistDaily; i++)
		{
			dailylist.append(checkitemhtml);
		}
		for (var i = 0; i < O.Options.int_numChecklistWeekly; i++)
		{
			weeklylist.append(checkitemhtml);
		}
		
		var insertSampleList = function(pList)
		{
			var samples = pList.attr("data-samples").split(I.cTextDelimiterChar);
			for (var i = 0; i < samples.length; i++)
			{
				pList.find("input[type='text']:eq(" + i + ")").val(samples[i]);
			}
		};
		insertSampleList(dailylist);
		insertSampleList(weeklylist);
		
		// Bind checkboxes and textboxes behavior
		var bindCustomChecklistBehavior = function(pChecklist, pTextlist, pListName)
		{
			var listid = "#chlCustomList" + pListName;
			var thislist = $(listid);
			var checkboxes = thislist.find("input:checkbox");
			X.initializeChecklist(pChecklist, checkboxes.length);

			checkboxes.each(function(iIndex)
			{
				$(this).change(function()
				{
					var state = X.getCheckboxEnumState($(this));

					X.setChecklistItem(pChecklist, iIndex, state);
					X.setCheckboxStyle(pChecklist, iIndex, $(this));

					var textinput = X.getCheckboxLabel($(this)).next();
					if (state === X.ChecklistEnum.Checked)
					{
						textinput.addClass("chlCustomTextChecked");
					}
					else
					{
						textinput.removeClass("chlCustomTextChecked");
					}
				});

				// Now that this checkbox is bound, trigger it as the state in checklist
				X.triggerCheckboxEnumState(pChecklist, iIndex, $(this));
			});

			// Bind uncheck all button
			$("#chlCustomUncheck" + pListName).click(function()
			{
				X.clearChecklist(pChecklist, X.ChecklistJob.UncheckTheChecked);
				thislist.find("input:checkbox").each(function(iIndex)
				{
					if ($(this).prop("checked"))
					{
						$(this).trigger("click");
					};
					X.setCheckboxStyle(pChecklist, iIndex, $(this));
				});
			});

			// Bind text fields behavior
			var restore = $("#chlCustomRestore" + pListName);
			X.initializeTextlist(pTextlist, listid + " input:text", null, 48, restore);
			X.bindTextlistSwap(thislist);
		};
		bindCustomChecklistBehavior(X.Checklists.CustomDaily, X.Textlists.CustomTextDaily, "Daily");
		bindCustomChecklistBehavior(X.Checklists.CustomWeekly, X.Textlists.CustomTextWeekly, "Weekly");
	},
	
	/*
	 * Clears the daily sensitive checklists. Called by the daily reset function.
	 */
	clearCustomChecklistDaily: function()
	{
		$("#chlCustomUncheckDaily").trigger("click");
		$("#chlDungeonUncheck").trigger("click");
		X.clearChecklist(X.Checklists.CustomDaily, X.ChecklistJob.UncheckTheChecked);
		X.clearChecklist(X.Checklists.Dungeon, X.ChecklistJob.UncheckTheChecked);
	},
	clearCustomChecklistWeekly: function()
	{
		$("#chlCustomUncheckWeekly").trigger("click");
		$("#chlRaidUncheck").trigger("click");
		X.clearChecklist(X.Checklists.CustomWeekly, X.ChecklistJob.UncheckTheChecked);
		X.clearChecklist(X.Checklists.Raid, X.ChecklistJob.UncheckTheChecked);
	},
	
	/*
	 * Binds notepad textarea behavior and button pages behavior.
	 */
	initializeNotepad: function()
	{
		// Numbered buttons' behavior
		$("#chlNotepadButtons button").each(function(iIndex)
		{
			$(this).click(function()
			{
				// Show selected number's sheet
				$("#chlNotepadSheets textarea").hide().eq(iIndex).show()
					.css({opacity: 0.5}).animate({opacity: 1}, 400);
				$("#chlNotepadButtons button").removeClass("btnActive");
				$(this).addClass("btnActive");
			});
		}).first().click(); // First sheet is default view
		
		// Bind text fields behavior
		var items = $("#chlNotepadSheets textarea");
		var restore = $("#chlNotepadRestore");
		X.initializeTextlist(X.Textlists.NotepadText, items, "Notepad sheet", 4096, restore);
		// Customize notepad according to options
		items.css("height", O.Options.int_sizeNotepadHeight);
		items.css("font-size", O.Options.int_sizeNotepadFont);
		items.first().show();
	}
};
U = {
/* =============================================================================
 * @@URL management for links and string/array/object manipulation
 * ========================================================================== */

	URL_META:
	{
		Forum: "https://www.tapatalk.com/groups/renaka/gw2timer-com-gw2-guild-wars-2-f4/",
		News: "https://www.tapatalk.com/groups/renaka/gw2timer-update-notes-t141.html",
		Overlay: "https://www.tapatalk.com/groups/renaka/gw2navi-guild-wars-2-overlay-t144.html",
		BuildNotes: "https://{0}-forum.guildwars2.com/categories/game-release-notes"
	},
	ScriptURLs: {}, // Associative array of script URLs, so they are not loaded again
	APIKey: null,
	APIKeyLength: 72, // The exact length of the API key in order for it to be used in the URL fragment
	ServerIDLength: 4,
	
	URL_API:
	{
		// Achievements
		Achievements: "https://api.guildwars2.com/v2/achievements",
		Daily: "https://api.guildwars2.com/v2/achievements/daily",
		Tomorrow: "https://api.guildwars2.com/v2/achievements/daily/tomorrow",
		
		// Map
		LangKey: "",
		Maps: "https://api.guildwars2.com/v1/maps",
		MapFloorTyria: "https://api.guildwars2.com/v1/map_floor.json?continent_id=1&floor=1",
		MapFloorMists: "https://api.guildwars2.com/v1/map_floor.json?continent_id=2&floor=1",
		EventDetails: "https://api.guildwars2.com/v1/event_details.json",
		
		// Exchange
		ItemListing: "https://api.guildwars2.com/v2/commerce/listings",
		ItemPrice: "https://api.guildwars2.com/v2/commerce/prices",
		ItemDetail: "https://api.guildwars2.com/v2/items",
		CoinPrice: "https://api.guildwars2.com/v2/commerce/exchange/gems?quantity=",
		GemPrice: "https://api.guildwars2.com/v2/commerce/exchange/coins?quantity=",
		
		// Guild
		Guild: "https://api.guildwars2.com/v2/guild/",
		
		// WvW
		Match: "https://api.guildwars2.com/v2/wvw/matches?world=",
		Matches: "https://api.guildwars2.com/v2/wvw/matches/",
		MatchFallback: "https://api.guildwars2.com/v1/wvw/match_details.json?match_id=",
		MatchesFallback: "https://api.guildwars2.com/v1/wvw/matches.json",
		
		// Other
		Root: "https://api.guildwars2.com/v2.json",
		Support: "https://en-forum.guildwars2.com/categories/api-development",
		Build: "https://api.guildwars2.com/v2/build",
		Worlds: "https://api.guildwars2.com/v2/worlds",
		Prefix: "https://api.guildwars2.com/v2/",
		Prefix1: "https://api.guildwars2.com/v1/",
		TextToSpeech: "http://code.responsivevoice.org/getvoice.php?tl=",
		TextToSpeechNative: "bin/tts/mespeak.js",
		ThreeDimensional: "https://ajax.googleapis.com/ajax/libs/threejs/r76/three.min.js",
		Charts: "bin/highstock.js"
	},
	PageLimit: 200, // Number of entries per API retrieval for paginated endpoints
	IDsLimit: 200, // Max item IDs in a single fetch URL
	
	URL_IMG:
	{
		Placeholder: "img/ui/placeholder.png",
		Sector: "img/map/scope.png",
		Waypoint: "img/map/waypoint.png",
		WaypointOver: "img/map/waypoint_h.png",
		Landmark: "img/map/landmark.png",
		LandmarkOver: "img/map/landmark_h.png",
		Vista: "img/map/vista.png",
		Mastery: "img/map/mastery.png",
		Challenge: "img/map/challenge.png",
		Heart: "img/map/heart.png"
	},
	
	URL_DATA:
	{
		Maps: "cache/maps_{0}.json",
		Events: "cache/events_{0}.json",
		Account: "data/account.js",
		WvW: "data/wvw.js",
		Itinerary: "data/itinerary.js",
		Materials: "data/materials.js",
		Skins: "data/skins.js",
		Outfits: "data/outfits.js",
		Gliders: "data/gliders.js",
		Dyes: "data/dyes.js",
		Minis: "data/minis.js",
		Carriers: "data/carriers.js",
		Champions: "data/champions.js",
		Finishers: "data/finishers.js",
		Nodes: "data/nodes.js",
		Cats: "data/cats.js",
		Raids: "data/raids.js",
		Dungeons: "data/dungeons.js",
		Catalog: "data/catalog.js",
		Cleanup: "data/cleanup.js",
		Ascended: "data/ascended.js",
		Recipes: "data/recipes.js",
		SAB: "data/sab.js",
		Prices: "cache/prices.json",
		Gem:  "data/gem.js",
		Sale:  "data/sale.js",
		Museum:  "data/museum.js",
		Pact:  "data/pact.js",
		// Data to load when opening a map page section
		Unscheduled: "data/chains-add.js",
		Daily: "data/daily.js",
		DryTop: "data/drytop.js",
		Resource: "data/resource.js",
		JP: "data/jp.js",
		Collectible: "data/collectible.js",
		Guild: "data/guild.js"
	},
	
	initializeAPIURLs: function()
	{
		var lang = D.langPartiallySupported;
		U.URL_API.LangKey = "lang=" + lang;
		
		var replacekey = I.cTextReplace;
		U.URL_META.BuildNotes = U.URL_META.BuildNotes.replace(replacekey, lang);
		U.URL_DATA.Maps = U.URL_DATA.Maps.replace(replacekey, lang);
		U.URL_DATA.Events = U.URL_DATA.Events.replace(replacekey, lang);
		U.URL_API.Worlds += "?" + U.URL_API.LangKey + "&ids=";
		U.URL_API.TextToSpeech += lang + "&sv=&vn=&pitch=0.5&rate=0.4";
	},
	
	/*
	 * Analog for jQuery's getScript but with the cache option enabled.
	 * @param string pURL
	 * @param function pCallback
	 * @param boolean pWantCache
	 * @returns jqobject
	 */
	getScript: function(pURL, pCallback, pWantCache)
	{
		var wantcache = (pWantCache !== undefined) ? pWantCache : true;
		if (U.ScriptURLs[pURL] === undefined || wantcache === false)
		{
			U.ScriptURLs[pURL] = true;
			var jqxhr = $.ajax({
				dataType: "script",
				url: pURL,
				cache: wantcache,
				success: function()
				{
					if (pCallback)
					{
						pCallback();
					}
				}
			});
			return jqxhr;
		}
		else if (pCallback)
		{
			pCallback();
		}
		// Dummy jqxhr return in case of already loaded
		return {fail: function() {}};
	},
	getJSON: function(pURL, pCallback, pWantCache)
	{
		var wantcache = (pWantCache !== undefined) ? pWantCache : true;
		var jqxhr = $.ajax({
			dataType: "json",
			url: pURL,
			cache: wantcache,
			success: function(pData)
			{
				if (pCallback)
				{
					pCallback(pData);
				}
			}
		});
		return jqxhr;
	},
	
	/*
	 * Fetches all the pages of an API endpoint and combines them into a single array.
	 * @param enum pURL
	 * @objparam boolean aWantCache whether to use default caching.
	 * @objparam enum aPermission of the endpoint.
	 * @objparam function aCallback with the combined pages as parameter.
	 * @objparam function aError to execute upon failure.
	 */
	fetchPaginated: function(pURL, pSettings)
	{
		var Settings = pSettings || {};
		var scrapethreshold = 50;
		var numfetched = 0;
		var numtofetch;
		var url = pURL + "&page_size=" + U.PageLimit;
		var wantcache = (Settings.aWantCache !== undefined) ? Settings.aWantCache : false;
		var pages = [];
		var book = [];
		
		var combinePages = function()
		{
			if (numfetched !== numtofetch)
			{
				return;
			}
			pages.forEach(function(iPage)
			{
				if (iPage)
				{
					book = book.concat(iPage);
				}
			});
			// Return the result in the callback
			Settings.aCallback(book);
		};
		
		$.ajax({
			dataType: "json",
			url: url,
			cache: wantcache,
			success: function(pData, pStatus, pXHR)
			{
				// First retrieval fetches the first page, which also tells how many pages there are
				numfetched++;
				numtofetch = parseInt(pXHR.getResponseHeader("X-Page-Total"));
				if (numtofetch > scrapethreshold) // If the number of pages to fetch is too large then delegate to the scrape function
				{
					var pagenumbers = [];
					for (var i = 1; i < numtofetch; i++)
					{
						pagenumbers.push(i);
					}
					Z.scrapeAPIArray(url + "&page=", pagenumbers, {
						aIsStandard: false,
						aCooldown: 30,
						aNumRetries: 10,
						aCallback: function(pPages)
					{
						book = book.concat(pData);
						pPages.forEach(function(iPage)
						{
							book = book.concat(iPage);
						});
						Settings.aCallback(book);
					}});
				}
				else if (numtofetch > 1)
				{
					pages = new Array(numtofetch);
					pages[0] = pData;
					// Fetch the rest of the pages and insert them to the sequential array
					for (var i = 1; i < numtofetch; i++)
					{
						(function(iIndex)
						{
							$.ajax({
								dataType: "json",
								url: url + "&page=" + iIndex,
								cache: wantcache,
								success: function(pDataInner)
								{
									pages[iIndex] = pDataInner;
									numfetched++;
									combinePages();
								},
								error: function()
								{
									numtofetch--;
									combinePages();
								}
							});
						})(i);
					}
				}
				else if (numtofetch === 1)
				{
					// If only one page exists then proceed with processing
					pages[0] = pData;
					combinePages();
				}
				else // No current transactions
				{
					Settings.aCallback(null);
				}
			},
			error: function(pRequest, pStatus)
			{
				if (Settings.aError)
				{
					Settings.aError();
				}
				else if (Settings.aPermission)
				{
					A.printError(Settings.aPermission, pStatus);
				}
			}
		});
	},
	
	/*
	 * Fetches multiple URLs with IDs embedded.
	 * @param string pURL with substring "{0}" to be replaced with an ID.
	 * @param array pIDs
	 */
	fetchPattern: function(pURL, pIDs, pSettings)
	{
		var Settings = pSettings || {};
		var wantcache = (Settings.aWantCache !== undefined) ? Settings.aWantCache : true;
		var data = {};
		var datasorted = {}, idata;
		var numfetched = 0;
		var numtofetch = pIDs.length;
		var finalizeFetch = function()
		{
			A.setProgressBar(numfetched, numtofetch);
			if (numfetched === numtofetch)
			{
				// Sort according to original ID order
				for (var i in pIDs)
				{
					idata = data[(pIDs[i])];
					if (idata)
					{
						datasorted[(pIDs[i])] = idata;
					}
				}
				if (Settings.aCallback)
				{
					Settings.aCallback(datasorted, numfetched);
				}
			}
		};
		
		// Fetch all at once
		for (var i = 0; i < pIDs.length; i++)
		{
			(function(iID)
			{
				U.getJSON(pURL.replace(I.cTextReplace, U.encodeURL(iID)), function(pData)
				{
					data[iID] = pData;
					numfetched++;
					finalizeFetch();
				}, wantcache).fail(function()
				{
					numtofetch--;
					finalizeFetch();
				});
			})(pIDs[i]);
		}
	},
	
	/*
	 * Bulk fetches an API endpoint using provided IDs. May recursively queue
	 * the fetches so the IDs can fit in each single URL request.
	 * @param string pURL prefix.
	 * @param array pIDs numbers.
	 * @objparam function aCallback with array of raw API objects accumulated.
	 * @objparam boolean aWantCache use browser cache from previous fetches, optional.
	 * @objparam string aLanguage code, otherwise user's language is used, optional.
	 */
	fetchAPI: function(pURL, pIDs, pSettings)
	{
		var Settings = pSettings || {};
		var wantcache = (Settings.aWantCache !== undefined) ? Settings.aWantCache : false;
		var itemids = [];
		var retarr = [];
		var failarr = [];
		var numfetched = 0;
		var numtofetch = 0;
		
		var finishFetch = function()
		{
			// Compile IDs that the API did not return
			if (itemids.length !== retarr.length)
			{
				var retids = [];
				for (var i in retarr)
				{
					if (retarr[i].id)
					{
						retids.push(retarr[i].id);
					}
				}
				failarr = U.getDifference(itemids, retids);
			}
			
			A.fillProgressBar();
			if (Settings.aCallback)
			{
				Settings.aCallback(retarr, failarr);
			}
		};
		
		var fetchArray = function(pArray, pIsRetry)
		{
			var fetchids = pArray, remainids;
			if (fetchids.length > U.IDsLimit)
			{
				fetchids = pArray.slice(0, U.IDsLimit);
				remainids = pArray.slice(U.IDsLimit);
			}
			var continueFetch = function()
			{
				if (remainids)
				{
					numfetched += U.IDsLimit;
					A.setProgressBar(numfetched, numtofetch);
					fetchArray(remainids);
				}
				else
				{
					finishFetch();
				}
			};
			
			$.ajax({
				dataType: "json",
				url: U.getLangURL(pURL, Settings.aLanguage) + "&ids=" + fetchids.join(","),
				cache: wantcache,
				success: function(pData)
				{
					retarr = retarr.concat(pData);
					continueFetch();
				},
				error: function()
				{
					// If error then retry this batch once, else continue with remainder
					if (pIsRetry)
					{
						continueFetch();
					}
					else
					{
						fetchArray(pArray, true);
					}
				}
			});
		};
		
		// First call to recursive fetch function
		if (pIDs.length)
		{
			itemids = U.getUnique(pIDs);
			numtofetch = itemids.length;
			fetchArray(itemids);
		}
		else if (Settings.aCallback)
		{
			Settings.aCallback();
		}
	},
	
	/*
	 * Gets the appropriate query string divider for a URL.
	 * @param string pURL.
	 * @param string pLanguage code to use instead of the user's, optional.
	 * @returns string
	 */
	getDivider: function(pURL)
	{
		return (pURL.indexOf("?") !== -1) ? "&" : "?";
	},
	getLangURL: function(pURL, pLanguage)
	{
		return pURL + U.getDivider(pURL) + (pLanguage ? ("lang=" + pLanguage) : U.URL_API.LangKey);
	},
	
	/*
	 * Gets the language specific URL of a standard v2 API that requires an ID.
	 * @param string pAPI endpoint name.
	 * @param int pID for request, if provided "true" then will use "all" query.
	 * @returns string URL to request data.
	 */
	getAPI: function(pAPI, pID)
	{
		var idstr = (pID === undefined) ? "" : ((pID === true) ? "?ids=all" : "/" + pID);
		return U.getLangURL(U.URL_API.Prefix + pAPI + idstr);
	},
	getAPIURL: function(pAPI)
	{
		return U.URL_API.Prefix + pAPI.toLowerCase();
	},
	getAPIMap: function(pID)
	{
		return U.getAPI("maps", pID);
	},
	getAPIAchievement: function(pID)
	{
		return U.getAPI("achievements", pID);
	},
	getAPIItem: function(pID)
	{
		return U.getAPI("items", pID);
	},
	getAPISkin: function(pID)
	{
		return U.getAPI("skins", pID);
	},
	getAPIRecipe: function(pID)
	{
		return U.getAPI("recipes", pID);
	},
	getAPIMaterial: function(pID)
	{
		return U.getAPI("materials", pID);
	},
	getAPIMini: function(pID)
	{
		return U.getAPI("minis", pID);
	},
	getAPISkill: function(pID)
	{
		return U.getAPI("skills", pID);
	},
	getAPITrait: function(pID)
	{
		return U.getAPI("traits", pID);
	},
	getAPISpecialization: function(pID)
	{
		return U.getAPI("specializations", pID);
	},
	getAPITitle: function(pID)
	{
		return U.getAPI("titles", pID);
	},
	getAPIPrice: function(pID)
	{
		return U.URL_API.ItemPrice + "/" + pID;
	},
	getAPIListings: function(pID)
	{
		return U.URL_API.ItemListing + "/" + pID;
	},
	
	/*
	 * Gets URL to retrieve the local items database.
	 * @param string pLanguage code.
	 * @returns string.
	 */
	getDatabaseURL: function(pName, pLanguage)
	{
		return "test/" + pName + "_" + pLanguage + I.cTXT;
	},
	getItemsDatabaseURL: function(pLanguage)
	{
		return "test/items_" + pLanguage + I.cTXT;
	},
	getDataScriptURL: function(pName)
	{
		return "data/" + pName.toLowerCase() + ".js";
	},
	getCacheURL: function(pName, pLanguage)
	{
		return "cache/" + pName.toLowerCase() + "_" + (pLanguage || D.langPartiallySupported) + I.cJSON;
	},
	getRecordHeader: function(pName)
	{
		return window["GW2T_" + pName.toUpperCase() + "_HEADERS"];
	},
	getRecordMetadata: function(pName)
	{
		return window["GW2T_" + pName.toUpperCase() + "_METADATA"];
	},
	getRecordBlacklist: function(pName)
	{
		return window["GW2T_" + pName.toUpperCase() + "_BLACKLIST"];
	},
	getRecordData: function(pName)
	{
		return window["GW2T_" + pName.toUpperCase() + "_DATA"];
	},

	/*
	 * URLArguments (Args) may contain Options object's variables. In the form of:
	 * http://example.com/?ExampleKey=ExampleValue&MoreExampleKey=MoreExampleValue
	 * so https://gw2timer.com/?bol_showPanel=false will hide the side panel
	 * regardless of previous localStorage or the defaults here.
	 * Note that "bol_showPanel" matches exactly as in the Options, otherwise
	 * it would have not overridden any Options variable. Values used apart from
	 * comparison should be sanitized first.
	 */
	Args: {},
	KeyEnum:
	{
		Page: "page",
		Section: "section",
		Article: "article",
		Mode: "mode",
		Go: "go",
		Draw: "draw",
		Fragment: "fragment",
		AutoAudit: "isAutoAudit"
	},
	
	/*
	 * Data type enum.
	 */
	TypeEnum:
	{
		isObject: "obj",
		isAssoc: "asc",
		isArray: "arr",
		isString: "str",
		isEnum: "enu",
		isInteger: "int",
		isFloat: "flt",
		isBoolean: "bol"
	},
	
	/*
	 * Capitalization case style enum.
	 */
	CaseEnum:
	{
		Original: -1,
		None: 0,
		Lower: 1,
		Sentence: 2,
		Title: 3,
		Every: 4,
		Upper: 5
	},
	
	/*
	 * Tells if a string is an enum of an enum object.
	 * @param string pString to test for inclusion.
	 * @param object pEnum container of enums.
	 * @returns boolean true if within.
	 */
	isEnumWithin: function(pString, pEnum)
	{
		for (var i in pEnum)
		{
			if (pEnum[i].toLowerCase() === pString.toLowerCase())
			{
				return true;
			}
		}
		return false;
	},
	
	/*
	 * Extracts arguments from a https://en.wikipedia.org/wiki/Query_string
	 * @returns object containing the key-value pairs.
	 */
	convertQueryString: function(pString)
	{
		var urlargs = pString.substr(1).replace(/&amp;/g, "&").split("&"); // Skip the "?" at the beginning of the query string
		if (urlargs === "")
		{
			return {};
		}
		
		var argsobject = {};
		for (var i = 0; i < urlargs.length; ++i)
		{
			var pair = urlargs[i].split("=");
			if (pair.length !== 2)
			{
				continue;
			}
			argsobject[pair[0]] = decodeURIComponent(pair[1].replace(/\+/g, " "));
		}
		return argsobject;
	},
	getURLArguments: function()
	{
		var loc = window.location;
		var argsobject = U.convertQueryString(loc.search);
		// The URL substring after # will be assigned to the fragment key
		if (loc.hash.length)
		{
			argsobject[U.KeyEnum.Fragment] = loc.hash.substr(1);
		}
		return argsobject;
	},
	
	/*
	 * Parses and stores the URL arguments then do appropriate changes.
	 */
	enforceURLArgumentsFirst: function()
	{
		U.Args = U.getURLArguments();
		I.cSiteTitle = document.title;
		// Store article value, if exists
		I.ArticleCurrent = U.Args[U.KeyEnum.Article];
		U.Args[U.KeyEnum.Article] = null;
		// Manage special URLs
		U.enforceURLArgumentsSpecial();
		
		var i;
		// Set up program mode
		var mode = U.Args[U.KeyEnum.Mode];
		if (mode)
		{
			for (i in I.ModeEnum)
			{
				if (I.ModeEnum[i].toLowerCase() === mode.toLowerCase())
				{
					I.ModeCurrent = I.ModeEnum[i];
					break;
				}
			}
		}
		
		if (I.ModeCurrent === null)
		{
			I.ModeCurrent = I.ModeEnum.Website;
		}
	},
	
	/*
	 * Does the commands within the address bar after the site's domain name.
	 * @pre URLArguments object was initialized by extraction.
	 */
	enforceURLArgumentsLast: function()
	{
		U.interpretPage(U.Args[U.KeyEnum.Page]);
	},
	
	/*
	 * Special URL keys that override others.
	 */
	enforceURLArgumentsSpecial: function()
	{
		/*
		 * The page key could've been written by the 404 webpage, which converts
		 * forward slash (/) separated directories into query strings, with
		 * the first argument as the page value. So if a user goes to the URL
		 * https://gw2timer.com/navi they will be redirected to https://gw2timer.com/?page=Navi
		 * These special pages must have unique names from the content pages.
		 */
		var i, ii;
		var ithpage;
		var go = function(pURL)
		{
			$("body").hide();
			document.location = pURL;
		};
		var page = U.Args[U.KeyEnum.Page];
		var fragment = U.Args[U.KeyEnum.Fragment];
		// Analyze URL fragment identifier
		if (fragment)
		{
			// If fragment looks like an API key
			if (fragment.length === U.APIKeyLength)
			{
				U.APIKey = U.stripToAlphanumericDash(fragment).toUpperCase();
				if (page === undefined)
				{
					U.Args[U.KeyEnum.Page] = I.SpecialPageEnum.Account;
				}
			}
		}
		// Analyze the page query
		if (page)
		{
			page = page.toLowerCase();
			// If page is a shortcut alias for a real page
			if (page === "a")
			{
				U.Args[U.KeyEnum.Page] = I.SpecialPageEnum.Account;
			}
			else if (page === "audit")
			{
				U.Args[U.KeyEnum.Page] = I.SpecialPageEnum.Account;
				U.Args[U.KeyEnum.Section] = I.PageEnum.Account.Characters;
				I.ArticleCurrent = I.SpecialPageEnum.Audit;
			}
			// Only proceed if "page" is not an actual content page
			else if (U.isEnumWithin(page, I.PlateEnum) === false)
			{
				if (page === "forum" || page === "forums")
				{
					go(U.URL_META.Forum);
				}
				if (page === "navi" || page === "overlay")
				{
					go(U.URL_META.Overlay);
				}
				else if (page === "m" || page === "mobile")
				{
					U.Args[U.KeyEnum.Mode] = I.ModeEnum.Mobile;
				}
				else if (page === "s" || page === "simple")
				{
					U.Args[U.KeyEnum.Mode] = I.ModeEnum.Simple;
				}
				else if (page === "t" || page === "tile")
				{
					U.Args[U.KeyEnum.Mode] = I.ModeEnum.Tile;
				}
				else if (page === "draw")
				{
					localStorage["bol_showWorldCompletion"] = "true";
					U.Args[U.KeyEnum.Page] = I.PlateEnum.Map;
					U.Args[U.KeyEnum.Draw] = U.Args[U.KeyEnum.Section];
				}
				else
				{
					// Check if is a page's section
					for (i in I.PageEnum)
					{
						ithpage = I.PageEnum[i];
						for (ii in ithpage)
						{
							if (ii.toLowerCase() === page)
							{
								// Page part becomes the section, section part becomes the article
								if (U.Args[U.KeyEnum.Section] !== undefined)
								{
									I.ArticleCurrent = U.Args[U.KeyEnum.Section];
								}
								U.Args[U.KeyEnum.Page] = i;
								U.Args[U.KeyEnum.Section] = ii;
								return;
							}
						}
					}
					// Check if is a server ID
					if (isNaN(page) === false && page.length === U.ServerIDLength)
					{
						for (var i in O.OptionEnum.Server)
						{
							if (O.OptionEnum.Server[i] === page)
							{
								U.Args["enu_Server"] = page;
								U.Args[U.KeyEnum.Page] = I.SpecialPageEnum.WvW;
								return;
							}
						}
					}
				}
			}
		}
		// Remember the initial page when the site loaded
		if (U.Args[U.KeyEnum.Page] !== undefined)
		{
			I.PageInitial = U.Args[U.KeyEnum.Page].toLowerCase();
		}
		
		// Check if the special page is actually a collectible
		for (i in X.Collectibles)
		{
			ithpage = X.Collectibles[i].urlkey;
			if (ithpage === page || U.Args[ithpage] !== undefined)
			{
				U.Args[U.KeyEnum.Page] = I.PlateEnum.Map;
				U.Args[U.KeyEnum.Section] = I.PageEnum.Map.Collectible;
				// Setting the article key will tell the generate collectibles function to do so for that one
				I.ArticleCurrent = ithpage;
				return;
			}
		}
		// Check if is a zone name
		if (page)
		{
			for (i in M.Zones)
			{
				if (page.indexOf(i) !== -1)
				{
					U.Args[U.KeyEnum.Go] = i;
					return;
				}
			}
		}
	},
	
	/*
	 * Tells if the current article variable matches the requesting initialization
	 * function before "opening" parts of the section automatically.
	 * @param string pArticle.
	 * @returns boolean.
	 */
	verifyArticle: function(pArticle, pCallback)
	{
		if (I.ArticleCurrent && I.ArticleCurrent.toLowerCase() === pArticle.toLowerCase())
		{
			I.ArticleCurrent = null;
			if (pCallback)
			{
				pCallback();
			}
			return true;
		}
		return false;
	},
	nullifyArticle: function()
	{
		I.ArticleCurrent = null;
	},
	
	/*
	 * Triggers the button or header associated with the requested page and section,
	 * which will cause that section to expand/show. This is to be called after
	 * a page has been AJAX loaded and bindings completed.
	 * @objparam string aPrefix HTML ID prefix of the button to trigger, optional.
	 * @objparam string aSection name to override URL's, optional.
	 * @objparam string aInitialSection to open initially, optional.
	 * @objparam string aButton HTML ID of the button to trigger, optional.
	 */
	openSectionFromURL: function(pSettings)
	{
		var Settings = $.extend({
			aPrefix: I.cHeaderPrefix + I.PageCurrent + "_",
			aSection: null,
			aInitialSection: null,
			aButton: null
		}, pSettings);
		
		/*
		 * Enclosed in setTimeout because without it the scroll to element
		 * animation function is glitchy (the function is called when the header
		 * is clicked so the page automatically scrolls to the header).
		 */
		setTimeout(function()
		{
			var section = (U.Args[U.KeyEnum.Section]) ? (U.Args[U.KeyEnum.Section]).toString() : null;
			// If section was specified in the URL arguments
			if (section)
			{
				U.Args[U.KeyEnum.Section] = null; // Use once only
				section = U.stripToAlphanumeric(section);
				var elm = $(null);
				if (typeof Settings.aButton === "string")
				{
					if (Settings.aSection !== undefined
						&& Settings.aSection.toLowerCase() === section.toLowerCase())
					{
						elm = $(Settings.aButton);
					}
				}
				else
				{
					// Try going to a section name in sentence letter case
					elm = $(Settings.aPrefix + U.toFirstUpperCase(section));
					if ( ! elm.length)
					{
						// Else try going to a section name in all caps
						elm = $(Settings.aPrefix + section.toUpperCase());
					}
					if (I.PageCurrent === I.PlateEnum.Chains)
					{
						// Click the chains header to hide it because it's shown by default
						$("#headerChains_Scheduled").trigger("click");
					}
				}
				elm.trigger("click");
			}
			// If section was specified by the function call
			else if (typeof Settings.aInitialSection === "string")
			{
				$(Settings.aPrefix + Settings.aInitialSection).trigger("click");
			}
		}, 0);
	},
	
	/*
	 * Automatically opens a "page" for the user, whether the content is generated or not.
	 * @param enum pPage
	 */
	interpretPage: function(pPage)
	{
		if (typeof pPage !== "string")
		{
			return;
		}
		var page = U.toFirstUpperCase(pPage);
		var pagecaps = pPage.toUpperCase();
		var pagebutton;
		var isaccountvisible = $("#panelAccount").is(":visible");
		var iswvwvisible = P.MapSwitchWebsite === P.MapEnum.Mists;
		var viewMap = function()
		{
			// Close the account panel in order to see the map
			if (isaccountvisible)
			{
				I.toggleAccount();
			}
			// Switch to PvE map if viewing WvW
			if (iswvwvisible)
			{
				I.switchMap();
			}
		};
		var viewWvW = function()
		{
			// Close the account panel in order to see the map
			if (isaccountvisible)
			{
				I.toggleAccount();
			}
			// Switch to WvW map if viewing PvE
			if (iswvwvisible === false)
			{
				I.switchMap(page);
			}
		};
		var viewAccount = function(page)
		{
			pagebutton = $("#accMenu_" + page);
			if (pagebutton.length)
			{
				if (isaccountvisible === false)
				{
					I.toggleAccount();
				}
				pagebutton.trigger("click");
			}
			else
			{
				I.toggleAccount();
				I.loadAccountPanel(page);
			}
		};
		
		// PLATE
		if (I.PlateEnum[page])
		{
			$(I.cPlateMenuPrefix + page).trigger("click");
			if (page === I.PlateEnum.Chains || page === I.PlateEnum.Map)
			{
				viewMap();
			}
		}
		// PLATE SECTION: Map
		else if (I.PageEnum.Map[page] || I.PageEnum.Map[pagecaps])
		{
			page = (I.PageEnum.Map[pagecaps]) ? pagecaps : page;
			if (I.Directory.Map[page])
			{
				viewMap();
			}
			// View the map section if already loaded, otherwise load then view
			pagebutton = $("#plateBeamIcon_" + page);
			if (pagebutton.length)
			{
				$(I.cPlateMenuPrefix + I.PlateEnum.Map).trigger("click");
				pagebutton.trigger("click");
			}
			else
			{
				I.loadMapPlate(page);
			}
		}
		// PLATE SECTION: Chains
		else if (I.PageEnum.Chains[page] || I.PageEnum.Chains[pagecaps])
		{
			page = (I.PageEnum.Chains[pagecaps]) ? pagecaps : page;
			viewMap();
			$(I.cPlateMenuPrefix + I.PlateEnum.Chains).trigger("click");
			I.openChainsSection(page);
		}
		// ACCOUNT SECTION
		else if (I.PageEnum.Account[page] || I.PageEnum.Account[pagecaps] || page === I.SpecialPageEnum.Account)
		{
			page = (I.PageEnum.Account[pagecaps]) ? pagecaps : page;
			viewAccount(page);
		}
		// SPECIAL PAGE: Audit
		else if (page === I.SpecialPageEnum.Audit)
		{
			if ($("#audExecute").is(":visible"))
			{
				$("#audExecute").trigger("click");
			}
			else
			{
				I.ArticleCurrent = I.SpecialPageEnum.Audit;
				viewAccount(I.PageEnum.Account.Characters);
			}
		}
		// SPECIAL PAGE: WvW
		else if (page === U.toFirstUpperCase(I.SpecialPageEnum.WvW))
		{
			viewWvW();
		}
		// SPECIAL PAGE: Leaderboard
		else if (page === I.SpecialPageEnum.Leaderboard)
		{
			// Switch to WvW map if viewing PvE
			if (iswvwvisible)
			{
				$("#lboRegion").trigger("click");
			}
			viewWvW();
		}
		// MODE
		else if (I.ModeEnum[page])
		{
			document.location = "./?mode=" + page;
		}
	},
	
	/*
	 * Sanitizes URLArguments value part before overriding. For example:
	 * https://gw2timer.com/?bol_showPanel=falsse "falsse" defaults to "true"
	 * @param string pKey of an option.
	 * @param string pValue of that option.
	 * @returns string sanitized value.
	 * @pre The key-value pair matches the Options object's, and numeric values
	 * have the OptionRange object initialized for legal numbers.
	 */
	sanitizeURLOptionsValue: function(pKey, pValue)
	{
		var datatype = pKey.substring(0, O.cLengthOfPrefixes);
		var s = pValue.toLowerCase();
		switch (datatype)
		{
			case U.TypeEnum.isBoolean:
			{
				if (s === "true" || s === "false")
				{
					return s;
				}
				return O.Options[pKey].toString(); // Default boolean
			} break;
			case U.TypeEnum.isInteger:
			{
				if (isFinite(s)) // Is a number
				{
					var theinteger = parseInt(s);
					if (theinteger >= O.OptionRange[pKey][0] && theinteger <= O.OptionRange[pKey][1])
					{
						return theinteger.toString();
					}
				}
				return O.Options[pKey].toString(); // Default number
			} break;
			case U.TypeEnum.isFloat:
			{
				if (isFinite(s)) // Is a number
				{
					var thefloat = parseFloat(s);
					if (thefloat >= O.OptionRange[pKey][0] && thefloat <= O.OptionRange[pKey][1])
					{
						return thefloat.toString();
					}
				}
				return O.Options[pKey].toString(); // Default number
			} break;
			case U.TypeEnum.isEnum:
			{
				return O.validateEnum(pKey, pValue);
			} break;
			case U.TypeEnum.isString:
			{
				return U.escapeHTML(pValue);
			} break;
		}
		return "null";
	},
	
	/*
	 * Sorts an array of objects by the provided key name, or language name if not.
	 * @param array pObjects.
	 * @objparam string aKeyName to key of each property to sort by.
	 * @objparam boolean aIsDescending order, optional. Ascending is default order.
	 * @objparam boolean aIsNumbers whether to interpret the keys as integers.
	 */
	sortObjects: function(pObjects, pSettings)
	{
		var Settings = pSettings || {};
		var key = (Settings.aKeyName) ? Settings.aKeyName : D.getNameKey();
		if (Settings.aIsDescending)
		{
			pObjects.sort(function(a, b)
			{
				var valA = (Settings.aIsNumbers && typeof a[key] === "string") ? U.stripToNumbers(a[key]) : a[key];
				var valB = (Settings.aIsNumbers && typeof b[key] === "string") ? U.stripToNumbers(b[key]) : b[key];
				if (valA < valB)
				{
					return 1;
				}
				if (valA > valB)
				{
					return -1;
				}
				return 0;
			});
		}
		else
		{
			pObjects.sort(function(a, b)
			{
				var valA = (Settings.aIsNumbers && typeof a[key] === "string") ? U.stripToNumbers(a[key]) : a[key];
				var valB = (Settings.aIsNumbers && typeof b[key] === "string") ? U.stripToNumbers(b[key]) : b[key];
				if (valA > valB)
				{
					return 1;
				}
				if (valA < valB)
				{
					return -1;
				}
				return 0;
			});
		}
	},
	
	/*
	 * Sorts an array of integers.
	 * @param array pArray.
	 */
	sortAscending: function(pArray)
	{
		pArray.sort(function(a, b) {
			return a - b;
		});
	},
	sortDescending: function(pArray)
	{
		pArray.sort(function(a, b) {
			return b - a;
		});
	},
	
	/*
	 * Converts an array of objects into an associative array accessible by
	 * one of their property acting as the key name.
	 * @param array pArray.
	 * @param string pKeyName to find in each object.
	 * @returns object.
	 * @pre Array has no duplicates sharing the same key.
	 */
	convertArrayToAssoc: function(pArray, pKeyName)
	{
		var assoc = {};
		var keyname = pKeyName || "id";
		var obj;
		for (var i = 0; i < pArray.length; i++)
		{
			obj = pArray[i];
			assoc[obj[keyname]] = obj;
		}
		return assoc;
	},
	convertAssocToArray: function(pAssoc, pKeyName)
	{
		var arr = [];
		if (pKeyName)
		{
			// An array of objects, with key assigned as a property of each object
			for (var i in pAssoc)
			{
				(pAssoc[i])[pKeyName] = i;
				arr.push(pAssoc[i]);
			}
		}
		else
		{
			// An array of keys
			for (var i in pAssoc)
			{
				arr.push(i);
			}
		}
		return arr;
	},
	convertAssocToInts: function(pAssoc)
	{
		var arr = [];
		for (var i in pAssoc)
		{
			arr.push(parseInt(i));
		}
		return arr;
	},
	
	/*
	 * Converts an array of keys into an existence associative array.
	 * @param array pArray
	 * @param object pFilterAssoc to filter in matching keys, optional
	 * @returns object
	 */
	getExistAssoc: function(pArray, pFilterAssoc)
	{
		// Element itself is the key
		var assoc = {};
		var entry;
		for (var i = 0; i < pArray.length; i++)
		{
			entry = pArray[i];
			if (pFilterAssoc === undefined || (pFilterAssoc && pFilterAssoc[entry]))
			{
				assoc[entry] = true;
			}
		}
		return assoc;
	},
	
	/*
	 * Gets elements that array A and B do not share.
	 * @param array pArrayA.
	 * @param array pArrayB.
	 * @returns array of difference.
	 */
	getDifference: function(pArrayA, pArrayB)
	{
		return pArrayA.concat(pArrayB).filter(function(iElm, iIndex, iArr){
			return iArr.indexOf(iElm) === iArr.lastIndexOf(iElm);
		});
	},
	getNew: function(pArrayOld, pArrayNew)
	{	
		return pArrayNew.filter(function(iElm)
		{
			return pArrayOld.indexOf(iElm) === -1;
		});
	},
	getUnique: function(pArray)
	{
		return pArray.filter(function(iElm, iIndex)
		{
			return pArray.indexOf(iElm) === iIndex;
		});
	},
	getUnion: function(pArrayA, pArrayB)
	{
		return U.getUnique(pArrayA.concat(pArrayB));
	},
	getRandomElement: function(pArray)
	{
		if (pArray.length)
		{
			var randind = T.getRandomIntRange(0, pArray.length - 1);
			return pArray[randind];
		}
		return null;
	},
	
	/*
	 * Gets the length of a uniform associative array object.
	 * @param object pObject to count.
	 * @returns int number of subobjects in object.
	 */
	getObjectLength: function(pObject)
	{
		var count = 0;
		for (var i in pObject)
		{
			count++;
		}
		return count;
	},
	
	/*
	 * Converts an integer to boolean.
	 * @param int pInteger to convert.
	 * @returns boolean true only if integer is greater than 0.
	 */
	intToBool: function(pInteger)
	{
		if (pInteger > 0)
		{
			return true;
		}
		return false;
	},
	boolToInt: function(pBoolean)
	{
		if (pBoolean)
		{
			return 1;
		}
		return 0;
	},
	stringToBool: function(pString)
	{
		if (pString.toLowerCase() === "true")
		{
			return true;
		}
		return false;
	},
	boolToString: function(pBoolean)
	{
		if (pBoolean)
		{
			return "true";
		}
		return "false";
	},
	randomBool: function()
	{
		return (Math.random() > 0.5) ? true : false;
	},
	isInteger: function(pValue)
	{
		return !isNaN(pValue) && (function(x) { return (x | 0) === x; })(parseFloat(pValue));
	},
	isObject: function(pValue)
	{
		if (pValue && Object.prototype.toString.call(pValue) === "[object Object]")
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Returns false if object is undefined or null or falsy, otherwise true.
	 * @param object pObject to test.
	 * @returns boolean whether object exists.
	 */
	objToBool: function(pObject)
	{
		if (pObject)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Converts an RGB array to a CSS hex code.
	 * @param intarray pRGB.
	 * @returns string hexadecimal color.
	 */
	convertRGBToHex: function(pRGB)
	{
		var str = "", num;
		for (var i = 0; i < pRGB.length; i++)
		{
			num = parseInt(pRGB[i]);
			str += ((num < T.cBASE_16) ? "0" : "") + num.toString(T.cBASE_16);
		}
		return "#" + str;
	},
	getRGBToHex: function(pString)
	{
		var numbers = pString.split(",");
		return U.convertRGBToHex([U.stripToNumbers(numbers[0]), U.stripToNumbers(numbers[1]), U.stripToNumbers(numbers[2])]);
	},
	convertHexToRGB: function(pHex)
	{
		// Source: https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
		var hex = (typeof pHex === "string" && pHex.charAt(0) === "#") ? pHex.substring(1, pHex.length) : pHex;
		var bigint = parseInt(hex, 16);
		var r = (bigint >> 16) & 255;
		var g = (bigint >> 8) & 255;
		var b = bigint & 255;
		return [r, g, b];
	},
	getHexToRGB: function(pString)
	{
		var rgba = U.convertHexToRGB(pString);
		return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", 1)";
	},
	
	/*
	 * Converts an RGB array to Hue Saturation Lightness array.
	 * @param intarray pRGB.
	 * @returns array.
	 * Source: https://stackoverflow.com/questions/11923659/javascript-sort-rgb-values
	 */
	convertRGBToHSL: function(pRGB)
	{
		var r = pRGB[0]/255, g = pRGB[1]/255, b = pRGB[2]/255;
		var max = Math.max(r, g, b), min = Math.min(r, g, b);
		var h, s, l = (max + min) / 2;

		if (max === min)
		{
			h = s = 0; // achromatic
		}
		else
		{
			var d = max - min;
			s = (l > 0.5) ? (d / (2 - max - min)) : (d / (max + min));
			switch(max)
			{
				case r: h = (g - b) / d + ((g < b) ? 6 : 0); break;
				case g: h = (b - r) / d + 2; break;
				case b: h = (r - g) / d + 4; break;
			}
			h /= 6;
		}
		return [h * 360, s * 100, l * 100];
	},
	sortRGBs: function(pRGBs)
	{
		var indexes = [];
		var sortedindexes = [];
		var hslArr = [];
		for (var i = 0; i < pRGBs.length; i++)
		{
			hslArr[i] = [U.convertRGBToHSL(pRGBs[i]), i]; 
			indexes.push(i);
		}
		
		var sortedHslArr = [];
		for (var i = 0; i < hslArr.length; i++)
		{
			var continueouter = false;
			for (var j = 0; j < sortedHslArr.length; j++)
			{
				if (sortedHslArr[j][0][0] > hslArr[i][0][0])
				{
					sortedHslArr.splice(j, 0, hslArr[i]);
					sortedindexes.splice(j, 0, i);
					continueouter = true;
					break;
				}
			}
			if (continueouter)
			{
				continue;
			}
			sortedHslArr.push(hslArr[i]);
			sortedindexes.push(i);
		}
		
		var sortedRgbArr = [];
		for (var i = 0; i < sortedHslArr.length; i++)
		{
			sortedRgbArr[i] = pRGBs[sortedHslArr[i][1]];
		}
		return {
			oRGBs: sortedRgbArr,
			oIndexes: sortedindexes
		};
	},
	
	/*
	 * Converts a decimal number into a decimal-less percentage.
	 * @param float pNumber to convert.
	 * @param int pPlaces decimal to keep.
	 * @returns string.
	 */
	convertRatioToPercent: function(pDecimal, pPlaces)
	{
		if (pDecimal === undefined || isFinite(pDecimal) === false)
		{
			return "0%";
		}
		if (pPlaces === undefined)
		{
			pPlaces = 0;
		}
		
		var sign = (pDecimal < 0) ? I.Symbol.Negative : "";
		return sign + Math.abs(pDecimal * 100).toFixed(pPlaces) + "%";
	},
	
	/*
	 * Formats a percentage number. Example: 1250.538 becomes 1,250.53%
	 * @param float pPercentage to convert.
	 * @param int pPlacesMax decimals to keep.
	 * @param int pPlacesMin decimals to keep if number has no decimal values.
	 * @returns string.
	 */
	formatPercentage: function(pPercentage, pPlacesMax, pPlacesMin)
	{
		if (pPercentage === parseInt(pPercentage)) // The percentage has no decimal points, then don't include them
		{
			if (pPlacesMin !== undefined)
			{
				return pPercentage.toFixed(pPlacesMin).toLocaleString() + "%";
			}
			return pPercentage.toLocaleString() + "%";
		}
		return pPercentage.toFixed((pPlacesMax === undefined) ? 2 : pPlacesMax).toLocaleString() + "%";
	},
	
	/*
	 * Gets string representation of JSON object, with default parameters.
	 * @param object pObject.
	 * @returns string.
	 */
	formatJSON: function(pObject)
	{
		var str = "failedstringify";
		try
		{
			str = JSON.stringify(pObject, null, "\t");
		}
		catch (e) {}
		return str;
	},
	escapeJSON: function(pObject)
	{
		return U.escapeHTML(U.formatJSON(pObject));
	},
	lineJSON: function(pObject, pWantQuotes)
	{
		// Returns the stringified JSON as a single line separated with spaces.
		var str = JSON.stringify(pObject, null, 1);
		if (pWantQuotes === false)
		{
			str = U.stripJSONQuotations(str);
		}
		return str
			.replace(/[\r\n]/g, "")
			.replace(/  +/g, " ")
			.replace(/ }/g, "}")
			.replace(/{ /g, "{")
			.replace(/ \]/g, "]")
			.replace(/\[ /g, "[");
	},
	compressToJS: function(pObject)
	{
		return U.stripJSONQuotations(JSON.stringify(pObject));
	},
	
	/*
	 * Strips all non-alphabet and non-numbers from a string using regex.
	 * @param string pString to strip.
	 * @returns string stripped.
	 */
	stripToAlphanumeric: function(pString)
	{
		return pString.replace(/\W/g, "");
	},
	stripToAlphanumericDash: function(pString)
	{
		return pString.replace(/[^a-zA-Z0-9\-]/g, "");
	},
	stripToNumbers: function(pString)
	{
		return parseInt(pString.replace(/[^0-9]/g, ""));
	},
	stripToColorString: function(pString)
	{
		// Allow only alphanumeric and number sign (color word or a hexadecimal color)
		return pString.replace(/[^a-zA-Z0-9#]/g, "");
	},
	stripToVariable: function(pString)
	{
		// Disallow spaces and ranges of programming characters !/:@[^`{~
		return pString.replace(/ /g, "_").replace(/[0-9\u0021-\u002f\u003a-\u0040\u005b-\u005e\u0060\u007b-\u007e]/g, "");
	},
	stripJSONQuotations: function(pString)
	{
		// Removes quotation marks from JSON stringified object properties
		return pString.replace(/\"([^(\")"]+)\":/g,"$1:");
	},
	
	/*
	 * Strips to alphanumeric and allow spaces and some punctuation marks.
	 * @param string pString to strip.
	 * @returns string stripped.
	 */
	stripToSentence: function(pString)
	{
		return pString.replace(/[^\w\s\'\"\:\,]/gi, "");
	},
	
	/*
	 * Allows only numbers, arithmetic operators, and parantheses.
	 * @param string pString arithmetic expression.
	 * @returns string stripped.
	 */
	stripToCalculation: function(pString)
	{
		return pString.replace(/[^0-9.()\-+/*]/gi, "");
	},
	
	/*
	 * Converts a string to be all lower case except the first letter which is capitalized.
	 * @param string pString to convert.
	 * @returns string converted.
	 */
	toFirstUpperCase: function(pString)
	{
		return pString.charAt(0).toUpperCase() + pString.slice(1).toLowerCase();
	},
	
	/*
	 * Changes letter case of a word or sentence.
	 * @param string pString to change.
	 * @returns string changed.
	 * @pre String is a readable text that starts with a letter.
	 */
	toCase: function(pString, pCase)
	{
		var i;
		var str = [];
		
		if (pCase === undefined || pCase === U.CaseEnum.None)
		{
			return pString;
		}
		if (pCase === U.CaseEnum.Title || pCase === U.CaseEnum.Every)
		{
			str = pString.split(" ");
		}
		
		switch (pCase)
		{
			case U.CaseEnum.Lower: return pString.toLowerCase();
			case U.CaseEnum.Sentence: return U.toFirstUpperCase(pString);
			case U.CaseEnum.Title:
			{
				// Capitalize the first word and the rest, but don't capitalize 2-letter words
				if (str.length > 1)
				{
					str[0] = U.toFirstUpperCase(str[0]);
					for (i = 1; i < str.length; i++)
					{
						if (str[i].length !== 2)
						{
							str[i] = U.toFirstUpperCase(str[i]);
						}
					}
					return str.join(" ");
				}
				else
				{
					return U.toFirstUpperCase(pString);
				}
			}
			case U.CaseEnum.Every:
			{
				if (str.length > 1)
				{
					for (i in str)
					{
						str[i] = U.toFirstUpperCase(str[i]);
					}
					return str.join(" ");
				}
				else
				{
					return U.toFirstUpperCase(pString);
				}
			}
			case U.CaseEnum.Upper: return pString.toUpperCase();
		}
		return pString;
	},
	
	/*
	 * Converts an HTML string to plain text.
	 * @param string pHTML
	 * @returns string
	 */
	toText: function(pHTML)
	{
		return $("<div>" + pHTML + "</div>").text();
	},
	
	/*
	 * Splits a string in half.
	 * @param string pString
	 * @param string pDelimiter
	 * @returns array
	 */
	toHalf: function(pString, pDelimiter)
	{
		var divind = pString.indexOf(pDelimiter);
		if (divind !== -1)
		{
			return [pString.substr(0, divind), pString.substr(divind + pDelimiter.length, pString.length)];
		}
		return [pString, ""];
	},
	
	/*
	 * Shortens a title/name string based on limit, and add ellipses.
	 * @param string pString.
	 * @returns string truncated if it's too long.
	 */
	truncateString: function(pString, pLimit, pSuffix)
	{
		pSuffix = pSuffix || "";
		if (pString.length > pLimit)
		{
			return pString.substring(0, pLimit) + pSuffix;
		}
		return pString;
	},
	
	/*
	 * Wraps a substring (or multiple substrings if separated by spaces) with a
	 * tag if the substring is found in the main string.
	 * @param string pString to search in.
	 * @param string pSubstring to wrap.
	 * @param string pTag HTML tag, optional.
	 * @returns string with substring wrapped with tag.
	 */
	highlightSubstring: function(pString, pSubstrings, pTag)
	{
		var tag = pTag || "u";
		var str = pString.replace(/{{|}}/g, ""); // Disallow the highlight markup alias
		var subs = pSubstrings.split(" ");
		var sub;
		for (var i = 0; i < subs.length; i++)
		{
			// Wrap the matches in the alias so that the wrapper itself isn't matched
			sub = subs[i];
			if (sub.length)
			{
				str = str.replace(new RegExp(U.escapeRegEx(sub), "gi"), "{{$&}}"); // $& is the original match, to maintain letter case
			}
		}
		// Replace the wrapper alias with the proper tag now that the matching is done
		str = str.replace(/{{/g, "<" + tag + ">");
		str = str.replace(/}}/g, "</" + tag + ">");
		return str;
	},
	
	/*
	 * Strips a string of HTML special characters for use in printing.
	 * @param string pString to escape.
	 * @returns string replaced string.
	 */
	escapeHTML: function(pString)
	{
		if (typeof pString === "string")
		{
			return pString
				.replace(/&/g, "&amp;")
				.replace(/</g, "&lt;")
				.replace(/>/g, "&gt;")
				.replace(/"/g, "&quot;")
				.replace(/'/g, "&apos;");
		}
		if (pString === undefined)
		{
			return "undefined";
		}
		return "null";
	},
	escapeRegEx: function(pString)
	{
		return pString.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
	},
	
	/*
	 * Replaces a character in a string with a specified character.
	 * @param string pString to manipulate.
	 * @param int pIndex of the target character.
	 * @param string pCharacter the replacement.
	 * @returns string with a character at index replaced.
	 */
	replaceCharAt: function(pString, pIndex, pCharacter)
	{
		return pString.substr(0, pIndex) + pCharacter + pString.substr(pIndex + pCharacter.length);
	},
	
	/*
	 * Creates a string of specified length containing only the specified character.
	 * @param string pChar to write.
	 * @param int pLength of returned string.
	 * @returns string of repeated character.
	 */
	repeatChar: function(pChar, pLength)
	{
		return Array(pLength + 1).join(pChar);
	},
	
	/*
	 * Counts the occurences of a string within a string.
	 * @param string pString to look in.
	 * @param string pMatch to look for.
	 * @returns int count.
	 */
	countOccurrence: function(pString, pMatch)
	{
		return pString.split(pMatch).length - 1;
	},
	
	/*
	 * Updates the address bar with the given string affixed to the site base URL.
	 * This should be the only place the "history" global variable is used.
	 * @param string pString URL query string.
	 */
	updateAddressBar: function(pString)
	{
		history.replaceState("", null, pString);
		// Workaround Firefox SVG url bug
		K.reapplyFilters();
	},
	
	/*
	 * Rewrites the URL in the address bar to show the current page and section.
	 * Does not actually load anything and is only a visual effect; however, if
	 * the user presses enter with that URL (go to such a link), a separate
	 * function will load that page (content plate) and expand that section.
	 * @param string pParamOptions additional query string options.
	 */
	updateQueryString: function(pParamOptions)
	{
		if (I.PageCurrent !== "")
		{
			var section = I.SectionCurrent[I.PageCurrent];
			var article = I.ArticleCurrent;
			var go = U.Args[U.KeyEnum.Go];

			var pagestring = "?" + U.KeyEnum.Page + "=" + I.PageCurrent;
			var sectionstring = "";
			var articlestring = "";
			var gostring = "";
			var modestring = "";
			pParamOptions = (pParamOptions === undefined) ? "" : "&" + pParamOptions;
			
			var title = I.PageCurrent;
			
			if (I.ModeCurrent !== I.ModeEnum.Website)
			{
				modestring = "&mode=" + I.getMode();
			}

			if (section)
			{
				sectionstring = "&" + U.KeyEnum.Section + "=" + section;
				title = section;
			}
			else if (I.ModeCurrent === I.ModeEnum.Website && I.PageCurrent === I.PlateEnum.Directory)
			{
				pagestring = "."; // Chains is the default and level top URL, so don't include it
				title = null;
			}
			if (article)
			{
				articlestring = "&" + U.KeyEnum.Article + "=" + article;
			}
			if (go)
			{
				gostring = "&" + U.KeyEnum.Go + "=" + go;
			}
			U.updateAddressBar(pagestring + sectionstring + articlestring + gostring + modestring + pParamOptions);
			U.updateTitle(title);
			U.updateLanguageLinks(pagestring + sectionstring + modestring);
		}
	},
	updateTitle: function(pTitle)
	{
		document.title = (pTitle) ? I.cSiteName + "/" + pTitle : I.cSiteTitle;
	},
	
	/*
	 * Updates the href attribute of the language links for the user to change
	 * language, while also keeping the current URL path.
	 * @param string pString prefix query string.
	 */
	updateLanguageLinks: function(pString)
	{
		$(".linkLanguage").each(function()
		{
			var lang = $(this).attr("data-lang");
			var suffixes = "";
			if (pString === undefined || pString === ".")
			{
				// This should be assigned when the website loads for the first time
				suffixes = (I.ModeCurrent === I.ModeEnum.Website) ? ("?enu_Language=" + lang) : ("?enu_Language=" + lang + "&mode=" + I.getMode());
			}
			else
			{
				// This should be assigned when the user changes to a different page
				suffixes = pString + "&enu_Language=" + lang;
			}
			$(this).attr("href", "./" + suffixes);
		});
	},
	initializeLanguageButton: function()
	{
		$("#itemLanguageButton").html(O.Options.enu_Language.toUpperCase());
		$("#itemLanguagePopup").click(function(pEvent)
		{
			pEvent.stopPropagation();
		});
	},
	
	/*
	 * Binds pseudolinks that has the "data-page" attribute pointing to pages.
	 * @param string pSelector
	 */
	convertInternalLink: function(pSelector)
	{
		$(pSelector).each(function()
		{
			var page = $(this).attr(I.cPageAttribute);
			if (page)
			{
				$(this).removeAttr(I.cPageAttribute).click(function()
				{
					U.interpretPage(page);
				});
			}
		});
	},
	
	/*
	 * Makes links open a new tab on an HTML page with analytics to record
	 * what link the user clicked on, then almost instantly redirect them to
	 * the proper address of the link.
	 * @param string pSelector to find tags to convert.
	 */
	convertExternalLink: function(pSelector)
	{
		$(pSelector).each(function()
		{
			var url = $(this).attr("href");
			if (!url)
			{
				return;
			}
			if (url.indexOf("./") === 0)
			{
				// Don't convert relative links
				return;
			}
			if (url.indexOf(I.cSiteExternal) === 0)
			{
				// Don't convert already converted links
				return;
			}
			if (I.ModeCurrent === I.ModeEnum.Overlay && url.indexOf(I.cSiteURL + "?") !== -1)
			{
				// For overlay, self-linking URLs should not new open window and must contain the mode
				$(this).attr("href", url + U.getDivider(url) + "mode=" + I.getMode());
			}
			else
			{
				$(this).attr("href", I.cSiteExternal + U.encodeURL(url)).attr("target", "_blank");
			}
		});
	},
	convertExternalURL: function(pURL)
	{
		// Prefixes the outgoing page to the URL
		return I.cSiteExternal + U.encodeURL(pURL);
	},
	convertExternalAnchor: function(pURL)
	{
		// This is to be placed within the property of an <a> tag
		return " href='" + I.cSiteExternal + U.encodeURL(pURL) + "' target='_blank' ";
	},
	convertPrivateAnchor: function(pURL)
	{
		// This is to be placed within the property of an <a> tag
		return " href='" + pURL + "' target='_blank' ";
	},
	
	/*
	 * Replaces href attributes in a raw HTML string and replace them with
	 * external prefixes.
	 * @param string pHTML.
	 * @returns string.
	 */
	convertExternalString: function(pHTML)
	{
		return pHTML.replace(/href='/g, "target='_blank' href='" + I.cSiteExternal);
	},
	
	/*
	 * Converts an internal URL to have the currently used mode query string.
	 * @param string pSelector
	 */
	convertModeLink: function(pSelector)
	{
		if (I.ModeCurrent !== I.ModeEnum.Website)
		{
			$(pSelector).each(function()
			{
				var url = $(this).attr("href");
				if (url && url.indexOf(I.cSiteExternal) !== 0
					&& (url.indexOf(I.cSiteURL) === 0 || url.indexOf("./") === 0))
				{
					$(this).attr("href", url + U.getDivider(url) + "mode=" + I.getMode());
				}
			});
		}
	},
	
	/*
	 * Opens a new browser tab with the requested URL.
	 * @param string pURL to go to.
	 */
	openExternalURL: function(pURL)
	{
		window.open(I.cSiteExternal + U.encodeURL(pURL), "_blank");
	},
	openPrivateURL: function(pURL)
	{
		window.open(pURL, "_blank");
	},
	
	/*
	 * Extracts the name part from a variable, as in "bol_showPanel" returns "showPanel".
	 * @param string pVariable full name.
	 * @returns string option name.
	 * @pre Variable name has exactly one underscore character.
	 */
	getVariableSuffix: function(pVariable)
	{
		var index = pVariable.indexOf("_");
		return pVariable.substring(index + 1, pVariable.length);
	},
	getVariablePrefix: function(pVariable)
	{
		var index = pVariable.indexOf("_");
		return pVariable.substring(0, index);
	},
	
	/*
	 * Extracts the "identifier" part of an HTML element's ID. Most iterable
	 * elements' IDs were manually named as [prefix]_[Index].
	 * @param jqobject pElement to extract.
	 * @returns string identifier of the element's ID.
	 */
	getSubstringFromHTMLID: function(pElement)
	{
		return U.getVariableSuffix(pElement.attr("id"));
	},
	/*
	 * Integer version of the ID extraction function.
	 * @param jqobject pElement to extract.
	 * @returns int identifier of the element's ID.
	 */
	getSubintegerFromHTMLID: function(pElement)
	{
		return parseInt(U.getVariableSuffix(pElement.attr("id")));
	},
	
	/*
	 * Gets the URL directory of the HTML source file
	 * @param string pPage name.
	 * @returns string path.
	 */
	getPageSrc: function(pPage)
	{
		return "page/" + pPage.toLowerCase() + ".html";
	},
	
	/*
	 * Encodes a string for URL usage with regards to "'" character (apostrophe).
	 * @param string pString to encode.
	 * @returns string encoded.
	 */
	encodeURL: function(pString)
	{
		return encodeURI(pString).replace(/'/g, "%27");
	},
	
	/*
	 * Converts a search query to GW2 wiki URL.
	 * @param string pString search entry.
	 * @returns string wiki link.
	 */
	getWikiLinkDefault: function(pString)
	{
		pString = pString.replace(/ /g, "_"); // Replace spaces with underscores
		return "https://wiki.guildwars2.com/wiki/" + U.encodeURL(pString);
	},
	getWikiLinkLanguage: function(pString)
	{
		pString = pString.replace(/ /g, "_");
		return "https://wiki-" + D.langFullySupported + ".guildwars2.com/wiki/" + U.encodeURL(pString);
	},
	getWikiLinkObject: function(pObject)
	{
		return D.isLanguageFullySupported ? U.getWikiLinkLanguage(D.getObjectName(pObject)) : U.getWikiLinkDefault(D.getObjectDefaultName(pObject));
	},
	getWikiLinkCode: function(pID, pName)
	{
		var chatlink = U.getChatlinkFromPoiID(pID);
		var name = (pName) ? ("&name=" + pName.replace(/ /g, "_")) : "";
		return "https://wiki.guildwars2.com/index.php?search=" + encodeURIComponent(chatlink) + name;
	},
	getWikiSearchDefault: function(pString)
	{
		pString = pString.replace(/ /g, "+"); // Replace spaces with plus sign
		return "https://wiki.guildwars2.com/index.php?search=" + U.encodeURL(pString);
	},
	getWikiSearchLanguage: function(pString)
	{
		pString = pString.replace(/ /g, "_");
		return "https://wiki-" + D.langFullySupported + ".guildwars2.com/index.php?search=" + U.encodeURL(pString);
	},
	getWikiItemDefault: function(pItem)
	{
		// This always return the English wiki. Non-English queries use item ID search rather than direct name
		if (D.isLanguageFullySupported && D.isLanguageDefault === false)
		{
			return U.getWikiSearchDefault((pItem.id).toString());
		}
		return U.getWikiLinkDefault(pItem.name);
	},
	
	/*
	 * Generates a link to news article at the GuildWars2.com site.
	 * @param string pString suffix.
	 * @returns string URL.
	 */
	getGW2OfficialLink: function(pString)
	{
		return "https://www.guildwars2.com/" + D.langFullySupported + "/" + pString;
	},
	
	/*
	 * Converts a search query to YouTube http link.
	 * @param string pString search entry.
	 * @returns string youtube link.
	 */
	getYouTubeLink: function(pString)
	{
		return "https://www.youtube.com/results?search_query=" + U.encodeURL(pString + " " + I.cGameNick);
	},
	
	/*
	 * Converts a search query to Trading Post http link.
	 * @param string pString search entry.
	 * @returns string search link.
	 */
	getTradingSearchLink: function(pString)
	{
		return "https://www.gw2tp.com/search?name=" + U.encodeURL(pString);
	},
	
	/*
	 * Gets a URL to an item page from an item's ID.
	 * @param string pID of the item.
	 * @param string pName of the item.
	 * @returns string item page link.
	 */
	getTradingItemLink: function(pID, pName)
	{
		return "http://www.gw2spidy.com/item/" + U.encodeURL(pID) + "?name=" + U.stripToSentence(pName).replace(/ /g, "_");
	},
	
	/*
	 * Gets an image URL from a third party provider for a guild banner.
	 * @param string pName of the guild.
	 * @returns string URL.
	 */
	getGuildBannerURL: function(pName)
	{
		if (pName)
		{
			var name = U.escapeHTML((pName.split(" ").join("-")).toLowerCase());
			return "https://guilds.gw2w2w.com/guilds/" + name + "/128.svg";
		}
		return U.URL_IMG.Placeholder;
	},
	
	/*
	 * Gets an API image URL from the cached emblem array. These emblems are
	 * uncolorized and unbackgrounded. Used as a backup or workaround when the
	 * default banner renderer is offline.
	 * @param object pGuild
	 * @returns string
	 * @pre Account page data was loaded, since the emblem data is inside it.
	 */
	getGuildBannerRaw: function(pGuild)
	{
		try { return U.getAPIImage(GW2T_EMBLEM_DATA.foreground[pGuild.emblem.foreground.id]); }
		catch (e) {}
		return "img/ui/unavailable.png";
	},
	getAPIImage: function(pSubstring)
	{
		return "https://render.guildwars2.com/file/" + pSubstring + ".png";
	},
	
	/*
	 * Converts a poi_id number from maps_floor.json to a valid chatlink.
	 * Code from http://virtus-gilde.de/gw2map
	 * @param int pID of the poi.
	 * @returns string chatlink.
	 */
	getChatlinkFromPoiID: function(pID)
	{
		var chatlink = String.fromCharCode(4);
		// Create unicode characters from the id
		for (var i = 0; i < 4; i++)
		{
			chatlink += String.fromCharCode((pID >> (i * 8)) & 255);
		}
		// Return base64 string with chat code tags
		return I.cChatcodePrefix + btoa(chatlink) + I.cChatcodeSuffix;
	},
	
	/*
	 * Converts an item id from items.json to a valid chatlink.
	 * Code from https://redd.it/zy8gb
	 * @param int pID of the item.
	 * @returns string chatlink.
	 */ 
	getChatlinkFromItemID: function(pID)
	{
		var str = "";
		try // To ignore "Failed to execute 'btoa' on 'Window'" exception
		{
			str = I.cChatcodePrefix + btoa(String.fromCharCode(2) + String.fromCharCode(1)
			+ String.fromCharCode(pID % 256) + String.fromCharCode(Math.floor(pID / 256))
			+ String.fromCharCode(0) + String.fromCharCode(0)) + I.cChatcodeSuffix;
		} catch (e) {};
		return str;
	},

	/*
	 * Converts a chatlink to a plain number ID.
	 * @param string pChatlink.
	 * @param boolean pWantType if to return the type of the ID also, optional.
	 * @returns int number or null if invalid.
	 * Code from https://wiki.guildwars2.com/wiki/MediaWiki:ChatLinkSearch.js
	 */
	getGameIDFromChatlink: function(pChatlink, pWantType)
	{
		var decodeChatLink = function(pCode)
		{
			var binary = window.atob(pCode);
			var octets = new Array(binary.length);
			for (var i = 0; i < binary.length; i++)
			{
				octets[i] = binary.charCodeAt(i);
			}
			return octets;
		};
		
		var id = null;
		// Extract the code portion of the chatlink [&CODE]
		if (typeof pChatlink === "string" && pChatlink.indexOf(I.cChatcodePrefix) === 0 && pChatlink.indexOf(I.cChatcodeSuffix === pChatlink.length - 1))
		{
			pChatlink = pChatlink.substring(2, pChatlink.length - 1);
		}
		
		try
		{
			var data = decodeChatLink(pChatlink);
			var id = data[2] << 8 | data[1];
			var type = null;
			switch (data[0])
			{
				case 2: {
					type = "item";
					id = data[3] << 8 | data[2];
					id = (data.length > 4 ? data[4] << 16 : 0) | id;
				} break;
				case 4: type = "location"; break;
				case 6: type = "skill"; break;
				case 8: type = "trait"; break;
				case 9: type = "recipe"; break;
				case 10: type = "skin"; break;
				case 11: type = "outfit"; break;
			}
		}
		catch (e)
		{
			I.write("Invalid chatlink to decode.");
		}
		
		if (pWantType)
		{
			var idtype = id + " (" + type + ")";
			I.print("<input class='cssInputText' type='text' value='" + id + "'></input>&nbsp;<span>" + idtype + "</span>");
			I.bindConsoleInput();
		}
		return id;
	}
};
Z = {
/* =============================================================================
 * @@Z Console commands and server-like maintenance and file functions
 * ========================================================================== */

	cCommandPrefix: "/",
	APICacheFiles: [], // Stores the URLs to generated blob files
	APICacheArrayOfIDs: null, // Array of ID numbers for any particular v2 API endpoint
	APICacheArrayOfObjects: null, // Array of objects downloaded from the IDs pointing there
	APICacheConsole: null, // JSON text entered by the user
	DatabaseCache: {}, // To be loaded with various API databases, access order: database name > language code > item ID
	DatabaseLanguages: ["en", "de", "es", "fr", "zh"],
	
	/*
	 * Loads an object from local storage into a variable for testing or console usage.
	 * @returns boolean true if successfully loaded into variable, else false.
	 */
	loadAPICache: function()
	{
		var cache = localStorage[O.Utilities.APICache.key];
		if (cache)
		{
			try {
				Z.APICacheConsole = JSON.parse(cache);
				return true;
			}
			catch (e) {
				I.print("Error loading API cache object.");
			}
		}
		return false;
	},
	saveAPICache: function()
	{
		if (Z.APICacheConsole)
		{
			localStorage[O.Utilities.APICache.key] = JSON.stringify(Z.APICacheConsole);
			return true;
		}
		else
		{
			I.print("Error saving cache object.");
		}
		return false;
	},
	
	/*
	 * Interprets and executes a command string, which may be a console command
	 * or a map data string.
	 * @param string pString command.
	 * @param object pMapObject which map to execute.
	 * @param enum pZoom level, optional.
	 */
	interpretCommand: function(pString, pMapObject, pZoom, pPin)
	{
		if (pString.indexOf(Z.cCommandPrefix) === 0)
		{
			// If input starts with a console command
			Z.parseCommand(pString, pMapObject);
		}
		else if (pString.indexOf(I.cChatencodedPrefix) !== -1)
		{
			try
			{
				var chatcode = decodeURIComponent(decodeURIComponent(pString));
				U.getGameIDFromChatlink(chatcode.substring(chatcode.indexOf("["), chatcode.indexOf("]")), true);
			}
			catch (e) {}
		}
		else if (pString.indexOf(I.cChatcodePrefix) === 0)
		{
			// If input is a chatcode
			U.getGameIDFromChatlink(pString, true);
		}
		else if (pMapObject.parsePersonalPath(pString) === false)
		{
			// If input looks like a 2D array of coordinates, then create pins from them
			pMapObject.goToArguments(pString, pZoom, pPin);
		}
	},
	
	/*
	 * Executes a console command.
	 * @param string pString command.
	 * @param object pMapObject which map the command was executed from.
	 */
	parseCommand: function(pString, pMapObject)
	{
		var that = pMapObject || M;
		var args = pString.substring(1, pString.length).split(" "); // Trim the command prefix character
		var argstr = pString.substring(pString.indexOf(" ") + 1, pString.length);
		var command = args[0].toLowerCase();
		
		var Commands = {
			clear: {usage: "Clears the console screen. Or just press the Esc key.", f: function()
			{
				I.clear();
			}},
			speak: {usage: "Speaks the given text. <em>Parameters: str_text</em>", f: function()
			{
				D.speak(argstr);
			}},
			notify: {usage: "Notifies the given text. <em>Parameters: str_text</em>", f: function()
			{
				I.notify(argstr);
			}},
			gps: {usage: "Prints GPS location information (overlay only).", f: function()
			{
				I.print("Position: " + U.formatJSON(GPSPositionArray) + "<br />"
					+ "Direction: " + U.formatJSON(GPSDirectionArray) + "<br />"
					+ "Perspective: " + U.formatJSON(GPSPerspectiveArray) + "<br />"
					+ "Camera: " + U.formatJSON(GPSCameraArray)
				);
			}},
			identity: {usage: "Prints GPS general information (overlay only).", f: function()
			{
				I.prettyJSON(GPSIdentityJSON);
			}},
			trace: {usage: "Prints GPS information continuously by toggle (overlay only).", f: function()
			{
				P.isGPSPrinting = !P.isGPSPrinting;
				if (P.isGPSPrinting)
				{
					I.print("Trace started.");
				}
				else
				{
					I.print("Trace stopped.");
				}
			}},
			agent: {usage: "Prints browser's navigator object.", f: function()
			{
				var str = "", obj, desc;
				for (var i in window.navigator)
				{
					obj = window.navigator[i];
					desc = (typeof obj === "string" || typeof obj === "number") ? obj : U.formatJSON(obj);
					str += U.escapeHTML(i + ": " + desc) + "<br />";
				}
				I.print(str);
			}},
			cal: {usage: "Prints a HTML calendar input element.", f: function()
			{
				I.print("<br /><input id='cslCalendar' type='date' /><br />");
				$("#cslCalendar")[0].valueAsDate = new Date();
			}},
			floor: {usage: "Sets the map floor. <em>Parameters: int_floornumber</em>", f: function()
			{
				that.changeFloor(parseInt(args[1]));
			}}, 
			lock: {usage: "Map cannot be moved.", f: function()
			{
				that.Map.dragging.disable(); that.Map.scrollWheelZoom.disable(); I.write("Map locked.");
			}},
			unlock: {usage: "Map can be moved.", f: function()
			{
				that.Map.dragging.enable(); that.Map.scrollWheelZoom.enable(); I.write("Map unlocked.");
			}},
			nct: {usage: "Disables the map's context menu.", f: function()
			{
				that.Map.off("contextmenu"); I.write("Map context menu disabled.");
			}},
			link: {usage: "Prints a coordinates URL of the current map view.", f: function()
			{
				I.paste(I.cSiteURL + that.convertLCtoGC(that.Map.getCenter()), true);
			}},
			dart: {usage: "Draws personal pins at random map coordinates. <em>Parameters: int_quantity</em>", f: function()
			{
				that.drawRandom(args[1]);
			}},
			nodes: {usage: "Sorts and prints a list coordinates. <em>Parameters: arr_coordinates</em>", f: function()
			{
				P.printNodes(P.sortCoordinates(M.parseCoordinatesMulti(args[1])));
			}},
			needles: {usage: "Numbers and prints a list of coordinates. <em>Parameters: arr_coordinates</em>", f: function()
			{
				P.printNodes(M.parseCoordinatesMulti(args[1]), true);
			}},
			latlngs: {usage: "Converts an array of LatLng's to standard coordinates. <em>Parameters: arr_latlngs</em>", f: function()
			{
				that.convertLatLngs(JSON.parse(argstr));
			}},
			jsonparse: {usage: "Converts a JSON string into an object for testing. <em>Parameters: str_json</em>", f: function()
			{
				try { Z.APICacheConsole = JSON.parse(argstr); I.print("Parse JSON successful."); }
				catch (e) { I.print("Parse JSON failed."); }
			}},
			url: {usage: "Prints the result of a URL. <em>Parameters: str_url</em>", f: function()
			{
				U.getJSON(argstr, function(pData)
				{
					if (pData)
					{
						I.prettyJSON(pData);
					}
				}).fail(function()
				{
					I.print("No results from URL.");
				});
			}},
			api: {usage: "Prints the output of an API URL &quot;" + U.URL_API.Prefix + "&quot;. <em>Parameters: str_apiurlsuffix, str_querystring (optional)</em>", f: function()
			{
				if (args[1])
				{
					Z.printAPI(args[1], args[2], args[3]);
				}
				else
				{
					U.openExternalURL("https://api.guildwars2.com/v2");
				}
			}},
			apicache: {usage: "Prints the cache of the previous console API call as an associative array. <em>Parameters: bol_wantoutputasfile (optional)</em>", f: function()
			{
				Z.printAPICache(U.TypeEnum.isAssoc, {aFileName: (args[1] === "true")});
			}},
			apicachearray: {usage: "...as an array.", f: function()
			{
				Z.printAPICache(U.TypeEnum.isArray, false);
			}},
			apicacheobject: {usage: "...as an object.", f: function()
			{
				Z.printAPICache(U.TypeEnum.isObject, false);
			}},
			apicacheids: {usage: "...as IDs.", f: function()
			{
				Z.printAPICache(U.TypeEnum.isInteger, false);
			}},
			apilang: {usage: "Prints all languages of an API data point. <em>Parameters: str_endpoint, int_id</em>", f: function()
			{
				Z.printAPIMultilingual(args[1], args[2]);
			}},
			acc: {usage: "Prints the output of an account API URL &quot;"
				+ U.URL_API.Prefix + "&quot;. Token must be initialized from the account page. <em>Parameters: str_apiurlsuffix</em>. "
				+ "Type &quot;acc&quot; alone to see list of URL suffixes. Please replace spaces in character's name with &quot;%20&quot;", f: function()
			{
				A.printAccount(args[1]);
			}},
			daily: {usage: "Prints today's and tomorrow's daily achievements.", f: function()
			{
				Z.printDaily();
			}},
			item: {usage: "Prints an item's information. <em>Parameters: int_itemid</em>", f: function()
			{
				Z.scrapeAPIArrayMultilingual("items", parseInt(args[1]), function(pDatabase)
				{
					I.clear();
					for (var i in pDatabase)
					{
						for (var ii in pDatabase[i])
						{
							Q.printItemInfo((pDatabase[i])[ii]);
						}
					}
				});
			}},
			items: {usage: "Prints the highest numbered item IDs in the API. <em>Parameters: int_offset</em>", f: function()
			{
				Z.printItemsAPI(args[1]);
			}},
			sortitems: {usage: "Sorts an array of item IDs by item type. <em>Parameters: arr_itemids</em>", f: function()
			{
				try
				{
					Q.sortItems(JSON.parse(args[1]), function(pItems, pIDs)
					{
						I.paste(U.lineJSON(pIDs));
					});
				}
				catch (e) {}
			}},
			events: {usage: "Prints the event names of the current zone, dynamic events option must be enabled.", f: function()
			{
				P.printZoneEvents();
			}},
			lower: {usage: "Converts a string to all lower case. <em>Parameters: str_string</em>", f: function()
			{
				if (args[1])
				{
					I.paste(U.toCase(argstr, U.CaseEnum.Lower));
				}
			}},
			upper: {usage: "Converts a string to all upper case. <em>Parameters: str_string</em>", f: function()
			{
				if (args[1])
				{
					I.paste(U.toCase(argstr, U.CaseEnum.Upper));
				}
			}},
			rgba: {usage: "Converts a hex color to RGBA format. <em>Parameters: str_hex</em>", f: function()
			{
				I.paste(U.getHexToRGB(argstr));
			}},
			hex: {usage: "Converts an RGBA color to hex format. <em>Parameters: str_rgba</em>", f: function()
			{
				I.paste(U.getRGBToHex(argstr));
			}},
			help: {usage: "Prints this help message.", f: function()
			{
				I.write("Available console commands:<br />");
				var s = "";
				for (var i in Commands)
				{
					s += "<b>" + i + "</b> - " + Commands[i].usage + "<br />";
				}
				s += "<br />The console also accepts: coordinates, array of coordinates, zone names, and chatcodes.<br />";
				I.print(s);
			}},
			wiki: {usage: "Search the game wiki. <em>Parameters: str_keywords</em>", f: function()
			{
				U.openExternalURL(U.getWikiSearchLanguage(argstr));
			}},
			test: {usage: "Test function for debugging.", f: function()
			{
				
			}},
			updatedb: {usage: "Prints an updated database of items. <em>Parameters: bol_wantrebuild (optional).", f: function()
			{
				Z.collateDatabase("items", args[1] === "true");
			}},
			subdb: {usage: "Prints a subset database of items used by an account page's section. <em>Parameters: str_section</em>", f: function()
			{
				if (args[1])
				{
					Z.updateItemsSubdatabase(args[1]);
				}
			}},
			collate: {usage: "Executes a function to update and categorize an unlockables record. <em>Parameters: str_section</em>", f: function()
			{
				Z.executeCollate(args[1], args[2]);
			}}
		};
		// Execute the command by finding it in the object
		if (Commands[command] !== undefined)
		{
			(Commands[command].f)();
		}
	},
	
	/*
	 * Creates a blob file with the provided text.
	 * @param string pString source text.
	 * @returns string URL to download the generated file.
	 */
	createFile: function(pString, pFileName)
	{
		var data = new Blob([pString], {type: "text/plain;charset=UTF-8"});
		var fileurl = window.URL.createObjectURL(data);
		Z.APICacheFiles.push(fileurl);
		
		var wantfilename = typeof pFileName === "string";
		var filename = (wantfilename) ? pFileName : "";
		var filenameoutput = (wantfilename) ? "<input class='cslFilename cssInputText' type='text' value='" + pFileName + "' /> " : "";
		I.print(filenameoutput + "<a href='" + fileurl + "' download='" + filename + "'>" + fileurl + "</a>");
		return fileurl;
	},
	
	/*
	 * Converts a text file into a string.
	 * @param object pFile
	 * @param function pCallback with string.
	 */
	openTextFile: function(pFile, pCallback)
	{
		var reader = new FileReader();
		reader.readAsText(pFile);
		reader.onload = function()
		{
			pCallback(reader.result);
		};
	},
	
	/*
	 * Binds a file input button for returning string.
	 * @param jqobject pInput
	 * @param function pCallback with the string if successful.
	 */
	bindFileInput: function(pInput, pCallback)
	{
		var input = $(pInput);
		input.change(function()
		{
			try
			{
				var file = $(this)[0].files[0];
				Z.openTextFile(file, function(pString)
				{
					pCallback(pString, file);
				});
			}
			catch (e)
			{
				I.write("Error loading file.");
			}
		});
	},
	
	/*
	 * Clears the array that stores URLs pointing to generated files, to clear
	 * up browser memory after the files have been used.
	 */
	freeFiles: function()
	{
		for (var i = 0; i < Z.APICacheFiles.length; i++)
		{
			if (Z.APICacheFiles[i])
			{
				window.URL.revokeObjectURL(Z.APICacheFiles[i]);
			}
		}
		Z.APICacheFiles = null;
		Z.APICacheFiles = [];
	},
	
	/*
	 * Prints a v2 API endpoint by querying each element in the array it
	 * returned, or just the object.
	 * @param string pString of API
	 * @param string pQueryStr arguments for the API url, or an array of IDs, optional.
	 */
	printAPI: function(pString, pQueryStr, pArray)
	{
		I.print("Gathering elements...");
		var versionprefix = "v1";
		var providedarray = null;
		var querystr = (pQueryStr === undefined) ? "" : pQueryStr;
		var url = U.URL_API.Prefix + pString;
		try
		{
			providedarray = JSON.parse(pArray || pQueryStr);
		}
		catch (e) {}
		
		var printResult = function()
		{
			I.clear();
			// Sort the objects by their IDs
			if (Z.APICacheArrayOfObjects.length > 0 && Z.APICacheArrayOfObjects[0].id)
			{
				U.sortObjects(Z.APICacheArrayOfObjects, {aKeyName: "id", aIsNumbers: true});
			}
			Z.printAPICache(U.TypeEnum.isArray);
		};
		var printIcon = function(pData)
		{
			var data = (typeof pData === "string") ? JSON.parse(pData) : pData;
			if (data.icon)
			{
				I.print("<img class='cssRight' src='" + U.escapeHTML(data.icon) + "' />");
			}
		};
		// Function to print retrieved data, or fetch more data if the original data is an array
		var iterateData = function(pData)
		{
			if (Array.isArray(pData))
			{
				var queryobj = U.convertQueryString(querystr);
				U.fetchAPI(url, pData, {
					aLanguage: (queryobj.lang) ? queryobj.lang : null,
					aCallback: function(pDataInner)
				{
					Z.APICacheArrayOfIDs = pData;
					Z.APICacheArrayOfObjects = pDataInner;
					printResult();
				}});
			}
			else
			{
				printIcon(pData);
				I.prettyJSON(pData);
			}
		};
		
		// If requesting v1 API by entering it in the first parameter
		if (pString === versionprefix)
		{
			url = U.URL_API.Prefix1 + pQueryStr;
			querystr = pArray || "";
		}
		
		// Fetch if did not provide an array in the parameter
		if (providedarray && Array.isArray(providedarray))
		{
			iterateData(providedarray);
		}
		else
		{
			$.get(url + querystr, function(pData)
			{
				iterateData(pData);
			}).fail(function()
			{
				I.warn(U.escapeHTML(url), true);
			});
		}
	},
	printAPIMultilingual: function(pSuffix, pID)
	{
		Z.scrapeAPIArrayMultilingual(pSuffix, parseInt(pID), function(pDatabase)
		{
			for (var i in pDatabase)
			{
				for (var ii in pDatabase[i])
				{
					Q.printItemInfo((pDatabase[i])[ii]);
				}
			}
		});
	},
	
	/*
	 * Prints the cached API arrays and objects.
	 * @param enum pType data type to output.
	 * @objparam object aCustomCache to use instead of the global.
	 * @objparam string aFileName of the file if want to output to file.
	 * @objparam boolean aWantQuotes whether to wrap key names in quotes (for JSON files).
	 */
	printAPICache: function(pType, pSettings)
	{
		var Settings = pSettings || {};
		var output = "";
		var obj;
		var wantfile = (Settings.aFileName !== undefined && Settings.aFileName !== false);
		var wantquotes = (Settings.aWantQuotes === undefined) ? wantfile : Settings.aWantQuotes;
		var cache = Settings.aCustomCache || Z.APICacheArrayOfObjects;
		var req = pType;
		
		// Compile the output
		if (req === undefined || req === U.TypeEnum.isAssoc || req === U.TypeEnum.isArray)
		{
			if (cache)
			{
				var length = cache.length;
				var brk = (wantfile) ? "\r\n" : "<br />";
				var quo = (wantfile) ? "\"" : "&quot;";
				var icon;
				output += ((req === U.TypeEnum.isAssoc) ? "{" : "[") + brk;
				for (var i = 0; i < length; i++)
				{
					obj = cache[i];
					icon = (obj.icon && !wantfile) ? "<img src='" + obj.icon + "' />" : "";
					output += icon + ((req === U.TypeEnum.isAssoc) ? (quo + obj.id + quo + ": ") : "")
						+ U.lineJSON(obj, wantquotes)
					+ ((i === length - 1) ? "" : ",") + brk;
				}
				output += ((req === U.TypeEnum.isAssoc) ? "}" : "]");
			}
			else
			{
				output = "API Objects Array is empty.";
			}
		}
		else if (req === U.TypeEnum.isObject)
		{
			output = (cache) ?
				((wantfile) ? U.lineJSON(cache) : U.escapeJSON(cache)) : "API Objects Array is empty.";
		}
		else if (req === U.TypeEnum.isInteger)
		{
			output = (Z.APICacheArrayOfIDs) ?
			((wantfile) ? U.lineJSON(Z.APICacheArrayOfIDs) : U.escapeJSON(Z.APICacheArrayOfIDs)) : "API IDs Array is empty.";
		}
		
		// Print or generate the output
		if (wantfile)
		{
			Z.createFile(output, (typeof Settings.aFileName === "string") ? Settings.aFileName : "apicache");
		}
		else
		{
			I.print(output);
		}
	},
	
	/*
	 * Creates a file from a regenerated unlockables record.
	 * @param object pRecord.
	 * @param boolean pIsFlat whether the record is just an array of numbers
	 * @param string pFilename or if "true" then will print to console.
	 * rather than objects.
	 */
	printUnlockables: function(pRecord, pIsFlat, pFilename)
	{
		var output = "";
		var catarr, arrlength;
		var objlength = U.getObjectLength(pRecord);
		var objlengthcounter = 0;
		for (var i in pRecord)
		{
			catarr = pRecord[i];
			arrlength = catarr.length;
			var keyq = (isNaN(i.charAt(0)) === false) ? "\"" : "";
			if (pIsFlat)
			{
				output += keyq + i + keyq + ": [" + catarr.toString() + "]";
			}
			else
			{
				output += keyq + i + keyq + ": [\r\n";
				for (var ii = 0; ii < arrlength; ii++)
				{
					output += "\t" + U.lineJSON(catarr[ii], false)
						+ ((ii === arrlength - 1) ? "" : ",") + "\r\n";
				}
				output += "]";
			}
			output += ((objlengthcounter === objlength - 1) ? "" : ",") + "\r\n";
			objlengthcounter++;
		}
		if (pFilename === true)
		{
			I.paste(output);
		}
		Z.createFile(output, pFilename);
	},
	
	/*
	 * Gets the latest items that was added to the API item database.
	 * @param int pSmartIndex if positive, will list that many latest items;
	 * if negative, will list the item at that index, from end of the array.
	 * @returns string of item details.
	 */
	printItemsAPI: function(pSmartIndex)
	{
		if (U.isInteger(pSmartIndex) === false)
		{
			I.write("Invalid reverse index.");
			return;
		}
		else
		{
			I.write("Retrieving items...");
			pSmartIndex = parseInt(pSmartIndex);
		}
		
		if (E.ItemsArray.length === 0)
		{
			$.get(U.URL_API.ItemDetail, function(pData)
			{
				E.ItemsArray = pData;
			}).done(function()
			{
				Z.printItemsAPI(pSmartIndex);
			}).fail(function()
			{
				I.warn("items database");
			});
		}
		else
		{
			var requesteditem = 0;
			var index = 0;
			if (pSmartIndex <= 0)
			{
				index = E.ItemsArray.length + pSmartIndex - 1;
				requesteditem = E.ItemsArray[index];
				Q.getItem(requesteditem, function(pData)
				{
					I.print("<img class='cssLeft' src='" + pData.icon + "' />" + U.escapeJSON(pData));
				}).fail(function()
				{
					I.warn("item: " + index);
				});
			}
			else
			{
				I.clear();
				for (var i = 0; i < pSmartIndex; i++)
				{
					index = E.ItemsArray.length - pSmartIndex - 1 - i;
					requesteditem = E.ItemsArray[index];
					Q.getItem(requesteditem, function(pData)
					{
						I.print("<img class='cssLeft' src='" + pData.icon + "' />" + U.escapeJSON(pData));
					}).fail(function()
					{
						I.warn("item: " + index);
					});
				}
			}
			
		}
	},
	
	/*
	 * Takes an array of API endpoint ID numbers, downloads every object they
	 * point to, and amasses them into an array of objects.
	 * @param string pSuffix of API endpoint.
	 * @param intarray pArray downloaded from API.
	 * @objparam string aQueryStr arguments for the API url.
	 * @objparam boolean aIsStandard whether to format the URL in standard v2 API format with a "/" preceding the ID.
	 * @objparam boolean aWantSort whether to sort the retrieved objects by their ID after, on by default.
	 * @objparam function aIterator to execute for every fetched data.
	 * @objparam function aCallback to execute after finishing scraping.
	 * @objparam int aCooldown seconds between cooldown.
	 * @objparam int aNumRetries number of retries.
	 * @objparam int aRetryCount used internally for recursive retrieval of failed IDs.
	 * @objparam array aCacheArray from previous scrape.
	 */
	scrapeAPIArray: function(pSuffix, pArray, pSettings)
	{
		var Settings = pSettings || {};
		var querystr = Settings.aQueryStr || "";
		var indexsep = (Settings.aIsStandard === false) ? "" : "/";
		var prefix = (Settings.aIsStandard === false) ? "" : U.URL_API.Prefix;
		var idsarray = [];
		var failedids = [];
		var failedindexes = [];
		var reqindex = 0;
		var numretries = (Settings.aNumRetries || 3);
		var reqlimit = 500;
		var reqcooldownms = (Settings.aCooldown || 30) * T.cMSECONDS_IN_SECOND;
		var numfetched = 0;
		var numtofetch = 0;
		var cachearr = Settings.aCacheArray || new Array(pArray.length);
		if (pArray.length === 0)
		{
			Settings.aCallback(null, null);
			return;
		}
		
		var finalizeScrape = function()
		{
			A.setProgressBar(numfetched, numtofetch);
			if (numfetched === numtofetch)
			{
				if (failedids.length > 0)
				{
					I.print("WARNING - Failed to retrieve some IDs: " + failedids);
				}
				else
				{
					I.print("All IDs successfully retrieved.");
				}
				// Recurse the function to retrieved fail IDs and append them to the current cache, will stop recursion if retry number exceeds
				if (Settings.aRetryCount !== 0 && failedids.length > 0)
				{
					var retrycount = (Settings.aRetryCount || numretries) - 1;
					I.print("Retrying " + retrycount + " times to fetch failed IDs...");
					Z.scrapeAPIArray(pSuffix, failedids, {
						aNumRetries: numretries,
						aRetryCount: retrycount,
						aCacheArray: cachearr,
						aFailedIndexes: failedindexes,
						aIsStandard: Settings.aIsStandard,
						aWantSort: Settings.aWantSort,
						aCooldown: Settings.aCooldown,
						aIterator: Settings.aIterator,
						aCallback: Settings.aCallback
					});
				}
				else
				{
					// Sort the objects by their IDs
					if (cachearr.length > 0 && cachearr[0].id && Settings.aWantSort !== false)
					{
						U.sortObjects(cachearr, {aKeyName: "id", aIsNumbers: true});
					}
					Z.APICacheArrayOfObjects = cachearr;
					// Execute callback if provided
					if (Settings.aCallback)
					{
						Settings.aCallback(cachearr, failedids);
					}
					else
					{
						I.print("Scrape completed. Enter /apicache to print the results.");
					}
				}
			}
		};
		
		var iterateIDs = function()
		{
			var reqcounter = 0;
			for (var i = reqindex; i < idsarray.length; i++)
			{
				if (reqcounter === reqlimit)
				{
					waitCooldown();
					return;
				}
				else
				{
					retrieveObject(idsarray[i], ((Settings.aFailedIndexes) ? Settings.aFailedIndexes[reqindex] : reqindex));
				}
				reqindex++;
				reqcounter++;
			}
		};
		
		var retrieveObject = function(pID, pIndex)
		{
			$.getJSON(prefix + pSuffix + indexsep + pID + querystr, function(pData)
			{
				cachearr[pIndex] = pData;
				// Execute iterator with data if requested
				if (Settings.aIterator)
				{
					Settings.aIterator(pData);
				}
				// Check for completion
				numfetched++;
				finalizeScrape();
			}).fail(function()
			{
				failedids.push(pID);
				failedindexes.push(pIndex);
				// Check for completion
				numtofetch--;
				finalizeScrape();
			});
		};
		
		var waitCooldown = function()
		{
			var percentcomplete = U.convertRatioToPercent(reqindex / idsarray.length);
			var secremaining = Math.ceil((idsarray.length - reqindex) / reqlimit) * Math.floor(reqcooldownms / T.cMSECONDS_IN_SECOND);
			I.print(D.getWordCapital("cooldown") + "... " + reqindex + " / " + idsarray.length
				+ " (" + percentcomplete + ")" + " " + T.formatTimeLetter(secremaining, true) + " " + D.getWord("remaining") + ".");
			setTimeout(function()
			{
				iterateIDs();
			}, reqcooldownms);
		};
		
		// Start the process
		if (Settings.aRetryCount === undefined)
		{
			Z.APICacheArrayOfIDs = pArray;
			Z.APICacheArrayOfObjects = [];
		}
		idsarray = pArray;
		numtofetch = idsarray.length;
		iterateIDs();
	},
	scrapeAPIArrayMultilingual: function(pSuffix, pArray, pCallback, pSettings)
	{
		var Settings = pSettings || {};
		Z.DatabaseCache[pSuffix] = {};
		var array;
		var multidb = Z.DatabaseCache[pSuffix]; 
		var counter = 0;
		var retrieveData = function()
		{
			if (counter < Z.DatabaseLanguages.length)
			{
				(function(iLang)
				{
					Settings.aQueryStr = "?lang=" + iLang;
					Settings.aCallback = function(pData)
					{
						multidb[iLang] = {};
						pData.forEach(function(iObj)
						{
							(multidb[iLang])[iObj.id] = iObj;
						});
						retrieveData();
					};
					Z.scrapeAPIArray(pSuffix, array, Settings);
				})(Z.DatabaseLanguages[counter]);
				counter++;
			}
			else
			{
				// Returns with a multilingual database, accessed first by the language code, then the object ID
				pCallback(multidb);
			}
		};
		if (Array.isArray(pArray))
		{
			array = pArray;
			retrieveData();
		}
		else if (typeof pArray === "number")
		{
			array = [pArray];
			retrieveData();
		}
		else
		{
			// If not provided an array of IDs then retrieve it from the API
			$.getJSON(U.getAPI(pSuffix), function(pData)
			{
				array = pData;
				retrieveData();
			});
		}
	},
	
	/*
	 * Fetches an API endpoint in all available languages.
	 * @param string pURL to fetch.
	 * @param function pCallback to execute after.
	 */
	fetchAPIMultilingual: function(pURL, pCallback)
	{
		var multidb = {};
		var numfetched = 0;
		var numtofetch = Z.DatabaseLanguages.length;
		var retrieveData = function()
		{
			if (numfetched < numtofetch)
			{
				(function(iLang)
				{
					var url = pURL + U.getDivider(pURL) + "lang=" + iLang;
					$.getJSON(url, function(pData)
					{
						multidb[iLang] = pData;
						retrieveData();
						A.setProgressBar(numfetched, numtofetch);
					}).fail(function()
					{
						I.print("Error retrieving " + U.escapeHTML(url) + ". Fetch aborted.");
					});
				})(Z.DatabaseLanguages[numfetched]);
				numfetched++;
			}
			else
			{
				// Returns with a multilingual database, accessed first by the language code, then the object ID
				pCallback(multidb);
			}
		};
		retrieveData();
	},
	
	/*
	 * Creates a processed object from a color API object, to be stored in the
	 * custom dyes database for use in account bank.
	 * @param object pColor.
	 * @returns object.
	 * @pre Items database for all languages were loaded.
	 */
	processDye: function(pColor, pColorDB)
	{
		var itemdb = (Z.DatabaseCache["items"])[O.OptionEnum.Language.Default];
		var item = itemdb[pColor.item];
		// Create CSS colors from the RGB values
		var materials = ["cloth", "leather", "metal"];
		var matarr = [];
		for (var i = 0; i < materials.length; i++)
		{
			var ithmat = materials[i];
			matarr.push(U.convertRGBToHex((pColor[ithmat]).rgb));
		}
		
		// Format of the object with properties in this order
		var obj = {};
		obj.u = pColor.id;
		if (pColor.item) // If the color has an associated item to unlock it
		{
			obj.i = pColor.item;
			obj.n = item.name;
		}
		else
		{
			obj.n = pColor.name;
		}
		obj.c = matarr;
		obj.h = pColor.categories[0];
		obj.m = pColor.categories[1];
		obj.l = item.chat_link;
		// Add translated names, with the property key as the language code
		Z.DatabaseLanguages.forEach(function(iLang)
		{
			obj[iLang] = (pColorDB[iLang])[pColor.id].name;
		});
		
		return obj;
	},
	
	/*
	 * Prints the current daily achievements.
	 * @param boolean pWantTomorrow whether to get tomorrow's instead of today's.
	 */
	printDaily: function(pWantTomorrow)
	{
		var numfetched = 0;
		var numtofetch = 0;
		var dailyobj = {};
		var finalizeDaily = function()
		{
			if (numtofetch === numfetched)
			{
				if (pWantTomorrow === undefined)
				{
					I.print("TODAY'S DAILIES");
				}
				for (var i in dailyobj)
				{
					I.print(i);
					for (var ii in dailyobj[i])
					{
						var ach = (dailyobj[i])[ii];
						I.prettyJSON(ach);
					}
				}
				// Also recursively print tomorrow's
				if (pWantTomorrow === undefined)
				{
					I.print("<br />");
					I.print("TOMORROW'S DAILIES");
					Z.printDaily(true);
				}
			}
		};
		
		var url = (pWantTomorrow) ? U.URL_API.Tomorrow : U.URL_API.Daily;
		$.getJSON(U.getLangURL(url), function(pData)
		{
			for (var i in pData)
			{
				numtofetch += (pData[i]).length;
			}
			for (var i in pData)
			{
				dailyobj[i] = [];
				for (var ii in pData[i])
				{
					var ach = (pData[i])[ii];
					(function(iAchArray, iAch)
					{
						$.getJSON(U.getAPIAchievement(iAch.id), function(iData)
						{
							iData.level = iAch.level; // Append the level from the daily object to the actual achievement
							iAchArray.push(iData);
						}).always(function()
						{
							numfetched++;
							finalizeDaily();
						});
					})(dailyobj[i], ach);
				}
			}
		});
	},
	
	/*
	 * Loads a database in all available languages.
	 * @param string pName of database to look for file.
	 * @param function pCallback to execute after loaded.
	 */
	loadMultilingualDatabase: function(pName, pCallback)
	{
		var dbname = pName.toLowerCase();
		var database = {};
		// Use loaded database if available
		var isdbloaded = true;
		Z.DatabaseLanguages.forEach(function(iLang)
		{
			if (Z.DatabaseCache[iLang] === undefined)
			{
				isdbloaded = false;
			}
		});
		if (isdbloaded)
		{
			pCallback(Z.DatabaseCache[dbname]);
			return;
		}
		
		// Check to see if all language versions of the database are loaded
		var finalize = function()
		{
			var isallloaded = true;
			Z.DatabaseLanguages.forEach(function(iLang)
			{
				if (database[iLang] === undefined)
				{
					isallloaded = false;
				}
			});
			if (isallloaded)
			{
				Z.DatabaseCache[dbname] = database;
				pCallback(Z.DatabaseCache[dbname]);
			}
		};
		
		// Retrieve the database
		Z.DatabaseLanguages.forEach(function(iLang)
		{
			$.getJSON(U.getItemsDatabaseURL(iLang), function(pData)
			{
				database[iLang] = pData;
				finalize();
			});
		});
	},
	
	/*
	 * Loads the items database in the default language.
	 * @param function pCallback to execute after loaded.
	 */
	getItemsDatabase: function(pCallback)
	{
		var lang = O.OptionEnum.Language.Default;
		var db = Z.DatabaseCache["items"];
		if (db && db[lang])
		{
			pCallback(db[lang]);
		}
		else
		{
			$.getJSON(U.getItemsDatabaseURL(lang), function(pData)
			{
				if (Z.DatabaseCache["items"] === undefined)
				{
					Z.DatabaseCache["items"] = {};
				}
				(Z.DatabaseCache["items"])[lang] = pData;
				pCallback(pData);
			});
		}
	},
	
	/*
	 * Loads the items database in all available languages.
	 * @param function pCallback to execute after loaded.
	 */
	loadItemsDatabase: function(pCallback)
	{
		Z.loadMultilingualDatabase("items", pCallback);
	},
	
	/*
	 * Creates JSON files containing an associative array of item details, for
	 * use by a specific Account page section.
	 * @param string pType section.
	 * @param intarray IDs to include instead of using the section record, optional.
	 */
	updateItemsSubdatabase: function(pType, pIDs)
	{
		var scripturl = U.getDataScriptURL(pType.toLowerCase());
		var dblang;
		var itemids = [];
		var createSubdatabase = function()
		{
			itemids = U.getUnique(itemids);
			for (var i in dblang)
			{
				// Reinitialize for ith language
				Z.APICacheArrayOfObjects = null;
				Z.APICacheArrayOfObjects = [];
				var db = dblang[i];
				var ithid;
				for (var ii = 0; ii < itemids.length; ii++)
				{
					ithid = itemids[ii];
					if (db[ithid])
					{
						Z.APICacheArrayOfObjects.push(db[ithid]);
					}
					else if (isNaN(ithid) === false)
					{
						I.print("Error looking up item: " + ithid);
					}
				}
				U.sortObjects(Z.APICacheArrayOfObjects, {aKeyName: "id"});
				var filename = pType.toLowerCase() + "_" + i + I.cJSON;
				Z.printAPICache(U.TypeEnum.isAssoc, {aWantQuotes: true, aFileName: filename});
			}
		};
		
		I.print("Loading items database...");
		Z.loadItemsDatabase(function(pDatabase)
		{
			dblang = pDatabase;
			if (pIDs)
			{
				itemids = pIDs;
				createSubdatabase();
			}
			else
			{
				I.print("Loading section record...");
				U.getScript(scripturl, function()
				{
					Z.freeFiles();
					var record = U.getRecordData(pType);
					for (var i in record)
					{
						var catarr = record[i];
						for (var ii = 0; ii < catarr.length; ii++)
						{
							if (catarr[ii].i)
							{
								itemids.push(catarr[ii].i);
							}
							else if (typeof catarr[ii] === "number")
							{
								itemids.push(catarr[ii]);
							}
						}
					}
					createSubdatabase();
				}).fail(function()
				{
					I.print("Error retrieving script: " + scripturl);
				});
			}
		});
	},
	
	/*
	 * Loads an unlockables record, downloads the current API array, compares
	 * for new IDs, and retrieves the new entries.
	 * @param string pSection name of account section and record.
	 * @param string pEndpoint name of API URL suffix, or an array of item IDs for comparison.
	 * @param function pCallback to execute after loaded.
	 */
	getNewAPIEntries: function(pSection, pEndpoint, pCallback)
	{
		var section = pSection;
		var sectionlower = pSection.toLowerCase();
		var endpoint;
		var record, blacklist, apiids;
		var iscustomids = Array.isArray(pEndpoint);
		
		var fetchNewEntries = function()
		{
			// Combine the record's categories into one associative array
			var catarr, entry, storedids = [];
			for (var i in record)
			{
				catarr = record[i];
				for (var ii = 0; ii < catarr.length; ii++)
				{
					entry = catarr[ii];
					if (iscustomids)
					{
						storedids.push(entry.i);
					}
					else
					{
						storedids.push(entry.u);
					}
				}
			}
			// Reformat the API IDs into an array of integers if it is objects
			apiids = A.flattenUnlocks(apiids);
			// Compile IDs to fetch by filtering: new IDs, not in blacklist
			var newids = U.getDifference(apiids, storedids);
			var filteredids = (blacklist === undefined) ? newids : (newids.filter(function(iID)
			{
				if (blacklist[iID] === undefined)
				{
					return iID;
				}
			}));
			
			if (filteredids.length === 0)
			{
				I.print("No difference found between stored " + sectionlower + " record and post-blacklisted API array.");
				return;
			}
			// Execute callback with filtered list in object
			if (iscustomids)
			{
				pCallback({
					oRecord: record,
					oBlacklist: blacklist,
					oEntries: filteredids,
					oNewIDs: filteredids
				});
			}
			else
			{
				// Fetch new entries
				U.fetchAPI(U.URL_API.Prefix + endpoint, filteredids, {aCallback: function(pData)
				{
					pCallback({
						oRecord: record,
						oBlacklist: blacklist,
						oEntries: pData,
						oNewIDs: filteredids
					});
				}});
			}
		};
		
		U.getScript(U.getDataScriptURL(section), function()
		{
			record = U.getRecordData(section);
			blacklist = U.getRecordBlacklist(section);
			if (iscustomids)
			{
				apiids = pEndpoint;
				fetchNewEntries();
			}
			else
			{
				endpoint = pEndpoint.toLowerCase();
				$.getJSON(U.getAPI(endpoint), function(pData)
				{
					apiids = pData;
					fetchNewEntries();
				});
			}
		});
	},
	
	/*
	 * Prints a new unlockables record entry to the console.
	 * @param array pEntries item details objects.
	 * @objparam string aItemIDsKey name of property for getting the associated item ID.
	 * @objparam object aItemDB for looking up items.
	 */
	printRecordEntry: function(pEntries, pSettings)
	{
		I.print("");
		if (pEntries.length)
		{
			I.print("New items added:");
		}
		else
		{
			I.print("No new items added. Record is up-to-date.");
			return;
		}
		
		var Settings = pSettings || {};
		var ithentry, entryobj, entrystr, blackliststr = "", entrystrs = [], itemidsproperty, itemids, itemid, name;
		var icon, entryelm, itemselm, inputselm, unlockid;
		for (var i in pEntries)
		{
			ithentry = pEntries[i];
			icon = (ithentry.icon) ? "<img src='" + ithentry.icon + "' />" : "";
			entryelm = $("<div style='margin-bottom:24px'><span>" + icon + U.escapeHTML(U.lineJSON(ithentry))
				+ "</span></div>").appendTo(I.getConsole());
			itemselm = $("<div></div>").appendTo(entryelm);
			
			unlockid = ithentry["unlock_items"];
			itemidsproperty = (unlockid) ? (unlockid || unlockid[0]) : ithentry[Settings.aItemIDsKey];
			if (itemidsproperty)
			{
				itemids = (Array.isArray(itemidsproperty)) ? itemidsproperty : [itemidsproperty];
				for (var ii = 0; ii < itemids.length; ii++)
				{
					itemid = itemids[ii];
					name = (Settings.aItemDB) ? Settings.aItemDB[itemid].name : ithentry.name;
					entryobj = ithentry.oRecordEntry || {
						u: ithentry.id,
						i: itemid,
						n: name,
						p: {gem: null}
					};
					if (entryobj.u === entryobj.i)
					{
						delete entryobj["u"];
					}
					entrystr = U.lineJSON(entryobj, false) + ",";
					inputselm = $("<aside>&nbsp;<a" + U.convertExternalAnchor(U.getWikiLinkDefault(name)) + ">" + name + "</a></aside>").appendTo(itemselm);
					$("<input class='cssInputText' type='text' />").prependTo(inputselm).val(entrystr);
					$("<input class='cssInputText' type='text' />").prependTo(inputselm).val(itemid);
					entrystrs.push(entrystr);
					blackliststr += "&quot;" + ithentry.id + "&quot;" + ": " + "&quot;<a"
						+ U.convertExternalAnchor(U.getWikiLinkDefault(name)) + "'>" + name + "</a>&quot;,<br />";
				}
			}
			I.bindInputSelect(entryelm.find(".cssInputText"));
		}
		I.print(blackliststr);
		I.print(entrystrs.join("<br />"));
		I.bindConsoleInput();
	},
	
	/*
	 * Executes a collate function.
	 * @param string pName of the function.
	 */
	executeCollate: function(pName, pExtra)
	{
		var prefix = "collate", name;
		var printFunctions = function()
		{
			I.print("Collate function not found, available functions:");
			for (var i in Z)
			{
				if (i.indexOf(prefix) !== -1)
				{
					name = i.substring(i.indexOf(prefix) + prefix.length, i.length).toLowerCase();
					I.print(name);
				}
			}
		};
		
		if (pName)
		{
			var functionname = prefix + U.toFirstUpperCase(pName);
			if (Z[functionname])
			{
				(Z[functionname])(pExtra);
			}
			else
			{
				printFunctions();
			}
		}
		else
		{
			printFunctions();
		}
	},
	
	/*
	 * Downloads API entries that are missing from the current version of the
	 * database for every available API languages.
	 * @param string pType of database, such as items or achievements.
	 * @boolean pIsRebuild whether to redownload all entries.
	 */
	collateDatabase: function(pType, pIsRebuild)
	{
		var type = pType.toLowerCase();
		var typeupper = U.toFirstUpperCase(type);
		var wantrebuild = (pIsRebuild === true);
		var counter = 0;
		var newitemslist, newitems, newitemids;
		var isitemsdb = (type === "items") ? true : false;
		
		var updateDBLang = function()
		{
			// Stopping condition for this recursive function
			if (counter >= Z.DatabaseLanguages.length)
			{
				I.print(typeupper + " database of all languages updated.");
				if (newitems && !wantrebuild)
				{
					if (isitemsdb)
					{
						Q.sortItems(newitemids, function(pSortedItems, pSortedIDs)
						{
							Z.printRecordEntry(pSortedItems, {aItemIDsKey: "id"});
							Z.collateMuseum(pSortedIDs);
						});
					}
					else
					{
						Z.printRecordEntry(newitems, {aItemIDsKey: "id"});
					}
				}
				return;
			}
			var lang = Z.DatabaseLanguages[counter];
			var dburl = (isitemsdb) ? U.getItemsDatabaseURL(lang) : U.getCacheURL(type, lang);
			$.getJSON(dburl, function(pData)
			{
				var dbarray = [];
				var currentitemids = [];
				// Convert the associative array into an array for later sorting
				for (var ithitemid in pData)
				{
					if (!wantrebuild)
					{
						dbarray.push(pData[ithitemid]);
					}
					currentitemids.push(parseInt(ithitemid));
				}
				// Find what item IDs are missing by comparing the API's current list with the one here
				newitemids = (wantrebuild) ? currentitemids : ((newitemids === undefined) ? U.getNew(currentitemids, newitemslist) : newitemids);
				if (newitemids.length)
				{
					U.fetchAPI(U.getAPIURL(type), newitemids, {
						aLanguage: lang,
						aCallback: function(pNewItems)
					{
						for (var i = 0; i < pNewItems.length; i++)
						{
							dbarray.push(pNewItems[i]);
						}
						if (lang === O.OptionEnum.Language.Default)
						{
							newitems = pNewItems;
						}
						U.sortObjects(dbarray, {aKeyName: "id"});
						Z.APICacheArrayOfObjects = dbarray;
						// Force unicode encoding on English
						var firstitem = Z.APICacheArrayOfObjects[0];
						if (lang === O.OptionEnum.Language.English && firstitem.name.indexOf(I.Symbol.Unicode) === -1)
						{
							firstitem.name += I.Symbol.Unicode;
						}
						Z.printAPICache(U.TypeEnum.isAssoc, {
							aWantQuotes: true,
							aFileName: type + "_" + lang + ((isitemsdb) ? I.cTXT : I.cJSON)
						});
						counter++;
						updateDBLang();
					}});
				}
				else
				{
					I.print(typeupper + " database is up-to-date. No difference found in IDs list.");
				}
			});
		};
		
		// Initial call
		I.print("Retrieving " + type + " index...");
		$.getJSON(U.getAPIURL(type), function(pData)
		{
			I.print("Looking for difference...");
			newitemslist = pData;
			updateDBLang();
		});
	},
	
	/*
	 * Decomposes the items database into a lightweight array for searching by name.
	 * Sample structure: [[69984,"bo"],[31283,"bow"],[70936,"keg"]...]
	 * @pre Items database files are up to date.
	 */
	collateSearch: function()
	{
		I.print("Loading items database...");
		Z.loadItemsDatabase(function()
		{
			I.print("Generating language search files...");
			Z.DatabaseLanguages.forEach(function(iLang)
			{
				var db = [];
				var sortabledb = [];
				var item;
				var ithdb = (Z.DatabaseCache["items"])[iLang];
				
				// Convert the assoc array into an array
				for (var ii in ithdb)
				{
					item = ithdb[ii];
					if (item.name)
					{
						sortabledb.push({
							i: item.id,
							n: item.name.toLowerCase(),
							l: item.name.length
						});
					}
				}
				// Sort the database by the item's name length, rather than ID number as it currently is
				U.sortObjects(sortabledb, {aKeyName: "l"});
				for (var ii = 0; ii < sortabledb.length; ii++)
				{
					item = sortabledb[ii];
					db.push([item.i, item.n]);
				}
				var dbstr = U.compressToJS(db);
				Z.createFile(dbstr, "search_" + iLang + I.cJSON);
			});
		});
	},
	
	/*
	 * Outputs the materials categories in the unlockables record format.
	 */
	collateMaterials: function()
	{
		var section = "Materials";
		U.getScript(U.getDataScriptURL(section), function()
		{
			var record = {};
			var headers = U.getRecordHeader(section);
			var assoc = U.getRecordMetadata(section).CategoryAssoc;
			var catname, catarr;
			for (var i in headers)
			{
				record[i] = [];
			}
			$.getJSON(U.getAPIMaterial(), function(pMatCategoryIDs)
			{
				Z.scrapeAPIArray(section.toLowerCase(), pMatCategoryIDs, {aCallback: function(pMatCategories)
				{
					for (var i in pMatCategories)
					{
						catarr = pMatCategories[i];
						catname = assoc[catarr.id];
						record[catname] = catarr.items;
					}
					Z.printUnlockables(record, true, true);
				}});
			});
		});
	},
	
	/*
	 * Updates the skins unlockables record by looking for new skin IDs, then
	 * downloads, categorizes, and associates the skins to their unlocking items.
	 * @pre Items database is up to date.
	 */
	collateSkins: function()
	{
		var section = "Skins";
		var itemdb, record, blacklist;
		var newentries, newskins, categorizedskins = {};
		
		// Updates an added skin entry in the record
		var updateSkinEntry = function(pEntry, pItem)
		{
			pEntry.i = pItem.id;
			// Add to the list of items associated with this skin, this will not be included in the result
			if (newskins[pEntry.u].oAssocItems === undefined)
			{
				newskins[pEntry.u].oAssocItems = [];
			}
			newskins[pEntry.u].oAssocItems.push(pItem.id);
			// Update skin entry properties
			if (Q.isTradeable(pItem))
			{
				// IDs of items that unlock the skin
				if (pEntry.b === undefined)
				{
					pEntry.b = [];
				}
				pEntry.b.push(pItem.id);
			}
			else
			{
				// If not tradeable then a custom payment property must be later manually assigned
				pEntry.p = {gem: null};
			}
		};
		
		// Scans through the item database once, modifying the skin entry in the record if the item has a matching skin ID
		var associateNewSkins = function()
		{
			var item, skinid, skinids;
			for (var i in itemdb)
			{
				item = itemdb[i];
				skinid = null;
				if (item.default_skin)
				{
					skinid = item.default_skin;
				}
				else if (item.details && item.details.skins)
				{
					skinid = item.details.skins;
				}
				// Get the matching skin entry and update its associated item ID property
				if (skinid)
				{
					skinids = (Array.isArray(skinid)) ? skinid : [skinid];
					for (var ii = 0; ii < skinids.length; ii++)
					{
						if (categorizedskins[skinids[ii]])
						{
							updateSkinEntry(categorizedskins[skinids[ii]], item);
						}
					}
				}
			}
			// Final output
			Z.printUnlockables(record, null, true);
			Z.printRecordEntry(newentries, {
				aItemDB: itemdb,
				aItemIDsKey: "oAssocItems"
			});
		};
		
		// Find new API entries
		Z.getNewAPIEntries(section, section, function(pReturn)
		{
			record = pReturn.oRecord;
			blacklist = pReturn.oBlacklist;
			newentries = pReturn.oEntries;
			
			var isnewblacklist = false;
			var catname;
			var ithskin;
			newskins = {};
			for (var i = 0; i < newentries.length; i++)
			{
				ithskin = newentries[i];
				newskins[ithskin.id] = ithskin;
				if (ithskin.name === "" || ithskin.type === undefined)
				{
					// Create a new blacklist by looking for mismatch or improper skins
					isnewblacklist = true;
					blacklist[ithskin.id] = ithskin.name;
				}
				else
				{
					// Categorize skin
					catname = "";
					if (ithskin.type === "Armor" && ithskin.details && ithskin.details.type && ithskin.details.weight_class)
					{
						catname = ithskin.type + "_" + ithskin.details.weight_class + "_" + ithskin.details.type;
					}
					else if (ithskin.type === "Weapon" && ithskin.details && ithskin.details.type)
					{
						catname = ithskin.type + "_" + ithskin.details.type;
					}
					else if (ithskin.type === "Back")
					{
						catname = ithskin.type;
					}
					// Create initial entry in the record, to be assigned with associated item ID later
					var entry = {
						u: ithskin.id,
						i: null,
						n: ithskin.name
					};
					if (record[catname])
					{
						record[catname].push(entry);
						categorizedskins[ithskin.id] = entry;
					}
					else
					{
						I.print("Warning uncategorizable skin:");
						I.prettyJSON(ithskin);
					}
				}
			}
			// Print the blacklist if there are new items to blacklist
			if (isnewblacklist)
			{
				I.prettyJSON(blacklist);
			}
			// Categorize
			Z.getItemsDatabase(function(pDatabase)
			{
				itemdb = pDatabase;
				associateNewSkins();
			});
		});
	},
	
	/*
	 * Finds and prints unlockables from the API not already in the unlockables record.
	 */
	collateUnlockables: function(pSection, pEndpoint)
	{
		var section = pSection;
		Z.getNewAPIEntries(section, pEndpoint || section, function(pReturn)
		{
			Z.printRecordEntry(pReturn.oEntries, {
				aItemIDsKey: "item_id"
			});
		});
	},
	collateOutfits: function()
	{
		Z.collateUnlockables("Outfits");
	},
	collateGliders: function()
	{
		Z.collateUnlockables("Gliders");
	},
	collateMinis: function()
	{
		Z.collateUnlockables("Minis");
	},
	collateCarriers: function()
	{
		Z.collateUnlockables("Carriers", "mailcarriers");
	},
	collateFinishers: function()
	{
		Z.collateUnlockables("Finishers");
	},
	collateNodes: function()
	{
		Z.collateUnlockables("Nodes");
	},
	collateCats: function()
	{
		Z.collateUnlockables("Cats");
	},
	
	/*
	 * Sorts the dyes database according to set, hue, then lightness.
	 */
	collateDyes: function()
	{
		var section = "Dyes";
		var record, newentries;
		I.print("Loading items database...");
		Z.getItemsDatabase(function()
		{
			I.print("Looking for difference...");
			Z.getNewAPIEntries(section, "colors", function(pReturn)
			{
				record = pReturn.oRecord;
				newentries = pReturn.oEntries;
				I.print("Downloading color translations...");
				Z.scrapeAPIArrayMultilingual("colors", pReturn.oNewIDs, function(pDataColor)
				{
					I.clear();
					newentries.forEach(function(iEntry)
					{
						var color = Z.processDye(iEntry, pDataColor);
						I.print(U.lineJSON(color, false) + ",");
					});
				});
			});
		});
	},
	
	/*
	 * Reads the item database for some collectionesque items. Other items such
	 * as toys will have to be manually added.
	 */
	collateCatalog: function()
	{
		var section = "Catalog";
		
		// Returns the category name of an item, if fitting
		var categorizeItem = function(pItem)
		{
			var name = pItem.name.toLowerCase();
			var desc = (pItem.description) ? pItem.description.toLowerCase() : "";
			if (desc.indexOf("to transform") !== -1 || desc.indexOf("transform into") !== -1 || desc.indexOf("to become") !== -1)
			{
				if (pItem.type === Q.ItemEnum.Gizmo)
				{
					return "TonicEndless";
				}
				if (pItem.type === Q.ItemEnum.Consumable)
				{
					return "TonicConsumable";
				}
			}
			if (desc.indexOf("to take out") !== -1)
			{
				if (pItem.type === Q.ItemEnum.Gizmo)
				{
					return "Toy";
				}
			}
			if (pItem.type === Q.ItemEnum.Gathering && pItem.rarity === Q.RarityEnum.Exotic)
			{
				return "Gathering";
			}
			if (pItem.type === Q.ItemEnum.UpgradeComponent && name.indexOf("infusion") !== -1)
			{
				return "Aura";
			}
			if (pItem.rarity === Q.RarityEnum.Legendary && (pItem.type === Q.ItemEnum.Weapon || pItem.type === Q.ItemEnum.Armor || pItem.type === Q.ItemEnum.Trinket))
			{
				return "Legendary";
			}
			return null;
		};
		
		I.print("Loading items database...");
		Z.getItemsDatabase(function(pDatabase)
		{
			I.print("Loading " + section);
			U.getScript(U.getDataScriptURL(section), function()
			{
				var item, catname;
				var newitems = [];
				var record = U.getRecordData(section);
				var assoc = A.flattenRecord(record);
				var blacklist = U.getRecordBlacklist(section);
				for (var i in pDatabase)
				{
					item = pDatabase[i];
					// Exclude blacklisted
					if (blacklist[item.id])
					{
						continue;
					}
					catname = categorizeItem(item);
					// Add the item if matched
					if (catname && assoc[item.id] === undefined)
					{
						newitems.push(item);
						record[catname].push({
							i: item.id,
							n: item.name,
							p: {gem: null}
						});
					}
				}
				Z.printUnlockables(record);
				Z.printRecordEntry(newitems, {
					aItemIDsKey: "id"
				});
			});
		});
	},
	
	/*
	 * Reads the item database for container items and "useless" items.
	 */
	collateCleanup: function()
	{
		var section = "Cleanup";
		var record = {};
		var db;
		
		var doCollate = function()
		{
			// Initialize the record's arrays
			var headers = U.getRecordHeader(section);
			for (var i in headers)
			{
				record[i] = [];
			}
			// Use the main catalog as the blacklist
			var blacklist = {};
			var catarr, itemid;
			var catalog = U.getRecordData("Catalog");
			for (var i in catalog)
			{
				catarr = catalog[i];
				for (var ii = 0; ii < catarr.length; ii++)
				{
					itemid = catarr[ii].i;
					blacklist[itemid] = true;
				}
			}
			// Exclude items from material storage
			var materials = U.getRecordData("Materials");
			for (var i in materials)
			{
				var matcat = materials[i];
				for (var ii = 0; ii < matcat.length; ii++)
				{
					blacklist[(matcat[ii])] = true;
				}
			}
			
			// Categorize the whitelist
			var item, catname;
			for (var i in db)
			{
				item = db[i];
				// Exclude blacklisted
				if (blacklist[item.id])
				{
					continue;
				}
				catname = Q.categorizeCleanableItem(item);
				// Add the item if matched
				if (catname)
				{
					record[catname].push(item.id);
				}
			}
			Z.printUnlockables(record, true, true);

			// Also print junk items prices
			var junkvalue = {};
			for (var i in db)
			{
				var item = db[i];
				if (item.rarity === Q.RarityEnum.Junk && item.vendor_value > 0)
				{
					junkvalue[item.id] = item.vendor_value;
				}
			}
			I.paste(U.lineJSON(junkvalue));
		};
		
		// Retrieve data first
		U.getScript(U.getDataScriptURL(section), function()
		{
			U.getScript(U.getDataScriptURL("Catalog"), function()
			{
				U.getScript(U.getDataScriptURL("Materials"), function()
				{
					Z.getItemsDatabase(function(pDatabase)
					{
						db = pDatabase;
						doCollate();
					});
				});
			});
		});
	},
	
	/*
	 * Updates the unlockables record of ascended items.
	 */
	collateAscended: function()
	{
		// Default payment value for item categories
		var payment =
		{
			ContainerWeapon: {coin: 1200000},
			ContainerArmor: {coin: 1200000},
			ContainerHelm: {coin: 900000},
			ContainerShoulders: {coin: 900000},
			ContainerCoat: {coin: 1200000},
			ContainerGloves: {coin: 900000},
			ContainerLeggings: {coin: 1100000},
			ContainerBoots: {coin: 1000000},
			Back: {craft: true},
			Ring: {coin: 0},
			Accessory: {achievement: 0},
			Amulet: {achievement: 0},
			LightHelm: {coin: 900000},
			LightShoulders: {coin: 900000},
			LightCoat: {coin: 1200000},
			LightGloves: {coin: 900000},
			LightLeggings: {coin: 1100000},
			LightBoots: {coin: 1000000},
			MediumHelm: {coin: 900000},
			MediumShoulders: {coin: 900000},
			MediumCoat: {coin: 1200000},
			MediumGloves: {coin: 900000},
			MediumLeggings: {coin: 1100000},
			MediumBoots: {coin: 1000000},
			HeavyHelm: {coin: 900000},
			HeavyShoulders: {coin: 900000},
			HeavyCoat: {coin: 1200000},
			HeavyGloves: {coin: 900000},
			HeavyLeggings: {coin: 1100000},
			HeavyBoots: {coin: 900000},
			LightHelmAquatic: {coin: 900000},
			MediumHelmAquatic: {coin: 900000},
			HeavyHelmAquatic: {coin: 900000},
			Axe: {coin: 1100000},
			Mace: {coin: 1100000},
			Sword: {coin: 1200000},
			Dagger: {coin: 1100000},
			Pistol: {coin: 1100000},
			Scepter: {coin: 1100000},
			Focus: {coin: 1000000},
			Shield: {coin: 1000000},
			Torch: {coin: 1000000},
			Warhorn: {coin: 1000000},
			Greatsword: {coin: 1200000},
			Hammer: {coin: 1100000},
			LongBow: {coin: 1300000},
			ShortBow: {coin: 1300000},
			Rifle: {coin: 1200000},
			Staff: {coin: 1200000},
			Harpoon: {coin: 1100000},
			Speargun: {coin: 1300000},
			Trident: {coin: 1000000}
		};
		
		var categorizeItem = function(pItem)
		{
			var name = pItem.name.toLowerCase();
			if (pItem.type === Q.ItemEnum.Container && name.indexOf("recipe") === -1)
			{
				if (name.indexOf("weapon") !== -1)
				{
					return "ContainerWeapon";
				}
				if (name.indexOf("armor") !== -1)
				{
					return "ContainerArmor";
				}
			}
			else if (pItem.type === Q.ItemEnum.Weapon || pItem.type === Q.ItemEnum.Trinket)
			{
				return pItem.details.type;
			}
			else if (pItem.type === Q.ItemEnum.Armor)
			{
				return pItem.details.weight_class + pItem.details.type;
			}
			else if (pItem.type === Q.ItemEnum.Back)
			{
				return pItem.type;
			}
			return null;
		};
		
		var ascendedids = [];
		Z.getItemsDatabase(function(pDatabase)
		{
			var item, name, type, category;
			// Compile a list of desired ascended items from the database
			for (var i in pDatabase)
			{
				item = pDatabase[i];
				type = item.type;
				if (item.rarity === Q.RarityEnum.Ascended)
				{
					if (categorizeItem(item))
					{
						ascendedids.push(item.id);
					}
				}
			}
			// Filter against current list of ascendeds and print the new items
			Z.getNewAPIEntries("ascended", ascendedids, function(pReturn)
			{
				var newitems = [];
				for (var i in pReturn.oEntries)
				{
					item = pDatabase[(pReturn.oEntries[i])];
					name = U.escapeHTML(item.name);
					// Add the categorizable items to the record and output as file
					category = categorizeItem(item);
					if (category)
					{
						pReturn.oRecord[category].push({
							i: item.id,
							n: item.name,
							p: payment[category] || {coin: -1}
						});
						newitems.push(item);
					}
				}
				Z.printUnlockables(pReturn.oRecord, null, true);
				Z.printRecordEntry(newitems, {
					aItemIDsKey: "id"
				});
			});
		});
	},
	
	/*
	 * Reads the database of recipes and creates an unlockables record with the
	 * disciplines as categories.
	 * @pre Recipes database from API is up to date and precached.
	 */
	collateRecipes: function()
	{
		var db, record = {}, item, entry, entries;
		var sheets = {};
		var sheetstradeable = {};
		var doCollate = function(pReturn)
		{
			record = pReturn.oRecord;
			entries = pReturn.oEntries;
			// Create a list of recipe sheets
			for (var i in db)
			{
				item = db[i];
				if (item.details && item.details.unlock_type === "CraftingRecipe")
				{
					if (Q.isTradeable(item))
					{
						sheetstradeable[(item.details.recipe_id)] = item.id;
					}
					sheets[(item.details.recipe_id)] = item.id;
				}
			};

			var recipe, catname, discipline, ingredients, type, itemid, newitems = [];
			for (var i in entries)
			{
				recipe = entries[i];
				type = recipe.type;
				itemid = recipe.output_item_id;
				for (var ii = 0; ii < recipe.disciplines.length; ii++)
				{
					discipline = recipe.disciplines[ii];
					catname = discipline + "_" + recipe.type;
					// Merge some smaller categories into a bigger category
					if (recipe.type === "RefinementObsidian" || recipe.type === "RefinementEctoplasm")
					{
						catname = discipline + "_" + "Refinement";
					}
					if (db[itemid] && record[catname])
					{
						ingredients = [];
						recipe.ingredients.forEach(function(iIngredient)
						{
							ingredients.push([iIngredient.item_id, iIngredient.count]);
						});
						entry = {
							u: recipe.id,
							i: itemid,
							n: db[itemid].name,
							r: ingredients
						};
						if (sheets[recipe.id])
						{
							entry.s = sheets[recipe.id];
						}
						if (sheetstradeable[recipe.id])
						{
							entry.b = sheetstradeable[recipe.id];
						}
						record[catname].push(entry);
						newitems.push(db[itemid]);
					}
				}
			}
			// Discard the empty array categories
			var newrecord = {};
			for (var i in record)
			{
				if (record[i].length)
				{
					newrecord[i] = record[i];
				}
			}
			Z.printUnlockables(newrecord);
			Z.printRecordEntry(newitems);
		};
		
		I.print("Loading items database...");
		Z.getItemsDatabase(function(pDatabase)
		{
			I.print("Looking for difference...");
			Z.getNewAPIEntries("Recipes", "Recipes", function(pReturn)
			{
				db = pDatabase;
				doCollate(pReturn);
			});
		});
	},
	
	/*
	 * Updates the achievements database for all languages.
	 */
	collateAchievements: function()
	{
		U.getJSON(U.getAPI("achievements/categories"), function(pData)
		{
			var newcats = [];
			var cats = A.Metadata.AchievementCategories;
			for (var i in pData)
			{
				var id = pData[i];
				var isnewcat = false;
				for (var ii in cats)
				{
					if (cats[ii] === id)
					{
						isnewcat = true;
						break;
					}
				}
				if (isnewcat === false)
				{
					newcats.push(id);
				}
			}
			if (newcats.length)
			{
				U.fetchAPI(U.getAPIURL("achievements/categories"), newcats, {aCallback: function(pData)
				{
					I.print("New achievement categories:");
					pData.forEach(function(iCat)
					{
						Q.printItemInfo(iCat);
					});
				}});
			}
			Z.collateDatabase("achievements");
		});
	},
	collateFractals: function()
	{
		$.getJSON("test/achievements_en.json", function(pData)
		{
			var a = [];
			for (var i in pData)
			{
				var ach = pData[i];
				if (ach.name.indexOf("Daily Recommended Fractal—Scale") !== -1 && T.DailyAssociation[ach.id] === undefined)
				{
					a.push(ach);
				}
			}
			I.print(a);
		});
	},
	
	/*
	 * Creates a cache file of Trading Post prices to be used by the account audit function.
	 */
	collatePrices: function()
	{
		// Should only include records that have tradeable items
		var recordnames = ["materials", "skins", "dyes", "minis", "carriers", "champions", "finishers", "nodes", "recipes"];
		var recordnamescounter = 0;
		var db, record, catarr;
		var idstocache = {};
		var numcached = 0;
		var numcaches = recordnames.length;
		
		var fetchPrices = function(pPriceDB)
		{
			// Scan the entire item database for untradeable items
			var blacklist = pPriceDB["blacklist"];
			for (var i in db)
			{
				if (Q.isTradeable(db[i]) === false && blacklist[i] === undefined)
				{
					blacklist[i] = 1;
				}
			}
			// Include ingredients of composite items
			var compositeingr = U.getRecordMetadata("ascended").CompositeIngredients;
			var ingrid;
			for (var i in compositeingr)
			{
				for (var ii = 0; ii < compositeingr[i].length; ii++)
				{
					ingrid = ((compositeingr[i])[ii])[0];
					if (blacklist[ingrid] === undefined)
					{
						idstocache[ingrid] = true;
					}
				}
			}
			// Convert associative array into array before fetching
			var arr = [];
			for (var i in idstocache)
			{
				if (blacklist[i] === undefined)
				{
					arr.push(parseInt(i));
				}
			}
			
			I.print("Fetching prices...");
			E.getPrices(arr, function(pData, pUntradeableIDs)
			{
				// Add to the untradeable list any items that got past the tradeable check
				/*for (var i in pUntradeableIDs)
				{
					blacklist[(pUntradeableIDs[i])] = 1;
				}*/
				// Extract retrieved prices and create database of prices
				var pricecache = {};
				var priceobj;
				for (var i in pData)
				{
					priceobj = pData[i];
					pricecache[i] = [priceobj.oPriceBuy, priceobj.oPriceSell];
				}
				var str = "{\r\n"
					+ "\"data\":" + U.lineJSON(pricecache).replace(/ /g, "") + ",\r\n"
					+ "\"blacklist\":" + U.lineJSON(blacklist).replace(/ /g, "") + "\r\n"
					+ "}";
				Z.createFile(str, "prices.json");
			});
		};
		
		// Load composite ingredient IDs and the previous ID blacklist
		var loadMetadata = function()
		{
			I.print("Loading prices data...");
			U.getScript(U.URL_DATA.Ascended, function()
			{
				$.getJSON(U.URL_DATA.Prices, function(pData)
				{
					fetchPrices(pData);
				});
			});
		};
		
		// Macro function to iterate over an unlockables record
		var iterateRecord = function(pIteration)
		{
			var name = recordnames[recordnamescounter];
			recordnamescounter++;
			U.getScript(U.getDataScriptURL(name), function()
			{
				record = U.getRecordData(name);
				for (var i in record)
				{
					catarr = record[i];
					catarr.forEach(function(iEntry)
					{
						pIteration(iEntry);
					});
				}
				numcached++;
				if (numcached === numcaches)
				{
					loadMetadata();
				}
			});
		};
		
		/*
		 * Load cacheable records and add unlockables' associated tradeable items'
		 * ID to the associative array. Executions must be in the same order as
		 * the record names array.
		 */
		I.print("Loading items database...");
		Z.getItemsDatabase(function(pDatabase)
		{
			db = pDatabase;
			
			// Include specific items that are tradeable
			iterateRecord(function(iID) // Materials
			{
				if (Q.isTradeable(db[iID]))
				{
					idstocache[iID] = true;
				}
			});
			iterateRecord(function(iEntry) // Skins
			{
				if (iEntry.p === undefined && Q.isTradeable(db[iEntry.i]))
				{
					idstocache[iEntry.i] = true;
				}
			});
			iterateRecord(function(iEntry) // Dyes
			{
				if (Q.isTradeable(db[iEntry.i]))
				{
					idstocache[iEntry.i] = true;
				}
			});
			iterateRecord(function(iEntry) // Minis
			{
				if (Q.isTradeable(db[iEntry.i]))
				{
					idstocache[iEntry.i] = true;
				}
			});
			iterateRecord(function(iEntry) // Carriers
			{
				if (Q.isTradeable(db[iEntry.i]))
				{
					idstocache[iEntry.i] = true;
				}
			});
			iterateRecord(function(iEntry) // Champions
			{
				if (Q.isTradeable(db[iEntry.i]))
				{
					idstocache[iEntry.i] = true;
				}
			});
			iterateRecord(function(iEntry) // Finishers
			{
				if (Q.isTradeable(db[iEntry.i]))
				{
					idstocache[iEntry.i] = true;
				}
			});
			iterateRecord(function(iEntry) // Nodes
			{
				if (Q.isTradeable(db[iEntry.i]))
				{
					idstocache[iEntry.i] = true;
				}
			});
			iterateRecord(function(iEntry) // Recipes
			{
				if (iEntry.b)
				{
					idstocache[iEntry.b] = true;
				}
			});
		});
	},
	
	/*
	 * Updates the record of new API items.
	 * @param array pIDs from the update database function.
	 */
	collateMuseum: function(pIDs)
	{
		var datestr = (((new Date()).toISOString()).split("T")[0]).split("-");
		var timestamp = datestr[0] + "-" + datestr[1];
		var ids;
		U.getScript(U.URL_DATA.Museum, function()
		{
			var record = U.getRecordData("museum");
			var trimmedrecord = {};
			if (record[timestamp])
			{
				ids = U.getUnion(record[timestamp], pIDs);
			}
			else
			{
				ids = pIDs;
			}
			Q.sortItems(ids, function(pSortedItems, pSortedIDs)
			{
				record[timestamp] = pSortedIDs;
				trimmedrecord[timestamp] = pSortedIDs;
				Z.printUnlockables(trimmedrecord, true, true);
				Z.printUnlockables(record, true, true);
			});
		}, false);
	},
	
	/*
	 * Prints subdatabase of Pact recipes and produced items.
	 */
	collatePact: function()
	{
		var ids = [];
		for (var i in H.Pact.Products)
		{
			ids.push(i);
			ids.push(H.Pact.Products[i]);
		}
		Z.updateItemsSubdatabase("Pact", ids);
	},
	
	/*
	 * Gets and trims the current map floor details.
	 */
	collateMaps: function()
	{
		var printFile = function(pData, pLanguage)
		{
			for (var i in pData.regions)
			{
				var region = pData.regions[i];
				for (var ii in region.maps)
				{
					// Only keep the prelisted zones
					if (M.isZoneValid(ii) === false)
					{
						delete region.maps[ii];
					}
				}
			}
			Z.createFile(U.lineJSON(pData), "maps_" + pLanguage + I.cJSON);
		};
		Z.fetchAPIMultilingual(U.URL_API.MapFloorTyria, function(pData)
		{
			for (var i in pData)
			{
				printFile(pData[i], i);
			}
		});
	},
	
	/*
	 * Updates the map dynamic events list.
	 */
	collateEvents: function()
	{
		var printFile = function(pData, pLanguage)
		{
			var formatteddata = [];
			for (var i in pData.events)
			{
				// Make the events accessible with its ID
				pData.events[i].id = i;
				formatteddata.push(pData.events[i]);
			}
			Z.printAPICache(U.TypeEnum.isAssoc, {aCustomCache: formatteddata, aFileName: "events_" + pLanguage + I.cJSON});
		};
		Z.fetchAPIMultilingual(U.URL_API.EventDetails, function(pData)
		{
			for (var i in pData)
			{
				printFile(pData[i], i);
			}
		});
	}
};
A = {
/* =============================================================================
 * @@Account panel, API key management, and audit
 * ========================================================================== */

	TokenCurrent: null,
	CharIndexCurrent: null,
	isAccountInitialized: false,
	isChartsInitialized: false,
	isAuditReady: false,
	isCharactersCached: false, // For force redownloading of characters data rather than use cached
	Metadata: {}, // Prewritten data loaded along with account page
	Currency: {}, // Currency data
	Equipment: {}, // Character equipment slots information
	Attribute: {}, // Character attribute points
	Data: { // Cache for retrieved API data objects and arrays
		Account: {},
		Characters: [],
		CharacterAssoc: {},
		CharacterNames: null,
		Vaults: null,
		Wallet: null,
		Titles: null
	},
	Possessions: null, // Associative array of actual items from the user's bank, inventory, equipment slots, shared slots, and bag slots
	Tally: null, // Number of filled slots and capacity of banks and collections, used in auditing
	URL: { // Account data type and URL substring
		Account: "account",
		Bank: "account/bank",
		Materials: "account/materials",
		Skins: "account/skins",
		Outfits: "account/outfits",
		Gliders: "account/gliders",
		Dyes: "account/dyes",
		Minis: "account/minis",
		Carriers: "account/mailcarriers",
		Champions: "account/pvp/heroes",
		Finishers: "account/finishers",
		Nodes: "account/home/nodes",
		Cats: "account/home/cats",
		Achievements: "account/achievements",
		Masteries: "account/masteries",
		MasteryPoints: "account/mastery/points",
		Raids: "account/raids",
		Dungeons: "account/dungeons",
		Characters: "characters",
		Shared: "account/inventory", // Shared inventory slots
		Wallet: "account/wallet",
		Titles: "account/titles",
		Recipes: "account/recipes",
		CharactersSAB: "characters/{0}/sab",
		Delivery: "commerce/delivery",
		Transactions: "commerce/transactions",
		CurrentBuys: "commerce/transactions/current/buys",
		CurrentSells: "commerce/transactions/current/sells",
		HistoryBuys: "commerce/transactions/history/buys",
		HistorySells: "commerce/transactions/history/sells",
		Stats: "pvp/stats",
		Games: "pvp/games",
		Standings: "pvp/standings",
		TokenInfo: "tokeninfo",
		GuildLog: "log",
		GuildMembers: "guild/{0}/members",
		GuildPermission: "guild/{0}/permission",
		GuildRanks: "guild/{0}/ranks",
		GuildStash: "guild/{0}/stash",
		GuildTeams: "guild/{0}/teams",
		GuildTreasury: "guild/{0}/treasury",
		GuildUpgrades: "guild/{0}/upgrades"
	},
	Permissions: {}, // Corresponds to tokeninfo.json permissions array
	PermissionEnum: {
		Account: "account", // Your account display name, ID, home world, and list of guilds. Required permission.
		Builds: "builds", // Your currently equipped specializations, traits, skills, and equipment for all game modes.
		Characters: "characters", // Basic information about your characters.
		Guilds: "guilds", // Guilds' rosters, history, and MOTDs for all guilds you are a member of.
		Inventories: "inventories", // Your account bank, material storage, recipe unlocks, and character inventories.
		Progression: "progression", // Your achievements, dungeon unlock status, mastery point assignments, and general PvE progress.
		PvP: "pvp", // Your PvP stats, match history, reward track progression, and custom arena details.
		TradingPost: "tradingpost", // Your Trading Post transactions.
		Wallet: "wallet", // Your account's wallet.
		Unlocks: "unlocks" // Your wardrobe unlocks—skins, dyes, minipets, finishers, etc.—and currently equipped skins.
	},
	DishCurrent: null, // The account section currently displayed
	
	/*
	 * Gets an authenticated API URL to retrieve account data.
	 * @param enum pSuffix type of account data.
	 * @returns string.
	 * @pre Token for use (API key) variable was initialized.
	 */
	getURL: function(pSuffix)
	{
		return "https://api.guildwars2.com/v2/" + pSuffix + U.getDivider(pSuffix) + "access_token=" + A.TokenCurrent;
	},
	getURLAll: function(pSuffix)
	{
		return A.getURL(pSuffix + "?ids=all");
	},
	
	/*
	 * Fetches a transactions.
	 * @param enum pURL type of transactions.
	 * @param object pSettings for the used fetch paginated function.
	 */
	getTransactions: function(pURL, pSettings)
	{
		var Settings = pSettings || {};
		Settings.aPermission = A.PermissionEnum.TradingPost;
		U.fetchPaginated(A.getURL(pURL), Settings);
	},
	
	/*
	 * Advances the global account page progress bar by given values, or clears
	 * the bar if completed progress.
	 * @param int pNumFetched dividend.
	 * @param int pNumToFetch divisor.
	 */
	setProgressBar: function(pNumFetched, pNumToFetch)
	{
		var progressbar = document.getElementById("accProgress");
		var progresscount = document.getElementById("accProgressCount");
		if (progressbar)
		{
			progressbar.style.width = (pNumFetched / pNumToFetch) * T.cPERCENT_100 + "%";
			progresscount.innerHTML = pNumFetched + " / " + pNumToFetch;
			if (pNumFetched === pNumToFetch)
			{
				A.resetProgressBar();
			}
		}
	},
	fillProgressBar: function()
	{
		A.setProgressBar(1, 1);
	},
	
	/*
	 * Fades and clears the progress bar.
	 */
	resetProgressBar: function(pWantAnimation)
	{
		var progress = $("#accProgress");
		var count = $("#accProgressCount");
		if (pWantAnimation || pWantAnimation === undefined)
		{
			progress.css({opacity: 1}).animate({opacity: 0}, 800, function()
			{
				$(this).css({width: "0px", opacity: 1});
			});
		}
		else
		{
			progress.css({width: "0px", opacity: 1});
		}
		count.empty();
	},
	
	/*
	 * Initializes common UI for the account panel.
	 */
	initializeAccount: function(pPage)
	{
		// Add new words to the dictionary
		D.addDictionary(GW2T_ACCOUNT_DICTIONARY);
		A.Metadata = GW2T_ACCOUNT_METADATA;
		A.Currency = GW2T_CURRENCY_DATA;
		A.Equipment = GW2T_EQUIPMENT_DATA;
		A.Attribute = GW2T_ATTRIBUTE_DATA;
		var ispageprovided = (typeof pPage === "string" && I.PageEnum.Account[pPage] !== undefined);
		// Add faux items
		Q.initializeFaux();
		
		// Initialize scaffolding HTML
		var scaffold = $("#accContent");
		scaffold.find("section").addClass("accPlatter");
		scaffold.find("article").addClass("accDishContainer jsScrollable").each(function()
		{
			var sectionname = $(this).attr("data-section");
			if ($(this).is(":empty"))
			{
				$(this).html("<div class='accDishPadding'></div>"
					+ "<div id='accDish_" + sectionname + "' class='accDish cntComposition'></div>");
			}
			else
			{
				$(this).wrapInner("<div id='accDish_" + sectionname + "' class='accDish cntComposition'></div>");
				$(this).prepend("<div class='accDishPadding'></div>");
			}
			I.bindScrollbar($(this));
		});
		$("#accContent").show();
		
		// Initialize common UI
		U.convertExternalLink($("#accHelp").find(".jsExternal").find("a"));
		A.generateMenu(ispageprovided);
		
		// Bind the window buttons
		$("#accToggle").click(function()
		{
			$("#accMenu").slideToggle("fast", function()
			{
				A.adjustAccountPanel();
			});
		});
		$("#accExpand").click(function()
		{
			$("#opt_bol_showPanel").trigger("click");
		});
		$("#accClose").click(function()
		{
			$("#mapAccountButton").trigger("click");
		});
		$("#accDisplayButton").toggle(!O.Options.bol_showPanel).click(function()
		{
			$("#opt_bol_showPanel").trigger("click");
		});
		
		// Initialize API keys
		A.initializeTokens();
		
		// Initialize tooltips and translate
		I.qTip.init($("#panelAccount").find("a, label, button, kbd, img"));
		D.translateElements();
		
		// Initialize the console, which is the same as the map's coordinates bar
		var consoleinput = $("#accConsole").onEnterKey(function()
		{
			var val = $(this).val();
			var str = (val.charAt(0) === Z.cCommandPrefix) ? val : Z.cCommandPrefix + val;
			Z.parseCommand(str, M);
		});
		I.bindInputBarText(consoleinput, "Enter \"help\" for commands...");
		Q.bindItemSearch("#accSearch", {
			aCallback: function(pItem)
			{
				Q.printItemInfo(pItem, true);
			}}
		);
		
		// Initialize context menu for bank and inventory slots
		Q.initializeItemContextMenu();
		
		// Translate directory
		if (D.isLanguageDefault === false)
		{
			$("#accDirectory var").each(function()
			{
				var word = $(this).text().toLowerCase();
				$(this).html(D.getWordCapital(word));
			});
		}
		U.convertExternalLink("#accDirectory .linkExternal");
		U.convertInternalLink("#accDirectory a");
	
		// Finally
		setTimeout(function()
		{
			A.adjustAccountPanel();
		}, 1000);
		A.isAccountInitialized = true;
		
		// Print messages if available
		H.getUrgent(H.Announcement.UrgentAccount);
		
		// Open a section if initially requested
		if (ispageprovided)
		{
			$("#accMenu_" + pPage).trigger("click");
		}
	},
	
	/*
	 * Binds functionality of the account page menu bar.
	 */
	generateMenu: function(pPage)
	{
		var menu = $("#accMenu");
		$("#accContent").find(".accDishMain").each(function()
		{
			var sectionname = $(this).attr("data-section");
			var sectionnamelow = sectionname.toLowerCase();
			var menutab = $("<aside id='accMenu_" + sectionname + "' class='accMenuTab accMenuClick curClick'>"
				+ "<span>"
					+ "<ins class='accMenuIcon accMenuIconMain mnu mnu_" + sectionnamelow + "' "
						+ "title='<dfn>" + D.getWordCapital(sectionnamelow) + "</dfn>'></ins>"
					+ "<var class='accMenuTitle'>" + D.getPhraseOriginal(sectionname) + "</var>"
				+ "</span>"
				+ "<span class='accMenuSubtab' style='display:none;'></span>"
			+ "</aside>");
			menu.append(menutab);
			(function(iTab, iSectionName)
			{
				var section = $("#accPlatter" + iSectionName);
				A.createDishMenu(iSectionName);
				/*
				 * Clicking on a menu tab shows the associated section, and
				 * clicking on a menu icon inside the tab shows the subsection
				 * of that section. The tab also acts as a menu icon if the user
				 * clicks on the tab instead of the icons the tab holds.
				 */
				iTab.click(function()
				{
					// Reset tab styles
					$(".accMenuTab").find(".accMenuIcon").removeClass("accMenuButtonFocused");
					$(".accPlatter").hide();
					// If previously viewing a non-main subsection of this section, then open that subsection
					if ($(this).data("iscurrentaccounttab") && $(this).hasClass("accMenuTabFocused") === false)
					{
						section.show();
						$(this).find(".accMenuCurrent").trigger("click");
					}
					else
					{
						// Else view the main subsection
						$(this).data("iscurrentaccounttab", null);
						A.DishCurrent = $("#accDish_" + iSectionName);
						// Show dish menu
						$(".accDishMenu").hide();
						$("#accDishMenu_" + iSectionName).show();
						// Show the main subsection
						section.find(".accDishContainer").hide();
						section.find(".accDishMain").show();
						$(this).find(".accMenuIconMain").addClass("accMenuButtonFocused");
						section.fadeIn(400);
						A.adjustAccountPanel();
						// Update address
						I.PageCurrent = I.SpecialPageEnum.Account;
						I.SectionCurrent[I.SpecialPageEnum.Account] =
							(iSectionName === I.PageEnum.Account.Manager) ? "" : iSectionName;
						U.updateQueryString();
						A.generateDish(iSectionName);
					}
					// Highlight the clicked tab
					$(".accMenuTab").removeClass("accMenuTabFocused").find(".accMenuSubtab").hide();
					$(this).addClass("accMenuTabFocused").find(".accMenuSubtab").show();
					// Clear the global progress bar, in case it froze
					A.resetProgressBar(false);
				});
				
				// A section (platter) may have multiple subsections (dishes)
				var subsections = section.find(".accDishContainer");
				if (subsections.length)
				{
					var subbuttons = iTab.find(".accMenuSubtab");
					subbuttons.append("<img src='img/ui/view.png' />");
					subsections.each(function()
					{
						if ($(this).hasClass("accDishMain") === false)
						{
							var subsectionname = $(this).attr("data-section");
							var subsectionnamelow = subsectionname.toLowerCase();
							var subbutton = $("<ins id='accMenu_" + subsectionname + "' class='accMenuButton accMenuIcon accMenuClick mnu mnu_" + subsectionnamelow + "' "
								+ "title='<dfn>" + D.getWordCapital(subsectionnamelow) + "</dfn>'></ins>");
							subbuttons.append(subbutton);
							A.createDishMenu(subsectionname);
							if ($(this).hasClass("accCharDependent"))
							{
								subbutton.addClass("accCharDependentMenu");
							}
							// Create a divider if this button is the beginning of a subtab group
							if ($(this).attr("data-islead"))
							{
								$("<span class='accMenuTabDivider'></span>").insertBefore(subbutton);
							}
							(function(iSubbutton, iSubsection)
							{
								iSubbutton.click(function(pEvent)
								{
									// Reset tab styles
									$(".accMenuTab").find(".accMenuIcon").removeClass("accMenuButtonFocused");
									$(".accPlatter").hide();
									$(".accMenuTab").removeClass("accMenuTabFocused").find(".accMenuSubtab").hide();
									section.show();
									var menutab = $(this).closest(".accMenuTab").data("iscurrentaccounttab", subsectionname);
									menutab.find(".accMenuCurrent").removeClass("accMenuCurrent");
									$(this).addClass("accMenuCurrent");
									A.DishCurrent = $("#accDish_" + subsectionname);
									// For the case that the subsection was opened programmatically, style the parent tab
									if (menutab.hasClass("accMenuTabFocused") === false)
									{
										menutab.addClass("accMenuTabFocused").find(".accMenuSubtab").show();
									}
									// Show dish menu menu
									$(".accDishMenu").hide();
									$("#accDishMenu_" + subsectionname).show();
									// Show the subsection
									pEvent.stopPropagation();
									iSubsection.parent().find(".accDishContainer").hide();
									iSubsection.fadeIn(200);
									A.adjustAccountPanel();
									// Highlight the button
									iTab.find(".accMenuIcon").removeClass("accMenuButtonFocused");
									$(this).addClass("accMenuButtonFocused");
									// Update address
									I.PageCurrent = I.SpecialPageEnum.Account;
									I.SectionCurrent[I.SpecialPageEnum.Account] = subsectionname;
									U.updateQueryString();
									A.generateDish(subsectionname);
								});
							})(subbutton, $(this));
						}
					});
				}
			})(menutab, sectionname);
		});
		I.qTip.init(".accMenuIcon");
		
		// Open the section if specified in the URL
		if (pPage !== true)
		{
			$("#accPlatterManager").show();
			U.openSectionFromURL({aPrefix: "#accMenu_", aInitialSection: I.PageEnum.Account.Manager});
		}
	},
	resetMenu: function()
	{
		// Clear menu tabs and icons state
		$(".accMenuTab").each(function()
		{
			$(this).data("iscurrentaccounttab", null).removeClass("accMenuTabFocused").find(".accMenuSubtab").hide();
			$(this).find(".accMenuIcon").removeClass("accMenuButtonFocused");
		});
		// Go to default dish
		$("#accMenu_Manager").trigger("click");
	},
	
	/*
	 * Adjusts the content portion of the account panel.
	 */
	adjustAccountPanel: function()
	{
		// Workaround for Firefox positioning, if not compensated then the account page will be invisible with height 0
		if (I.BrowserCurrent === I.BrowserEnum.Firefox)
		{
			$("#panelAccount").css({
				position: (O.Options.bol_showPanel) ? "relative" : "static",
				height: (O.Options.bol_showPanel) ? "100%" : $(window).height() + "px"
			});
		}
		// Resize the width of the menu bar based on the size of the content window
		var menualign = (O.Options.bol_alignPanelRight) ? {left: "0px", right: "auto"} : {left: "auto", right: "0px"};
		$("#accOverhead").css({width: ($("#accContent").width() - 8) + "px"}).css(menualign);
		// Put padding between the menu bar and the content
		if (A.DishCurrent)
		{
			A.DishCurrent.parent().find(".accDishPadding").css({height: A.getOverheadHeight() + "px"});
			A.adjustAccountScrollbar();
		}
	},
	getOverheadHeight: function()
	{
		return $("#accOverhead").height();
	},
	
	/*
	 * Updates the scroll bar of the currently viewed account section.
	 */
	adjustAccountScrollbar: function()
	{
		I.updateScrollbar(A.DishCurrent.parent());
	},
	
	/*
	 * Initializes the API keys manager and their storage.
	 */
	initializeTokens: function()
	{
		var tokenslimit = 64;
		var tokensarr = localStorage[O.Utilities.APITokens.key];
		var token;
		try
		{
			tokensarr = JSON.parse(tokensarr);
		}
		catch (e) {}
		if (tokensarr === undefined)
		{
			tokensarr = [];
			tokensarr.push(A.createToken("Example Key Name", "EXAMPLE-API-KEY-PLEASE-REPLACE-WITH-YOUR-OWN-HERE"));
		}
		// Create the token UI inputs
		var wantnewurlapikey = true;
		if (U.APIKey)
		{
			for (var i = 0; i < tokensarr.length; i++)
			{
				token = tokensarr[i];
				if (U.APIKey === token.key) // If the URL API key already exists in the manager, use it
				{
					token.isUsed = true;
					wantnewurlapikey = false;
				}
				else
				{
					delete token["isUsed"];
				}
			}
		}
		else
		{
			wantnewurlapikey = false;
		}
		if (U.APIKey && wantnewurlapikey) // Create a new token with the URL API key if doesn't exist
		{
			tokensarr.push(A.createToken("URL API Key", U.APIKey, true));
		}
		// Create the token UI inputs
		for (var i = 0; i < tokensarr.length; i++)
		{
			token = tokensarr[i];
			A.insertTokenRow(token.name, token.key, token.isUsed);
		}
		// Swap tokens behavior
		X.bindTextlistSwap("#accTokenList", "#accTokenList .accTokenButtons", A.saveTokens);
		A.saveTokens();
		A.loadToken();
		
		// Bind button to print the tokens
		$("#accManagerPrint").click(function()
		{
			var tokens = localStorage[O.Utilities.APITokens.key];
			try
			{
				tokens = JSON.parse(tokens);
				I.prettyJSON(tokens);
			}
			catch (e) {}
		});
		$("#accManagerHide").click(function()
		{
			$("#accManager").toggle();
		});
		
		// Bind button to add another token/row
		$("#accTokenNew").attr("title", "<dfn>" + D.getWordCapital("add") + "</dfn> " + D.getPhrase("key slot") + ".");
		$("#accTokenNew").click(function()
		{
			if (O.Utilities.APITokens.value.length < tokenslimit)
			{
				A.insertTokenRow("", "");
				A.saveTokens();
				I.qTip.init($("#accManager").find("button"));
			}
			else
			{
				I.write("API tokens limit reached.");
			}
		});
		
		// Finally
		D.translateElements();
		I.qTip.init($("#accManager").find("button"));
	},
	
	/*
	 * Inserts a token (row) into the API key manager.
	 * @param string pName.
	 * @param string pAPIKey.
	 */
	insertTokenRow: function(pName, pAPIKey, pIsUsed)
	{
		var token = $("<div class='accToken'></div>").appendTo("#accTokenList");
		var link = $("<img class='accTokenLink curClick' src='img/ui/link.png' title='Get private <dfn>shareable link</dfn>.' />").appendTo(token);
		var key = $("<input class='accTokenKey' type='text' value='" + pAPIKey + "' maxlength='128' />").appendTo(token);
		var name = $("<input class='accTokenName' type='text' value='" + pName + "' maxlength='64' />").appendTo(token);
		var buttons = $("<div class='accTokenButtons'></div>").appendTo(token);
		var use = $("<button class='accTokenUse' title='<dfn>" + D.getWordCapital("use") + "</dfn> "
			+ D.getPhrase("this key") + ".<br />" + D.getPhraseOriginal("Double click to audit") + ".'><img src='img/ui/adjust_use.png' /></button>").appendTo(buttons);
		var del = $("<button class='accTokenDelete' title='<dfn>" + D.getWordCapital("delete") + "</dfn> "
			+ D.getPhrase("this key") + ".'><img src='img/ui/adjust_del.png' /></button>").appendTo(buttons);
		var updateLink = function()
		{
			I.updateClipboard(link[0], "https://gw2timer.com#" + U.escapeHTML(U.stripToAlphanumericDash(key.val())));
		};
		
		// Use the token if specified
		if (pIsUsed === true)
		{
			A.TokenCurrent = U.stripToAlphanumericDash(pAPIKey);
			name.addClass("cssInputActive");
			use.addClass("btnActive");
		}
		
		// Button to use this token's API key
		use.click(function()
		{
			var str = key.val();
			if (str.length > 0)
			{
				$(".accTokenName").removeClass("cssInputActive");
				$(".accTokenUse").removeClass("btnActive");
				name.addClass("cssInputActive");
				use.addClass("btnActive").find("img");
				A.TokenCurrent = U.stripToAlphanumericDash(str);
				A.loadToken();
				A.saveTokens();
			}
			else
			{
				I.write("Please enter a valid API key.");
			}
		}).dblclick(function()
		{
			U.interpretPage(I.SpecialPageEnum.Audit);
		});
		// Entering a new key in the input box triggers the use button
		key.change(function()
		{
			use.trigger("click");
			updateLink();
		});
		// Clicking the link icon gets a shareable URL
		I.bindClipboard(link);
		updateLink();
		// Button to delete this token
		del.click(function()
		{
			var str = key.val();
			if (O.Utilities.APITokens.value.length > 1)
			{
				// Ask for confirmation if key is not empty
				if (str.length > 0)
				{
					if (confirm("Delete this API token?\nNote: Audit history must be manually deleted at gw2timer.com/audit"))
					{
						token.remove();
						A.saveTokens();
					}
				}
				else
				{
					token.remove();
					A.saveTokens();
				}
				I.qTip.hide();
			}
			else
			{
				I.write("Must have at least one API token.");
			}
		});
		// Autoselect the input boxes on click and save on change
		$([name, key]).each(function()
		{
			$(this).click(function()
			{
				$(this).select();
			}).change(function()
			{
				A.saveTokens();
			});
		});
		// Highlight the row when hovered on a button
		$([link, buttons]).each(function()
		{
			$(this).hover(
				function()
				{
					name.addClass("cssInputFocused");
					key.addClass("cssInputFocused");
				},
				function()
				{
					name.removeClass("cssInputFocused");
					key.removeClass("cssInputFocused");
				}
			);
		});
	},
	
	/*
	 * Creates a token object which contains a token's name and the API key string.
	 * @param string pName.
	 * @param string pAPIKey.
	 * @param boolean pIsUsed optional.
	 * @returns object.
	 */
	createToken: function(pName, pAPIKey, pIsUsed)
	{
		var token = {
			name: pName,
			key: pAPIKey
		};
		if (pIsUsed)
		{
			token.isUsed = true;
		}
		return token;
	},
	
	/*
	 * Reads text from the token inputs then serialize and store them.
	 */
	saveTokens: function()
	{
		var tokens = [];
		$(".accToken").each(function()
		{
			var name = U.escapeHTML($(this).find(".accTokenName").val());
			var key = U.stripToAlphanumericDash($(this).find(".accTokenKey").val());
			var token = A.createToken(name, key, $(this).find(".accTokenUse").hasClass("btnActive"));
			tokens.push(token);
		});
		var obj = O.Utilities.APITokens;
		obj.value = tokens;
		localStorage[obj.key] = JSON.stringify(obj.value);
	},
	
	/*
	 * Readies the account panel for the current API key.
	 */
	loadToken: function()
	{
		if (A.TokenCurrent === null)
		{
			return;
		}
		
		// Reset variables so the sections will reload the account data
		for (var i in A.Permissions)
		{
			A.Permissions[i] = null;
		}
		A.Data.CharacterNames = null;
		A.Data.Vaults = null;
		A.isAuditReady = false;
		// Prevent skipping loading the characters section first
		$("#accMenu_Characters").data("iscurrentaccounttab", null);
		$(".accDishMenu").empty();
		A.wipeDish("Characters");
		
		// Initialize permissions
		$.getJSON(A.getURL(A.URL.TokenInfo), function(pData)
		{
			for (var i in pData.permissions)
			{
				var permission = pData.permissions[i];
				A.Permissions[permission] = true;
			}
		}).fail(function(pRequest, pStatus)
		{
			A.printError(A.PermissionEnum.Account, pStatus, false);
		});
	},
	
	/*
	 * Prints standard API key error message to the console.
	 * @param string pRequestType the permission requested.
	 * @param string pStatus from AJAX.
	 * @param boolean pWantRedirect to return user to the manager section.
	 */
	printError: function(pPermission, pStatus, pWantRedirect)
	{
		if (A.TokenCurrent === null)
		{
			I.write("Please enter an API key first.");
		}
		else
		{
			if (pStatus === "error")
			{
				I.write("Unable to retrieve response. " + I.cErrorAPI);
			}
			else
			{
				I.write("Unable to access data for this key from ArenaNet API server.");
			}
			I.write(A.TokenCurrent);
		}
		if (pPermission)
		{
			// If missing permission then go to the Manager section for the user to update their key
			I.write("Requested permission: " + pPermission, 10);
			if (pWantRedirect || pWantRedirect === undefined)
			{
				$("#accMenu_Manager").trigger("click");
			}
		}
		U.nullifyArticle();
	},
	
	/*
	 * Checks if permission exists, else prints error.
	 * @returns boolean success.
	 */
	checkPermission: function(pPermission)
	{
		if (A.Permissions[pPermission])
		{
			return true;
		}
		A.printError(pPermission);
		return false;
	},
	
	/*
	 * Prints data from an account API.
	 * @param string pURLSuffix.
	 */
	printAccount: function(pURLSuffix)
	{
		if (pURLSuffix)
		{
			I.print("Loading " + pURLSuffix + "...");
			$.ajax({
				dataType: "json",
				url: A.getURL(pURLSuffix),
				cache: false,
				success: function(pData, pStatus, pRequest)
				{
					I.prettyJSON(pData);
				},
				error: function(pRequest, pStatus)
				{
					A.printError(null, pStatus);
				}
			});
		}
		else
		{
			I.print("Available account API URL suffixes:");
			for (var i in A.URL)
			{
				I.print(A.URL[i]);
			}
		}
	},
	
	/*
	 * Gets the current user selected character.
	 * @returns object character.
	 */
	getCurrentCharacter: function()
	{
		try
		{
			return A.Data.Characters[A.CharIndexCurrent];
		}
		catch (e) {}
		return null;
	},
	getCharacterByName: function(pName)
	{
		var charindex = A.Data.CharacterAssoc[pName];
		return A.Data.Characters[charindex];
	},
	
	/*
	 * Gets the name of the account section an element resides in.
	 * @param jqobject pElement.
	 * @returns string.
	 */
	getDishName: function(pElement)
	{
		return $(pElement).closest(".accDishContainer").attr("data-section");
	},
	
	/*
	 * Tells if a section has the current account's content generated, else wipe.
	 * @param jqobject pDish to check.
	 * @param boolean pIsForce to proceed without checks.
	 * @returns boolean.
	 */
	reinitializeDish: function(pDish, pIsForce)
	{
		if (!pIsForce && pDish.is(":empty") === false && pDish.data("token") === A.TokenCurrent)
		{
			return false;
		}
		var dishname = U.getSubstringFromHTMLID(pDish);
		
		// Wipe dish
		pDish.empty().data("token", A.TokenCurrent);
		// Wipe dish menu
		$("#accDishMenu_" + dishname).empty();
		
		if (pIsForce)
		{
			pDish.removeClass("accDishWipeable");
		}
		else
		{
			pDish.addClass("accDishWipeable");
			I.updateScrollbar(pDish);
		}
		return true;
	},
	
	/*
	 * Wipes all applicable dishes to relieve browser rendering, to be called
	 * when account panel is no longer used.
	 */
	reinitializePanel: function()
	{
		$(".accDishWipeable").each(function()
		{
			A.reinitializeDish($(this), true);
		});
		// Reset account viewed page
		A.resetMenu();
	},
	
	/*
	 * Executes the serve function which generates content for an account section.
	 * @param string pDish section name.
	 */
	generateDish: function(pDish)
	{
		var functionname = "serve" + pDish; // Special generate functions start with this word
		if (V[functionname])
		{
			(V[functionname])();
		}
	},
	
	/*
	 * Wipes a section's content and reexecutes the serve function.
	 * @param string pDish.
	 */
	regenerateDish: function(pDish)
	{
		A.wipeDish(pDish);
		A.generateDish(pDish);
	},
	wipeDish: function(pDish)
	{
		$("#accDish_" + pDish).empty().data("isloaded", false);
		$("#accDishMenu_" + pDish).empty();
	},
	
	/*
	 * Creates a container to insert items into a section-specific menu.
	 * @param string pSection name.
	 * @returns jqobject.
	 */
	createDishMenu: function(pDish)
	{
		$("<aside id='accDishMenu_" + pDish + "' class='accDishMenu'></aside>").appendTo("#accDishMenuContainer");
	},
	getDishMenu: function(pDish)
	{
		return $("#accDishMenu_" + pDish);
	},
	
	/*
	 * Creates fixed menu that scrolls to an associated character's element when
	 * clicked on its icon from the selection bar.
	 * @param objarray pCharacters
	 * @param string pSection
	 * @objparam function aClick custom scrolling action, with provided character index, optional.
	 * @objparam string aElementPrefix HTML ID for element to scroll to, to be suffixed by character index.
	 * @objparam int aOffset scroll from the element.
	 */
	createCharacterScroller: function(pCharacters, pSection, pSettings)
	{
		var Settings = pSettings || {};
		var dishmenu = A.getDishMenu(pSection);
		var container = $("<div class='eqpSelectContainer'></div>").appendTo(dishmenu);
		pCharacters.forEach(function(iChar)
		{
			var select = $("<span class='eqpSelect curClick' title='" + iChar.oCharName + " (" + iChar.level + ")' style='border-left: 2px solid " + iChar.oCharColor + "'>"
				+ "<img class='eqpSelectPortrait' src='" + iChar.oCharPortrait + "' />"
				+ "<img class='eqpSelectProfession' src='img/account/classes/" + iChar.oCharElite + ".png' />"
			+ "</span>").appendTo(container);
			if (iChar.oCharIsLowLevel)
			{
				select.addClass("accTrivial");
			}
			
			(function(iIndex)
			{
				select.click(function()
				{
					if (Settings.aClick)
					{
						Settings.aClick(iIndex);
					}
					else
					{
						var elm = $("#" + Settings.aElementPrefix + iIndex);
						if (elm && elm.length)
						{
							I.scrollToElement(elm, {
								aOffset: Settings.aOffset,
								aSpeed: "fast"
							});
						}
					}
					A.adjustAccountScrollbar();
				});
			})(iChar.oCharIndex);
		});
		I.qTip.init(container.find(".eqpSelect"));
		// Readjust because the newly created bar takes space up top
		A.adjustAccountPanel();
	},
	
	/*
	 * Creates a page wide banner with a character's name and portrait.
	 * @param object pCharacter
	 * @param jqobject pContainer
	 * @param string pPrefix for creating banner HTML ID.
	 */
	createCharacterBanner: function(pContainer, pCharacter, pPrefix)
	{
		var idstr = (pPrefix) ? "id='" + pPrefix + pCharacter.oCharIndex + "'" : "";
		$("<div " + idstr + " class='eqpCharSeparator'><img class='eqpCharPortrait' src='" + pCharacter.oCharPortrait + "' />"
			+ "<img class='eqpCharProfession' src='img/account/classes/" + pCharacter.oCharElite + ".png' />"
			+ "<span class='eqpCharName'>" + pCharacter.oCharName + "</span>"
		+ "</div>").prependTo(pContainer);
	},
	
	/*
	 * Embeds a website into an account section. Because the account page occupies
	 * the map container, embedding the site itself allows the map to be displayed.
	 * @param jqobject pContainer to insert iframe.
	 * @param string pURL source.
	 */
	embedFrame: function(pContainer, pURL)
	{
		var container = $(pContainer);
		if (!container.find(".accEmbedContainer").length)
		{
			var frameouter = $("<div class='accEmbedContainer'></div>").appendTo(container);
			var frame = $("<iframe class='accEmbedFrame'></iframe>").appendTo(frameouter);
			frame[0].src = pURL;
		}
	},
	
	/*
	 * Assigns a gem store account upgrade.
	 * @param string pUpgrade key name.
	 * @param int pOwned for example the total number of tabs in a bank tab.
	 */
	assignAccountUpgrades: function(pUpgrade, pOwned)
	{
		var upgobj = A.Currency.AuditUpgrades[pUpgrade];
		upgobj.purchased = pOwned - upgobj.starting;
		upgobj.totalgem = upgobj.gem * upgobj.purchased;
		upgobj.totalowned = upgobj.starting + upgobj.purchased;
	},
	initializeAccountUpgrades: function()
	{
		var upgs = A.Currency.AuditUpgrades;
		for (var i in upgs)
		{
			upgs[i].purchased = 0;
			upgs[i].totalgem = 0;
			upgs[i].totalowned = upgs[i].starting;
		}
	},
	getAccountUpgradesGem: function()
	{
		var upgs = A.Currency.AuditUpgrades;
		var gemsum = 0;
		for (var i in upgs)
		{
			gemsum += upgs[i].totalgem;
		}
		return gemsum;
	},
	
	/*
	 * Caches guild details objects for the current account if haven't already.
	 * @param array pGuilds containing guild IDs.
	 * @param function pCallback to execute after.
	 */
	initializeGuilds: function(pCallback)
	{
		var guildids = A.Data.Account.guilds;
		if (guildids === undefined || guildids === null || guildids.length <= 0)
		{
			pCallback();
			return;
		}
		Q.getGuilds(guildids, function()
		{
			pCallback();
		});
	},
	
	/*
	 * Downloads guild bank data for all of the account's guilds, if permitting.
	 * @param function pCallback to execute after.
	 * @pre Account guilds data were downloaded.
	 */
	initializeVault: function(pCallback)
	{
		A.initializeGuilds(function()
		{
			U.fetchPattern(A.getURL(A.URL.GuildStash), A.Data.Account.guilds, {aCallback: function(pData, pLength)
			{
				if (pLength)
				{
					A.Data.Vaults = pData;
				}
				else
				{
					A.Data.Vaults = null;
					I.print("Unable to access any guild bank for this account.<br />Requires API key from account of guild leader.");
				}
				pCallback(A.Data.Vaults);
			}});
		});
	},
	
	/*
	 * Iterates through an "inventory" style array whose objects may have these properties:
	 * id, upgrades, infusions, skin. Then return their item and skin IDs for prefetching.
	 * @param array pArray
	 * @param function pIterator
	 * @returns object
	 */
	iterateInventory: function(pArray, pIterator)
	{
		var slot, upgs, infs, skin;
		var itemids = [];
		var skins = [];
		for (var i in pArray)
		{
			slot = pArray[i];
			if (slot)
			{
				itemids.push(slot.id); // The ID of the item itself
				upgs = slot.upgrades;
				infs = slot.infusions;
				skin = slot.skin;
				if (upgs && upgs.length)
				{
					upgs.forEach(function(iUpg)
					{
						itemids.push(iUpg);
					});
				}
				if (infs && infs.length)
				{
					infs.forEach(function(iInf)
					{
						itemids.push(iInf);
					});
				}
				if (skin)
				{
					skins.push(skin);
				}
				if (pIterator)
				{
					pIterator(slot);
				}
			}
		}
		return {
			oItemIDs: itemids,
			oSkinIDs: skins
		};
	},
	
	/*
	 * Initializes the associative array accessed by item IDs that holds the
	 * count of each items, based on the account's bank, inventory, shared slots,
	 * equipment, and materials. Also initializes the tally and gem store upgrades
	 * objects for use in auditing.
	 * @param function pCallback to execute after.
	 * @param boolean pWantVault whether to include guild banks too.
	 * @pre Characters data were downloaded by the Characters page.
	 */
	initializePossessions: function(pCallback, pWantVault)
	{
		// Continue with callback if already initialized
		if ((A.Possessions && !pWantVault) || (A.Possessions && pWantVault && A.Data.Vaults))
		{
			pCallback();
			return;
		}
		A.Possessions = {};
		
		// Adds an item to the possessions database
		var addItem = function(pItemID, pLocation, pCount, pIsBound)
		{
			// Create entry if doesn't exist
			if (A.Possessions[pItemID] === undefined)
			{
				A.Possessions[pItemID] = {
					oCount: 0,
					oAudit: {} // Will contain length 2 arrays: index 0 is unbound found, index 1 is total found
				};
			}
			var auditobj = A.Possessions[pItemID].oAudit;
			// Initializes the audit object in an audit location if doesn't exist, and adds its count
			var updateAuditObj = function(pAuditLocation)
			{
				if (auditobj[pAuditLocation] === undefined)
				{
					auditobj[pAuditLocation] = [0, 0];
				}
				if ( ! pIsBound)
				{
					(auditobj[pAuditLocation])[0] += pCount;
				}
				(auditobj[pAuditLocation])[1] += pCount;
			};
			
			// Update total item found count
			A.Possessions[pItemID].oCount += pCount;
			
			// Assign discrete category counts; the Characters location combines inventory, equipment
			var locationkey = (isNaN(pLocation) === false) ? "Characters" : U.toFirstUpperCase(pLocation);
			updateAuditObj(locationkey);
			// Per character audit entries
			if (isNaN(pLocation) === false)
			{
				updateAuditObj(pLocation);
			}
		};
		
		// Adds a slotted upgrade from an item such as a weapon or armor piece
		var addUpgrades = function(pSlot, pLocation)
		{
			if (pSlot.upgrades)
			{
				pSlot.upgrades.forEach(function(iID)
				{
					addItem(iID, pLocation, 1, true); // Upgrades must be salvaged, so consider it account bound
				});
			}
			if (pSlot.infusions)
			{
				pSlot.infusions.forEach(function(iID) // Infusions can be easily extracted with a coin bought item
				{
					addItem(iID, pLocation, 1);
				});
			}
		};
		
		// Search the account for items
		var compilePossessions = function(pSharedData, pBankData, pMaterialsData, pVaultData)
		{
			// Hold filled and capacity numbers
			A.Tally = {
				Characters: [0, 0],
				Shared: [0, 0],
				Bank: [0, 0],
				Materials: [0, 0],
				Vault: [0, 0]
			};
			var bagsupgobj = A.Currency.AuditUpgrades.BagSlot;
			var bagspurchased = 0;
			var craftsupgobj = A.Currency.AuditUpgrades.CraftingLicense;
			var craftspurchased = 0;
			
			// Compile character possessions
			A.Data.Characters.forEach(function(iChar)
			{
				// Add character's equipped items (equipment) and their slotted upgrades or infusions
				if (iChar.equipment)
				{
					iChar.equipment.forEach(function(iSlot)
					{
						addItem(iSlot.id, iChar.oCharIndex, 1, true);
						addUpgrades(iSlot, iChar.oCharIndex);
					});
				}
				// Add character's inventories
				if (iChar.bags)
				{
					bagspurchased += iChar.bags.length - A.Currency.AuditUpgrades.BagSlot.starting;
					iChar.bags.forEach(function(iBag)
					{
						if (iBag)
						{
							A.Tally.Characters[1] += iBag.size;
							addItem(iBag.id, iChar.oCharIndex, 1); // Add the bag itself which is an item
							iBag.inventory.forEach(function(iSlot)
							{
								if (iSlot)
								{
									A.Tally.Characters[0] += 1;
									addItem(iSlot.id, iChar.oCharIndex, iSlot.count, iSlot.binding);
									addUpgrades(iSlot, iChar.oCharIndex);
								}
							});
						}
					});
				}
				// Count the highest number of active crafting disciplines
				if (iChar.crafting)
				{
					var activecrafts = 0;
					iChar.crafting.forEach(function(iCraft)
					{
						if (iCraft.active)
						{
							activecrafts++;
						}
					});
					if (activecrafts > (craftspurchased + craftsupgobj.starting))
					{
						craftspurchased++;
					}
				}
			});
			A.assignAccountUpgrades("CraftingLicense", craftspurchased + craftsupgobj.starting);
			// Bag slot upgrades are counted manually instead of by the macro function
			bagsupgobj.purchased = bagspurchased;
			bagsupgobj.totalgem = bagsupgobj.gem * bagspurchased;
			bagsupgobj.totalowned = (A.Data.Characters.length * bagsupgobj.starting) + bagspurchased;
			
			// Add shared inventory slot items
			A.assignAccountUpgrades("SharedSlot", pSharedData.length);
			A.Tally.Shared[1] = pSharedData.length;
			pSharedData.forEach(function(iSlot)
			{
				if (iSlot)
				{
					A.Tally.Shared[0] += 1;
					addItem(iSlot.id, "Shared", iSlot.count, iSlot.binding);
				}
			});
			
			// Add bank contents
			A.assignAccountUpgrades("BankTab", Math.floor(pBankData.length / A.Metadata.Bank.NumSlotsPerTab));
			A.Tally.Bank[1] = pBankData.length;
			pBankData.forEach(function(iSlot)
			{
				if (iSlot)
				{
					A.Tally.Bank[0] += 1;
					addItem(iSlot.id, "Bank", iSlot.count, iSlot.binding);
					addUpgrades(iSlot, "Bank");
				}
			});
			
			// Add materials deposits
			var materialcountlargest = 0;
			A.Tally.Materials[1] = pMaterialsData.length;
			pMaterialsData.forEach(function(iSlot)
			{
				if (iSlot && iSlot.count > 0)
				{
					A.Tally.Materials[0] += 1;
					addItem(iSlot.id, "Materials", iSlot.count);
					if (iSlot.count > materialcountlargest)
					{
						materialcountlargest = iSlot.count;
					}
				}
			});
			A.assignAccountUpgrades("StorageExpander", Math.ceil(materialcountlargest / Q.GameLimit.StackSize));
			
			// Add vault contents for all guilds if requested and permitted
			if (pVaultData)
			{
				for (var i in pVaultData)
				{
					pVaultData[i].forEach(function(iSubvault)
					{
						iSubvault.inventory.forEach(function(iSlot)
						{
							if (iSlot)
							{
								A.Tally.Vault[0] += 1;
								addItem(iSlot.id, "Vault", iSlot.count);
							}
						});
						A.Tally.Vault[1] += iSubvault.size;
					});
				}
			}
			
			// Execute callback after finishing compilation
			pCallback();
		};
		
		// Download additional API data containing the account's items
		$.getJSON(A.getURL(A.URL.Shared), function(pSharedData)
		{
			$.getJSON(A.getURL(A.URL.Bank), function(pBankData)
			{
				$.getJSON(A.getURL(A.URL.Materials), function(pMaterialsData)
				{
					if (pWantVault)
					{
						A.initializeVault(function(pVaultData)
						{
							compilePossessions(pSharedData, pBankData, pMaterialsData, pVaultData);
						});
					}
					else
					{
						compilePossessions(pSharedData, pBankData, pMaterialsData);
					}
				});
			});
		}).fail(function(pRequest, pStatus)
		{
			A.printError(A.PermissionEnum.Inventories, pStatus);
		});
	},
	
	/*
	 * Gets a list of locations an item of a type is located in the account.
	 * @param object pLocations from possessions object.
	 * @returns string.
	 */
	formatPossessionLocations: function(pPossessionEntry)
	{
		var str = "";
		var locations = pPossessionEntry.oAudit;
		for (var i in locations)
		{
			// Show the character names rather than the combined characters location, ignore empty locations
			if (i !== "Characters" && ((locations[i])[0] > 0 || (locations[i])[1] > 0))
			{
				if (isNaN(i))
				{
					str += D.getWordCapital(i.toLowerCase());
				}
				else
				{
					if (A.Data.Characters[i])
					{
						str += A.Data.Characters[i].oCharName;
					}
				}
				str += " (" + (locations[i])[1] + ")" + ", "; // Write the count next to the location name
			}
		}
		str = str.substring(0, str.length - 2); // Trim the trailing comma
		return str;
	},
	getFoundString: function(pPossessionEntry)
	{
		return "<var class='itmColor_reminder'>" + D.getPhrase("found in", U.CaseEnum.Sentence)
			+ ": " + A.formatPossessionLocations(pPossessionEntry) + "</var>";
	},
	
	/*
	 * Iterates a function over an unlockables record.
	 * @param object pRecord.
	 * @param function pIteration with parameters entry and entry's category name.
	 */
	iterateRecord: function(pRecord, pIteration)
	{
		var catarr, entry;
		for (var i in pRecord)
		{
			catarr = pRecord[i];
			for (var ii = 0; ii < catarr.length; ii++)
			{
				entry = catarr[ii];
				pIteration(entry, i);
			}
		}
	},
	flattenRecord: function(pRecord)
	{
		var newrec = {}; // Returns a record as a single associative array instead of one 
		A.iterateRecord(pRecord, function(pEntry)
		{
			newrec[pEntry.i] = pEntry;
		});
		return newrec;
	},
	
	/*
	 * An account's unlocks API may return an array of unlock IDs (if an ID is in
	 * the array, that unlockable is unlocked), or an array of objects with more
	 * information. This function flattens to the IDs format if it is objects.
	 * @param array pUnlocks from any account unlock API.
	 * @returns array of integers.
	 */
	flattenUnlocks: function(pUnlocks)
	{
		var arr = [];
		if (pUnlocks.length && pUnlocks[0].id !== undefined)
		{
			pUnlocks.forEach(function(iUnlock)
			{
				if (iUnlock.id && iUnlock.permanent !== false)
				{
					arr.push(iUnlock.id);
				}
			});
			pUnlocks = arr;
			return arr;
		}
		return pUnlocks;
	},
	
	/*
	 * Loads the charts script and initialize it if haven't already.
	 * @param function pCallback
	 */
	initializeCharts: function(pCallback)
	{
		U.getScript(U.URL_API.Charts, function()
		{
			if (A.isChartsInitialized === false)
			{
				Highcharts.setOptions(
				{
					global: {useUTC: false}
				});
				A.isChartsInitialized = true;
			}
			pCallback();
		});
	},
	getChartsTimeFormat: function()
	{
		if (O.Options.bol_use24Hour)
		{
			return {
				second: "%H:%M:%S",
				minute: "%H:%M",
				hour: "%H:%M"
			};
		}
		return {
			second: "%l:%M:%S %p",
			minute: "%l:%M %p",
			hour: "%l:%M %p"
		};
	},
	
	/*
	 * Macro function to be used in chart tooltip property.
	 * @param object pPoints
	 * @param object pColors to colorize the lines and format values.
	 * @returns string html.
	 */
	getChartsCurrencyFormat: function(pPoints, pColors)
	{
		var html = (T.formatWeektime(pPoints[0].x, true)) + "<table>";
		for (var i = 0; i < pPoints.length; i++)
		{
			var ipoint = pPoints[i];
			var series = ipoint.series;
			var name = series.name;
			var currencystr = "";
			if (pColors && pColors[name].currency)
			{
				switch (pColors[name].currency)
				{
					case "gem": { currencystr = E.formatGemString(ipoint.y, true); } break;
					case "karma": { currencystr = E.formatKarmaString(ipoint.y, true); } break;
				}
			}
			else
			{
				currencystr = E.formatCoinStringColored(ipoint.y); 
			}
			
			html += "<tr>"
				+ "<td style='color:" + series.color + "'>" + D.getWordCapital(name.toLowerCase()) + "</td>"
				+ "<td><b>" + currencystr + "</b></td>"
			+ "</tr>";
		};
		html += "</table>";
		return html;
	},
	
	/*
	 * Generates the account audit subsection into the Characters page.
	 * The inner functions are executed from bottom to top.
	 */
	generateAudit: function()
	{
		var sampleconversionamount = 100;
		var button = $("#audExecute");
		var buttonalt = $("#audExecuteAlternate").hide();
		I.suspendElement(button);
		var container = $("#accAudit").empty();
		var auditpayments = A.Currency.AuditPayments; // Auditable payment objects
		var cachedprices; // Will contain payment or TP prices, accessible by item ID
		var untradeabledb;
		E.Paylist = {}; // Holds payment object or processed TP price, items whose ID is not in this will have no value
		var priceids = {}; // Tradeable item IDs to fetch, an associative array so no duplicate
		var ascendeddata, ascendedheader, ingredients, ascendedingr, compositeingr, auditmetadata;
		var currentbuysdata, currentsellsdata;
		var categoriesview = {}; // Holds categories which holds item IDs and totaled payments of possession or unlocks, for the bank view
		var recordsdata = {
			Ascended: {},
			Catalog: {},
			Skins: {},
			Outfits: {},
			Gliders: {},
			Dyes: {},
			Minis: {},
			Carriers: {},
			Champions: {},
			Finishers: {},
			Nodes: {},
			Recipes: {}
		};
		var unlocksdata = { // Account's unlocked IDs retrieved from API
			Skins: {},
			Outfits: {},
			Gliders: {},
			Dyes: {},
			Minis: {},
			Carriers: {},
			Champions: {},
			Finishers: {},
			Nodes: {}
		};
		
		var finalizeAutoAudit = function()
		{
			// If ran from an embed then assume this was automated, so close the webpage after the audit finishes
			if (I.isProgramEmbedded && U.Args[(U.KeyEnum.AutoAudit)])
			{
				window.location.href = "about:blank";
			}
		};
		
		// Resets the auditing process in case it failed to let the user restart it
		var dealError = function()
		{
			I.suspendElement(button, false);
			buttonalt.show();
			finalizeAutoAudit();
		};
		
		// Creates a standard object of payments to be displayed for an audit category
		var createAuditPayments = function(pInitialAmount)
		{
			var paymentsobj = {};
			var amount = (pInitialAmount === undefined) ? 0 : pInitialAmount;
			for (var i in auditpayments)
			{
				paymentsobj[i] = amount;
			}
			return paymentsobj;
		};
		var initializeAuditCategories = function()
		{
			for (var i in A.Currency.AuditCategories)
			{
				A.Currency.AuditCategories[i] = createAuditPayments();
				A.Currency.AuditHistory[i] = null; // Also initializes audit history
			}
			A.Currency.AuditCategoriesCharacters = {};
		};
		
		// Adds a payment or price object to an audit category
		var addPaymentToCategory = function(pCategory, pPayment, pCount, pIsBound, pItemID)
		{
			var auditcat = A.Currency.AuditCategories[pCategory];
			if (isNaN(pCategory) === false) // If auditing an individual character
			{
				if (A.Currency.AuditCategoriesCharacters[pCategory] === undefined)
				{
					A.Currency.AuditCategoriesCharacters[pCategory] = createAuditPayments();
				}
				auditcat = A.Currency.AuditCategoriesCharacters[pCategory];
			}
			var count = (pCount === undefined) ? 1 : pCount;
			if (E.isPriceObject(pPayment))
			{
				if (pIsBound === true)
				{
					// Bound items cannot be liquidated for cash, so only have appraised values
					auditcat.coin_appraisedbuy += pPayment.oPriceBuy * count;
					auditcat.coin_appraisedsell += pPayment.oPriceSell * count;
				}
				else
				{
					auditcat.coin_liquidbuy += pPayment.oPriceBuyTaxed * count;
					auditcat.coin_liquidsell += pPayment.oPriceSellTaxed * count;
					auditcat.coin_appraisedbuy += pPayment.oPriceBuy * count;
					auditcat.coin_appraisedsell += pPayment.oPriceSell * count;
				}
			}
			else
			{
				for (var i in pPayment)
				{
					if (auditcat[i] !== undefined && pPayment[i] > 0)
					{
						auditcat[i] += pPayment[i] * count;
					}
				}
			}
			// Update the category view object that totals the items and appraised sell coin of that category
			if (pItemID)
			{
				var itemid = parseInt(pItemID);
				if (categoriesview[pCategory] === undefined)
				{
					categoriesview[pCategory] = {};
				}
				var catview = categoriesview[pCategory];
				if (catview[itemid] === undefined)
				{
					catview[itemid] = [0, 0];
					if (E.isPriceObject(pPayment))
					{
						(catview[itemid])[1] = convertCurrencyToCoin("coin_appraisedsell", pPayment.oPriceSell);
					}
					else
					{
						for (var i in pPayment)
						{
							if (auditcat[i] !== undefined && pPayment[i] > 0)
							{
								(catview[itemid])[1] = convertCurrencyToCoin(i, pPayment[i]);
							}
						}
					}
				}
				// Update the count of the item in that category
				(catview[itemid])[0] += count;
			}
		};
		
		// Evaluates the wallet audit category
		var auditWallet = function()
		{
			var quantity, paymentobj;
			for (var i in A.Data.Wallet)
			{
				quantity = A.Data.Wallet[i];
				if (i === "1") // If the currency is coin
				{
					addPaymentToCategory("Wallet", E.createPricePlain(quantity), 1);
				}
				else if (A.Currency.AuditWallet[i]) // Audit applicable currencies
				{
					paymentobj = {};
					paymentobj[(A.Currency.AuditWallet[i]).payment] = quantity;
					addPaymentToCategory("Wallet", paymentobj, 1, true);
				}
			}
		};
		
		// Evaluates the bank, characters, and materials audit categories
		var auditPossessions = function()
		{
			var legendaryinclusion = auditmetadata.LegendaryInclusion;
			var payment, auditcat, auditobj, count;
			A.Tally.Legendary = {
				count: 0,
				price: E.createPrice()
			};
			for (var i in A.Possessions)
			{
				payment = E.Paylist[i];
				if (payment)
				{
					for (var ii in A.Possessions[i].oAudit)
					{
						auditcat = A.Currency.AuditCategories[ii];
						auditobj = A.Possessions[i].oAudit[ii];
						if (isNaN(ii) === false) // If auditing an individual character
						{
							if (A.Currency.AuditCategoriesCharacters[ii] === undefined)
							{
								A.Currency.AuditCategoriesCharacters[ii] = createAuditPayments();
							}
							auditcat = A.Currency.AuditCategoriesCharacters[ii];
						}
						if (auditcat) // Add payment if it is of a valid audit category or is a character audit
						{
							if (E.isPriceObject(payment))
							{
								/*
								 * Index [0] is the count of unbound (tradeable, liquid and appraised).
								 * Index [1] is the count of all items (mixed).
								 * [1] - [0] = the count of bound items (untradeable, appraised only).
								 */
								if (auditobj[1] === auditobj[0]) // If there is no bound item
								{
									addPaymentToCategory(ii, payment, auditobj[1], false, i);
								}
								else // If there at least one bound item, then add bound and unbound items separately
								{
									addPaymentToCategory(ii, payment, auditobj[0], false, i);
									addPaymentToCategory(ii, payment, (auditobj[1] - auditobj[0]), true, i);
								}
							}
							else
							{
								addPaymentToCategory(ii, payment, auditobj[1], false, i);
							}
						}
					}
					// Tally the legendary gear possessed
					if (legendaryinclusion[i])
					{
						count = A.Possessions[i].oCount;
						A.Tally.Legendary.count += count;
						A.Tally.Legendary.price = E.addPrice(A.Tally.Legendary.price, E.recountPrice(payment, count));
					}
				}
			}
		};
		
		// Evaluates an unlocks audit category
		var auditUnlocks = function(pName, pWantPossessions)
		{
			var payment;
			var unlockedids; // An associative array of unlock IDs
			var itemkey = "i";
			// Special case for recipes because the unlocks is stored within the characters data instead of an API flat array
			if (pName === "Recipes")
			{
				// Initialize the recipes unlocks array
				unlocksdata.Recipes = [];
				unlockedids = {};
				itemkey = "b"; // The item ID of tradeable recipes is stored in the recipes record under this object key
				A.Data.Characters.forEach(function(iChar)
				{
					if (iChar.recipes)
					{
						// Compile recipe unlocks by combining each characters' learned recipes
						for (var i = 0; i < iChar.recipes.length; i++)
						{
							if (unlockedids[(iChar.recipes[i])] === undefined)
							{
								unlocksdata.Recipes.push(iChar.recipes[i]); // This is for the tally
								unlockedids[(iChar.recipes[i])] = true;
							}
						}
					}
				});
				// Add the bound recipe payments
				var recipesdata = U.getRecordData("recipes");
				var recipepayment;
				A.iterateRecord(recipesdata, function(pEntry)
				{
					if (unlockedids[pEntry.u] && unlockedids[pEntry.u] !== 1 && pEntry.p)
					{
						unlockedids[pEntry.u] = 1; // Only audit the recipe once
						for (var ii in pEntry.p)
						{
							payment = {};
							payment[ii] = pEntry.p[ii];
							recipepayment = ((ii === "coin") ? E.createPriceBound(pEntry.p[ii]) : payment);
							addPaymentToCategory(pName, recipepayment, 1, true, pEntry.s);
						}
					}
				});
			}
			
			// Audit by adding the payment value once for each unlock (which has an associated item that has a payment)
			unlocksdata[pName] = A.flattenUnlocks(unlocksdata[pName]);
			A.Tally[pName] = [(unlocksdata[pName]).length, 0];
			if (unlockedids === undefined)
			{
				unlockedids = U.getExistAssoc(unlocksdata[pName]);
				// Special case for skins, nullify some from auditing
				if (pName === "Skins")
				{
					for (var i in auditmetadata.SkinsExclusion)
					{
						unlockedids[i] = false;
					}
				}
				// Consider the backpack skin and ignore the glider, for those from gem store combo
				if (pName === "Gliders")
				{
					var gliderscombo = GW2T_GLIDERS_DATA["Combo"];
					for (var i in gliderscombo)
					{
						unlockedids[(gliderscombo[i].u)] = false;
					}
				}
			}
			var associtems = {};
			var associtemid;
			A.iterateRecord(recordsdata[pName], function(pEntry)
			{
				(A.Tally[pName])[1] += 1;
				associtemid = pEntry[itemkey];
				if (associtemid)
				{
					payment = E.Paylist[associtemid];
					/*
					 * Audit if payment exists, the unlock is unlocked, and the associated
					 * item has not been audited for this record and is not in possession.
					 */
					if (payment
						&& unlockedids[pEntry.u] && unlockedids[pEntry.u] !== 1
						&& associtems[associtemid] === undefined
						&& ((pWantPossessions === false && A.Possessions[associtemid] === undefined) || (pWantPossessions !== false)))
					{
						unlockedids[pEntry.u] = 1; // Only audit the unlock once
						addPaymentToCategory(pName, payment, 1, true, associtemid);
						associtems[pEntry.i] = true;
					}
				}
			});
		};
		
		// Evaluates transactions of coin in buy orders or items in sell listings
		var auditTransactions = function()
		{
			var payment;
			if (currentbuysdata)
			{
				A.Tally.Buying = [currentbuysdata.length, currentbuysdata.length];
				currentbuysdata.forEach(function(iTransaction)
				{
					addPaymentToCategory("Buying", E.createPricePlain(iTransaction.price), iTransaction.quantity, false, iTransaction.item_id);
				});
			}
			if (currentsellsdata)
			{
				A.Tally.Selling = [currentsellsdata.length, currentsellsdata.length];
				currentsellsdata.forEach(function(iTransaction)
				{
					payment = E.Paylist[iTransaction.item_id];
					if (payment)
					{
						addPaymentToCategory("Selling", payment, iTransaction.quantity, false, iTransaction.item_id);
					}
				});
			}
		};
		
		// Adds two audit categories' payments and returns a sum audit category
		var sumAuditCategories = function(pCategoryA, pCategoryB)
		{
			var auditcat = {};
			for (var i in pCategoryA)
			{
				auditcat[i] = pCategoryA[i] + pCategoryB[i];
			}
			return auditcat;
		};
		
		// Appraises a non-coin currency into a coin amount; the exchange ratios must have been initialized
		var convertCurrencyToCoin = function(pCurrencyName, pAmount, pPriceType)
		{
			var name = pCurrencyName;
			var pricetype = pPriceType || "oPriceSell";
			if (name.indexOf("coin") !== -1) // Coin cases
			{
				return pAmount;
			}
			if (name === "gem") // Gem case
			{
				return E.convertGemToCoin(pAmount);
			}
			
			var conversion = auditpayments[name].conversion;
			if (conversion === 0) // Unconvertible case
			{
				return 0;
			}
			if (isNaN(conversion) === false) // Normal case
			{
				return pAmount * conversion;
			}
			if (Array.isArray(conversion)) // Item dependent case
			{
				var barteramount = conversion[0];
				var barteritem = conversion[1];
				var payment = E.Paylist[barteritem];
				if (payment && payment[pricetype])
				{
					return Math.floor(pAmount * (payment[pricetype] / barteramount));
				}
			}
			return 0;
		};
		
		// Creates an audit page separator and title
		var createTitle = function(pTitle)
		{
			return $("<div class='audTitleContainer'><aside class='audTitle'>" + pTitle + "</aside></div>");
		};
		
		// Creates an audit presentation table
		var createTable = function(pTitle)
		{
			var table = $("<div class='audTable'></div>").appendTo(container);
			createTitle(pTitle).insertBefore(table);
			return table;
		};
		
		// Inserts a headered but empty column into a table
		var insertColumn = function(pTable, pHeader, pCategory)
		{
			var tally = A.Tally[pCategory], tallystr = "";
			if (tally)
			{
				tallystr = "<span class='audTableTally'>" + tally[0] + " / " + tally[1]
					+ " (" + U.convertRatioToPercent(tally[0] / tally[1]) + ")</span>";
			}
			var auditcolumn = $("<div class='audTableColumn'></div>").appendTo(pTable);
			var columnheader = $("<div class='audTableCell audTableHeaderHorizontal'>" + pHeader + tallystr + "</div>").appendTo(auditcolumn);
			// Bind category view function on category header
			if (pCategory && pCategory !== "Wallet")
			{
				columnheader.click(function()
				{
					createCategoryView(pCategory);
				}).addClass("audTableHeaderView curZoom").attr("id", "audViewHeader_" + pCategory);
			}
			return auditcolumn;
		};
		
		// Inserts a leading column of currency names into a table
		var insertTableCurrencyHeader = function(pTable, pWantHidden)
		{
			// Write the first column which acts as headers for the rows of currencies
			var paymentobj, currency, headerwords;
			var currencyheaders = $("<div class='audTableHeaderVertical audTableColumn'></div>").appendTo(pTable);
			for (var i in auditpayments)
			{
				if (!pWantHidden && auditpayments[i].ishidden)
				{
					continue;
				}
				paymentobj = auditpayments[i];
				currency = A.Currency.AuditWallet[paymentobj.id];
				headerwords = (paymentobj.id === 1) ? D.getPhraseOriginal(paymentobj.header) : D.getObjectName(currency);
				currencyheaders.append("<div class='audTableCell'>"
					+ headerwords + "&nbsp;<ins class='acc_wallet acc_wallet_" + paymentobj.id + "'></ins></div>");
			}
			// Padding cell at the top left corner of the table
			currencyheaders.prepend("<div class='audTableCell audTableHeaderCorner'></div>");
		};
		
		// Creates an audit category containing the max amount found from multiple categories, for creating mini bar charts
		var createCurrencyMaxes = function(pCategories)
		{
			var ithcat;
			var maxcat = createAuditPayments(Number.NEGATIVE_INFINITY);
			for (var i in pCategories)
			{
				ithcat = pCategories[i];
				for (var ii in ithcat)
				{
					if (ithcat[ii] > maxcat[ii])
					{
						maxcat[ii] = ithcat[ii];
					}
				}
			}
			return maxcat;
		};
		
		// Fills a table column with currencies
		var fillCurrencyColumn = function(pColumn, pCategory, pIsConversion, pMaxCategory, pWantHidden)
		{
			var amount, paymentkey, barstr, prefix;
			for (var i in pCategory)
			{
				if (!pWantHidden && auditpayments[i].ishidden)
				{
					continue;
				}
				amount = pCategory[i];
				paymentkey = (i.indexOf("coin") !== -1 || pIsConversion) ? "coin" : i;
				barstr = "";
				if (pMaxCategory)
				{
					barstr = "<samp class='audTableCellBar'>"
						+ "<s style='background:url(img/background/bargraph.png), linear-gradient(to right, black 0%, " + auditpayments[i].color + " 100%);"
						+ "width:" + ((pMaxCategory[i] > 0) ? ((amount / pMaxCategory[i]) * T.cPERCENT_100) : 0) + "%'></s>"
					+ "</samp>";
				}
				prefix = (pIsConversion) ? ("<span class='cssLeft'>" + ((auditpayments[i].isappraised) ? I.Symbol.Approx : I.Symbol.ArrowRight) + "</span>") : "";
				pColumn.append("<div class='audTableCell'>" + prefix + E.formatPayment(paymentkey, amount) + barstr + "</div>");
			}
		};
		// Same as original function but shows the hidden payment rows
		var fillCurrencyColumnFull = function(pColumn, pCategory, pIsConversion, pMaxCategory)
		{
			fillCurrencyColumn(pColumn, pCategory, pIsConversion, pMaxCategory, true);
		};
		
		// Fills a table column with the rows' currency converted to coin
		var fillConversionColumn = function(pColumn, pCategory)
		{
			var convertedpayments = createAuditPayments();
			for (var i in pCategory)
			{
				convertedpayments[i] = convertCurrencyToCoin(i, pCategory[i]);
			}
			fillCurrencyColumnFull(pColumn, convertedpayments, true);
		};
		
		// Generates a "bank" of audited items in a category with their payment preconverted to appraised sell coin
		var createCategoryView = function(pCategory)
		{
			var audview = $("#audView").empty();
			var viewcontainer = B.createBank(audview);
			var viewbank = B.getTabsContainer(viewcontainer);
			var tabtitle = (isNaN(pCategory) === false) ? A.Data.Characters[pCategory].oCharPreface : D.getWordCapital(pCategory);
			var viewtab = B.createBankTab(viewbank, {aTitle: tabtitle});
			var viewslotscontainer = B.getSlotsContainer(viewtab);
			var itemids = [];
			for (var i in categoriesview[pCategory])
			{
				itemids.push(i);
			}
			
			// Fill the "bank" with item slots
			Q.getPricedItems(itemids, function()
			{
				for (var i in categoriesview[pCategory])
				{
					(function(iSlot, iItemID, iView)
					{
						Q.getItem(iItemID, function(iItem)
						{
							B.styleBankSlot(iSlot, {aItem: iItem, aPrice: iView[1], aSlotMeta: {count: iView[0]}});
							var payment = E.Paylist[iItemID];
							if (payment && E.isPriceObject(payment) === false)
							{
								B.updateSlotPayment(iSlot, payment, iView[0], "bnkSlotPriceSell");
							}
						});
					})(B.createBankSlot(viewslotscontainer), i, (categoriesview[pCategory])[i]);
				}
				B.tallyBank(viewcontainer);
				B.createBankMenu(viewbank, {aWantClear: true, aReloadElement: $("#audViewHeader_" + pCategory)});
				I.scrollToElement("#audViewTitle", {aSpeed: "fast"});
			});
		};
		
		// Reformats a history object for chart display
		var formatAuditHistory = function(pHistory)
		{
			var lines = [], histcat;
			var histstamp = pHistory["Timestamps"];
			for (var i in pHistory)
			{
				if (i !== "Timestamps")
				{
					var ithline = {
						name: i,
						data: [],
						color: A.Currency.AuditColor[i].color
					};
					histcat = pHistory[i];
					for (var ii = 0; ii < histcat.length; ii++)
					{
						ithline.data.push([
							new Date(histstamp[ii]).getTime(),
							histcat[ii]
						]);
					}
					lines.push(ithline);
				}
			}
			return lines;
		};
		
		/*
		 * Writes HTML to display the audit results.
		 */
		var generateResults = function()
		{
			// Clear the console of load messages
			I.clear();
			var tablecategory = createTable(D.getPhraseOriginal("Audit Categories"));
			var tablesum = createTable(D.getPhraseOriginal("Sum &amp; Conversion"));
			var tablechar = createTable(D.getPhraseOriginal("Audit Characters"));
			
			// TABLE: Audit categories
			insertTableCurrencyHeader(tablecategory);
			// Write a column for each audit category
			var auditcolumn;
			var auditcats = A.Currency.AuditCategories;
			var auditcatsmax = createCurrencyMaxes(auditcats);
			for (var i in auditcats)
			{
				if ((i === "Vault" && A.Data.Vaults === null)
					|| (i === "Buying" && currentbuysdata === undefined)
					|| (i === "Selling" && currentsellsdata === undefined))
				{
					// Don't show the transaction columns if did not opt to audit them
					continue;
				}
				auditcolumn = insertColumn(tablecategory, D.getWordCapital(i.toLowerCase()), i);
				fillCurrencyColumn(auditcolumn, auditcats[i], false, auditcatsmax);
			}
			
			// TABLE: Sum and conversions
			insertTableCurrencyHeader(tablesum, true);
			// Sum columns
			var sumcolumn = insertColumn(tablesum, D.getPhraseOriginal("Account Sum"));
			var convertedsumcolumn = insertColumn(tablesum, D.getPhraseOriginal("Account Sum"));
			var sumcat = createAuditPayments();
			for (var i in auditcats)
			{
				// Add all audit categories' payments into one "sum" category
				sumcat = sumAuditCategories(sumcat, auditcats[i]);
			}
			fillCurrencyColumnFull(sumcolumn, sumcat);
			fillConversionColumn(convertedsumcolumn, sumcat);
			// Wallet columns
			var walletcat = auditcats["Wallet"];
			var walletcolumn = insertColumn(tablesum, D.getPhraseOriginal("Wallet"));
			var convertedwalletcolumn = insertColumn(tablesum, D.getPhraseOriginal("Wallet"));
			fillCurrencyColumnFull(walletcolumn, walletcat);
			fillConversionColumn(convertedwalletcolumn, walletcat);
			// Sample columns
			var samplecat = createAuditPayments(sampleconversionamount);
			var samplecolumn = insertColumn(tablesum, D.getPhraseOriginal("Conversion"));
			var convertedsamplecolumn = insertColumn(tablesum, D.getPhraseOriginal("Conversion"));
			fillCurrencyColumnFull(samplecolumn, samplecat);
			fillConversionColumn(convertedsamplecolumn, samplecat);
			
			// TABLE: Characters
			insertTableCurrencyHeader(tablechar);
			var charcolumn;
			var charcats = A.Currency.AuditCategoriesCharacters;
			var charcatsmax = createCurrencyMaxes(charcats);
			for (var i in charcats)
			{
				charcolumn = insertColumn(tablechar, A.Data.Characters[i].oCharIcons, i);
				fillCurrencyColumn(charcolumn, charcats[i], false, charcatsmax);
			}
			tablechar.addClass("audTableHorizontal");
			I.bindScrollbar(tablechar, true);
			I.qTip.init(tablechar.find(".chrPreface"));
			
			// VIEW
			createTitle("View Audit").attr("id", "audViewTitle").appendTo(container);
			$("<div id='audView'></div>").appendTo(container);
			
			// GEM STORE UPGRADES
			var summaryupgrades = $("<div id='audUpgrades'></div>").appendTo(container);
			var upggems = A.getAccountUpgradesGem();
			var upgcontainer = B.createBank(summaryupgrades);
			var upgbank = B.getTabsContainer(upgcontainer);
			var upgtab = B.createBankTab(upgbank, {aTitle: D.getPhraseTitle("Account Upgrades")});
			var upgslotscontainer = B.getSlotsContainer(upgtab);
			// Fill the "bank" with pseudo item slots
			for (var i in A.Currency.AuditUpgrades)
			{
				(function(iSlot, iUpg)
				{
					Q.getItem(iUpg.id, function(iItem)
					{
						B.styleBankSlot(iSlot, {aItem: iItem, aGem: iUpg.gem, aSlotMeta: {count: iUpg.purchased}});
					});
				})(B.createBankSlot(upgslotscontainer), A.Currency.AuditUpgrades[i]);
			}
			
			// SUMMARY
			E.getCoinFromGem(walletcat["gem"], function(pCoin)
			{
				// Appraised sell plus all non-coin payments converted to coin
				var totalappraisedbuy = sumcat["coin_appraisedbuy"];
				var totalappraisedsell = sumcat["coin_appraisedsell"];
				var totalappraisedbuynogems = sumcat["coin_appraisedbuy"];
				var totalappraisedsellnogems = sumcat["coin_appraisedsell"];
				// Liquid sell plus gem converted to coin plus all non-coin payments converted to coin
				var totalliquidbuy = sumcat["coin_liquidbuy"] + pCoin;
				var totalliquidsell = sumcat["coin_liquidsell"] + pCoin;
				var totalliquidbuynogems = sumcat["coin_liquidbuy"];
				var totalliquidsellnogems = sumcat["coin_liquidsell"];
				for (var i in auditpayments)
				{
					if (i.indexOf("coin") === -1)
					{
						totalappraisedbuy += convertCurrencyToCoin(i, sumcat[i], "oPriceBuy");
						totalappraisedsell += convertCurrencyToCoin(i, sumcat[i], "oPriceSell");
						if (i.indexOf("gem") === -1)
						{
							totalappraisedbuynogems += convertCurrencyToCoin(i, sumcat[i], "oPriceBuy");
							totalappraisedsellnogems += convertCurrencyToCoin(i, sumcat[i], "oPriceSell");
						}
					}
					if (auditpayments[i].isliquid)
					{
						totalliquidbuy += convertCurrencyToCoin(i, walletcat[i], "oPriceBuyTaxed");
						totalliquidsell += convertCurrencyToCoin(i, walletcat[i], "oPriceSellTaxed");
					}
				}
				// Add gems spent from account upgrades to appraisal
				var sumgems = sumcat["gem"];
				var totalgems = sumgems + upggems;
				var upggemstocoin = convertCurrencyToCoin("gem", upggems);
				totalappraisedbuy += upggemstocoin;
				totalappraisedsell += upggemstocoin;
				
				// For each audit category, convert their payments to coin and remember their sum
				var convertcat = {};
				for (var i in auditcats)
				{
					convertcat[i] = 0;
					for (var ii in auditcats[i])
					{
						// The desired coin payment is "coin_appraisedsell", so avoid these duplicates
						if (ii !== "coin_liquidbuy"
							&& ii !== "coin_liquidsell"
							&& ii !== "coin_appraisedbuy")
						{
							convertcat[i] += convertCurrencyToCoin(ii, (auditcats[i])[ii], "oPriceSell");
						}
					}
				}
				
				var summarycontainer = $("<div id='audSummaryContainer'></div>").prependTo(container);
				var summary = $("<div id='audSummary'></div>").appendTo(summarycontainer).hide();
				var historycontainer = $("<div id='audHistoryContainer'></div>").appendTo(summarycontainer).hide();
				var historychart = $("<div id='audHistory'></div>").appendTo(historycontainer);
				summary.append("<div id='audSummaryName'><var id='audAccountName'>" + U.escapeHTML(A.Data.Account.name) + "</var></div>");
				summary.append("<div id='audSummaryValues'>"
					+ "<div class='audSummarySubtitle'>― " + D.getWordCapital("appraised") + " ―</div>"
					+ "<div id='audSummaryAppraised' class='audSummaryCoin curHelp'>" + E.formatCoinString(0, {aWantBig: true}) + "</div>"
					+ "<div class='audSummaryMoney'>" + I.Symbol.Approx + " " + E.formatGemToMoney(totalgems + E.convertCoinToGem(totalappraisedsellnogems)) + "</div>"
					+ "<div class='audSummarySubtitle'>― " + D.getWordCapital("liquid") + " ―</div>"
					+ "<div id='audSummaryLiquid' class='audSummaryCoin curHelp'>" + E.formatCoinString(0, {aWantBig: true}) + "</div>"
					+ "<div class='audSummaryMoney'>" + I.Symbol.Approx + " " + E.formatGemToMoney(walletcat["gem"] + E.convertCoinToGem(totalliquidsellnogems)) + "</div>"
				+ "</div>");
				
				// Tooltip over the coin value to show both and buy and sell
				var appraisedtip = "<dfn>" + D.getPhraseOriginal("Appraised Summary") + ":</dfn> <br />"
					+ D.getPhraseOriginal("Appraised Sell") + ": " + E.formatCoinStringColored(totalappraisedsell) + "<br />"
					+ D.getPhraseOriginal("Appraised Buy") + ": " + E.formatCoinStringColored(totalappraisedbuy) + "<br />"
					+ "<br />"
					+ "<dfn>" + D.getPhraseOriginal("Appraised Summary Exclude Gems") + ":</dfn> <br />"
					+ D.getPhraseOriginal("Appraised Sell") + ": " + E.formatCoinStringColored(totalappraisedsellnogems) + "<br />"
					+ D.getPhraseOriginal("Appraised Buy") + ": " + E.formatCoinStringColored(totalappraisedbuynogems) + "<br />"
					+ "<br />"
					+ "<dfn>" + D.getWordCapital("Info") + ":</dfn> <br />"
					+ D.getPhraseOriginal("Legendary Equipment") + ": " + E.formatCoinStringColored(A.Tally.Legendary.price.oPriceSell)
						+ " (" + A.Tally.Legendary.count + " " + D.getWord("legendary") + ")<br />"
					+ D.getPhraseOriginal("Ascended Equipment") + ": " + E.formatCoinStringColored(A.Tally.Ascended.price.oPriceSell)
						+ " (" + A.Tally.Ascended.armorcount + " " + D.getWord("armor") + ", " + A.Tally.Ascended.weaponcount + " " + D.getWord("weapons") + ")<br />"
					+ D.getPhraseOriginal("Gem Categories Sum") + ": " + E.formatGemToMoney(sumgems)
						+ " " + I.Symbol.ArrowRight + " " +  E.formatGemString(sumgems, true)
						+ " " + I.Symbol.ArrowLeft + " " + E.formatGemToCoin(sumcat["gem"]) + "<br />"
					+ D.getPhraseOriginal("Gem Account Upgrades") + ": " + E.formatGemToMoney(upggems)
						+ " " + I.Symbol.ArrowRight + " " + E.formatGemString(upggems, true)
						+ " " + I.Symbol.ArrowLeft + " " + E.formatCoinStringColored(upggemstocoin) + "<br />";
				var liquidtip = "<dfn>" + D.getPhraseOriginal("Liquid Summary") + ":</dfn> <br />"
					+ D.getPhraseOriginal("Liquid Sell") + ": " + E.formatCoinStringColored(totalliquidsell) + "<br />"
					+ D.getPhraseOriginal("Liquid Buy") + ": " + E.formatCoinStringColored(totalliquidbuy) + "<br />"
					+ "<br />"
					+ "<dfn>" + D.getPhraseOriginal("Liquid Summary Exclude Gems") + ":</dfn> <br />"
					+ D.getPhraseOriginal("Liquid Sell") + ": " + E.formatCoinStringColored(totalliquidsellnogems) + "<br />"
					+ D.getPhraseOriginal("Liquid Buy") + ": " + E.formatCoinStringColored(totalliquidbuynogems) + "<br />";
				var appraisedelm = $("#audSummaryAppraised").click(function(pEvent)
				{
					if (pEvent.which === I.ClickEnum.Left)
					{
						I.print(appraisedtip);
					}
				});
				var liquidelm = $("#audSummaryLiquid").click(function(pEvent)
				{
					if (pEvent.which === I.ClickEnum.Left)
					{
						I.print(liquidtip);
					}
				});
				
				// Show the summary box animated
				var animationspeed = 3000;
				summary.show("slow", function()
				{
					I.animateNumber(totalappraisedsell, function(pValue)
					{
						appraisedelm[0].innerHTML = E.formatCoinString(pValue, {aWantBig: true});
					}, animationspeed, "easeInOutQuart");
					I.animateNumber(totalliquidsell, function(pValue)
					{
						liquidelm[0].innerHTML = E.formatCoinString(pValue, {aWantBig: true});
					}, animationspeed, "easeInOutQuart");
					historycontainer.show();
					// Bind tooltip after the animation
					setTimeout(function()
					{
						I.qTip.init(appraisedelm.attr("title", appraisedtip));
						I.qTip.init(liquidelm.attr("title", liquidtip));
					}, animationspeed);
				});
				
				/*
				 * Load audit history and generate chart.
				 */
				var now = new Date();
				var histbook = O.loadCompressedObject(O.Utilities.AuditHistory.key) || {};
				var accname = A.Data.Account.oAccName;
				if (U.isObject(histbook[accname]) === false)
				{
					histbook[accname] = {};
				}
				var hist = {}; // New object so the variable order follows the template
				// Verify the account's audit history object
				for (var i in A.Currency.AuditHistory)
				{
					var histrow = (histbook[accname])[i];
					hist[i] = (histrow === undefined || Array.isArray(histrow) === false) ? [] : histrow;
				}
				// Each array's nth element are associated with a timestamp, so all arrays must be of the same length
				var audstamps = hist["Timestamps"];
				var historylength = audstamps.length;
				for (var i in hist)
				{
					if (hist[i].length < historylength)
					{
						var padarray = new Array(historylength - hist[i].length).fill(0);
						hist[i] = hist[i].concat(padarray);
					}
					// Shave the history if larger than limit
					if (historylength >= O.Options.int_numAuditReports)
					{
						hist[i] = hist[i].slice(1, O.Options.int_numAuditReports);
					}
					else if (hist[i].length > historylength)
					{
						hist[i] = hist[i].slice(0, historylength);
					}
				}
				// Append the new audit data to the history
				hist["Timestamps"].push(T.formatISO(now));
				hist["WalletCoin"].push(walletcat["coin_liquidsell"]);
				hist["WalletKarma"].push(walletcat["karma"]);
				hist["WalletGem"].push(walletcat["gem"]);
				hist["TotalGems"].push(totalgems);
				hist["TotalAppraisedSellNoGems"].push(totalappraisedsellnogems);
				hist["TotalLiquidSellNoGems"].push(totalliquidsellnogems);
				
				// Record only the coin currency of audit categories, or their converted sum if opted
				if (O.Options.bol_auditHistoryConverted)
				{
					for (var i in auditcats)
					{
						hist[i].push(convertcat[i]);
					}
				}
				else
				{
					for (var i in auditcats)
					{
						hist[i].push((auditcats[i])["coin_appraisedsell"]);
					}
				}
				// Save the audit history object
				histbook[accname] = hist;
				O.saveCompressedObject(O.Utilities.AuditHistory.key, histbook);
				
				// Draw the history chart
				A.initializeCharts(function()
				{
					historychart.highcharts("StockChart", {
						chart: {width: 720, height: 445},
						series: formatAuditHistory(hist),
						credits: {enabled: false},
						xAxis:
						{
							type: "datetime",
							ordinal: false,
							dateTimeLabelFormats: A.getChartsTimeFormat()
						},
						yAxis:
						{
							startOnTick: false,
							endOnTick: false,
							labels:
							{
								useHTML: true,
								formatter: function()
								{
									return E.formatCoinStringColored(this.value);
								}
							}
						},
						tooltip:
						{
							useHTML: true,
							formatter: function()
							{
								return A.getChartsCurrencyFormat(this.points, A.Currency.AuditColor);
							}
						}
					});
					var historybuttons = $("<div id='audHistoryButtons'></div>").appendTo(historycontainer);
					// Button to print this account's history
					$("<button class='accButton'>" + D.getPhraseOriginal("Print History") + "</button>").appendTo(historybuttons).click(function()
					{
						I.prettyJSON(hist);
					});
					// Button to print the entire history object
					$("<button class='accButton'>" + D.getPhraseOriginal("Print Storage") + "</button>").appendTo(historybuttons).click(function()
					{
						var history = O.loadCompressedObject(O.Utilities.AuditHistory.key);
						if (history)
						{
							try
							{
								I.prettyJSON(history);
							}
							catch (e) {}
						}
					});
					// Button to reformat the history to have unique dates only
					$("<button class='accButton'>" + D.getPhraseOriginal("Trim History") + "</button>").appendTo(historybuttons).click(function()
					{
						var audstamps = hist["Timestamps"];
						var historylength = audstamps.length;
						if (historylength > 1 && confirm("This will delete some of your history so there is one entry max per day. Continue?"))
						{
							var histnew = {}, uniquedates = {}, ithstamp;
							for (var i in A.Currency.AuditHistory)
							{
								histnew[i] = [];
							}
							for (var index = historylength - 1; index >= 0; index--) // Iterate backward so only the latest entry is saved
							{
								ithstamp = audstamps[index].split("T")[0]; // Get the date portion of the ISO time string
								if (ithstamp && uniquedates[ithstamp] === undefined)
								{
									uniquedates[ithstamp] = true;
									for (var i in A.Currency.AuditHistory)
									{
										histnew[i].unshift((hist[i])[index]);
									}
								}
							}
							hist = histnew;
							histbook[accname] = hist;
							O.saveCompressedObject(O.Utilities.AuditHistory.key, histbook);
						}
					});
					// Selection to delete an account in the history
					var searchdb = [];
					for (var i in histbook)
					{
						searchdb.push({name: i});
					}
					I.createSearchBar(historybuttons, {
						aIsSelect: true,
						aIsInline: true,
						aFillerText: D.getPhraseOriginal("Delete Storage"),
						aDatabase: searchdb,
						aCallback: function(pElm)
						{
							var acctodelete = pElm.name;
							if (confirm("Delete account " + acctodelete + " from audit storage?"))
							{
								if (histbook[acctodelete])
								{
									delete histbook[acctodelete];
									O.saveCompressedObject(O.Utilities.AuditHistory.key, histbook);
									I.write(acctodelete + " was deleted from the storage.");
								}
								else
								{
									I.write(acctodelete + " was already deleted or not found in history.");
								}
							}
						}
					});
					
					finalizeAutoAudit();
				});
			});
			
			// Debug buttons at the bottom
			var debug = $("<div id='audDebug'></div>").appendTo(container);
			$("<button class='accButton'>Print Possessions</button>").appendTo(debug).click(function()
			{
				I.prettyJSON(A.Possessions);
			});
			$("<button class='accButton'>Print Paylist</button>").appendTo(debug).click(function()
			{
				I.prettyJSON(E.Paylist);
			});
			$("<button class='accButton'>Print View</button>").appendTo(debug).click(function()
			{
				I.prettyJSON(categoriesview);
			});
			
			// Finalize elements
			I.scrollToElement("#accAuditCenter", {aSpeed: "fast"});
			I.suspendElement(button, false);
			buttonalt.show();
		};
		
		/*
		 * Audits the banks and unlocks after prices have been assigned.
		 */
		var executeAudit = function()
		{
			initializeAuditCategories();
			auditWallet();
			auditPossessions();
			auditUnlocks("Skins", false);
			auditUnlocks("Outfits");
			auditUnlocks("Gliders");
			auditUnlocks("Dyes");
			auditUnlocks("Minis");
			auditUnlocks("Carriers");
			auditUnlocks("Champions");
			auditUnlocks("Finishers");
			auditUnlocks("Nodes");
			auditUnlocks("Recipes");
			auditTransactions();
			generateResults();
		};
		
		// Sums the coin price of an item's ingredients to get the appraised value of the untradeable item
		var sumIngredients = function(pIngredients)
		{
			var sum = E.createPrice(), ingrprice;
			pIngredients.forEach(function(iIngr)
			{
				// Sum the ingredients' prices
				if (iIngr)
				{
					ingrprice = E.Paylist[iIngr[0]];
					if (ingrprice && E.isPriceObject(ingrprice))
					{
						sum = E.addPrice(sum, E.recountPrice(ingrprice, iIngr[1]));
					}
				}
			});
			return E.createPriceBound(sum);
		};
		
		// Updates the payment database with the appraised value of untradeable items
		var appraiseCraftable = function()
		{
			ascendedheader = U.getRecordHeader("ascended");
			ascendeddata = U.getRecordData("ascended");
			ascendedingr = auditmetadata.AscendedIngredients;
			compositeingr = auditmetadata.CompositeIngredients;
			
			// Ascended items
			var appraisal = {}, ascendedtype;
			for (var i in ascendedheader)
			{
				// If armor or weapon then append the ingredients for insignia or inscription
				ascendedtype = ascendedheader[i].type;
				ingredients = (ascendedtype === "Armor" || ascendedtype === "Weapon")
					? ascendedingr[i].concat(ascendedingr[ascendedtype]) : ascendedingr[i];
				appraisal[i] = sumIngredients(ingredients);
			}
			A.Tally.Ascended = {
				armorcount: 0,
				weaponcount: 0,
				price: E.createPrice()
			};
			// Items of an ascended category gets the same appraised value, except trinkets
			var count;
			A.iterateRecord(ascendeddata, function(pEntry, pCategory)
			{
				ascendedtype = ascendedheader[pCategory].type;
				if (ascendedtype !== "Trinket")
				{
					E.Paylist[pEntry.i] = appraisal[pCategory];
					// Also count the number of ascended armor and weapons pieces
					if (A.Possessions[pEntry.i])
					{
						count = A.Possessions[pEntry.i].oCount;
						if (ascendedtype === "Armor")
						{
							A.Tally.Ascended.armorcount += count;
						}
						else if (ascendedtype === "Weapon")
						{
							A.Tally.Ascended.weaponcount += count;
						}
						// Sum the prices of all non-trinket ascended items
						A.Tally.Ascended.price = E.addPrice(A.Tally.Ascended.price, E.recountPrice(appraisal[pCategory], count));
					}
				}
			});
			
			// Crafted, forged, or combined items from other ingredient items
			for (var i in compositeingr)
			{
				E.Paylist[i] = sumIngredients(compositeingr[i]);
			}
		};
		
		// Scans an unlockables record and updates the payment database with applicable payments
		var insertPaymentsFromRecord = function(pName, pIsPossessions)
		{
			var record = recordsdata[pName];
			A.iterateRecord(record, function(pEntry)
			{
				if (pEntry.p)
				{
					for (var i in pEntry.p)
					{
						// Update payment database item if the payment type is applicable
						if (auditpayments[i] || pEntry.p.coin)
						{
							E.Paylist[pEntry.i] = (pEntry.p.coin) ? E.createPriceBound(pEntry.p.coin) : pEntry.p;
						}
					}
				}
				else if (pIsPossessions)
				{
					// For possessions, bound items that came from a tradeable container item will have this property, so copy the price
					if (pEntry.u && E.Paylist[pEntry.u])
					{
						E.Paylist[pEntry.i] = E.createPriceBound(E.Paylist[pEntry.u]);
					}
				}
			});
		};
		
		/*
		 * Begins downloading of numerous uncached prices and defines the payment
		 * database, the order of insertion will affect override of item payments.
		 */
		var fetchPrices = function()
		{
			I.print(D.getPhraseOriginal("Loading trading price") + "...");
			E.getPrices(U.convertAssocToArray(priceids), function(pPriceDB)
			{
				// Insert cached Trading Post prices
				var boundpayments = auditmetadata.BoundPayments;
				for (var i in cachedprices)
				{
					E.Paylist[i] = E.processPrice(cachedprices[i]);
				}
				// Insert fresh Trading Post prices
				if (pPriceDB)
				{
					for (var i in pPriceDB)
					{
						E.Paylist[i] = pPriceDB[i];
					}
				}
				// Insert audit metadata untradeable item prices
				for (var i in boundpayments)
				{
					if (boundpayments[i].coin)
					{
						E.Paylist[i] = E.createPricePlain(boundpayments[i].coin);
					}
					else
					{
						for (var ii in boundpayments[i])
						{
							E.Paylist[i] = {};
							(E.Paylist[i])[ii] = (boundpayments[i])[ii];
						}
					}
				}
				
				// Insert junk rarity item prices
				for (var i in auditmetadata.JunkValue)
				{
					E.Paylist[i] = E.createPricePlain(auditmetadata.JunkValue[i]);
				}
				// Insert ascended payments
				insertPaymentsFromRecord("Ascended", true);
				// Insert untradeable crafted or forged item prices
				appraiseCraftable();
				// Insert untradeable catalog item payments
				insertPaymentsFromRecord("Catalog", true);
				// Insert armors, weapons, backpacks item payments
				insertPaymentsFromRecord("Skins");
				// Insert outfits item payments
				insertPaymentsFromRecord("Outfits");
				// Insert gliders item payments
				insertPaymentsFromRecord("Gliders");
				// Insert minis item payments
				insertPaymentsFromRecord("Minis");
				// Insert mail carriers item payments
				insertPaymentsFromRecord("Carriers");
				// Insert mists champions item payments
				insertPaymentsFromRecord("Champions");
				// Insert finisher item payments
				insertPaymentsFromRecord("Finishers");
				// Insert home instance node item payments
				insertPaymentsFromRecord("Nodes");
				// Begin auditing
				executeAudit();
			});
		};
		
		/*
		 * Readies the IDs of possessions and priority items to retrieve live TP prices.
		 */
		var initializePrices = function()
		{
			// Load the cached prices
			I.print(D.getPhraseOriginal("Loading info price") + "...");
			$.getJSON(U.URL_DATA.Prices, function(pPriceDB)
			{
				cachedprices = pPriceDB["data"];
				untradeabledb = pPriceDB["blacklist"];
				// Include owned items in the list of prices to fetch, if it is not already cached and is tradeable
				for (var i in A.Possessions)
				{
					if (cachedprices[i] === undefined && untradeabledb[i] === undefined)
					{
						priceids[i] = true;
					}
				}
				// Include barter items for currencies conversion into coin
				var conversion;
				for (var i in auditpayments)
				{
					conversion = auditpayments[i].conversion;
					if (Array.isArray(conversion) && auditpayments[i].isbound !== true)
					{
						priceids[(conversion[1])] = true;
					}
				}
				// Include items that require fresh uncached prices
				auditmetadata = U.getRecordMetadata("ascended");
				auditmetadata.PriorityTradeable.forEach(function(iID)
				{
					priceids[iID] = true;
				});
				// Load unbought and unsold items in the account's Trading Post
				if (O.Options.bol_auditTransactions === false)
				{
					fetchPrices();
					return;
				}
				I.print(D.getPhraseOriginal("Loading buying transactions") + "...");
				A.getTransactions(A.URL.CurrentBuys, {
					aCallback: function(pDataBuys)
					{
						I.print(D.getPhraseOriginal("Loading selling transactions") + "...");
						A.getTransactions(A.URL.CurrentSells, {
							aCallback: function(pDataSells)
							{
								// Include existing TP items in the price list
								if (pDataBuys && pDataBuys.length)
								{
									currentbuysdata = pDataBuys;
									pDataBuys.forEach(function(iTransaction)
									{
										priceids[iTransaction.item_id] = true;
									});
								}
								if (pDataSells && pDataSells.length)
								{
									currentsellsdata = pDataSells;
									pDataSells.forEach(function(iTransaction)
									{
										priceids[iTransaction.item_id] = true;
									});
								}
								fetchPrices();
							},
							aError: function()
							{
								fetchPrices();
							}
						});
					},
					aError: function()
					{
						fetchPrices();
					}
				});
			});
		};
		
		/*
		 * Loads all the unlockables record files to get their item payments.
		 */
		var loadRecords = function()
		{
			var numfetched = 0;
			var numtofetch = U.getObjectLength(recordsdata);
			for (var i in recordsdata)
			{
				I.print(D.getPhraseOriginal("Loading info " + i.toLowerCase()) + "...");
				(function(iName)
				{
					U.getScript(U.URL_DATA[iName], function()
					{
						recordsdata[iName] = U.getRecordData(iName);
						numfetched++;
						if (numfetched === numtofetch)
						{
							initializePrices();
						}
					}).fail(function()
					{
						I.print("Failed to load " + iName + " record file. Auditing aborted.");
						dealError();
					});
				})(i);
			}
		};
		
		/*
		 * Retrieves account unlocks.
		 */
		var fetchUnlocks = function()
		{
			var numfetched = 0;
			var numtofetch = U.getObjectLength(unlocksdata);
			for (var i in unlocksdata)
			{
				I.print(D.getPhraseOriginal("Loading account " + i.toLowerCase()) + "...");
				(function(iName)
				{
					$.getJSON(A.getURL(A.URL[iName]), function(pData)
					{
						unlocksdata[iName] = pData;
					}).done(function()
					{
						numfetched++;
						if (numfetched === numtofetch)
						{
							loadRecords();
						}
					}).fail(function()
					{
						I.print("Failed to retrieve " + iName + " account unlocks. Auditing aborted.<br />Please check account permissions.");
						dealError();
					});
				})(i);
			}
		};
		
		// Load the bank, inventory, equipment, materials, vaults
		I.clear();
		I.print(D.getPhraseOriginal("Loading account bank materials inventory") + "...");
		A.initializePossessions(function()
		{
			fetchUnlocks();
		}, O.Options.bol_auditVault);
	}
};
V = {
/* =============================================================================
 * @@View and generate account character and bank sections
 * ========================================================================== */
	
	/*
	 * Rearranges all the characters columns based on one column's data values.
	 * @param string pClassifier class names of data containing cells.
	 * @param boolean pOrder descending if true, ascending if false.
	 */
	sortCharacters: function(pClassifier, pOrder)
	{
		var sortable = [];
		$("." + pClassifier).each(function()
		{
			sortable.push({
				// Get the index from the list item containing the value
				index: U.getSubintegerFromHTMLID($(this).parent()),
				value: parseInt($(this).attr("data-value"))
			});
		});
		U.sortObjects(sortable, {aKeyName: "value", aIsDescending: pOrder});
		
		// Sort all the rows using the new order
		for (var i = 0; i < sortable.length; i++)
		{
			var index = sortable[i].index;
			$("#chrSelection_" + index).appendTo("#chrSelection");
			$("#chrUsage_" + index).appendTo("#chrUsage");
			$("#chrSeniority_" + index).appendTo("#chrSeniority");
		}
	},
	
	/*
	 * Initializes the account audit subsection of the characters page.
	 */
	serveAudit: function()
	{
		$("#accAuditContainer").show("fast");
		// Audit option
		$("#accAuditTop").append(
			"<label><input id='audWantTransactions' type='checkbox' /> " + D.getPhraseOriginal("Include current trading transactions") + ".</label><br />"
			+ "<label><input id='audWantVaults' type='checkbox' /> " + D.getPhraseOriginal("Include guilds vault") + ".</label><br />"
			+ "<label><input id='audWantAutomatic' type='checkbox' /> " + D.getPhraseOriginal("Automatic daily audit") + ".</label><br />"
			+ "<label><input id='audWantConverted' type='checkbox' /> " + D.getPhraseOriginal("Convert currencies in history") + ".</label>"
		);
		O.mimicInput("#audWantTransactions", "bol_auditTransactions");
		O.mimicInput("#audWantVaults", "bol_auditVault");
		O.mimicInput("#audWantAutomatic", "bol_auditAccountOnReset");
		O.mimicInput("#audWantConverted", "bol_auditHistoryConverted");
		X.rewrapCheckboxes();
		// Audit buttons
		var buttoncontainer = $("#accAuditCenter");
		var executebtn = $("<button id='audExecute'>" + D.getPhraseOriginal("Audit Account") + "</button>")
			.appendTo(buttoncontainer).click(function()
		{
			A.generateAudit();
		});
		$("<button id='audHelp'>" + D.getWordCapital("help") + "</button>")
			.appendTo(buttoncontainer).click(function()
		{
			if (I.isConsoleShown() === false)
			{
				I.help($("#accHelpAudit").html());
			}
		});
		// Alternate button up top
		var executebtnalt = $("<button id='audExecuteAlternate' title='<dfn>Audit</dfn> account.<br />gw2timer.com/audit'> "
			+ "<img src='img/ui/stats.png' /></button>").insertAfter("#chrAccountReload").click(function()
		{
			$(this).hide();
			executebtn.trigger("click");
		});
		I.qTip.init("#audExecuteAlternate");
		
		// Scroll to execute button if requested by URL
		A.isAuditReady = true;
		V.attemptAudit();
	},
	attemptAudit: function()
	{
		if (A.isAuditReady)
		{
			U.verifyArticle(I.SpecialPageEnum.Audit, function()
			{
				$("#audExecute").trigger("click");
			}, true);
		}
		U.nullifyArticle();
	},
	
	/*
	 * Initializes the characters subpage.
	 * @param string pSection to open after finishing loading characters.
	 */
	serveCharacters: function(pSection)
	{
		// Don't retrieve if already did
		var dish = $("#accDish_Characters");
		if (A.reinitializeDish(dish) === false)
		{
			V.attemptAudit();
			return;
		}
		var chardependentmenu = $(".accCharDependentMenu");
		
		A.Possessions = null;
		dish.html("<div id='chrSummary'></div>"
		+ "<div id='chrStatistics' class='cssStats'>"
			+ "<ul id='chrSelection'></ul>"
			+ "<ul id='chrUsage' class='chrStats'></ul>"
			+ "<ul id='chrSeniority' class='chrStats'></ul>"
			+ "<ul id='chrGuilds' class='chrStats'></ul>"
		+ "</div>"
		+ "<div id='accAuditContainer'>"
			+ "<div id='audSeparatorTop' class='accSeparator'></div>"
			+ "<div id='accAuditTop' class='accComposition'></div>"
			+ "<div id='accAuditCenter'></div>"
			+ "<div id='accAudit'></div>"
		+ "</div>");
		$(".chrWallet").remove();
		$(".chrStats").hide();
		I.suspendElement(chardependentmenu);
		dish.prepend(I.cThrobber);
		
		// Retrieve characters data
		U.getJSON(A.getURLAll(A.URL.Characters), function(pData)
		{
			A.wipeDish("Hero");
			I.removeThrobber(dish);
			A.adjustAccountScrollbar();
			A.isCharactersCached = true;
			
			// Reset variables
			var numcharacters = pData.length;
			A.initializeAccountUpgrades();
			A.assignAccountUpgrades("CharacterSlot", numcharacters);
			A.Data.CharacterNames = [];
			A.CharIndexCurrent = null;
			A.Data.Characters = null;
			A.Data.Characters = new Array(numcharacters);
			A.Data.CharacterAssoc = {};
			var charindex = 0;
			pData.forEach(function(iCharData)
			{
				A.Data.CharacterNames.push(iCharData.name);
				$("#chrSelection").append("<li id='chrSelection_" + charindex + "' class='chrSelection curClick'></li>");
				$("#chrUsage").append("<li id='chrUsage_" + charindex + "'></li>");
				$("#chrSeniority").append("<li id='chrSeniority_" + charindex + "'></li>");
				// Add extra or preformatted properties 
				A.Data.Characters[charindex] = iCharData;
				A.Data.Characters[charindex].oCharIndex = charindex;
				A.Data.Characters[charindex].oCharName = U.escapeHTML(iCharData.name);
				A.Data.CharacterAssoc[iCharData.name] = charindex;
				V.generateCharactersSelection(iCharData);
				charindex++;
			});
			I.suspendElement(chardependentmenu, false);
			V.generateCharactersStatistics();
			if (pSection)
			{
				$("#accMenu_" + pSection).trigger("click");
			}
		}, A.isCharactersCached).fail(function(pRequest, pStatus)
		{
			I.removeThrobber(dish);
			A.printError(A.PermissionEnum.Characters, pStatus);
		});
	},
	
	/*
	 * Generates a row in the first column showing common information about a character.
	 * @param object pCharacter characters data.
	 */
	generateCharactersSelection: function(pCharacter)
	{
		// Initializes common character values to reused later
		var icon = (pCharacter.profession).toLowerCase();
		pCharacter.oCharElite = icon;
		pCharacter.oCharProfession = icon;
		pCharacter.oCharColor = A.Metadata.Profession[icon].color;
		pCharacter.oCharIsLowLevel = (pCharacter.level < Q.GameLimit.LevelMax);
		if (pCharacter.specializations && pCharacter.specializations.pve)
		{
			var specs = pCharacter.specializations.pve;
			for (var i = 0; i < specs.length; i++)
			{
				if (specs[i])
				{
					// If one of the character's specs is found to be in the elite spec
					var specid = specs[i].id;
					if (A.Metadata.ProfElite[specid] !== undefined)
					{
						icon = A.Metadata.ProfElite[specid];
						pCharacter.oCharElite = icon; // Remember the icon
						break;
					}
				}
			}
		}
		
		// Get active crafting disciplines
		var craftused = "";
		var crafttooltip = "";
		if (pCharacter.crafting && pCharacter.crafting.length > 0)
		{
			pCharacter.oCharCraft = {};
			pCharacter.crafting.forEach(function(iCraft)
			{
				var trivial = (iCraft.rating >= A.Metadata.CraftingRank.Master) ? "" : "accTrivial";
				var craftstr = "<b class='" + trivial + "'><ins class='acc_craft acc_craft_" + (iCraft.discipline).toLowerCase() + "'></ins>"
					+ "<sup class='chrCraftingRating'>" + iCraft.rating + "</sup></b> ";
				if (iCraft.active)
				{
					craftused += craftstr;
					pCharacter.oCharCraft[iCraft.discipline] = iCraft.rating;
				}
				crafttooltip += craftstr + " ";
			});
		}
		
		// SELECTION COLUMN (left)
		var charvalue = A.Metadata.Race[(pCharacter.race).toLowerCase() + "_" + (pCharacter.gender).toLowerCase()] || 1;
		var professionvalue = (A.Metadata.Profession[(pCharacter.profession).toLowerCase()]).weight;
		var trivial = (pCharacter.oCharIsLowLevel) ? "accTrivial" : "";
		// Remember character portrait
		pCharacter.oCharPortrait = "img/account/characters/" + (pCharacter.race).toLowerCase() + "_" + (pCharacter.gender).toLowerCase() + I.cPNG;
		// Create character name row that leads to its hero page
		$("#chrSelection_" + pCharacter.oCharIndex).append(
			"<img id='chrPortrait_" + pCharacter.oCharIndex + "' class='chrPortrait' src='" + pCharacter.oCharPortrait + "' />"
			+ "<var id='chrName_" + pCharacter.oCharIndex + "' class='chrName' data-value='" + charvalue + "'>" + pCharacter.oCharName + "</var>"
			+ "<span class='chrCommitment' data-value='" + professionvalue + "'>"
				+ "<var class='chrProfession " + trivial + "'>"
					+ "<ins class='chrProfessionIcon acc_prof acc_prof_" + icon + "'></ins><sup>" + pCharacter.level + "</sup></var>"
				+ "<var class='chrCrafting'>" + craftused + "</var>"
			+ "</span>"
			+ "<img class='chrProceed' src='img/ui/view.png' />")
		.click(function()
		{
			var charindex = U.getSubintegerFromHTMLID($(this));
			if (A.CharIndexCurrent === charindex)
			{
				A.CharIndexCurrent = null;
				$(this).find(".chrProceed").animate({rotation: 0}, {duration: 200, queue: false});
				$(this).removeClass("chrSelected");
			}
			else
			{
				A.CharIndexCurrent = charindex;
				$(".chrProceed").animate({rotation: 0}, {duration: 200, queue: false});
				$(this).find(".chrProceed").animate({rotation: T.cCIRCLE_RIGHT_DEGREE}, {duration: 200, queue: false});
				$(".chrSelection").removeClass("chrSelected");
				$(this).addClass("chrSelected");
				$("#accMenu_Hero").trigger("click");
				A.adjustAccountScrollbar();
			}
		});
		// Mini portrait can be clicked to print raw data
		$("#chrPortrait_" + pCharacter.oCharIndex).click(function(pEvent)
		{
			pEvent.stopPropagation();
			var charindex = U.getSubintegerFromHTMLID($(this));
			I.prettyJSON(A.Data.Characters[charindex]);
		});
		// Remember HTML containing the character's portrait, profession icon, and name, to be used in bank tab headers
		var prefacecontent = "<img class='chrPrefaceIcon' src='" + pCharacter.oCharPortrait + "' />"
			+ "<ins class='acc_prof acc_prof_" + pCharacter.oCharElite + " " + trivial + "'></ins>";
		pCharacter.oCharPreface = "<span class='chrPreface'>" + prefacecontent + pCharacter.oCharName + "</span>";
		pCharacter.oCharIcons = "<span class='chrPreface' title='" + pCharacter.oCharName + "'>" + prefacecontent + "</span>";
		// Additional information as tooltip
		I.qTip.init($("#chrSelection_" + pCharacter.oCharIndex).find(".chrCommitment").attr("title", crafttooltip));
	},
	
	/*
	 * Generates the columns for presenting the character's data values.
	 */
	generateCharactersStatistics: function()
	{
		var now = new Date();
		var nowmsec = now.getTime();
		var hourstr = D.getWord("h");
		var daystr = D.getWord("d");
		var yearstr = D.getWord("y");
		var highestage = 0;
		var highestdeaths = 0;
		var highestlifetime = 0;
		var totalage = 0;
		var totaldeaths = 0;
		
		var getWvWTitle = function(pRank)
		{
			var rankobj = A.Metadata.WvWRank;
			var ranks = rankobj.Ranks;
			var wvwtitle = "", wvwtitletip = "", wvwtitlenext = "";
			var titleindex, modifierindex;
			var length = ranks.length;
			for (var i = 0; i < length; i++)
			{
				if (ranks[i] > pRank)
				{
					// Current rank
					titleindex = (i-1) % rankobj.RanksPerModifier;
					modifierindex = Math.floor((i-1) / rankobj.RanksPerModifier);
					wvwtitle = D.orderModifier(
						D.getObjectTranslation(rankobj.Titles[titleindex]),
						D.getObjectTranslation(rankobj.Modifiers[modifierindex])
					);
					// Next rank
					if (i < length)
					{
						titleindex = i % rankobj.RanksPerModifier;
						modifierindex = Math.floor(i / rankobj.RanksPerModifier);
						wvwtitlenext = D.orderModifier(
							D.getObjectTranslation(rankobj.Titles[titleindex]),
							D.getObjectTranslation(rankobj.Modifiers[modifierindex])
						);
						wvwtitletip = pRank + " + " + (ranks[i] - pRank) + "<img src=\"img/account/summary/worldabilitypoint.png\" />" + " = " + wvwtitlenext;
					}
					break;
				}
			}
			// Max rank case
			if (pRank >= ranks[length - 1])
			{
				wvwtitle = D.orderModifier(
					D.getObjectTranslation(rankobj.Titles[rankobj.Titles.length - 1]),
					D.getObjectTranslation(rankobj.Modifiers[rankobj.Modifiers.length - 1])
				);
			}
			return "<var id='chrAccountWvWRank' title='" + wvwtitletip + "'>" + wvwtitle + "</var>";
		};
		
		// First loop to find max values for age and deaths
		A.Data.Characters.forEach(function(iChar)
		{
			if (highestage < iChar.age)
			{
				highestage = iChar.age;
			}
			if (highestdeaths < iChar.deaths)
			{
				highestdeaths = iChar.deaths;
			}
			iChar.oCharLifetime = Math.floor((nowmsec - (new Date(iChar.created)).getTime()) / T.cMSECONDS_IN_SECOND);
			if (highestlifetime < iChar.oCharLifetime)
			{
				highestlifetime = iChar.oCharLifetime;
			}
		});
		// Write a row for each character
		A.Data.Characters.forEach(function(iChar)
		{
			var name = "<abbr>" + iChar.oCharName + "</abbr>";
			// USAGE COLUMN (middle)
			totalage += iChar.age; // Seconds
			totaldeaths += iChar.deaths;
			var age = Math.round(iChar.age / T.cSECONDS_IN_HOUR);
			var agepercent = (iChar.age / highestage) * T.cPERCENT_100;
			var deathpercent = (iChar.deaths / highestdeaths) * T.cPERCENT_100;
			var usage = "<var class='chrAge' title='" + T.formatTimeLetter(iChar.age) + "' data-value='" + age + "'>" + age + hourstr + "</var>"
				+ "<span class='chrHoverName'>" + name + I.getBar(agepercent, true) + I.getBar(deathpercent) + "</span>"
				+ "<var class='chrDeaths' title='" + T.parseRatio(iChar.deaths / age, 2) + "x / " + "1" + hourstr + "' data-value='" + iChar.deaths + "'>" + iChar.deaths + "x</var>";
			$("#chrUsage_" + iChar.oCharIndex).append(usage);
			// SENIORITY COLUMN (right)
			var birthdate = (new Date(iChar.created)).toLocaleString();
			var birthdays = Math.floor(iChar.oCharLifetime / T.cSECONDS_IN_YEAR);
			var lifetime = Math.floor(iChar.oCharLifetime / T.cSECONDS_IN_DAY);
			var lifetimepercent = (iChar.oCharLifetime / highestlifetime) * T.cPERCENT_100;
			var birthdaysince = Math.floor((iChar.oCharLifetime % T.cSECONDS_IN_YEAR) / T.cSECONDS_IN_DAY);
			var birthdaytill = T.cDAYS_IN_YEAR - birthdaysince;
			var birthdaypercent = (birthdaysince / T.cDAYS_IN_YEAR) * T.cPERCENT_100;
			var seniority = "<var class='chrLifetime' title='" + T.formatTimeLetter(iChar.oCharLifetime) + "' data-value='" + iChar.oCharLifetime + "'>"
					+ lifetime + daystr + " (" + birthdays + yearstr + ")</var>"
				+ "<span class='chrHoverName'>" + name + I.getBar(lifetimepercent, true) + I.getBar(birthdaypercent) + "</span>"
				+ "<var class='chrBirthday' title='" + T.formatTimeLetter(birthdaytill * T.cSECONDS_IN_DAY) + "' data-value='" + birthdaysince + "'>" + birthdaytill + daystr + "</var>"
				+ "<var class='chrBirthdate'>" + birthdate + "</var>";
			$("#chrSeniority_" + iChar.oCharIndex).append(seniority);
		});
		// Highlight the character's name when hovered over a statistics row
		$(".chrStats li").hover(
			function() { $("#chrSelection_" + U.getSubstringFromHTMLID($(this))).css({outline: "1px solid red"}); },
			function() { $("#chrSelection_" + U.getSubstringFromHTMLID($(this))).css({outline: "none"}); }
		);
		// Insert header above the columns
		var sym = " <b class='jsSortableHeaderSymbol'>" + I.Symbol.TriDown + "</b>";
		$("#chrSelection").prepend("<li class='chrHeader'><var class='chrHeaderLeft curClick' data-classifier='chrName'>"
			+ A.Data.Characters.length + " "
			+ D.getWordCapital("characters") + sym + "</var><var class='chrHeaderRight curClick' data-classifier='chrCommitment'>"
			+ D.getWordCapital("profession") + sym + "</var></li>");
		$("#chrUsage").prepend("<li class='chrHeader'><var class='chrHeaderLeft curClick' data-classifier='chrAge'>"
			+ D.getWordCapital("age") + sym + "</var><var class='chrHeaderRight curClick' data-classifier='chrDeaths'>"
			+ D.getWordCapital("deaths") + sym + "</var></li>");
		$("#chrSeniority").prepend("<li class='chrHeader'><var class='chrHeaderLeft curClick' data-classifier='chrLifetime'>"
			+ D.getWordCapital("lifetime") + sym + "</var><var class='chrHeaderRight curClick' data-classifier='chrBirthday'>"
			+ D.getWordCapital("birthday") + sym + "</var></li>");
		// Header click to sort the columns
		$(".chrHeaderLeft, .chrHeaderRight").click(function()
		{
			I.toggleSortableHeader($(this));
			V.sortCharacters($(this).attr("data-classifier"), $(this).data("isdescending"));
		});
		// SUMMARY MARQUEE (top)
		$.getJSON(A.getURL(A.URL.Account), function(pData)
		{
			A.Data.Account = pData;
			A.Data.Account.oAccName = U.escapeHTML(pData.name);
			A.Data.Account.oAccNick = A.Data.Account.oAccName.split(".")[0]; // Omit the identifier number from the account name
			var forumlink = U.convertPrivateAnchor("https://forum-en.guildwars2.com/members/" + pData.name.replace(/[\s\.]/g, "-") + "/showposts");
			var totalagehour = Math.round(totalage / T.cSECONDS_IN_HOUR);
			var accountbirthdate = new Date(pData.created);
			var accountlifetime = Math.floor((nowmsec - accountbirthdate.getTime()) / T.cMSECONDS_IN_SECOND);
			var accountbirthdaysince = T.formatTimeLetter(accountlifetime).trim();
			var hoursperday = T.parseRatio((totalage / accountlifetime) * T.cHOURS_IN_DAY, 2);
			var commandership = (pData.commander) ? "" : "accTrivial";
			var wvwtitle = (pData.wvw_rank) ? (" " + getWvWTitle(pData.wvw_rank)) : "";
			var access = pData.access;
			var accessstr = "";
			if (access && access.length)
			{
				access.forEach(function(iAccess)
				{
					if (Q.AccessEnum[iAccess])
					{
						accessstr += "<img src='img/account/summary/access_" + iAccess + ".png' /> ";
					}
				});
			}
			var accountadditional = "<span id='chrAccountMisc'>"
				+ "<dfn><a id='chrAccountLink' title='" + U.escapeHTML(pData.id) + "'" + forumlink + ">" + U.escapeHTML(pData.name) + "</a></dfn><br />" + accountbirthdate.toLocaleString() + "<br />"
				+ "<img class='" + commandership +  "' src='img/account/summary/commander.png' />"
				+ accessstr
				+ "<img src='img/account/summary/fractal.png' />" + (pData.fractal_level || "?") + " "
				+ "<img src='img/account/summary/worldabilitypoint.png' />" + (pData.wvw_rank || "?") + " "
				+ "<img src='img/account/summary/daily.png' />" + (pData.daily_ap || "?") + " "
				+ "<img src='img/account/summary/monthly.png' />" + (pData.monthly_ap || "?")
			+ "</span><br />";
			var summary = "<var id='chrAccountName'>" + A.Data.Account.oAccNick + "</var>"
				+ accountadditional
				+ "<var id='chrAccountServer'></var>" + wvwtitle + "<br />"
				+ "<var id='chrAccountAge' title='" + hoursperday + hourstr + " / " + T.cHOURS_IN_DAY + hourstr + "<br />"
						+ T.formatTimeLetter(totalage) + " / " + accountbirthdaysince + "'>" + totalagehour + hourstr + "</var> / "
					+ "<var id='chrAccountDeaths' title='" + T.parseRatio(totaldeaths / totalagehour, 2) + "x / " + "1" + hourstr + "'>" + totaldeaths + "x</var> &nbsp; "
					+ "<var id='chrAccountLifetime'>" + accountbirthdaysince +  "</var>"
					+ " &nbsp; <span id='chrAccountTitles'></span> &nbsp; "
					+ "<button id='chrAccountReload' title='<dfn>Reload</dfn> characters data (statistics, equipment, inventory).'><img src='img/ui/refresh.png' /></button>";
			$("#chrSummary").append(summary);
			I.qTip.init("#chrSummary var, #chrAccountReload");
			// Account reload button
			$("#chrAccountReload").click(function()
			{
				// Wipe previous sections that use characters data
				A.isCharactersCached = false;
				$(".accCharDependent").each(function()
				{
					A.wipeDish($(this).attr("data-section"));
				});
				I.qTip.hide();
				A.regenerateDish("Characters");
			});
			// Insert server name
			$.getJSON(U.URL_API.Worlds + pData.world, function(pDataInner)
			{
				if (Array.isArray(pDataInner) && pDataInner.length > 0)
				{
					$("#chrAccountServer").text(pDataInner[0].name);
				}
			});
			// Retrieve and insert guilds
			A.initializeGuilds(function()
			{
				// Guild tag next to each character's name
				var guildids = pData.guilds;
				A.Data.Characters.forEach(function(iChar)
				{
					if (iChar.guild)
					{
						var guild = Q.getCachedGuild(iChar.guild);
						if (guild)
						{
							$("#chrName_" + iChar.oCharIndex).append("<sup class='chrTag'>[" + guild.tag + "]" + "</sup>");
						}
					}
				});

				var guildheader = "<li class='chrHeader'><var class='chrHeaderLeft'>" + D.getWordCapital("guilds") + "</var></li>";
				$("#chrGuilds").append(guildheader);
				for (var i in guildids)
				{
					var guild = Q.getCachedGuild(guildids[i]);
					if (guild)
					{
						(function(iGuild)
						{
							var banner = U.getGuildBannerRaw(iGuild);
							var guildrow = $("<li class='chrGuild'><span class='chrGuildHover'><img class='chrGuildBanner' src='" + banner + "' />"
									+ "<img class='chrGuildBanner chrGuildBannerLarge' src='" + banner + "' /></span>"
								+ "<var class='chrGuildName'>" + iGuild.name + " " + iGuild.oTag + "</var></li>").click(function()
								{
									I.prettyJSON(iGuild);
								});
							$("#chrGuilds").append(guildrow);
						})(guild);
					}
				}
			});
			V.initializeWallet();
			V.initializeTitles();
			
			// Finally show the summary
			$("#chrSummary").show("fast");
		});
		
		// Finally
		I.qTip.init("#accPlatterCharacters var");
		$(".chrStats").show("fast");
	},
	
	/*
	 * Initializes the wallet object and generate columns (categorized wallets) for currencies.
	 */
	initializeWallet: function()
	{
		var generateWallet = function(pWallet, pName)
		{
			// Prepare HTML
			var wallet = $("<ul id='chrWallet_" + pName + "' class='chrStats chrWallet'></ul>").insertBefore("#chrGuilds");
			var header = "";
			switch (pName)
			{
				case "General": header = D.getModifiedWord("currencies", "general", U.CaseEnum.Every); break;
				case "Dungeon": header = D.getModifiedWord("tokens", "dungeon", U.CaseEnum.Every); break;
				case "Map": header = D.getModifiedWord("tokens", "map", U.CaseEnum.Every); break;
				case "PvP": header = D.getModifiedWord("currencies", "pvp", U.CaseEnum.Every); break;
			}
			wallet.append("<li class='chrHeader'><var class='chrHeaderLeft curClick'>" + header + "</var></li>");
			I.bindSortableTable(wallet, {aIsList: true});
			
			// First loop to find max value of the wallet
			var currency, value, amount, coef, amountstr;
			for (var i = 0; i < pWallet.length; i++)
			{
				currency = pWallet[i];
				amount = A.Data.Wallet[currency.id];
				amount = (amount === undefined || amount === null) ? 0 : amount;
				coef = currency.coefficient;
				
				// Adjust the value so the currencies can be compared
				currency.value = (coef === "gem") ? E.convertGemToCoin(amount)
					: ((coef === undefined) ? amount : (amount * coef));
				
				// Insert wallet currency into accessible associative array
				if (currency.payment)
				{
					A.Currency.AuditWallet[currency.id] = currency;
				}
			}
			var max = T.getMinMax(pWallet, "value").oMax;
			
			// Generate the currencies for this wallet
			for (var i = 0; i < pWallet.length; i++)
			{
				currency = pWallet[i];
				amount = A.Data.Wallet[currency.id];
				amount = (amount === undefined || amount === null) ? 0 : amount;
				amountstr = amount.toLocaleString();
				value = currency.value;
				switch (currency.id)
				{
					case 1: amountstr = E.formatCoinStringColored(amount); break;
					case 2: amountstr = E.formatKarmaString(amount, true); break;
					case 3: amountstr = E.formatLaurelString(amount, true); break;
					case 4: amountstr = E.formatGemString(amount, true); break;
				}

				var percent = (value / max) * T.cPERCENT_100;
				var link = U.getWikiLinkDefault(D.getObjectDefaultName(currency));
				wallet.append("<li data-value='" + value + "'>"
					+ "<var class='chrWalletAmount'>" + amountstr + "</var>"
					+ "<ins class='acc_wallet acc_wallet_" + currency.id + "'></ins>"
					+ "<var class='chrWalletCurrency'><a class='chrWalletLink'" + U.convertExternalAnchor(link) + ">" + D.getObjectName(currency) + "</a></var>"
					+ I.getBar(percent)
				+ "</li>");
			}
		};
		
		$.getJSON(A.getURL(A.URL.Wallet), function(pData)
		{
			E.updateExchangeRatios(function() // For the gem conversion
			{
				A.Data.Wallet = null;
				A.Data.Wallet = {};
				// Convert the API array of currency objects into an associative array of currency IDs and values
				for (var i = 0; i < pData.length; i++)
				{
					var currency = pData[i];
					A.Data.Wallet[currency.id] = parseInt(currency.value);
				}

				var wallets = A.Currency.Wallet;
				for (var i in wallets)
				{
					generateWallet(wallets[i], i);
				}
				// Show the audit button now that wallet is loaded
				V.serveAudit();
			});
		}).fail(function()
		{
			// Cannot audit without wallet
			U.nullifyArticle();
		});
	},
	
	/*
	 * Retrieves account's acquired titles and assign them to each character.
	 */
	initializeTitles: function()
	{
		var generateTitles = function()
		{
			// Add a title as a tooltip for each character's selection line
			var usedtitles = {};
			A.Data.Characters.forEach(function(iChar)
			{
				var titleid = iChar.title;
				if (titleid)
				{
					var box = Q.getBoxedTitle(titleid);
					if (box)
					{
						if (usedtitles[titleid] === undefined)
						{
							usedtitles[titleid] = 0;
						}
						usedtitles[titleid] += 1;
						var title = box.oData;
						I.qTip.init($("#chrSelection_" + iChar.oCharIndex).attr("title", "&quot;<dfn>" + title.name + "</dfn>&quot;"));
					}
				}
			});
			
			// List all unlocked titles as a dropdown menu
			var searchdb = [];
			for (var i in A.Data.Titles)
			{
				var box = Q.getBoxedTitle(i);
				if (box)
				{
					var title = box.oData;
					// Also append a count next to used titles
					var count = ((usedtitles[title.id]) ? "(" + usedtitles[title.id] + ") " : "");
					searchdb.push({
						name: count + title.name,
						wiki: U.getWikiLinkLanguage(title.name)
					});
				}
			}
			I.createSearchBar("#chrAccountTitles", {
				aIsSelect: true,
				aIsInline: true,
				aFillerText: searchdb.length + " " + D.getPhraseOriginal("Titles Unlocked"),
				aDatabase: searchdb,
				aCallback: function(aTitle)
				{
					U.openExternalURL(aTitle.wiki);
				}
			});
		};
		
		// Get account title unlocks
		$.getJSON(A.getURL(A.URL.Titles), function(pData)
		{
			A.Data.Titles = null;
			A.Data.Titles = U.getExistAssoc(pData);
			// Get title data
			Q.getTitles(pData, function()
			{
				generateTitles();
			});
		});
	},
	
	/*
	 * Requires characters data to be loaded first before loading other subsections.
	 * @param string pSection to open after characters data are loaded.
	 * @returns boolean true if characters data is required.
	 */
	requireCharacters: function(pSection)
	{
		if ($("#accDish_Characters").is(":empty"))
		{
			V.serveCharacters(pSection);
			$("#accMenu_Characters").trigger("click");
			return true;
		}
		return false;
	},
	
	/*
	 * Shows or hides a character or all characters hero overview window, and
	 * generates them if haven't already.
	 * @pre Characters array was loaded by AJAX.
	 */
	serveHero: function()
	{
		if (V.requireCharacters("Hero"))
		{
			return;
		}
		else if ( ! A.Data.Characters[0].equipment)
		{
			A.printError(A.PermissionEnum.Builds);
			return;
		}
		var dish = $("#accDish_Hero");
		var equipcur = $("#eqpContainer_" + A.CharIndexCurrent);
		var equipall = $(".eqpContainer");
		var doGenerate = function()
		{
			// Generate all characters
			I.removeThrobber(dish);
			A.Data.Characters.forEach(function(iChar)
			{
				V.generateHero(iChar);
			});
			equipall.show();
			
			// Create the quick scroller since multiple characters are shown
			A.createCharacterScroller(A.Data.Characters, "Hero", {
				aElementPrefix: "eqpContainer_",
				aOffset: -120
			});
		};
		
		// Generate for single character if user chosen, else all characters
		if (A.CharIndexCurrent !== null)
		{
			V.generateHero();
			equipall.hide();
			equipcur.show();
		}
		else
		{
			if (A.reinitializeDish(dish) === false)
			{
				equipall.show();
			}
			else
			{
				// Prefetch equipped items, and their transmuted skins, upgrades, and infusions
				dish.prepend(I.cThrobber);
				var itemstofetch = [];
				var skinstofetch = [];
				A.Data.Characters.forEach(function(iChar)
				{
					var result = A.iterateInventory(iChar.equipment);
					itemstofetch = itemstofetch.concat(result.oItemIDs);
					skinstofetch = skinstofetch.concat(result.oSkinIDs);
				});
				Q.getItems(itemstofetch, function()
				{
					Q.getSkins(skinstofetch, function()
					{
						doGenerate();
					});
				});
			}
		}
	},
	
	/*
	 * Generates the equipment subsection of the characters page.
	 * @param object pCharacter characters data.
	 */
	generateHero: function(pCharacter)
	{
		var char = pCharacter || A.getCurrentCharacter();
		if (char === undefined || char === null || Array.isArray(char.equipment) === false || $("#eqpContainer_" + char.oCharIndex).length)
		{
			return;
		}
		// Initialize variables
		var dish = $("#accDish_Hero");
		var container = $("<div id='eqpContainer_" + char.oCharIndex + "' class='eqpContainer'></div>").appendTo(dish);
		// Title and separator
		A.createCharacterBanner(container, char);
		// Equipment icons and brief glance information
		var subcontainer = $("<div class='eqpSubcontainer eqpSubcontainer_" + char.profession + "'></div>").appendTo(container);
		var subconleft = $("<div class='eqpLeft eqpColumn'></div>").appendTo(subcontainer);
		var subconright = $("<div class='eqpRight eqpColumn'></div>").appendTo(subcontainer);
		var subconbuild = $("<div class='eqpBuild eqpColumn'></div>").appendTo(subcontainer);
		var eqp = A.Equipment;
		var equipleft = eqp.ColumnLeft;
		var equipright = eqp.ColumnRight;
		var equiprightbrief = eqp.BriefRight;
		var equiptoggle = eqp.ToggleableSlots;
		var attrwindow = $("<div class='eqpAttrWindow'><aside class='eqpAttrHeader'><span class='eqpAttrTitle'>"
			+ D.getWordCapital("attributes") + "</span></aside><aside class='eqpAttrContent'></aside></div>").appendTo(subconbuild);
		// Object containing attribute points to be added by the retrieved items
		var attrobj = new A.Attribute.Base();
		var numtofetch = char.equipment.length;
		var numfetched = 0;
		
		/*
		 * Macro HTML writing functions.
		 */
		var formatEquipmentSlotLeft = function(pEquipment)
		{
			return "<aside class='eqpRow eqp" + pEquipment + "'>"
				+ "<span class='eqpSlotOuter'><span class='eqpSlot eqpSlot_" + pEquipment
					+ "' style='background-image:url(\"img/account/equipment/" + pEquipment.toLowerCase() + ".png\")'></span></span>"
				+ "<span class='eqpBrief eqpBrief_" + pEquipment + "'></span>"
			+ "</aside>";
		};
		var formatEquipmentSlotRight = function(pEquipment)
		{
			return "<aside class='eqpCell eqp" + pEquipment + "'>"
				+ "<span class='eqpSlot eqpSlot_" + pEquipment
					+ "' style='background-image:url(\"img/account/equipment/" + pEquipment.toLowerCase() + ".png\")'></span>"
			+ "</aside>";
		};
		var formatItemBrief = function(pBox)
		{
			var str = "";
			var levelstr = (pBox.oData.level < Q.GameLimit.LevelMax) ? (" (" + pBox.oData.level + ")") : "";
			str = "<span class='eqpBriefName " + Q.getRarityClass(pBox.oData.rarity) + "'>" + pBox.oData.name + levelstr + "</span><br />";
			pBox.oInfusions.forEach(function(iInfusion)
			{
				str += "<span class='" + Q.getRarityClass(iInfusion.rarity) + "'><img src='" + iInfusion.icon + "' /> " + iInfusion.name + "</span><br />";
			});
			pBox.oUpgrades.forEach(function(iUpgrade)
			{
				str += "<span class='" + Q.getRarityClass(iUpgrade.rarity) + "'><img src='" + iUpgrade.icon + "' /> " + iUpgrade.name + "</span><br />";
			});
			return str;
		};
		
		/*
		 * Windows to generate after equipments are fully loaded.
		 */
		var formatAttributesWindow = function()
		{
			// BUILD COLUMN: Attributes
			var attrcontent = attrwindow.find(".eqpAttrContent");
			var attrstrobj = Q.calculateAttributes(attrobj, char);
			for (var i in attrstrobj)
			{
				attrcontent.append("<span class='eqpAttrBlock eqpAttr_" + i + "' title='<dfn>" + D.getString(i) + "</dfn>'>"
					+ "<img src='img/account/attributes/" + i.toLowerCase() + ".png' />"
					+ "<var class='eqpAttrSum'>" + attrstrobj[i] + "</var><var class='eqpAttrBonus'>+" + attrobj[i] + "</var>"
				+ "</span>");
			}
			// Insert profession-specific attribute
			attrcontent.find(".eqpAttr_Power").after("<span class='eqpAttrBlock eqpAttr_Profession'>"
				+ "<img src='img/account/attributes/" + char.oCharElite.toLowerCase() + ".png' /><var>0%</var></span>");
			I.qTip.init(attrcontent.find("span"));
		};
		var formatTraitsWindow = function()
		{
			// BUILD COLUMN: Specializations
			var spec = char.specializations;
			var skills = char.skills;
			if (spec === undefined)
			{
				return;
			}
			var traitwindow = $("<div class='spzWindow'>"
				+ "<aside class='spzSwitchContainer'><span class='spzSwitchWrapper'>"
					+ "<img class='spzBuildIcon' src='img/ui/menu/build.png' />"
					+ "<img src='img/ui/view.png' />"
					+ "<img class='spzSwitch curClick' data-assoc='PVE' src='img/ui/menu/map.png' />"
					+ "<img class='spzSwitch curClick' data-assoc='WVW' src='img/ui/menu/wvw.png' />"
					+ "<img class='spzSwitch curClick' data-assoc='PVP' src='img/ui/menu/pvp.png' />"
				+ "</span></aside>"
				+ "<div class='spzContainer'>"
					+ "<div class='spzPanel spzPanel_PVE'></div>"
					+ "<div class='spzPanel spzPanel_WVW'></div>"
					+ "<div class='spzPanel spzPanel_PVP'></div>"
				+ "</div>"
				+ "<div class='sklContainer'>"
					+ "<div class='sklPanel sklPanel_PVE'></div>"
					+ "<div class='sklPanel sklPanel_WVW'></div>"
					+ "<div class='sklPanel sklPanel_PVP'></div>"
				+ "</div>"
			+ "</div>").appendTo(subconbuild);
			// Bind game mode buttons to switch to appropriate specializations panel
			traitwindow.find(".spzSwitch").each(function()
			{
				$(this).click(function()
				{
					traitwindow.find(".spzSwitch").removeClass("spzSwitchFocused");
					$(this).addClass("spzSwitchFocused");
					var buildmode = $(this).attr("data-assoc");
					var buildmodelower = buildmode.toLowerCase();
					var specpanel = traitwindow.find(".spzPanel_" + buildmode);
					var skillpanel = traitwindow.find(".sklPanel_" + buildmode);
					traitwindow.find(".spzPanel").hide();
					traitwindow.find(".sklPanel").hide();
					specpanel.show();
					skillpanel.show();
					// Generate the traits and skills panels if have not already
					V.generateTraits(spec[buildmodelower], specpanel);
					V.generateSkills(skills[buildmodelower], skillpanel);
				});
			});
			// Automatically opens the PVE traits window first
			traitwindow.find(".spzSwitch:first").trigger("click");
		};
		
		/*
		 * Function to execute after every single item and subitems have been retrieved.
		 */
		var finalizeEquipment = function()
		{
			A.setProgressBar(numfetched, numtofetch);
			if (numtofetch === numfetched)
			{
				formatAttributesWindow();
				formatTraitsWindow();
			}
		};
		
		// LEFT COLUMN armor and weapon
		equipleft.forEach(function(iEquip)
		{
			subconleft.append(formatEquipmentSlotLeft(iEquip));
		});
		// Add swap weapon ornamental icon
		subconleft.find(".eqpWeaponA2").after("<aside class='eqpSwap'><img class='eqpSwapIcon' src='img/account/equipment/swap.png' /></aside>");
		subconleft.find(".eqpWeaponA1").after("<span class='eqpSwapOuter eqpSwapA'><img class='eqpSwapIcon' src='img/account/equipment/swapa.png' /></span>");
		subconleft.find(".eqpWeaponB1").after("<span class='eqpSwapOuter eqpSwapB'><img class='eqpSwapIcon' src='img/account/equipment/swapb.png' /></span>");
		// RIGHT COLUMN trinket and underwater
		equipright.forEach(function(iEquip)
		{
			subconright.append(formatEquipmentSlotRight(iEquip));
		});
		subconright.prepend("<aside class='eqpSepTrinket'></aside>");
		var briefcontainer = $("<aside class='eqpBriefRight'></aside>").prependTo(subconright);
		equiprightbrief.forEach(function(iEquip)
		{
			briefcontainer.append("<span class='eqpBrief eqpBrief_" + iEquip + "' style='display:none;'></span>");
		});
		// Add padding separators
		subconright.find(".eqpRing2").after("<aside class='eqpSepGathering'><span class='eqpSepInner'></span></aside>");
		subconright.find(".eqpPick").after("<aside class='eqpSepUnderwater'><span class='eqpSepInner'></span></aside>");
		// Add swap weapon ornamental icon
		subconright.find(".eqpWeaponAquaticA").after("<aside class='eqpSwapAquatic eqpCell'><img class='eqpSwapIcon' src='img/account/equipment/swap.png' /></aside>");
		subconright.find(".eqpWeaponAquaticA").after("<span class='eqpSwapAquaticOuter eqpSwapAquaticA'><img class='eqpSwapIcon' src='img/account/equipment/swapaquatica.png' /></span>");
		subconright.find(".eqpWeaponAquaticB").after("<span class='eqpSwapAquaticOuter eqpSwapAquaticB'><img class='eqpSwapIcon' src='img/account/equipment/swapaquaticb.png' /></span>");
		// Add aquatic weapon background
		subconright.append("<img class='eqpAquaticBackground' src='img/account/equipment/aquatic.png' />");
		
		// Retrieve and slot the equipment
		var runesets = Q.countRuneSets(char);
		var itemids = [];
		for (var i in char.equipment)
		{
			itemids.push(char.equipment[i].id);
		}
		Q.getItems(itemids, function()
		{
			for (var i in char.equipment)
			{
				(function(iEquipment)
				{
					Q.getItem(iEquipment.id, function(iItem)
					{
						var ithcontainer = $("#eqpContainer_" + char.oCharIndex);
						var slot = ithcontainer.find(".eqpSlot_" + iEquipment.slot);
						var slotimg = (iEquipment.skin) ? U.URL_IMG.Placeholder : iItem.icon;
						var sloticon = $("<img class='eqpIcon' src='" + slotimg + "' />").appendTo(slot);
						Q.scanItem(iItem, {
							aElement: slot,
							aItemMeta: iEquipment,
							aRuneSets: runesets,
							aWantAttr: true,
							aCallback: function(iBox)
							{
								// Set the slot icon as the transmuted skin icon
								ithcontainer.find(".eqpBrief_" + iEquipment.slot).append(formatItemBrief(iBox)).show();
								var skinname = null;
								if (iBox.oSkin)
								{
									skinname = iBox.oSkin.name;
									sloticon.attr("src", iBox.oSkin.icon);
								}
								// If the item is slotted in an attributable slot, (armor, primary weapons, trinkets, not underwater), then tally the attribute points
								if (A.Equipment.AttributableSlots[iEquipment.slot])
								{
									Q.sumAttributeObject(attrobj, iBox.oAttr);
								}
								// Add simulated checkboxes for toggleable armor slots
								if (equiptoggle[iEquipment.slot])
								{
									subcontainer.find(".eqpSlot_" + iEquipment.slot).prepend("<img class='eqpCheckbox' src='img/ui/checkbox.png' />");
								}
								// Add charges number over gathering tools
								if (iItem.type === "Gathering" && iEquipment.charges)
								{
									sloticon.attr("src", iBox.oData.icon);
									subcontainer.find(".eqpSlot_" + iEquipment.slot).prepend("<span class='eqpCharges'>" + iEquipment.charges + "</span>");
								}
								// Bind click behavior for the icon
								Q.bindItemSlotBehavior(sloticon, {
									aItem: iBox.oData,
									aSearch: skinname,
									aWantClick: true
								});
								numfetched++;
								finalizeEquipment();
							}
						});
					});
				})(char.equipment[i]);
			}
		});
		
		// In case the character is wearing nothing, the finalize callback would not have happened
		if (char.equipment.length === 0)
		{
			finalizeEquipment();
		}

		// Hide secondary weapon slots for professions that can't swap weapons
		if ((A.Metadata.Profession[char.oCharProfession]).isswappable === false)
		{
			var elmstoconceal = [".eqpSwap", ".eqpSwapB", ".eqpWeaponB1", ".eqpWeaponB2"];
			var elmstohide = [".eqpSwapAquatic", ".eqpSwapAquaticB", ".eqpWeaponAquaticB"];
			elmstoconceal.forEach(function(iSelector)
			{
				// Set visibility instead of hide so their width and height presence remains
				subcontainer.find(iSelector).css({visibility: "hidden"});
			});
			elmstohide.forEach(function(iSelector)
			{
				subcontainer.find(iSelector).hide();
			});
			subconright.find(".eqpAquaticBackground").addClass("eqpAquaticBackgroundSingle");
			subconright.find(".eqpHelmAquatic").addClass("eqpHelmAquaticSingle");
		}
	},
	
	/*
	 * Generates a specializations panel for a profession.
	 * @param array pTraitLines from character API under "specializations" property.
	 * Example structure: [{"id": 1, "traits": [701, 1889, 704]}, ...]
	 * @param jqobject pContainer to place the trait panel.
	 */
	generateTraits: function(pTraitLines, pContainer)
	{
		if (pTraitLines === undefined || pContainer.is(":empty") === false)
		{
			return;
		}
		
		var traitassoc = {};
		var insertSpecialization = function(pSpecID, pTraits)
		{
			var specline = $("<aside class='spzLine'>"
				+ "<span class='spzLineBackground'></span>"
				+ "<span class='spzLineForeground'></span>"
				+ "<span class='spzLineContent'>"
					+ "<span class='spzSpecSide'><var class='spzSpecSideIcon'></var></span>"
					+ "<span class='spzSpecColumn'><var class='spzSpecName'></var></span>"
					+ "<span class='spzColumn'>"
						+ "<var class='spzMinor spzMinor_10' data-tier='0'><em class='spzCon_01'></em></var>"
					+ "</span>"
					+ "<span class='spzColumn'>"
						+ "<var class='spzMajor_10'><em class='spzCon_10L'></em><em class='spzCon_10R'></em></var><br />"
						+ "<var class='spzMajor_11'><em class='spzCon_11L'></em><em class='spzCon_11R'></em></var><br />"
						+ "<var class='spzMajor_12'><em class='spzCon_12L'></em><em class='spzCon_12R'></em></var><br />"
					+ "</span>"
					+ "<span class='spzColumn'>"
						+ "<var class='spzMinor spzMinor_20' data-tier='1'></var>"
						+ "</var>"
					+ "</span>"
					+ "<span class='spzColumn'>"
						+ "<var class='spzMajor_20'><em class='spzCon_20L'></em><em class='spzCon_20R'></em></var><br />"
						+ "<var class='spzMajor_21'><em class='spzCon_21L'></em><em class='spzCon_21R'></em></var><br />"
						+ "<var class='spzMajor_22'><em class='spzCon_22L'></em><em class='spzCon_22R'></em></var><br />"
					+ "</span>"
					+ "<span class='spzColumn'>"
						+ "<var class='spzMinor spzMinor_30' data-tier='2'></var>"
					+ "</span>"
					+ "<span class='spzColumn'>"
						+ "<var class='spzMajor_30'><em class='spzCon_30L'></em></var><br />"
						+ "<var class='spzMajor_31'><em class='spzCon_31L'></em></var><br />"
						+ "<var class='spzMajor_32'><em class='spzCon_32L'></em></var><br />"
					+ "</span>"
				+ "</span>"
			+ "</aside>").appendTo(pContainer);
			specline.find("img").attr("src", U.URL_IMG.Placeholder);
			
			var formatTraitIcon = function(pTraitID)
			{
				var trait = Q.getBoxedTrait(pTraitID).oData;
				var traitelm = specline.find(".spz" + trait.slot + "_" + trait.tier + trait.order);
				traitelm.css({backgroundImage: "url(" + trait.icon + ")"});
				var traithighlight = "";
				var traitname = "";
				var tier = traitelm.attr("data-tier");
				if (traitassoc[pTraitID] // If the trait present in the character's traits array
					|| pTraits[tier]) // If the traits array is filled up at least to that "tier" (index)
				{
					traitelm.find("em").show(); // Show the connecting line between trait icons
					traithighlight = "spzActive"; // Brighten the active trait icon
					if (trait.slot === "Major")
					{
						traitname = "<span class='spzMajorName'>" + trait.name + "</span>";
					}
				}
				traitelm.append(traitname + "<mark class='" + traithighlight + "'>" + I.Symbol.Filler + "</mark>");
				// Generate tooltip for trait
				Q.analyzeTrait(trait, {aElement: traitelm});
			};
			var formatSpecLine = function()
			{
				var spec = Q.getBoxedSpecialization(pSpecID).oData;
				specline.css({backgroundImage: "url(" + spec.background + ")"});
				specline.find(".spzSpecName").text(spec.name);
				if (spec.elite)
				{
					specline.find(".spzLineBackground").addClass("spzLineBackgroundElite");
				}
				
				var traitids = spec.minor_traits.concat(spec.major_traits);
				traitids.forEach(function(iTraitID)
				{
					formatTraitIcon(iTraitID);
				});
			};
			
			// Generate
			formatSpecLine();
		};
		
		// Prefetch all of this character's specializations and traits
		var specstofetch = [];
		var traitstofetch = [];
		pTraitLines.forEach(function(iLine)
		{
			if (iLine)
			{
				specstofetch.push(iLine.id);
				if (iLine.traits)
				{
					iLine.traits.forEach(function(iTrait)
					{
						if (iTrait)
						{
							traitstofetch.push(iTrait);
							// Convert the traits array into an associative array for highlighting active traits
							traitassoc[iTrait] = true;
						}
					});
				}
			}
		});
		Q.getSpecializations(specstofetch, function()
		{
			// API only shows IDs of active major, so also manually include all the IDs of a spec line
			for (var i in specstofetch)
			{
				var spec = Q.getBoxedSpecialization(specstofetch[i]).oData;
				traitstofetch = traitstofetch.concat(spec.minor_traits.concat(spec.major_traits));
			}
			Q.getTraits(traitstofetch, function()
			{
				// Insert specialization lines to the panel of specific game mode
				pTraitLines.forEach(function(iLine)
				{
					if (iLine)
					{
						// Insert that line of traits into the panel
						insertSpecialization(iLine.id, iLine.traits);
					}
				});
			});
		});
		
	},
	
	/*
	 * Generates a skills bar for a profession.
	 * @param array pSkills from character API under "skills" property.
	 * Example structure: { "heal": 10548, "utilities": [10622, 10606, 10612], "elite": 10646 }
	 * @param jqobject pContainer to place the skills bar.
	 */
	generateSkills: function(pSkills, pContainer)
	{
		if (pSkills === undefined || pContainer.is(":empty") === false)
		{
			return;
		}
		
		var bar = $("<div class='sklBar'></div>").appendTo(pContainer);
		var insertSkill = function(pSkillID, pSlot)
		{
			if (pSkillID)
			{
				var skill = Q.getBoxedSkill(pSkillID).oData;
				pSlot.find(".sklSlotIcon").css({backgroundImage: "url(" + skill.icon + ")"});
				// Include ground targeting icon if skill is so
				for (var i = 0; i < skill.flags.length; i++)
				{
					if (skill.flags[i] === "GroundTargeted")
					{
						pSlot.append("<span class='sklSlotTarget'></span>");
						break;
					}
				}
				// Generate tooltip for trait
				Q.analyzeSkill(skill, {aElement: pSlot});
			}
			else
			{
				// Don't show the select bar over skill slots if the skill is locked
				pSlot.find(".sklSlotSelect, .sklSlotForeground").hide();
			}
		};
		var createSlot = function(pSlotType, pHotkey)
		{
			return $("<aside class='sklSlot sklSlot_" + pSlotType + "'>"
				+ "<span class='sklSlotSelect'></span>"
				+ "<span class='sklSlotLocked'></span>"
				+ "<span class='sklSlotIcon'></span>"
				+ "<span class='sklSlotForeground'></span>"
				+ "<span class='sklSlotHotkey'>" + pHotkey + "</span>"
			+ "</aside>").appendTo(bar);
		};
		
		// First create empty slots
		var heal = createSlot("heal", "6");
		createSlot("utilities0", "7");
		createSlot("utilities1", "8");
		createSlot("utilities2", "9");
		var elite = createSlot("elite", "0");
		
		// Prefetch skills
		var idstofetch = [];
		for (var i in pSkills)
		{
			var ithskill = pSkills[i];
			if (ithskill)
			{
				if (isNaN(ithskill) === false)
				{
					idstofetch.push(ithskill);
				}
				else
				{
					for (var ii in ithskill)
					{
						idstofetch.push(ithskill[ii]);
					}
				}
			}
		}
		
		// Fill the slots by additionally retrieving skill data
		Q.getSkills(idstofetch, function()
		{
			insertSkill(pSkills.heal, heal);
			for (var i = 0; i < pSkills.utilities.length; i++)
			{
				insertSkill(pSkills.utilities[i], bar.find(".sklSlot_utilities" + i));
			}
			insertSkill(pSkills.elite, elite);
		});
	},
	
	/*
	 * Generates inventory of all characters as bank tabs.
	 */
	serveInventory: function()
	{
		if (V.requireCharacters("Inventory"))
		{
			return;
		}
		else if ( ! A.Data.Characters[0].bags)
		{
			A.printError(A.PermissionEnum.Inventories);
			return;
		}
		
		var dish = $("#accDish_Inventory");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		var container = B.createBank(dish);
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var slotdata;
		var tab, slotscontainer, slot;
		var char, bagdata;
		var tabfill = 0;
		var tabcapacity = 0;
		var tabcount = 0;
		var bankfill = 0;
		var bankcapacity = 0;
		var bankcount = 0;
		
		// Fills a tab, which is one character's inventory
		var fillInventory = function(pTab, pCharacter)
		{
			var itemids = [];
			var numfetched = 0;
			var numtofetch = 0;
			slotscontainer = B.getSlotsContainer(pTab.append(I.cThrobber));
			// First count items to fetch
			for (var ii = 0; ii < pCharacter.bags.length; ii++)
			{
				bagdata = pCharacter.bags[ii];
				if (bagdata)
				{
					for (var iii = 0; iii < bagdata.inventory.length; iii++)
					{
						slotdata = bagdata.inventory[iii];
						if (slotdata)
						{
							itemids.push(slotdata.id);
							numtofetch++;
						}
					}
				}
			}
			// Fetch the items and fill slots
			Q.getPricedItems(itemids, function()
			{
				I.removeThrobber(pTab);
				for (var ii = 0; ii < pCharacter.bags.length; ii++)
				{
					bagdata = pCharacter.bags[ii];
					if (bagdata)
					{
						for (var iii = 0; iii < bagdata.inventory.length; iii++)
						{
							slot = B.createBankSlot(slotscontainer);
							slotdata = bagdata.inventory[iii];
							if (slotdata)
							{
								slot.data("count", slotdata.count);
								(function(iSlot, iSlotData)
								{
									Q.getItem(iSlotData.id, function(iItem)
									{
										B.styleBankSlot(iSlot, {aItem: iItem, aSlotMeta: iSlotData, aCallback: function()
										{
											numfetched++;
											A.setProgressBar(numfetched, numtofetch);
										}});
									});
								})(slot, slotdata);
							}
							else
							{
								// For empty inventory slots
								B.styleBankSlot(slot);
							}
						}
					}
				}
			});
		};
		
		$.getJSON(A.getURL(A.URL.Shared), function(pData)
		{
			bank.empty();
			var sharedtab = B.createBankTab(bank, {aTitle: D.getPhraseOriginal("Shared Inventory")});
			tabfill = 0;
			tabcapacity = pData.length;
			bankcapacity = pData.length;
			tabcount = 0;
			// Generate a first tab for the shared inventory slots
			for (var i = 0; i < pData.length; i++)
			{
				slot = B.createBankSlot(B.getSlotsContainer(sharedtab), "bnkSlotShared");
				slotdata = pData[i];
				if (slotdata)
				{
					slot.data("count", slotdata.count);
					tabfill++;
					bankfill++;
					tabcount += slotdata.count;
					bankcount += slotdata.count;
					(function(iSlot, iSlotData)
					{
						Q.getItem(iSlotData.id, function(iItem)
						{
							B.styleBankSlot(iSlot, {aItem: iItem, aSlotMeta: iSlotData});
						});
					})(slot, slotdata);
				}
			}
			B.updateTabTally(sharedtab, tabfill, tabcapacity, tabcount);
			
			// Generate the tabs for each character that fills their inventory after clicking to expand
			for (var i = 0; i < A.Data.Characters.length; i++)
			{
				tabfill = 0;
				tabcapacity = 0;
				tabcount = 0;
				char = A.Data.Characters[i];
				// Bank tab separator for each character
				tab = B.createBankTab(bank, {aTitle: char.oCharPreface, aIsCollapsed: true});
				B.createInventorySidebar(tab, char.bags);
				(function(iTab, iChar)
				{
					iTab.one("click", function()
					{
						fillInventory(iTab, iChar);
					});
				})(tab, char);
				
				// Calculate inventory sizes and stack count
				for (var ii = 0; ii < char.bags.length; ii++)
				{
					bagdata = char.bags[ii];
					if (bagdata)
					{
						for (var iii = 0; iii < bagdata.inventory.length; iii++)
						{
							slotdata = bagdata.inventory[iii];
							if (slotdata)
							{
								tabfill++;
								bankfill++;
								if (slotdata.count)
								{
									tabcount += slotdata.count;
									bankcount += slotdata.count;
								}
							}
						}
						tabcapacity += bagdata.inventory.length;
						bankcapacity += bagdata.inventory.length;
					}
				}
				B.updateTabTally(tab, tabfill, tabcapacity, tabcount);
			}
			B.updateBankTally(container, bankfill, bankcapacity, bankcount);
			B.createBankMenu(bank);
		});
	},
	
	/*
	 * Generates the account's possessions as single item slots in bank tabs.
	 */
	servePossessions: function()
	{
		if (V.requireCharacters("Possessions"))
		{
			return;
		}
		else if ( ! A.Data.Characters[0].bags)
		{
			A.printError(A.PermissionEnum.Inventories);
			return;
		}
		
		var dish = $("#accDish_Possessions");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		var container = B.createBank(dish);
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var slotscontainers = {};
		var tab, slotscontainer, slot;
		
		var generatePossessions = function()
		{
			bank.empty();
			// Bank tab for each item type
			for (var i in Q.ItemEnum)
			{
				tab = B.createBankTab(bank, {aTitle: D.getString(i)});
				slotscontainers[i] = B.getSlotsContainer(tab);
			}
			// Insert item slots into proper type tab
			for (var i in A.Possessions)
			{
				(function(iItemID, iPossession)
				{
					Q.getItem(iItemID, function(iItem)
					{
						slotscontainer = slotscontainers[iItem.type];
						if (slotscontainer)
						{
							slot = B.createBankSlot(slotscontainer);
							B.styleBankSlot(slot,
							{
								aItem: iItem,
								aSlotMeta: {count: iPossession.oCount},
								aComment: A.getFoundString(iPossession)
							});
						}
					});
				})(i, A.Possessions[i]);
			}
			B.createBankMenu(bank);
			B.tallyBank(container);
		};
		
		A.initializePossessions(function()
		{
			Q.getPricedItems(U.convertAssocToArray(A.Possessions), function()
			{
				generatePossessions();
			});
		});
	},
	
	/*
	 * Generates the items catalog bank window.
	 */
	serveCatalog: function()
	{
		B.generateCatalog("Catalog", {
			aIsCustomCatalog: true
		});
	},
	
	/*
	 * Generates the ascended equipment catalog bank window.
	 */
	serveCleanup: function()
	{
		B.generateCatalog("Cleanup", {
			aIsCollection: false,
			aIsLookup: true,
			aWantItems: true,
			aWantGem: false,
			aWantDefaultHelp: false
		});
	},
	
	/*
	 * Generates the ascended equipment catalog bank window.
	 */
	serveAscended: function()
	{
		B.generateCatalog("Ascended", {
			aWantPrices: false,
			aWantGem: false,
			aWantDefaultHelp: false
		});
	},
	
	/*
	 * Generates the learned recipes as a bank categorized by crafting disciplines.
	 */
	serveRecipes: function()
	{
		var section = "Recipes";
		if (V.requireCharacters(section))
		{
			return;
		}
		else if ( ! A.Data.Characters[0].recipes)
		{
			A.printError(A.PermissionEnum.Inventories);
			return;
		}
		
		var dish = $("#accDish_Recipes");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		var container = B.createBank(dish, {
			aIsCollection: true,
			aWantGem: false
		});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		
		// Retrieve data before generating
		U.getScript(U.URL_DATA.Recipes, function()
		{
			var headers = {};
			var metadata = GW2T_RECIPES_METADATA;
			var record = GW2T_RECIPES_DATA;
			
			// Merge the record arrays into one lookup table
			var recipelookup = {}; // Will be used to find a character's unlocked recipe
			var itemlookup = {}; // Will be used to find a character's unlocked recipe by searching with the item
			var searchsubset = {};
			var discname, entry, recipeid, itemid;
			for (var i in record)
			{
				discname = i.split("_")[0];
				for (var ii = 0; ii < record[i].length; ii++)
				{
					entry = (record[i])[ii];
					searchsubset[entry.i] = i;
					if (recipelookup[entry.u] === undefined)
					{
						recipelookup[entry.u] = {
							oItemID: entry.i, // Item ID of crafted product
							oDisciplines: [discname] // Disciplines that can craft this recipe
						};
					}
					else
					{
						recipelookup[entry.u].oDisciplines.push(discname);
					}
				}
			}
			
			// Merge all characters' unlocked recipes array into one
			var unlockeds = [];
			A.Data.Characters.forEach(function(iChar)
			{
				unlockeds = U.getUnion(unlockeds, iChar.recipes);
				// Create a list of items with the characters' names who can craft it
				for (var ii = 0; ii < iChar.recipes.length; ii++)
				{
					recipeid = iChar.recipes[ii];
					if (recipelookup[recipeid])
					{
						itemid = recipelookup[recipeid].oItemID;
						var discnames = recipelookup[recipeid].oDisciplines;
						var discicons = "";
						for (var iii = 0; iii < discnames.length; iii++)
						{
							discname = discnames[iii];
							if (iChar.oCharCraft && iChar.oCharCraft[discname])
							{
								discicons += "<ins class='acc_craft acc_craft_" + discname.toLowerCase() + "'></ins>";
							}
						}
						if (discicons.length)
						{
							if (itemlookup[itemid] === undefined)
							{
								itemlookup[itemid] = [];
							}
							itemlookup[itemid].push(iChar.oCharName + discicons);
						}
					}
				}
			});
			// Add the characters' names to the record so later the style slot function can write them in item tooltips
			var craftstr = D.getPhrase("crafted by", U.CaseEnum.Sentence) + ": ";
			for (var i in record)
			{
				for (var ii = 0; ii < record[i].length; ii++)
				{
					var entry = (record[i])[ii];
					if (itemlookup[entry.i])
					{
						entry.t = "<var class='itmColor_reminder'>" + craftstr + (itemlookup[entry.i]).join(", ") + "</var>";
					}
					else
					{
						delete entry.t;
					}
				}
			}
			
			// Construct tab headers from crafting disciplines and recipe types
			var lang = D.langFullySupported;
			var catname;
			for (var i in metadata.Disciplines)
			{
				for (var ii in metadata.Types)
				{
					catname = i + "_" + ii;
					headers[catname] = {};
					(headers[catname])["name_" + lang] = (metadata.Disciplines[i])[lang] + " " + (metadata.Types[ii])[lang];
				}
			}
			
			// Get the account wide unlocked recipes
			$.getJSON(A.getURL(A.URL.Recipes), function(pData)
			{
				unlockeds = U.getUnion(unlockeds, pData);
				// Generate the bank
				B.generateUnlockables(bank, {
					aHeaders: headers,
					aRecord: record,
					aUnlockeds: unlockeds,
					aIsCollapsed: true,
					aTabIterator: function(pCatName)
					{
						var discipline = pCatName.split("_")[0];
						var catname = D.getObjectName(headers[pCatName]);
						var caticon = "<ins class='bnkTabIcon acc_craft acc_craft_" + discipline.toLowerCase() + "'></ins>"
							+ "<ins class='bnkTabIcon acc_recipes acc_recipes_" + pCatName.toLowerCase() + "'></ins>";
						var tab = B.createBankTab(bank, {
							aID: "rcpTab_" + pCatName,
							aTitle: catname,
							aIcon: caticon,
							aIsCollapsed: true
						});
						return tab;
					}
				});

				/*
				 * Piggyback on the bank search bar (created by the generate unlockables
				 * function) and make it print the characters who have unlocked the
				 * recipe to create that searched item.
				 */
				var searchbar = B.getBankSearch(section);
				Q.bindItemSearch(searchbar, {
					aSubset: searchsubset,
					aFillerText: null,
					aCallback: function(pItem)
					{
						var itemname = "&quot;<a" + U.convertExternalAnchor(U.getWikiLinkLanguage(pItem.name)) + ">" + pItem.name + "</a>&quot;";
						if (itemlookup[pItem.id])
						{
							var charnames = (itemlookup[pItem.id]).join(", ");
							I.write(itemname + " was learned and can be crafted by:<br /><br />" + charnames);
						}
						else
						{
							I.write("None of your characters have learned how to craft " + itemname);
						}
						// Show the tab the item is in
						B.scrollToBankTab("#rcpTab_" + searchsubset[pItem.id]);
					}
				});
			});
		});
	},
	
	/*
	 * Generates Super Adventure Box per-character unlocks.
	 */
	serveSAB: function()
	{
		var section = "SAB";
		if (V.requireCharacters(section))
		{
			return;
		}
		
		var dish = $("#accDish_SAB");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var record, headers;
		var elmprefix = "sabProgressionBanner_";
		var createBank = function(pUnlockAssoc, pCharacter)
		{
			var container = B.createBank(dish, {
				aIsCollection: true,
				aWantGem: false,
				aWantCoin: false
			});
			A.createCharacterBanner(container, pCharacter, elmprefix);
			var bank = B.getTabsContainer(container);
			var tab, slotscontainer, slot, unlock;
			
			for (var i in record)
			{
				tab = B.createBankTab(bank, {aTitle: D.getObjectName(headers[i])});
				slotscontainer = B.getSlotsContainer(tab);
				for (var ii in record[i])
				{
					unlock = (record[i])[ii];
					slot = B.createPseudoSlot(slotscontainer, {
						aName: unlock.n,
						aTooltip: unlock.t || unlock.n,
						aIcon: "img/account/sab/" + unlock.i + I.cPNG,
						aIsUnlocked: pUnlockAssoc[unlock.u],
						aLabel: unlock.l
					});
				}
			}
			B.tallyBank(container);
			B.createBankDivider(container);
		};
		
		// Turns the API's multiple arrays into one associative array
		var flattenUnlocks = function(pData)
		{
			var unlockassoc = {};
			for (var i in pData)
			{
				for (var ii in pData[i])
				{
					var newid = i + "_" + (pData[i])[ii].id; // This is the ID as it appears in the custom record
					unlockassoc[newid] = true;
				}
			}
			return unlockassoc;
		};
		
		// Retrieve data and unlocks
		dish.prepend(I.cThrobber);
		U.getScript(U.URL_DATA.SAB, function()
		{
			headers = U.getRecordHeader(section);
			record = U.getRecordData(section);
			U.fetchPattern(A.getURL(A.URL.CharactersSAB), A.Data.CharacterNames, {aCallback: function(pData, pLength)
			{
				I.removeThrobber(dish);
				if (pLength)
				{
					var validcharacters = [];
					for (var i in pData)
					{
						// Only create a bank for a character if it has any unlocks
						var idata = pData[i];
						if (idata.zones && idata.unlocks && idata.songs &&
							(idata.zones.length || idata.unlocks.length || idata.songs.length))
						{
							var ichar = A.getCharacterByName(i);
							validcharacters.push(ichar);
							createBank(flattenUnlocks(pData[i]), ichar);
						}
					}
					// Create characters bar after generating banks
					if (validcharacters.length > 1)
					{
						A.createCharacterScroller(validcharacters, section, {
							aElementPrefix: elmprefix,
							aOffset: -120 // Consider the character banner
						});
					}
				}
				else
				{
					A.printError(A.PermissionEnum.Progression);
				}
			}});
		});
	},
	
	/*
	 * Generates the items bank window.
	 */
	serveBank: function()
	{
		var dish = $("#accDish_Bank");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var container = B.createBank(dish);
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var slotdata;
		var tab, slotscontainer, slot;
		var nexti;
		var numitems = 0;
		var numfetched = 0;
		var numtofetch = 0;
		var doGenerate = function(pData)
		{
			// First generate empty bank slots, then fill them up asynchronously by item details retrieval
			bank.empty();
			for (var i = 0; i < pData.length; i++)
			{
				// Bank tab separator every so slots
				if ((i === 0 || nexti % A.Metadata.Bank.NumSlotsPerTab === 0) && nexti !== pData.length)
				{
					tab = B.createBankTab(bank);
					slotscontainer = B.getSlotsContainer(tab);
				}
				nexti = i+1;

				slot = B.createBankSlot(slotscontainer);
				slotdata = pData[i];
				// Line breaks (new rows) are automatically rendered by the constant width of the bank's container
				if (slotdata)
				{
					slot.data("count", slotdata.count);
					numitems += slotdata.count;
					(function(iSlot, iSlotData)
					{
						Q.getItem(iSlotData.id, function(iItem)
						{
							B.styleBankSlot(iSlot, {aItem: iItem, aSlotMeta: iSlotData, aCallback: function()
							{
								numfetched++;
								A.setProgressBar(numfetched, numtofetch);
							}});
						});
					})(slot, slotdata);
				}
				else
				{
					// For empty inventory slots
					B.styleBankSlot(slot);
				}
			}
			// Update tallies
			B.tallyBank(container);
			// Ornamental bank tab separator at the bottom
			bank.append("<div class='bnkTabSeparator'><var class='bnkTabLocked'>" + I.Symbol.Filler + "</var></div>");
			// Create search bar
			B.createBankMenu(bank);
		};
		
		// Get bank information and prefetch item data
		$.getJSON(A.getURL(A.URL.Bank), function(pData)
		{
			// Count the number of items in the bank first, because empty slots are written as "null" in the API
			var result = A.iterateInventory(pData, function()
			{
				numtofetch++;
			});
			
			Q.getPricedItems(result.oItemIDs, function()
			{
				Q.getSkins(result.oSkinIDs, function()
				{
					doGenerate(pData);
				});
			});
		}).fail(function(pRequest, pStatus)
		{
			A.printError(A.PermissionEnum.Inventories, pStatus);
			dish.empty();
		});
	},
	
	/*
	 * Generates the guild bank window for all permitting guilds.
	 */
	serveVault: function()
	{
		var dish = $("#accDish_Vault");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		var container = B.createBank(dish);
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var guild;
		var tab, slotscontainer, slot;
		var sortedvaults = [], vault, subvault;
		var subbankname = {
			"0": D.getString("GuildStash"),
			"1": D.getString("TreasureTrove"),
			"2": D.getString("DeepCave")
		};
		
		var generateVault = function()
		{
			var itemids = [];
			var numitems = 0;
			var numfetched = 0;
			var numtofetch = 0;
			// First order the vaults by the number of unique items they have
			for (var i in A.Data.Vaults)
			{
				vault = A.Data.Vaults[i];
				var uniqueitems = {};
				var uniquecount = 0;
				vault.forEach(function(iSubvault)
				{
					iSubvault.inventory.forEach(function(iSlotData)
					{
						if (iSlotData)
						{
							numtofetch++;
							if (uniqueitems[iSlotData.id] === undefined)
							{
								uniqueitems[iSlotData.id] = true;
								uniquecount++;
								itemids.push(iSlotData.id);
							}
						}
					});
				});
				vault.oGuildID = i;
				vault.oUniqueCount = uniquecount;
				sortedvaults.push(vault);
			}
			U.sortObjects(sortedvaults, {aKeyName: "oUniqueCount", aIsDescending: true});
			
			Q.getPricedItems(itemids, function()
			{
				bank.empty();
				// Fill the vaults
				for (var i in sortedvaults)
				{
					vault = sortedvaults[i];
					guild = Q.getCachedGuild(vault.oGuildID);
					if (!guild)
					{
						continue;
					}
					for (var ii = 0; ii < vault.length; ii++)
					{
						subvault = vault[ii];
						tab = B.createBankTab(bank, {aTitle: guild.oTag + " " + subbankname[ii]});
						slotscontainer = B.getSlotsContainer(tab);
						subvault.inventory.forEach(function(iSlotData)
						{
							slot = B.createBankSlot(slotscontainer);
							// Line breaks (new rows) are automatically rendered by the constant width of the bank's container
							if (iSlotData)
							{
								slot.data("count", iSlotData.count);
								numitems += iSlotData.count;
								(function(iSlot, iSlotData)
								{
									Q.getItem(iSlotData.id, function(iItem)
									{
										B.styleBankSlot(iSlot, {aItem: iItem, aSlotMeta: iSlotData, aCallback: function()
										{
											numfetched++;
											A.setProgressBar(numfetched, numtofetch);
										}});
									});
								})(slot, iSlotData);
							}
							else
							{
								// For empty inventory slots
								B.styleBankSlot(slot);
							}
						});
					}
				}
				// Update tallies
				B.tallyBank(container);
				// Create search bar
				B.createBankMenu(bank);
			});
		};
		
		// Retrieve guilds and guild data
		$.getJSON(A.getURL(A.URL.Account), function(pData)
		{
			A.Data.Account = pData;
			A.initializeVault(function(pData)
			{
				if (pData)
				{
					generateVault();
				}
				else
				{
					bank.empty();
				}
			});
		}).fail(function(pRequest, pStatus)
		{
			bank.empty();
			A.printError(A.PermissionEnum.Account, pStatus);
		});
	},
	
	/*
	 * Generates the crafting materials window.
	 */
	serveMaterials: function()
	{
		var section = "Materials";
		var dish = $("#accDish_" + section);
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var container = B.createBank(dish, {
			aIsCollection: false,
			aWantGem: false
		});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var doGenerate = function(pUnlockeds)
		{
			var entry;
			var unlockeds = {};
			// Reformat the unlockeds array from API
			for (var i in pUnlockeds)
			{
				entry = pUnlockeds[i];
				if (entry.count > 0)
				{
					unlockeds[entry.id] = {
						oCount: entry.count
					};
				}
			}
			B.generateUnlockables(bank, {
				aHeaders: U.getRecordHeader(section),
				aRecord: U.getRecordData(section),
				aUnlockeds: unlockeds,
				aWantSearchHighlight: false,
				aWantDefaultHelp: false
			});
		};
		
		U.getScript(U.URL_DATA.Materials, function()
		{
			$.getJSON(A.getURL(A.URL.Materials), function(pData)
			{
				Q.loadItemsSubdatabase(section.toLowerCase(), function()
				{
					doGenerate(pData);
				});
			}).fail(function(pRequest, pStatus)
			{
				A.printError(A.PermissionEnum.Inventories, pStatus);
				dish.empty();
			});
		});
	},
	
	/*
	 * Generates the skin wardrobe window.
	 */
	serveWardrobe: function()
	{
		var dish = $("#accDish_Wardrobe");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var section = "Wardrobe";
		var headers, galleries, record;
		var galleryword = D.getWordCapital("gallery");
		// Macro function to add link to gallery buttons next to the tab separators
		var createGalleryLinks = function(pTab, pCategory)
		{
			var galkey = headers[pCategory].set || pCategory;
			var link = galleries[galkey];
			var hoverelm = $("<aside class='bnkTabHover'></aside>").prependTo(pTab.find(".bnkTabSeparator"));
			if (typeof link === "string")
			{
				$("<button class='bnkTabHoverButton'>" + galleryword + "</button>").click(function(pEvent)
				{
					pEvent.stopPropagation();
					U.openExternalURL(link);
				}).appendTo(hoverelm);
			}
			else
			{
				var counter = 0;
				for (var i in link)
				{
					counter++;
					(function(iLink)
					{
						$("<button class='bnkTabHoverButton'><img src='img/account/characters/" + i.toLowerCase() + ".png' /></button>").click(function(pEvent)
						{
							pEvent.stopPropagation();
							U.openExternalURL(iLink);
						}).appendTo(hoverelm);
					})(link[i]);
					if (counter % 2 === 0)
					{
						hoverelm.append("<br />");
					}
				}
			}
		};
		
		var container = B.createBank(dish, {aIsCollection: true});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var generateWardrobe = function(pUnlockeds)
		{
			galleries = GW2T_SKINS_GALLERIES;
			headers = GW2T_SKINS_HEADERS;
			record = GW2T_SKINS_DATA;
			
			B.generateUnlockables(bank, {
				aHeaders: headers,
				aRecord: record,
				aUnlockeds: pUnlockeds,
				aIsCollapsed: true,
				aTabIterator: function(pCatName)
				{
					var catname = D.getObjectName(headers[pCatName]);
					var caticon = "<ins class='bnkTabIcon acc_wardrobe acc_wardrobe_" + pCatName.toLowerCase() + "'></ins>";
					var tab = B.createBankTab(bank, {
						aID: "wrdTab_" + pCatName,
						aTitle: catname,
						aIcon: caticon,
						aIsCollapsed: true
					});
					createGalleryLinks(tab, pCatName);
					return tab;
				}
			});
			
			// Piggyback on the bank search bar with custom search for skin items
			var searchsubset = {};
			A.iterateRecord(record, function(pEntry, pCatName)
			{
				searchsubset[pEntry.i] = pCatName;
			});

			Q.bindItemSearch(B.getBankSearch(section), {
				aSubset: searchsubset,
				aFillerText: null,
				aCallback: function(pItem)
				{
					// Show the tab the item is in
					B.scrollToBankTab("#wrdTab_" + searchsubset[pItem.id]);
				}
			});
		};
		
		// Retrieve data before generating
		U.getScript(U.URL_DATA.Skins, function()
		{
			$.getJSON(A.getURL(A.URL.Skins), function(pData)
			{
				generateWardrobe(pData);
			}).fail(function(pRequest, pStatus)
			{
				A.printError(A.PermissionEnum.Unlocks, pStatus);
				dish.empty();
			});
		});
	},
	
	/*
	 * Generates a standard unlockables collection window without extra features.
	 * @param string pSection
	 * @objparam boolean aWantPrices to prefetch TP prices for all items, optional.
	 * @objparam boolean aWantGem whether to display the gem tally, optional.
	 * @objparam enum aPermission required for those unlockables, optional.
	 * @objparam function aCallback to execute after generate.
	 */
	serveUnlockables: function(pSection, pSettings)
	{
		var section = pSection;
		var dish = $("#accDish_" + section);
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		var Settings = pSettings || {};
		
		var container = B.createBank(dish, {
			aIsCollection: true,
			aWantGem: Settings.aWantGem
		});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var doGenerate = function(pUnlockeds)
		{
			B.generateUnlockables(bank, {
				aHeaders: U.getRecordHeader(section),
				aRecord: U.getRecordData(section),
				aUnlockeds: pUnlockeds,
				aWantPrices: (Settings.aWantPrices !== false) ? true : false,
				aCallback: Settings.aCallback
			});
		};
		
		U.getScript(U.URL_DATA[section], function()
		{
			$.getJSON(A.getURL(A.URL[section]), function(pData)
			{
				Q.loadItemsSubdatabase(section.toLowerCase(), function()
				{
					doGenerate(pData);
				});
			}).fail(function(pRequest, pStatus)
			{
				A.printError(Settings.aPermission || A.PermissionEnum.Unlocks, pStatus);
				dish.empty();
			});
		});
	},
	serveOutfits: function()
	{
		V.serveUnlockables("Outfits", {aWantPrices: false});
	},
	serveGliders: function()
	{
		V.serveUnlockables("Gliders", {aWantPrices: false});
	},
	serveMinis: function()
	{
		V.serveUnlockables("Minis");
	},
	serveCarriers: function()
	{
		V.serveUnlockables("Carriers");
	},
	serveChampions: function()
	{
		V.serveUnlockables("Champions");
	},
	serveFinishers: function()
	{
		V.serveUnlockables("Finishers");
	},
	serveNodes: function()
	{
		V.serveUnlockables("Nodes");
	},
	serveCats: function()
	{
		V.serveUnlockables("Cats", {aPermission: A.PermissionEnum.Progression, aWantGem: false, aCallback: function(pReturn)
		{
			A.embedFrame("#accDish_Cats", G.getCollectibleURL(X.Collectibles.HungryCats, pReturn.aUnlockAssoc));
		}});
	},
	serveRaids: function()
	{
		V.serveUnlockables("Raids", {aPermission: A.PermissionEnum.Progression, aWantPrices: false, aWantGem: false, aCallback: function()
		{
			T.isChecklistCountdownsStarted = true;
			$("#accDish_Raids").prepend("<div class='accCountdown jsCountdownToWeekly'></div>");
		}});
	},
	serveDungeons: function()
	{
		V.serveUnlockables("Dungeons", {aPermission: A.PermissionEnum.Progression, aWantPrices: false, aWantGem: false, aCallback: function()
		{
			T.isChecklistCountdownsStarted = true;
			$("#accDish_Dungeons").prepend("<div class='accCountdown jsCountdownToDaily'></div>");
		}});
	},
	
	/*
	 * Generates the dye color collection window.
	 */
	serveDyes: function()
	{
		var dish = $("#accDish_Dyes");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var container = B.createBank(dish, {
			aClass: "bnkBankDyes",
			aIsPseudo: true
		});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		U.getScript(U.URL_DATA.Dyes, function()
		{
			$.getJSON(A.getURL(A.URL.Dyes), function(pData)
			{
				B.generateUnlockables(bank, {
					aHeaders: GW2T_DYES_HEADERS,
					aRecord: GW2T_DYES_DATA,
					aUnlockeds: pData,
					aWantDefaultHelp: false,
					aWantSearchHighlight: false,
					aIsDyes: true
				});
			}).fail(function(pRequest, pStatus)
			{
				A.printError(A.PermissionEnum.Unlocks, pStatus);
				dish.empty();
			});
		});
	},
	
	/*
	 * Generates and tallies achievement points.
	 */
	serveAchievements: function()
	{
		var dish = $("#accDish_Achievements");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var section = "Achievements";
		var unlocks = {};
		var searchdb = [];
		var generateBank = function(pData)
		{
			I.removeThrobber(dish);
			var container = B.createBank(dish, {
				aIsPseudo: true
			});
			var bank = B.getTabsContainer(container);
			var tab, slot;
			var categorizedach = {};
			var categories = {}, cat, achid, box, ithach, ithunlock, processedach;
			
			var createTab = function(pCategory)
			{
				tab = B.createBankTab(bank, {
					aID: "achTab_" + pCategory.id,
					aTitle: pCategory.name,
					aIcon: "<img class='bnkTabIcon' src='" + pCategory.icon + "' />"
				});
				
				// Compute all achievements for showing on the bank and tab tallies
				for (var ii = 0; ii < pCategory.achievements.length; ii++)
				{
					achid = pCategory.achievements[ii];
					box = Q.getBoxedAchievement(achid);
					if (box)
					{
						categorizedach[achid] = true;
						ithach = box.oData;
						ithunlock = unlocks[achid];
						processedach = Q.processAchievement(ithach, ithunlock);
						
						B.updateSlotPrice(tab, {
							aIsTab: true,
							aCount: (ithunlock && ithunlock.done) ? 1 : 0,
							aPrice: processedach.oAPPointCurrent,
							aPossible: processedach.oAPPointPossible,
							aPaymentEnum: "achievement"
						});
						// Create search database
						if (ithach.icon === undefined)
						{
							ithach.icon = pCategory.icon;
						}
						ithach.oCategoryName = pCategory.name;
						ithach.oCategoryID = pCategory.id;
						ithach.keywords = ithach.name.toLowerCase() + " " + pCategory.name.toLowerCase();
						searchdb.push(ithach);
					}
				}
				
				// Generate the slots on demand when a tab is expanded
				(function(iTab)
				{
					iTab.find(".bnkTabSeparator").one("click", function()
					{
						var slotscontainer = B.getSlotsContainer(iTab);
						for (var ii = 0; ii < pCategory.achievements.length; ii++)
						{
							achid = pCategory.achievements[ii];
							box = Q.getBoxedAchievement(achid);
							if (box)
							{
								ithach = box.oData;
								ithunlock = unlocks[achid];
								processedach = Q.processAchievement(ithach, ithunlock);
								
								slot = B.createPseudoSlot(slotscontainer, {
									aID: "achSlot_" + achid,
									aIsUnlocked: (ithunlock && ithunlock.done) ? true : false,
									aName: ithach.name,
									aLabel: ithach.name,
									aIcon: pCategory.icon,
									aPayment: {achievement: processedach.oAPPointCurrent},
									aIsTab: false,
									aPossible: processedach.oAPPointPossible,
									aCard: Q.analyzeAchievement(ithach, {aAchievement: processedach, aWantCard: true}),
									aTooltip: Q.analyzeAchievement(ithach, {aAchievement: processedach}),
									aKeywords: pCategory.name + " " + ithach.name + " " + ithach.requirement
								});
								// Include a completion percent if this achievement is partially participated
								var apratio = processedach.oAPCountCurrent / processedach.oAPCountPossible;
								if (apratio < 1 && processedach.oAPCountPossible > 1)
								{
									slot.append("<var class='bnkSlotCount'>" + processedach.oAPCountCurrent + "/" + processedach.oAPCountPossible + "</var>");
								}
								
								// Right click achievement slot prints raw data
								(function(iAchievement, iUnlock, iProcessed)
								{
									slot.contextmenu(function(pEvent)
									{
										pEvent.preventDefault();
										I.prettyJSON(iAchievement);
										I.prettyJSON(iUnlock);
										I.prettyJSON(iProcessed);
									});
								})(ithach, ithunlock, processedach);
							}
						}
					});
				})(tab);
			};
			
			// Create the achievement category tabs in the same order as the game, not the API
			pData.forEach(function(iCategory)
			{
				categories[iCategory.id] = iCategory;
			});
			A.Metadata.AchievementCategories.forEach(function(iCategoryID)
			{
				if (typeof iCategoryID === "object")
				{
					B.createTabDivider(bank, {aTitle: D.getObjectTranslation(iCategoryID)});
				}
				else
				{
					cat = categories[iCategoryID];
					if (cat)
					{
						createTab(cat);
						delete categories[iCategoryID]; // Any unknown categories will remain in the assoc
					}
					else if (iCategoryID === -1) // Extra category for achievements without a category
					{
						var fauxcategory = {
							name: "",
							icon: "img/ui/unknown.png",
							achievements: []
						};
						for (var i in Q.Boxes.Achievements)
						{
							if (categorizedach[i] === undefined)
							{
								fauxcategory.achievements.push(i);
							}
						}
						createTab(fauxcategory);
					}
				}
			});
			// Include any unknown categories not in the pre-sorted achievement categories
			for (var i in categories)
			{
				createTab(categories[i]);
			}
			
			// Finish up UI
			B.tallyBank(container);
			B.createBankDivider(container);
			B.createBankMenu(bank, {
				aIsPseudo: true,
				aIsCollapsed: true,
				aWantCard: true,
				aWantSearchHighlight: true
			});
			// Total the account's achievement points
			$.getJSON(A.getURL(A.URL.Account), function(pData)
			{
				var bankap = B.getBankPrice(container);
				var dailyap = pData.daily_ap;
				var monthlyap = pData.monthly_ap;
				container.find(".bnkPrice").append("<div class='achBankTotal'>"
					+ E.formatAchievement(bankap[0]) + " + "
					+ dailyap.toLocaleString() + "<img class='css24' src='img/account/summary/daily.png' /> + "
					+ monthlyap.toLocaleString() + "<img class='css24' src='img/account/summary/monthly.png' /> = "
					+ "<var class='achBankActual'>" + E.formatAchievement(bankap[0] + dailyap + monthlyap) + "</var>"
					+ " / " + E.formatAchievement(bankap[0] + bankap[1] + Q.GameLimit.DailyAP)
				+ "</div>");
			});
			
			// Piggyback on the bank search bar with custom search for achievements
			Q.bindItemSearch(B.getBankSearch(section), {
				aDatabase: searchdb,
				aFillerText: null,
				aAchievements: unlocks,
				aCallback: function(pAch)
				{
					// Scroll to the bank tab (category) when clicked on an achievement in the search results
					B.showBankTab($("#achTab_" + pAch.oCategoryID));
					I.scrollToElement($("#achSlot_" + pAch.id), {
						aOffset: -A.getOverheadHeight(),
						aSpeed: "fast"
					});
				}
			});
		};
		
		dish.prepend(I.cThrobber);
		// Get account's achievement unlocks
		U.getJSON(A.getURL(A.URL.Achievements), function(pAccountAch)
		{
			// Convert array into associative array for constant access
			pAccountAch.forEach(function(iUnlock)
			{
				unlocks[iUnlock.id] = iUnlock;
			});
			// Get achievement categories
			U.getJSON(U.getAPI("achievements/categories", true), function(pCategories)
			{
				// Get cache of all achievements
				U.getJSON(U.getCacheURL(section), function(pAchievements)
				{
					Q.initializeBoxes(section, pAchievements);
					generateBank(pCategories);
				});
			});
		}).fail(function()
		{
			A.printError(A.PermissionEnum.Progression);
		});
	},
	
	/*
	 * Generates mastery unlocks.
	 */
	serveMasteries: function()
	{
		var dish = $("#accDish_Masteries");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var unlockassoc = {};
		var generateBank = function(pData)
		{
			I.removeThrobber(dish);
			var container = B.createBank(dish, {
				aIsPseudo: true
			});
			var bank = B.getTabsContainer(container);
			var tab, slotscontainer, slot;
			var ithmastery;
			
			pData.forEach(function(iLine)
			{
				tab = B.createBankTab(bank, {aTitle: iLine.name});
				slotscontainer = B.getSlotsContainer(tab);
				for (var ii = 0; ii < iLine.levels.length; ii++)
				{
					ithmastery = iLine.levels[ii];
					slot = B.createPseudoSlot(slotscontainer, {
						aIsUnlocked: unlockassoc[iLine.id + "_" + ii],
						aName: ithmastery.name,
						aIcon: ithmastery.icon,
						aLabel: ithmastery.name,
						aTooltip: Q.analyzeAchievement(ithmastery, {
							aClass: "itmTooltipMastery",
							aWantIcon: true
						}),
						aCard: Q.analyzeAchievement(ithmastery, {aWantCard: true}),
						aPayment: {mastery: ithmastery.point_cost}
					});
				}
			});
			B.tallyBank(container);
			B.createBankDivider(container);
			B.createBankMenu(bank, {
				aIsPseudo: true,
				aWantCard: true
			});
		};
		
		// Get all possible masteries
		dish.prepend(I.cThrobber);
		U.getJSON(U.getAPI("masteries", true), function(pData)
		{
			// Get account's mastery unlocks
			U.getJSON(A.getURL(A.URL.Masteries), function(pDataInner)
			{
				/*
				 * The API gives how far in the mastery line the account has
				 * progressed (array length) rather than the ID of mastery unlocked.
				 * Level 0 counts as completing the first mastery in the line;
				 * a line not in the account unlocks means no point was spent on it.
				 */
				pDataInner.forEach(function(iLine)
				{
					for (var ii = 0; ii <= iLine.level; ii++)
					{
						// Create a custom ID based on mastery line ID and the mastery's array index
						unlockassoc[iLine.id + "_" + ii] = true;
					}
				});
				generateBank(pData);
			}).fail(function()
			{
				A.printError(A.PermissionEnum.Progression);
			});
		});
	},
	
	/*
	 * Generates the gem exchange columns in the Trading section.
	 */
	generateExchange: function()
	{
		var container = $("#accTrading");
		var rowduration = 100;
		var blurduration = 200;
		var goldsamples = $("#exgGoldSamples");
		var gemsamples = $("#exgGemSamples");
		var animateRows = function(pElements)
		{
			pElements.find("tr").each(function(i) {
				$(this).css({opacity: 0})
					.delay(i * (rowduration / 2))
					.animate({opacity: 1}, rowduration);
			});
		};
		var removeBlur = function()
		{
			setTimeout(function()
			{
				container.find(".cssBlur").removeClass("cssBlur");
			}, blurduration);
		};
		var fillExchange = function()
		{
			goldsamples.empty().html(I.cThrobber);
			gemsamples.empty().html(I.cThrobber);
			E.updateExchangeRatios(function()
			{
				goldsamples.empty();
				A.Metadata.Exchange.GoldSamples.forEach(function(iSample)
				{
					goldsamples.prepend("<tr>"
						+ "<td>" + iSample.toLocaleString() + "<img class='exgUnit' src='img/account/trading/gold_small.png' /></td>"
						+ "<td>" + E.formatCoinToGem(iSample * E.Exchange.COPPER_IN_GOLD) + "</td>"
						+ "<td>" + E.formatGemToMoney(E.convertCoinToGem(iSample * E.Exchange.COPPER_IN_GOLD)) + "</td>"
					+ "</tr>");
				});
				animateRows(goldsamples);
				
				gemsamples.empty();
				A.Metadata.Exchange.GemSamples.forEach(function(iSample)
				{
					gemsamples.prepend("<tr>"
						+ "<td>" + iSample.toLocaleString() + "<img class='exgUnit' src='img/account/trading/gem_small.png' /></td>"
						+ "<td>" + E.formatGemToCoin(iSample) + "</td>"
						+ "<td>" + E.formatGemToMoney(iSample) + "</td>"
					+ "</tr>");
				});
				animateRows(gemsamples);
			});
		};
		
		// Initialize
		I.loadImg(container);
		$("#exgGoldTitle").text(D.getPhraseOriginal("Get Coin"));
		$("#exgGemTitle").text(D.getPhraseOriginal("Get Gem"));
		fillExchange();
		
		// Custom exchange
		var goldcustom = $("#exgGoldCustom");
		var gemcustom = $("#exgGemCustom");
		var goldinput = goldcustom.find(".exgCustomInput");
		var geminput = gemcustom.find(".exgCustomInput");
		var goldoutput0 = goldcustom.find(".exgCustomOutput0");
		var goldoutput1 = goldcustom.find(".exgCustomOutput1");
		var gemoutput0 = gemcustom.find(".exgCustomOutput0");
		var gemoutput1 = gemcustom.find(".exgCustomOutput1");
		goldinput.on("input", $.throttle(Q.cSEARCH_LIMIT, function()
		{
			var val = parseInt($(this).val());
			if (val > 0)
			{
				E.updateGemInCoin(function()
				{
					goldoutput0.html(E.formatCoinToGem(val * E.Exchange.COPPER_IN_GOLD)).addClass("cssBlur");
					goldoutput1.html(E.formatGemToMoney(E.convertCoinToGem(val * E.Exchange.COPPER_IN_GOLD))).addClass("cssBlur");
					removeBlur();
				});
			}
		})).trigger("input");
		geminput.on("input", $.throttle(Q.cSEARCH_LIMIT, function()
		{
			var val = parseInt($(this).val());
			if (val > 0)
			{
				E.updateGemInCoin(function()
				{
					gemoutput0.html(E.formatGemToCoin(val)).addClass("cssBlur");
					gemoutput1.html(E.formatGemToMoney(val)).addClass("cssBlur");
					removeBlur();
				});
			}
		})).trigger("input");
		
		// Search bar to place an item's gold value into the custom gold exchange
		var itemsearch = $("#exgItemSearch");
		var itemquantity = $("#exgItemQuantity");
		var itempricetype = $("#exgItemPriceType");
		var exchangeItem = function(pPrice)
		{
			var price;
			if (pPrice)
			{
				price = pPrice;
				itemsearch.data("price", pPrice);
			}
			else
			{
				price = itemsearch.data("price");
			}
			var quantity = T.parseQuantity(itemquantity.val());
			var pricequantity = (quantity * price);
			var itemgold = (pricequantity > E.Exchange.COPPER_IN_GOLD) ? Math.ceil(pricequantity / E.Exchange.COPPER_IN_GOLD) : 1;
			goldinput.val(itemgold).trigger("input");
		};
		Q.bindItemSearch(itemsearch, {aCallback: function(pItem)
		{
			E.getPrice(pItem.id, function(pPrice)
			{
				var price = (itempricetype.prop("checked")) ? pPrice.oPriceSell : pPrice.oPriceBuy;
				exchangeItem(price);
			});
		}});
		itemquantity.change(function()
		{
			exchangeItem();
		});
		
		// Button to refresh exchange rates
		$("#exgReload").click(function()
		{
			goldinput.trigger("input");
			geminput.trigger("input");
			fillExchange();
		});
	},
	
	/*
	 * Generates the recent transactions column of the Trading section.
	 */
	generateRecent: function()
	{
		$("#trsRecentTitle").text(D.getPhraseOriginal("Recent"));
		var table = $("#trsRecentTable");
		var reloader = $("#trsRecentReload");
		var transactionsrecentlimit = 20;
		var bought, sold, combined;
		var boughtword = D.getWordCapital("bought");
		var soldword = D.getWordCapital("sold");
		
		var fillRecent = function()
		{
			var nowms = (new Date()).getTime();
			table.empty();
			reloader.removeClass("jsSuspended");
			A.adjustAccountScrollbar();
			
			combined.forEach(function(iTransaction)
			{
				var item = Q.getCachedItem(iTransaction.item_id);
				var row = $("<tr></tr>").appendTo(table);
				var timestamp = (new Date(iTransaction.purchased)).toLocaleString();
				var type = (iTransaction.isBought) ? boughtword : soldword;
				var quantitystr = (iTransaction.quantity > 1) ? ("<var class='trsRecentCount'>" + iTransaction.quantity + "</var>") : "";
				row.html("<td>"
					+ "<span class='trsRecentItem'>"
						+ "<span class='trsRecentSlot'><img class='trsRecentIcon' src='" + item.icon + "' />" + quantitystr + "</span>"
						+ "<span class='trsRecentName'>"
							+ "<var class='trsRecentType'>" + type + "</var>: <var class='" + Q.getRarityClass(item.rarity) + "'>" + item.name + "</var>"
						+ "</span>"
					+ "</span>"
					+ "<span>"
						+ "<var class='trsRecentTime' title='" + timestamp + "'>" + T.formatMilliseconds(nowms - (new Date(iTransaction.purchased)).getTime()) + "</var>"
						+ "<var class='trsRecentPrice'>" + E.formatCoinStringColored(iTransaction.quantity * iTransaction.price) + "</var>"
					+ "</span>"
				+ "</td>");
				var slot = row.find(".trsRecentSlot");
				I.qTip.init(row.find(".trsRecentTime"));
				Q.scanItem(item, {aElement: slot});
				Q.bindItemSlotBehavior(slot, {aItem: item, aWantClick: true});
			});
		};
		var dealError = function()
		{
			table.html("<tr><td class='trsRecentError'>" + D.getPhraseOriginal("No transactions") + ".</td></tr>");
			reloader.removeClass("jsSuspended");
		};
		var retrieveTransactions = function()
		{
			table.empty().html(I.cThrobber);
			// Retrieves the first page of the historical transactions
			U.getJSON(A.getURL(A.URL.HistoryBuys), function(pData)
			{
				bought = pData;
				U.getJSON(A.getURL(A.URL.HistorySells), function(pDataInner)
				{
					sold = pDataInner;
					// Get the first few transactions from the retrieved
					for (var i = 0; i < bought.length; i++)
					{
						bought[i].isBought = true;
					}
					combined = bought.concat(sold);
					U.sortObjects(combined, {aKeyName: "purchased", aIsDescending: true});
					combined = combined.slice(0, transactionsrecentlimit);
					// Fetch items
					var ids = [];
					combined.forEach(function(iTransaction)
					{
						ids.push(iTransaction.item_id);
					});
					Q.getItems(ids, function()
					{
						fillRecent();
					});
				}, false).fail(function(){
					dealError();
				});
			}, false).fail(function(){
				dealError();
			});
		};
		
		// Initialize
		retrieveTransactions();
		reloader.click(function()
		{
			retrieveTransactions();
			$(this).addClass("jsSuspended");
		});
	},
	generateDelivery: function()
	{
		$("#trsDeliveryTitle").text(D.getPhraseOriginal("Delivery"));
		var table = $("#trsDeliveryTable");
		var tally = $("#trsDeliveryTally");
		var reloader = $("#trsDeliveryReload");
		var deliverycount, deliveryitems, coins;
		
		var fillDelivery = function()
		{
			table.empty();
			reloader.removeClass("jsSuspended");
			A.adjustAccountScrollbar();
			
			for (var i in deliverycount)
			{
				var itemid = i;
				var count = deliverycount[i];
				var item = Q.getCachedItem(itemid);
				var priceobj = E.getCachedPrice(itemid);
				var row = $("<tr></tr>").appendTo(table);
				var quantitystr = (count > 1) ? ("<var class='trsRecentCount'>" + count + "</var>") : "";
				row.html("<td>"
					+ "<span class='trsRecentItem'>"
						+ "<span class='trsRecentSlot'><img class='trsRecentIcon' src='" + item.icon + "' />" + quantitystr + "</span>"
						+ "<span class='trsRecentName'><var class='" + Q.getRarityClass(item.rarity) + "'>" + item.name + "</var></span>"
					+ "</span>"
					+ "<span>"
						+ "<var class='trsRecentPrice'>" + I.Symbol.Approx + " " + E.formatCoinStringColored(count * priceobj.oPriceSell) + "</var>"
					+ "</span>"
				+ "</td>");
				var slot = row.find(".trsRecentSlot");
				Q.scanItem(item, {aElement: slot});
				Q.bindItemSlotBehavior(slot, {aItem: item, aWantClick: true});
			}
			
			// Coin to pick up
			tally.html(
				"<span id='trsDeliveryCount'>" + D.getWordCapital("transactions") + ": " + deliveryitems.length + "</span>"
				+ "<span id='trsDeliveryCoin'>" + D.getWordCapital("coin") + ": " + E.formatCoinStringColored(coins) + "</span>"
			);
		};
		var dealError = function()
		{
			table.html("<tr><td class='trsRecentError'>" + D.getPhraseOriginal("No delivery items") + ".</td></tr>");
			reloader.removeClass("jsSuspended");
		};
		var retrieveTransactions = function()
		{
			table.empty().html(I.cThrobber);
			tally.empty();
			// Retrieves the first page of the historical transactions
			U.getJSON(A.getURL(A.URL.Delivery), function(pData)
			{
				deliveryitems = pData.items;
				coins = pData.coins;
				if (coins > 0 || deliveryitems.length > 0)
				{
					deliverycount = {};
					// Combine same items into the same count
					for (var i in deliveryitems)
					{
						var ithid = deliveryitems[i].id;
						if (deliverycount[ithid] === undefined)
						{
							deliverycount[ithid] = 0;
						}
						deliverycount[ithid] += deliveryitems[i].count;
					}
					// Fetch items using the unique IDs
					Q.getPricedItems(U.convertAssocToArray(deliverycount), function()
					{
						fillDelivery();
					});
				}
				else
				{
					dealError();
				}
			}, false).fail(function(){
				dealError();
			});
		};
		
		// Initialize
		retrieveTransactions();
		reloader.click(function()
		{
			retrieveTransactions();
			$(this).addClass("jsSuspended");
		});
	},
	
	/*
	 * Generates the Trading Post overview page. This function only initializes once.
	 */
	serveTrading: function()
	{
		var dish = $("#accDish_Trading");
		if ( ! dish.data("isloaded"))
		{
			V.generateExchange();
			V.generateRecent();
			V.generateDelivery();
			var inputs = I.bindInputSelect(dish.find("input"));
			I.qTip.init(inputs);
			dish.data("isloaded", true);
			X.rewrapCheckboxes();
		}
		else if (dish.data("token") !== A.TokenCurrent)
		{
			// If already loaded but changed account, then reload the recent transactions
			dish.data("token", A.TokenCurrent);
			$("#trsRecentReload").trigger("click");
			$("#trsDeliveryReload").trigger("click");
		}
	},
	
	/*
	 * Generates gem store gallery displayed as bank tabs. Does not require account information.
	 */
	serveGem: function()
	{
		var dish = $("#accDish_Gem");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var section = "Gem";
		var container = B.createBank(dish, {
			aIsCollection: true,
			aWantCoin: false
		});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var validids = {}, availableids = {}, recordedvalues = {};
		
		// Sets the memory of a slot
		var toggleSlotAlarm = function(pSlot, pItem)
		{
			var id = pItem.id;
			var issubscribed = (pSlot.find(".bnkSlotSymbol").hasClass("bnkSlotSymbolActive"));
			if (issubscribed)
			{
				// If subscribed then unsubscribe the slot
				toggleSlotSymbol(pSlot, false);
				H.unsubscribeGem(id);
			}
			else
			{
				X.setCheckboxEnumState($("#opt_bol_alertGem"), X.ChecklistEnum.Checked); // Turn on voice alert
				H.isGemPaused = false;
				if (availableids[id])
				{
					// Subscribing to an available item will alert for discounted condition
					H.subscribeGemDiscounted(id);
					I.write(U.escapeHTML(pItem.name) + D.getPhraseOriginal(" is available - Alarm when item is discount"));
				}
				else
				{
					// Subscribing to an unavailable item will alert for available condition
					H.subscribeGemAvailable(id);
					I.write(U.escapeHTML(pItem.name) + D.getPhraseOriginal(" is not available - Alarm when item is available"));
				}
				toggleSlotSymbol(pSlot, true);
			}
			
			// Save to storage
			H.saveGemSubscription();
		};
		
		// Sets the appearance of a slot
		var toggleSlotSymbol = function(pSlot, pState, pItem)
		{
			if (pSlot)
			{
				var symbol = pSlot.find(".bnkSlotSymbol");
				symbol.removeClass("bnkSlotSymbolActive");
				if (pState)
				{
					symbol.addClass("bnkSlotSymbolActive");
					pSlot.data("ismarked", true);
				}
				else
				{
					pSlot.data("ismarked", false);
				}
			}
			else
			{
				// If did not provide a slot then consider as a wipe all command
				bank.find(".bnkSlotSymbol").removeClass("bnkSlotSymbolActive");
				bank.find(".bnkSlot").data("ismarked", false);
			}
			if (pItem)
			{
				var value = recordedvalues[pItem.id];
				var salevalue = H.Sale.Values[pItem.id];
				if (value !== undefined && salevalue >= 0)
				{
					pSlot.data("ismarked", true);
					if (salevalue < Math.abs(value) || salevalue === 0)
					{
						pSlot.addClass("bnkSlotDiscount");
						// Show pre-discounted gem price when hovered
						pSlot.append("<var class='bnkSlotPriceBuy'>" + E.formatGemString(Math.abs(value), true) + "</var>");
					}
					else if (salevalue)
					{
						pSlot.addClass("bnkSlotAvailable");
					}
				}
			}
		};
		
		var doGenerate = function()
		{
			// An item is "unlocked" if it is available on the gem store, which is a positive-number gem payment
			var record = U.getRecordData(section);
			A.iterateRecord(record, function(pEntry)
			{
				var id = pEntry.i;
				validids[id] = true;
				pEntry.u = id; // The item's ID is its unlock ID
				var payment = pEntry.p;
				var salevalue = H.Sale.Values[id];
				if (payment)
				{
					for (var i in payment)
					{
						recordedvalues[id] = payment[i];
						if (salevalue >= 0 && salevalue <= Math.abs(payment[i])) // Items being promoted overrides the payment value of the record's
						{
							payment[i] = salevalue;
							availableids[id] = true;
						}
						if (payment[i] <= 0)
						{
							// Negative price signifies it is unavailable, restore the positive price after iterating
							payment[i] = -1 * payment[i];
						}
						else
						{
							// Positive price signifies it is available
							availableids[id] = true;
						}
						break; // Consider only the first payment type
					}
				}
			});
			// Erase entries in the subscription that do not exist in the gem record
			for (var i in H.GemSubscription)
			{
				if (validids[i] === undefined)
				{
					delete H.GemSubscription[i];
				}
			}
			
			// Fill the "bank"
			B.generateUnlockables(bank, {
				aHeaders: U.getRecordHeader(section),
				aRecord: record,
				aUnlockeds: availableids,
				aWantGemConvert: true,
				aWantDefaultHelp: false,
				aWantSearchHighlight: false,
				aBind: function(pSlot, pItem)
				{
					var id = pItem.id;
					var symbol = $("<img class='bnkSlotSymbol curToggle' src='img/ui/menu/alarm.png' />").appendTo(pSlot);
					toggleSlotSymbol(pSlot, H.isGemSubscribed(id), pItem);
					// If on touch device then clicking the slot itself toggles the alarm
					if (I.isTouchEnabled)
					{
						pSlot.unbind("click").click(function()
						{
							toggleSlotAlarm(pSlot, pItem);
						});
					}
					else
					{
						symbol.click(function(pEvent)
						{
							pEvent.stopPropagation();
							toggleSlotAlarm(pSlot, pItem);
						});
					}
				}
			});
			
			// Button to clear all subscriptions
			var controller = $("<div class='cssCenter'></div>").prependTo(dish);
			$("<div class='cssCenter'>This feature is no longer maintained.</div>").prependTo(dish);
			var dishmenu = $("#accDishMenu_Gem");
			$("<button class='accButton'>" + D.getPhraseOriginal("Help") + "</button>").appendTo(controller).click(function()
			{
				dishmenu.find(".bnkButtonHelp").trigger("click");
			});
			$("<button class='accButton curToggle'>" + D.getPhraseOriginal("View Subscription") + "</button>").appendTo(controller).click(function()
			{
				dishmenu.find(".bnkButtonEmpty").trigger("click").trigger("click"); // Cycle to the tier that shows marked slots
			});
			$("<button class='accButton'>" + D.getPhraseOriginal("Clear Subscription") + "</button>").appendTo(controller).click(function()
			{
				if (confirm("Delete all gem store subscriptions?"))
				{
					I.write(D.getPhraseOriginal("Gem alarm and subscription off"));
					H.initializeGemSubscription(true);
					X.setCheckboxEnumState($("#opt_bol_alertGem"), X.ChecklistEnum.Unchecked); // Turn off voice alert
					toggleSlotSymbol();
				}
			});
		};
		
		H.updateGemSubscription(function()
		{
			Q.loadItemsSubdatabase(section.toLowerCase(), function()
			{
				doGenerate();
			});
		});
	},
	
	/*
	 * Creates the bank of historical API items.
	 */
	serveMuseum: function()
	{
		var dish = $("#accDish_Museum");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var container = B.createBank(dish, {
			aIsCollection: true,
			aWantGem: false
		});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		
		U.getScript(U.URL_DATA.Museum, function()
		{
			B.generateUnlockables(bank, {
				aRecord: U.getRecordData("Museum"),
				aIsCollapsed: true,
				aWantSearchHighlight: false,
				aWantDefaultHelp: false
			});
			// Open the first tab, leaving the rest collapsed
			setTimeout(function()
			{
				dish.find(".bnkTabSeparator").first().trigger("click");
			}, 400);
		});
	},
	
	/*
	 * Generates Pact Supply history and statistics.
	 */
	servePact: function()
	{
		var dish = $("#accDish_Pact");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		$("<div id='pctBank'></div>"
			+ "<div id='pctStatistics' data-date='2015-2016'>"
				+ "<div class='bnkTitle cssCenter'>Statistics</div><br />"
				+ "<table id='pctStatTable'></table>"
			+ "</div>").appendTo(dish);
		
		var section = "Pact";
		var container = B.createBank($("#pctBank"));
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var tab, slotscontainer, slot;
		var numfetched = 0;
		var numtofetch = 0;
		
		var history, products = H.Pact.Products;
		var occurnums = {}, occurdates = {}, highestoccur = 0, highestprice = 0;
		U.convertExternalLink("#accDish_Pact a");
		var generateStatistics = function()
		{
			var stat = $("#pctStatTable").append("<tr class='pctTableHeader'><th></th><th>Occurrence</th><th>Recipe</th><th>Price</th><th></th></tr>");
			for (var i in products)
			{
				Q.getItem(products[i], function(pItem)
				{
					var name = U.escapeHTML(pItem.name);
					var priceobj = E.Pricelist[i];
					var pricevalue = (priceobj) ? priceobj.oPriceSell : 0;
					var pricestr = ((priceobj) ? E.formatCoinStringColored(priceobj.oPriceSell)
						: E.formatKarmaString(H.Pact.Prices[i] || H.Pact.PriceDefault));
					stat.append("<tr class='pctStatRow cssStats'>"
						+ "<td class='pctStatCount' data-value='" + occurnums[i] + "'>" + occurnums[i] + "</td>"
						+ "<td data-value='" + occurnums[i] +  "'>" + I.getBar((occurnums[i] / highestoccur) * T.cPERCENT_100, true) + "</td>"
						+ "<td class='pctStatName' data-value='" + name + "' title='" + occurdates[i] + "'>"
							+ "<a class='" + Q.getRarityClass(pItem.rarity) + "'" + U.convertExternalAnchor(U.getTradingItemLink(i, pItem.name)) + "'>" + name + "</a></td>"
						+ "<td data-value='" + pricevalue + "'>" + I.getBar((((priceobj) ? priceobj.oPriceSell : 0) / highestprice) * T.cPERCENT_100) + "</td>"
						+ "<td class='pctStatPrice' data-value='" + pricevalue + "'>" + pricestr + "</td>"
					+ "</tr>");
				});
			}
			I.qTip.init(".pctStatName");
			I.bindSortableTable(stat, {aPresortColumn: 4});
		};
		
		var doGenerate = function()
		{
			history = GW2T_PACT_DATA;
			// Count occurences
			for (var i in history)
			{
				var day = history[i];
				var dayoccur = {};
				for (var ii = 0; ii < day.length; ii++)
				{
					var id = day[ii];
					if (occurnums[id] === undefined) // Initialize occurence entry for this item ID
					{
						occurnums[id] = 0;
						occurdates[id] = "";
					}
					if (dayoccur[id] === undefined) // Prevent counting of multiple offers of the same item in a day
					{
						occurnums[id]++;
						occurdates[id] += i + "<br />";
						dayoccur[id] = true;
					}
					if (occurnums[id] > highestoccur)
					{
						highestoccur = occurnums[id];
					}
				}
			}
			// Count the number of items in the bank first, because empty slots are written as "null" in the API
			var itemids = [];
			for (var i in products)
			{
				itemids.push(i);
				itemids.push(products[i]);
			}
			numtofetch = itemids.length;
			Q.getPricedItems(itemids, function()
			{
				// First generate empty bank slots, then fill them up asynchronously by item details retrieval
				bank.empty();
				tab = B.createBankTab(bank, {
					aTitle: $("#pctStatistics").attr("data-date")
				});
				slotscontainer = B.getSlotsContainer(tab);
				for (var i = 0; i < itemids.length; i++)
				{
					var itemid = itemids[i];
					var count = occurnums[itemid] || 1;
					slot = B.createBankSlot(slotscontainer);
					slot.data("count", 1);
					(function(iSlot, iSlotData)
					{
						Q.getItem(iSlotData.id, function(iItem)
						{
							B.styleBankSlot(iSlot, {aItem: iItem, aSlotMeta: iSlotData, aCallback: function()
							{
								numfetched++;
								A.setProgressBar(numfetched, numtofetch);
							}});
						});
					})(slot, {id: itemid, count: -count});
					if (occurnums[itemid])
					{
						E.getPriceObject(itemid, function(pPrice)
						{
							if (pPrice && pPrice.oPriceSell > highestprice)
							{
								highestprice = pPrice.oPriceSell;
							}
						});
					}
				}
				// Update tallies
				B.tallyBank(container);
				// Create search bar
				B.createBankMenu(bank, {
					aIsCollection: true
				});
				generateStatistics();
			});
		};
		
		U.getScript(U.URL_DATA.Pact, function()
		{
			Q.loadItemsSubdatabase(section.toLowerCase(), function()
			{
				doGenerate();
			});
		});
	},
	
	/*
	 * Generates the Trading Post transactions page.
	 */
	serveBuying: function()
	{
		B.generateTransactions("Buying", A.URL.CurrentBuys);
	},
	serveSelling: function()
	{
		B.generateTransactions("Selling", A.URL.CurrentSells);
	},
	serveBought: function()
	{
		B.generateTransactions("Bought", A.URL.HistoryBuys);
	},
	serveSold: function()
	{
		B.generateTransactions("Sold", A.URL.HistorySells);
	}
};
B = {
/* =============================================================================
 * @@Bank window, tab, item slot, catalog, and transactions generation
 * ========================================================================== */

	/*
	 * Creates a bank container element.
	 * @param jqobject pDestination to append bank.
	 * @objparam string aTitle of the bank, optional.
	 * @objparam string aID HTML ID for the container.
	 * @objparam string aClass CSS style class for bank element, optional.
	 * @objparam boolean aIsCollection whether the bank is an unlock collection, which will show untaxed prices, optional
	 * @objparam boolean aWantCoin whether to display the coin tally, optional.
	 * @objparam boolean aWantGem whether to display the gem tally, optional.
	 * @objparam int aSlotsPerRow to resize the bank beforehand, optional.
	 * @returns jqobject bank.
	 */
	createBank: function(pDestination, pSettings)
	{
		var Settings = pSettings || {};
		if (Settings.aIsPseudo)
		{
			Settings.aIsCollection = true;
			Settings.aWantGem = false;
		}
		
		var container = $("<div " + ((Settings.aID) ? "id='" + Settings.aID + "'" : "") + " class='bnkContainer'>"
			+ "<div class='bnkTop'>"
				+ ((Settings.aTitle) ? "<aside class='bnkTitle'>" + Settings.aTitle + "</aside>" : "")
				+ "<aside class='bnkBankTally'></aside>"
				+ ((Settings.aWantCoin !== false) ? ("<aside class='bnkPrice'>"
					+ "<var class='bnkPriceTitleA'></var><var class='bnkPriceValueA_Coin'></var>"
					+ " &nbsp; "
					+ "<var class='bnkPriceTitleB'></var><var class='bnkPriceValueB_Coin'></var>"
				+ "</aside>") : "")
				+ ((Settings.aIsCollection && Settings.aWantGem !== false) ? ("<aside class='bnkGem'>"
					+ "<var class='bnkPriceTitleA'></var><var class='bnkPriceValueA_Gem'></var>"
					+ " &nbsp; "
					+ "<var class='bnkPriceTitleB'></var><var class='bnkPriceValueB_Gem'></var>"
				+ "</aside>") : "")
			+ "</div>"
		+ "</div>").appendTo(pDestination);
		var bank = $("<div class='bnkBank " + (Settings.aClass || "") + "'></div>").appendTo(container);
		bank.css({width: ((Settings.aSlotsPerRow || A.Metadata.Bank.NumSlotsHorizontal) * B.getBankSlotWidth()) + "px"});

		if (Settings.aIsCollection)
		{
			var strunlocked = D.getWordCapital("unlocked") + ": +";
			var strlocked = D.getWordCapital("locked") + ": −";
			container.data("iscollection", true);
			container.find(".bnkPriceTitleA").html(strunlocked);
			container.find(".bnkPriceTitleB").html(strlocked);
			container.find(".bnkPriceValueA_Coin").html(E.formatCoinStringColored(0));
			container.find(".bnkPriceValueB_Coin").html(E.formatCoinStringColored(0));
			container.find(".bnkPriceValueA_Gem").html(E.formatGemString(0, true));
			container.find(".bnkPriceValueB_Gem").html(E.formatGemString(0, true));
		}

		return container;
	},
	getBankContainer: function(pBank)
	{
		return pBank.closest(".bnkContainer");
	},
	getTabsContainer: function(pContainer)
	{
		return pContainer.find(".bnkBank");
	},
	createBankDivider: function(pContainer)
	{
		pContainer.append("<div class='bnkDivider'></div>");
	},
	
	/*
	 * Gets the bank slot's current desired width.
	 * @param boolean pBoolean used if called from the bank buttons rather than creation.
	 * @returns boolean true if currently want smaller slots.
	 */
	getBankSlotWidth: function(pBoolean)
	{
		var boolean = (pBoolean !== undefined) ? pBoolean : O.Options.bol_condenseBank;
		return (boolean) ? A.Metadata.Bank.SlotWidthCondensed : A.Metadata.Bank.SlotWidth;
	},
	
	/*
	 * Creates a standard bank window tab that holds item slots, and a separator
	 * that toggles the tab.
	 * @param jqobject pBank container of tabs.
	 * @objparam string aTitle for tab header title.
	 * @objparam string aIcon HTML for tab header icon, optional.
	 * @objparam boolean aWantPrepend to place the tab on top, optional.
	 * @objparam boolean aIsCollapsed whether the tab is pre-collapsed, for tabs
	 * that generate slots on demand, optional.
	 * @returns jqobject bank tab.
	 */
	createBankTab: function(pBank, pSettings)
	{
		var Settings = pSettings || {};
		
		var tab = $("<div class='bnkTab'></div>");
		var iconstr = (Settings.aIcon) ? Settings.aIcon : "";
		var titlestr = (Settings.aTitle) ? "<var class='bnkTabText'>" + Settings.aTitle + "</var>" : "";
		var tabseparator = $("<div class='bnkTabSeparator curToggle'>"
			+ "<aside class='bnkTabHeader'>"
				+ iconstr
				+ titlestr
				+ "<var class='bnkTabPrice bnkTabPrice_Coin'></var>"
				+ "<var class='bnkTabPrice bnkTabPrice_Gem'></var>"
				+ "<var class='bnkTabToggle'></var>"
				+ "<var class='bnkTabTally'></var>"
			+ "</aside>"
		+ "</div>").appendTo(tab);
		var tabtoggle = tabseparator.find(".bnkTabToggle");
		var tabslots = $("<div class='bnkTabSlots'></div>").appendTo(tab);
		
		tabseparator.click(function()
		{
			B.toggleBankTab(tab);
		});
		if (Settings.aID)
		{
			tab.attr("id", Settings.aID);
		}
		if (Settings.aIsCollapsed)
		{
			I.toggleToggleIcon(tabtoggle, false);
			tabslots.hide();
		}
		if (Settings.aIsCustomCatalog)
		{
			B.placeCatalogTab(pBank, tab, Settings.aWantPrepend);
		}
		else if (Settings.aWantPrepend)
		{
			pBank.prepend(tab);
		}
		else
		{
			pBank.append(tab);
		}
		return tab;
	},
	getSlotsContainer: function(pElement)
	{
		return pElement.find(".bnkTabSlots");
	},
	
	/*
	 * Toggles a bank tab which contains slots.
	 * @param jqobject pTab a single tab or a bank for toggling all tabs.
	 * @param boolean pBoolean
	 * @param boolean pIsExclusive whether to show only one tab at a time, optional.
	 */
	toggleBankTab: function(pTab, pBoolean, pIsExclusive)
	{
		var tab = (pTab.hasClass("bnkBank")) ? pTab.find(".bnkTab") : pTab;
		var tabslots = B.getSlotsContainer(tab);
		var state = (typeof pBoolean === "boolean") ? pBoolean : !(tabslots.is(":visible"));
		
		if (state)
		{
			if (pIsExclusive)
			{
				// One time recursive call to hide all tabs, then show the desired tab
				B.toggleBankTab(tab.closest(".bnkBank"), false);
			}
			tabslots.slideDown("fast", function()
			{
				A.adjustAccountScrollbar();
			});
		}
		else
		{
			tabslots.slideUp("fast", function()
			{
				A.adjustAccountScrollbar();
			});
		}
		// Also change the toggle icon
		I.toggleToggleIcon(tab.find(".bnkTabToggle"), state);
	},
	showBankTab: function(pTab)
	{
		if (B.getSlotsContainer(pTab).is(":visible") === false)
		{
			pTab.find(".bnkTabSeparator").trigger("click");
		}
	},
	
	/**
	 * Macro function for bank search bar, to scroll to a tab and refreshes the
	 * search, assuming an item was found in the search results.
	 * @param jqobject pTab
	 */
	scrollToBankTab: function(pTab)
	{
		var tab = $(pTab);
		B.showBankTab(tab);
		// First scroll to the tab
		I.scrollToElement(tab, {
			aOffset: -A.getOverheadHeight(),
			aSpeed: "fast"
		});
		// Scroll tab again after it's assumed that content have been downloaded and generated
		setTimeout(function()
		{
			I.scrollToElement(tab, {
				aOffset: -A.getOverheadHeight()
			});
			B.refreshBankSearch(A.getDishName(tab));
		}, 2000);
	},
	
	/*
	 * Creates a divider between tabs in a bank.
	 * @param jqobject pBank container.
	 * @param string pHTML within the divider, optional.
	 */
	createTabDivider: function(pBank, pSettings)
	{
		var Settings = pSettings || {};
		
		var titlestr = (Settings.aTitle) ? "<var class='bnkTabDividerText'>" + Settings.aTitle + "</var>" : "";
		$("<div class='bnkTabDivider'>"
			+ "<aside class='bnkTabHeader'>"
				+ titlestr
			+ "</aside>"
		+ "</div>").appendTo(pBank);
	},
	
	/*
	 * Gets the tally numbers on the tab header of how many slots are filled.
	 * @param int pFilled number of filled slots
	 * @param int pCapacity number of slots the tab has.
	 * @param int pCount number of items summed from all slots, optional.
	 */
	getTallyString: function(pFilled, pCapacity, pCount)
	{
		var acquiredstr = (pCount) ? (" " + pCount + I.Symbol.Quantity) : "";
		var ratio = pFilled / pCapacity;
		var ratioclass = (ratio === 1) ? "accSignificant" : "accTrivial";
		var remaining = (ratio === 1) ? "" : ("<span class='accTrifle'>" + (pCapacity - pFilled) + "+</span>");
		return remaining + pFilled + " / " + pCapacity
			+ "<span class='" + ratioclass + "'> (" + U.convertRatioToPercent(ratio) + ")" + acquiredstr + "</span>";
	},
	updateTabTally: function(pElement, pFilled, pCapacity, pCount)
	{
		pElement.find(".bnkTabTally").html(B.getTallyString(pFilled, pCapacity, pCount));
	},
	updateBankTally: function(pElement, pFilled, pCapacity, pCount)
	{
		pElement.find(".bnkBankTally").html(B.getTallyString(pFilled, pCapacity, pCount));
	},
	
	/*
	 * Updates the tally of every tabs in a bank, and of the bank itself.
	 * Not to be used with unlockables because those banks may have on demand tab generation.
	 * @param jqobject pContainer of the bank.
	 */
	tallyBank: function(pContainer)
	{
		var itemsinbank = 0;
		var bankfill = 0;
		var bankcapacity = 0;
		var iscollection = pContainer.data("iscollection");
		B.getSlotsContainer(pContainer).each(function()
		{
			var tab = $(this).parent();
			var itemsintab = 0;
			var tabfill = 0;
			var tabcapacity = 0;
			var precount = tab.data("tabcount");
			var prefill = tab.data("tabfill");
			var precapacity = tab.data("tabcapacity");
			
			if (prefill !== undefined)
			{
				itemsintab += precount;
				itemsinbank += precount;
				tabfill += prefill;
				tabcapacity = precapacity;
			}
			else
			{
				var slots = $(this).find(".bnkSlot");
				slots.each(function()
				{
					var count = $(this).data("count");
					if (count)
					{
						// Sum slot
						itemsintab += count;
						itemsinbank += count;
						tabfill++;
					}
				});
				tabcapacity = slots.length;
			}
			if (iscollection)
			{
				itemsintab = 0;
			}
			// Tally tab
			B.updateTabTally(tab, tabfill, tabcapacity, itemsintab);
			// Sum tab
			bankfill += tabfill;
			bankcapacity += tabcapacity;
		});
		// Tally bank
		if (iscollection)
		{
			itemsinbank = 0;
		}
		B.updateBankTally(pContainer, bankfill, bankcapacity, itemsinbank);
	},
	
	/*
	 * Creates a vertical bar that holds bags on the left side of a bank tab.
	 * @param jqobject pTab to append.
	 * @param objarray pBags from characters API.
	 */
	createInventorySidebar: function(pTab, pBagsData)
	{
		if (pBagsData === undefined)
		{
			return;
		}
		
		pTab.addClass("bnkTabInventory");
		var sidebarcontainer = $("<div class='bnkSidebarContainer'></div>").prependTo(pTab);
		var sidebar = $("<div class='bnkSidebar'></div>").prependTo(sidebarcontainer);
		$("<div class='bnkSidebarBorder'></div>").appendTo(sidebarcontainer);
		var bagscolumn = $("<div class='bnkSidebarColumn'></div>").appendTo(sidebar);
		var bagouter, bag;
		pBagsData.forEach(function(iBagData)
		{
			if (iBagData)
			{
				// Count the number of items the bag is holding
				var bagfill = 0;
				for (var i = 0; i < iBagData.inventory.length; i++)
				{
					if (iBagData.inventory[i])
					{
						bagfill++;
					}
				}
				// Create the bag icon
				bagouter = $("<div class='bnkSidebarBagOuter'></div>").appendTo(bagscolumn);
				bag = $("<span class='bnkSidebarBag'><var class='bnkSidebarBagCount'>" + bagfill + "/" + iBagData.size + "</var></span>").appendTo(bagouter);
				(function(iBag)
				{
					Q.getItem(iBagData.id, function(iItem)
					{
						iBag.css({backgroundImage: "url(" + iItem.icon + ")"});
						Q.scanItem(iItem, {aElement: iBag});
						Q.bindItemSlotBehavior(iBag, {aItem: iItem, aWantClick: true});
					});
				})(bag);
			}
			else
			{
				// For ununused bag slots (no bag placed in the sidebar slot)
				bagouter = $("<div class='bnkSidebarBagOuter'></div>").appendTo(bagscolumn);
				bag = $("<span class='bnkSidebarBag'><var class='bnkSidebarBagCount'></var></span>").appendTo(bagouter);
			}
		});
	},
		
	/*
	 * Inserts a standard inventory slot for use in inventory, bank, materials,
	 * and other windows. Uses native DOM manipulation for performance.
	 * @param jqobject pSlotContainer of a tab.
	 * @param string pClass to change the slot style.
	 * @returns jqobject slot.
	 */
	createBankSlot: function(pSlotContainer, pClass)
	{
		var slot = document.createElement("span");
		slot.innerHTML = "<var class='bnkSlotBackground " + (pClass || "") + "'></var>"
			+ "<var class='bnkSlotIcon'></var>"
			+ "<var class='bnkSlotForeground'></var>";
		slot.className = "bnkSlot";
		pSlotContainer[0].appendChild(slot);
		return $(slot);
	},
	createPseudoSlot: function(pSlotContainer, pSettings)
	{
		// Pseudo slot does not contain a game item
		var Settings = pSettings || {};
		
		var slot = B.createBankSlot(pSlotContainer);
		var count = 0;
		
		if (Settings.aID)
		{
			slot.attr("id", Settings.aID);
		}
		if (Settings.aName)
		{
			slot.click(function(pEvent)
			{
				if (pEvent.which === I.ClickEnum.Left)
				{
					U.openExternalURL(U.getWikiSearchDefault(Settings.aName));
				}
			});
		}
		if (Settings.aTooltip)
		{
			slot.attr("title", Settings.aTooltip);
			I.qTip.init(slot);
		}
		if (Settings.aIcon)
		{
			slot.find(".bnkSlotIcon").css({backgroundImage: "url(" + Settings.aIcon + ")"});
		}
		if (!Settings.aIsUnlocked)
		{
			slot.addClass("bnkSlotZero");
		}
		if (Settings.aIsUnlocked)
		{
			count = Settings.aCount || 1;
		}
		if (Settings.aCount !== undefined)
		{
			slot.append("<var class='bnkSlotCount'>" + Settings.aCount + "</var>");
		}
		if (Settings.aLabel)
		{
			slot.append("<var class='bnkSlotLabel'>" + Settings.aLabel + "</var>");
		}
		if (Settings.aPayment)
		{
			for (var i in Settings.aPayment)
			{
				B.updateSlotPrice(slot, {
					aIsTab: Settings.aIsTab,
					aPrice: Settings.aPayment[i],
					aPossible: Settings.aPossible,
					aCount: count,
					aPaymentEnum: i
				});
			}
		}
		if (Settings.aCard)
		{
			slot.after("<span class='bnkCard itmTooltip cssTooltip'>" + Settings.aCard + "</span>");
		}
		
		slot.data("keywords", $("<div>" + (Settings.aKeywords || Settings.aTooltip || "").toLowerCase() + "</div>").text());
		slot.data("count", count);
		return slot;
	},
	createBankCard: function(pSlotContainer, pSettings)
	{
		// Bank "slots" that are tooltip blocks inserted into the bank
		var Settings = pSettings || {};
		var slot = document.createElement("span");
		slot.innerHTML = Settings.aHTML;
		slot.className = "bnkCard";
		pSlotContainer[0].appendChild(slot);
		return $(slot);
	},
	
	/*
	 * Styles a standard inventory slot and prepare it for search.
	 * @param jqobject pSlot to style.
	 * @objparam object aSlotMeta data retrieved from characters or bank API,
	 * containing stack count and transmutation data.
	 * @objparam object aItem item details retrieved from API.
	 * @objparam int aTradeableID ID of item to get TP price, such as the tradeable container of the bound item, optional.
	 * @objparam int aPrice custom coin price for untradeable items, optional.
	 * @objparam int aGem custom gem price for untradeable items, optional.
	 * @objparam boolean aWantGemConvert whether to convert gem to coin for hover price display, optional.
	 * @objparam string aComment to append to tooltip, optional.
	 * @objparam string aLabel to append to slot label, optional.
	 * @objparam string aWiki name of wiki article to open when double clicked, optional.
	 * @objparam function aCallback to execute after styling.
	 * @objparam function aPriceCallback to execute after fetching the item price, optional.
	 * @objparam function aBind for custom slot behavior binding, must manually
	 * unbind click event, can be used a slot iterator, optional.
	 */
	styleBankSlot: function(pSlot, pSettings)
	{
		var Settings = pSettings || {};
		if (pSettings)
		{
			var count = 1, pricecount = 1;
			if (Settings.aSlotMeta.count >= 0)
			{
				count = Settings.aSlotMeta.count;
				pricecount = count;
			}
			// Negative "count" is regarded as 1 for price, and visually as the positive count
			else if (Settings.aSlotMeta.count < 0)
			{
				count = Settings.aSlotMeta.count * -1;
				pricecount = 1;
			}
			var itemmeta = null;
			var validmeta = {
				upgrades: true, infusions: true, skin: true, bound_to: true
			};
			for (var i in Settings.aSlotMeta)
			{
				if (validmeta[i])
				{
					itemmeta = Settings.aSlotMeta;
					break;
				}
			}
			
			Q.scanItem(Settings.aItem, {
				aElement: pSlot,
				aItemMeta: itemmeta,
				aComment: Settings.aComment,
				aCallback: function(pBox)
			{
				// Load retrieved proper transmuted icon if available
				var icon = (pBox.oSkin) ? pBox.oSkin.icon : Settings.aItem.icon;
				pSlot.find(".bnkSlotIcon").css({backgroundImage: "url(" + icon + ")"}).addClass("bnkSlotRarity_" + Settings.aItem.rarity);
				// Make the item searchable by converting its tooltip HTML into plain text
				var keywords = ($(pBox.oHTML).text() + " " + D.getString(Settings.aItem.rarity)).toLowerCase();
				pSlot.data("keywords", keywords);
				pSlot.data("itemid", Settings.aItem.id);
				if (itemmeta && itemmeta.skin)
				{
					pSlot.data("skinid", itemmeta.skin);
				}
				// Bind slot click behavior
				var wikisearch = Settings.aWiki || Settings.aItem.name;
				var searchurl = (Settings.aWiki) ? U.getWikiSearchDefault(wikisearch) : U.getWikiSearchLanguage(wikisearch);
				pSlot.click(function(pEvent)
				{
					if (pEvent.which === I.ClickEnum.Left)
					{
						U.openExternalURL(searchurl);
					}
				});
				if (Settings.aBind)
				{
					Settings.aBind(pSlot, Settings.aItem);
				}
				else if (Settings.aIsCustomCatalog)
				{
					B.bindCatalogSlot(pSlot);
				}
				Q.bindItemSlotBehavior(pSlot, {
					aItem: Settings.aItem,
					aTradeableID: Settings.aTradeableID,
					aSearch: wikisearch
				});
				// Custom label over the slot icon, if available
				if (Settings.aLabel && Settings.aLabel.length)
				{
					pSlot.append("<var class='bnkSlotLabel'>" + Settings.aLabel + "</var>");
				}
				// Numeric label over the slot icon indicating stack size or charges remaining
				if (count > 1)
				{
					// Stack size
					var countmaxclass = (count % Q.GameLimit.StackSize === 0) ? "bnkSlotCountMax" : "";
					pSlot.append("<var class='bnkSlotCount " + countmaxclass + "'>" + count + "</var>");
				}
				else if ((Settings.aItem.type === "Tool" || Settings.aItem.type === "Gathering") && Settings.aSlotMeta && Settings.aSlotMeta.charges)
				{
					// Remaining charges
					pSlot.append("<var class='bnkSlotCount'>" + Settings.aSlotMeta.charges + "</var>");
				}
				// Fade the slots that act as collections
				if (count === 0)
				{
					pSlot.addClass("bnkSlotZero");
					pSlot.data("count", count);
				}
				else
				{
					// Assign count data for the hide empty slots filter
					pSlot.data("count", count);
				}
				// Custom price has priority over TP price
				if (Settings.aPrice > 0)
				{
					B.updateSlotPrice(pSlot, {
						aPrice: Settings.aPrice,
						aCount: pricecount,
						aPaymentEnum: E.PaymentEnum.Coin
					});
				}
				else if (Settings.aGem > 0)
				{
					B.updateSlotPrice(pSlot, {
						aPrice: Settings.aGem,
						aCount: pricecount,
						aPaymentEnum: E.PaymentEnum.Gem,
						aWantGemConvert: Settings.aWantGemConvert
					});
				}
				else if (pBox.oIsTradeable || Settings.aTradeableID)
				{
					// Add the boolean for the bank filter button to look for
					pSlot.addClass("bnkSlotTradeable");
					pSlot.data("istradeable", true);
					var itemidforprice = Settings.aTradeableID || Settings.aItem.id;
					E.getPriceObject(itemidforprice, function(pPrice)
					{
						B.updateSlotPrice(pSlot, {
							aPrice: pPrice,
							aCount: pricecount,
							aPaymentEnum: E.PaymentEnum.Coin,
							aTransactionBuy: Settings.aTransactionBuy,
							aTransactionSell: Settings.aTransactionSell
						});
						if (Settings.aPriceCallback)
						{
							Settings.aPriceCallback(pPrice);
						}
					});
				}
				// Execute callback if requested
				if (Settings.aCallback)
				{
					Settings.aCallback();
				}
			}});
		}
		else
		{
			// Empty slot gets keywords anyway for use in search
			pSlot.data("keywords", "*");
		}
	},
	
	/*
	 * Updates the price displayed over the bank slot, the bank tab, and bank top.
	 * @param jqobject pSlot for price label.
	 * @objparam int or object aPrice amount or processed object by the get price function.
	 * @objparam int aPossible the max possible price, optional.
	 * @objparam int aTransactionBuy of a transaction, optional.
	 * @objparam int aTransactionSell of a transaction, optional.
	 * @objparam int aCount of items.
	 * @objparam enum aPaymentEnum such as coin or gem.
	 * @objparam boolean aWantGemConvert whether to convert gem to coin for hover price display, optional.
	 */
	updateSlotPrice: function(pSlot, pSettings)
	{
		var Settings = pSettings || {};
		
		var elementsuffix = (E.PaymentEnum[Settings.aPaymentEnum]) ? Settings.aPaymentEnum : E.PaymentEnum.Coin;
		var container = B.getBankContainer(pSlot);
		var top = container.find(".bnkTop");
		var iscollection = container.data("iscollection");
		var tabdisplayprice = ((Settings.aIsTab) ? pSlot : pSlot.closest(".bnkTab")).find(".bnkTabPrice_" + elementsuffix);
		
		var count = (Settings.aPossible !== undefined) ? 1 : (Settings.aCount || 1);
		var prices = (typeof Settings.aPrice === "number") ?
			((Settings.aPaymentEnum) ? E.createPricePlain(Settings.aPrice, count) : E.createPrice(Settings.aPrice, count))
			: E.recountPrice(Settings.aPrice, count);
		var pricetorecord = (iscollection || Settings.aPaymentEnum) ? prices.oPriceSell : prices.oPriceSellTaxed;
		
		if (Settings.aTransactionBuy)
		{
			prices = E.createPrice(Settings.aTransactionBuy);
			pricetorecord = prices.oPriceBuy;
		}
		else if (Settings.aTransactionSell)
		{
			prices = E.createPrice(Settings.aTransactionSell);
			pricetorecord = prices.oPriceSellTaxed;
		}
		
		var updatePriceDisplay = function(pDisplay, pLeft, pRight, pIsCollectionTab)
		{
			var displaypriceleft = (pDisplay.data("priceleft") || 0) + pLeft;
			var displaypriceright = (pDisplay.data("priceright") || 0) + pRight;
			pDisplay.data("priceleft", displaypriceleft).data("priceright", displaypriceright);
			var tabtext, pricestrleft, pricestrright;
			switch (Settings.aPaymentEnum)
			{
				case E.PaymentEnum.Coin: {
					pricestrleft = E.formatCoinStringShort(displaypriceleft);
					pricestrright = E.formatCoinStringShort(displaypriceright);
					tabtext = (pIsCollectionTab) ? ("+" + pricestrleft + " −" + pricestrright) : (pricestrright + " <span class='accTrivial'>" + pricestrleft + "</span>");
				}; break;
				case E.PaymentEnum.Gem: {
					pricestrleft = E.formatGemString(displaypriceleft, true);
					pricestrright = E.formatGemString(displaypriceright, true);
					tabtext = (pIsCollectionTab) ? ("+" + pricestrleft + " −" + pricestrright) : (pricestrright);
				}; break;
				default: {
					pricestrleft = E.formatPayment(Settings.aPaymentEnum, displaypriceleft);
					pricestrright = E.formatPayment(Settings.aPaymentEnum, displaypriceright);
					tabtext = (pIsCollectionTab) ? ("+" + pricestrleft + " −" + pricestrright) : (pricestrright);
				}
			}
			pDisplay.html(tabtext);
		};
		
		// Label the slot with the item's or stack's price
		if (Settings.aIsTab !== true)
		{
			switch (Settings.aPaymentEnum)
			{
				case E.PaymentEnum.Coin: {
					pSlot.append("<var class='bnkSlotPrice'>" + E.formatCoinStringSlot(pricetorecord) + "</var>");
					if (pSlot.data("istradeable"))
					{
						var priceone = (typeof Settings.aPrice === "number") ? E.createPrice(Settings.aPrice, 1) : E.recountPrice(Settings.aPrice, 1);
						pSlot.append("<var class='bnkSlotPriceBuy'>" + E.formatCoinStringSlot(priceone.oPriceBuy) + "</var>");
						pSlot.append("<var class='bnkSlotPriceSell'>" + E.formatCoinStringSlot(priceone.oPriceSell) + "</var>");
					}
				}; break;
				case E.PaymentEnum.Gem: {
					pSlot.append("<var class='bnkSlotPrice'>" + E.formatGemString(pricetorecord, true) + "</var>");
					if (Settings.aCount > 1)
					{
						pSlot.append("<var class='bnkSlotPriceBuy'>" + E.formatGemString(Settings.aPrice, true) + "</var>");
					}
					if (Settings.aWantGemConvert)
					{
						pSlot.append("<var class='bnkSlotPriceSell'>" + E.formatGemToCoin(pricetorecord) + "</var>");
					}
				}; break;
				default: {
					var possiblestr = E.formatPayment(Settings.aPaymentEnum, pricetorecord);
					if (Settings.aPossible === 0)
					{
						possiblestr = "";
					}
					else if (Settings.aPossible > 0 && pricetorecord !== Settings.aPossible)
					{
						possiblestr = pricetorecord + " / " + E.formatPayment(Settings.aPaymentEnum, Settings.aPossible);
					}
					pSlot.append("<var class='bnkSlotPrice'>" + possiblestr + "</var>");
				}
			}
			
			// Remember coin value for price search
			if (Settings.aPaymentEnum === E.PaymentEnum.Coin)
			{
				pSlot.data("price", pricetorecord);
				pSlot.data("pricebuy", prices.oPriceBuy);
				pSlot.data("pricesell", prices.oPriceSell);
			}
			else if (Settings.aPaymentEnum === E.PaymentEnum.Gem)
			{
				var gemadjusted = pricetorecord * E.Exchange.COPPER_IN_SILVER; // Integers are in silver, so gem was considered copper
				pSlot.data("price", gemadjusted);
				pSlot.data("pricebuy", gemadjusted);
				pSlot.data("pricesell", gemadjusted);
			}
		}

		if (Settings.aIsTab !== false)
		{
			pSlot.data("tabcount", (pSlot.data("tabcount") || 0) + Settings.aCount);
			pSlot.data("tabfill", (pSlot.data("tabfill") || 0) + ((Settings.aCount > 0) ? 1 : 0));
			pSlot.data("tabcapacity", (pSlot.data("tabcapacity") || 0) + 1);
			// Only add if item actually exists (not a zero stack slot)
			var priceleft, priceright;
			if (iscollection)
			{
				priceleft = prices.oPriceBuy;
				priceright = prices.oPriceSell;
				// Update the display
				if (Settings.aPossible !== undefined)
				{
					priceleft = pricetorecord;
					priceright = Settings.aPossible - pricetorecord;
					updatePriceDisplay(tabdisplayprice, priceleft, priceright, true);
					updatePriceDisplay(top.find(".bnkPriceValueA_" + elementsuffix), priceleft, priceleft);
					updatePriceDisplay(top.find(".bnkPriceValueB_" + elementsuffix), priceright, priceright);
				}
				else if (Settings.aCount !== 0)
				{
					updatePriceDisplay(tabdisplayprice, prices.oPriceSell, 0, true);
					updatePriceDisplay(top.find(".bnkPriceValueA_" + elementsuffix), priceleft, priceright);
				}
				else
				{
					updatePriceDisplay(tabdisplayprice, 0, prices.oPriceSell, true);
					updatePriceDisplay(top.find(".bnkPriceValueB_" + elementsuffix), priceleft, priceright);
				}
			}
			else
			{
				if (Settings.aTransactionBuy)
				{
					priceleft = prices.oPriceBuy;
					priceright = prices.oPriceBuy;
				}
				else if (Settings.aTransactionSell)
				{
					priceleft = prices.oPriceSell;
					priceright = prices.oPriceSellTaxed;
				}
				else
				{
					priceleft = prices.oPriceBuyTaxed;
					priceright = prices.oPriceSellTaxed;
				}
				// Update the display
				if (Settings.aCount !== 0)
				{
					updatePriceDisplay(tabdisplayprice, priceleft, priceright);
					updatePriceDisplay(top.find(".bnkPriceValueA_" + elementsuffix), priceleft, priceright);
				}
			}
		}
	},
	getBankPrice: function(pContainer)
	{
		var valueA = pContainer.find(".bnkPriceValueA_Coin").data("priceleft") || 0;
		var valueB = pContainer.find(".bnkPriceValueB_Coin").data("priceleft") || 0;
		return [valueA, valueB];
	},
	
	/*
	 * Updates the price displayed over a slot with a payment.
	 * @param jqobject pSlot.
	 * @param object pPayment.
	 * @param int pCount.
	 * @param string pSlotClass optional.
	 */
	updateSlotPayment: function(pSlot, pPayment, pCount, pSlotClass)
	{
		for (var paymentkey in pPayment) // This is not a loop, used to access the key of the object
		{
			var paymentvalue = pPayment[paymentkey];
			var priceclass = "";
			if (paymentvalue < 0)
			{
				// A negative price means it should not be added, only displayed subtly
				priceclass = "bnkSlotPriceTrivial";
				paymentvalue *= -1;
			}
			pSlot.append("<var class='" + (pSlotClass || "bnkSlotPrice") + " " + priceclass + "'>"
				+ E.formatPayment(paymentkey, paymentvalue * (pCount || 1))
			+ "</var>");
			break;
		}
	},
	
	/*
	 * Creates and binds a search bar and buttons for a bank.
	 * @param jqobject pBank for insertion.
	 * @objparam boolean aWantClear whether to wipe the dish menu to recreate the menu, optional.
	 * @objparam boolean aWantSearchHighlight whether to highlight instead of show and hide when searching, optional.
	 * @objparam boolean aWantCard whether to allow info elements adjacent to slots.
	 * @objparam boolean aIsCollection whether the bank is an unlock collection.
	 * @objparam boolean aIsPseudo if bank contains pseudo slots instead of items.
	 * @objparam boolean aIsCollapsed whether to initially collapse all the tabs, assuming slots are generated, optional.
	 * @objparam jqobject aReloadElement to trigger instead of the default reload, optional.
	 * @pre Bank slots were generated.
	 */
	createBankMenu: function(pBank, pSettings)
	{
		var Settings = pSettings || {};
		// Initialize commonly used elements
		var sectionname = A.getDishName(pBank);
		var dishmenu = A.getDishMenu(sectionname);
		if (Settings.aWantClear)
		{
			dishmenu.empty();
		}
		var bankmenu = $("<div class='bnkMenu'></div>").prependTo(dishmenu);
		
		// Toggles a bank slot and card if available, to be used in iteration
		var toggleSlot = function(pSlot, pBoolean)
		{
			pSlot.toggle(pBoolean);
			if (Settings.aWantCard)
			{
				pSlot.each(function()
				{
					var card = $(this).next();
					if (card.length && card.hasClass("bnkCard"))
					{
						card.toggle(pBoolean);
						if (pBoolean)
						{
							card.css({display: ""}); // Showing the card adds a display CSS rule to the element
						}
					}
				});
			}
		};
		
		/*
		 * Search bar.
		 */
		var searchcontainer = $("<div class='bnkSearch'></div>").prependTo(bankmenu);
		var input = $("<input class='bnkSearchInput' type='text' />").appendTo(searchcontainer);
		I.bindInputBarText(input);
		input.on("input", $.throttle(Q.cSEARCH_LIMIT, function()
		{
			$(this).removeClass("cssSearchNone");
			var slots = pBank.find(".bnkSlot");
			var query = $(this).val().toLowerCase();
			var queries = [];
			var equality0, equality1;
			var keywords = "";
			var ismatchslots = false;
			if (query.length > 0)
			{
				equality0 = query.charAt(0);
				equality1 = query.charAt(1);
				// If searching by price range
				if ((equality0 === "<" || equality0 === ">") && query.length > 1)
				{
					var wantsell = (equality1 === "<" || equality1 === ">" && query.length > 2);
					var pricequeryindex = wantsell ? 2 : 1;
					var pricetype = wantsell ? "pricesell" : "pricebuy";
					var pricewant = E.parseCoinString(query.substring(pricequeryindex, query.length));
					slots.each(function()
					{
						var priceslot = $(this).data(pricetype);
						if (priceslot && ((equality0 === ">" && priceslot >= pricewant) || (equality0 === "<" && priceslot <= pricewant)))
						{
							toggleSlot($(this), true);
							ismatchslots = true;
						}
						else
						{
							toggleSlot($(this), false);
						}
					});
				}
				// If searching by keywords
				else
				{
					queries = query.split(" ");
					// Search for every substring in the user's query, which is space separated
					slots.each(function()
					{
						keywords = $(this).data("keywords"); // The text version of the item's tooltip HTML
						var ismatchkeywords = true;
						if (keywords)
						{
							if (Settings.aWantSearchHighlight)
							{
								for (var i = 0; i < queries.length; i++)
								{
									// If at least one substring of the search query isn't found, then hide that item
									if (keywords.indexOf(queries[i]) === -1)
									{
										$(this).removeClass("bnkSlotMatch");
										ismatchkeywords = false;
										break;
									}
								}
								// The boolean is only true if every substrings were found
								if (ismatchkeywords)
								{
									$(this).addClass("bnkSlotMatch");
									ismatchslots = true;
								}
							}
							else
							{
								for (var i = 0; i < queries.length; i++)
								{
									// If at least one substring of the search query isn't found, then hide that item
									if (keywords.indexOf(queries[i]) === -1)
									{
										toggleSlot($(this), false);
										ismatchkeywords = false;
										break;
									}
								}
								// The boolean is only true if every substrings were found
								if (ismatchkeywords)
								{
									toggleSlot($(this), true);
									ismatchslots = true;
								}
							}
						}
					});
				}
				// Recolor the search bar text if no match was fou
				if (ismatchslots === false)
				{
					$(this).addClass("cssSearchNone", !ismatchslots);
				}
			}
			else
			{
				slots.each(function()
				{
					$(this).removeClass("bnkSlotMatch");
					toggleSlot($(this), true);
				});
			}
			A.adjustAccountScrollbar();
		})).click(function()
		{
			$(this).select();
		});
		
		/*
		 * Add buttons next to the search bar for bank functionalities.
		 */
		var buttoncontainer = $("<aside class='bnkButtons'></aside>").appendTo(bankmenu);
		
		// Reload button reloads the section entirely
		$("<div class='bnkButtonReload bnkButton curClick' title='<dfn>Reload</dfn> this bank.<br />Press this if the progress bar has frozen.'></div>")
			.appendTo(buttoncontainer).click(function()
		{
			if (Settings.aReloadElement)
			{
				Settings.aReloadElement.trigger("click");
			}
			else
			{
				A.regenerateDish(sectionname);
			}
		});
		
		// Button to show help and search usage message
		var isshowinghelp = true;
		$("<div class='bnkButtonHelp bnkButton curClick' title='Show this bank&apos;s <dfn>help</dfn> message.'></div>")
			.appendTo(buttoncontainer).click(function()
		{
			var helpelm = $("#accHelp" + sectionname);
			var helpsec = (helpelm.length) ? helpelm.html() : "";
			if (isshowinghelp || I.isConsoleShown() === false)
			{
				I.help(helpsec + (Settings.aHelpMessage || "") + $("#accHelpBank").html());
			}
			isshowinghelp = !isshowinghelp;
		});
		
		// Empty slot filter: first click show filled slots only, second click show empty slots only, third show full stacks, fourth click show all slots, cycle
		var emptyfilterstate = 0;
		$("<div class='bnkButtonEmpty bnkButton curToggle' title='"
			+ "Filter:<br />1st click: non-empty/unlocked <dfn>slots</dfn><br />2nd click: marked or "
			+ Q.GameLimit.StackSize + " stack slots<br />3rd click: empty/locked slots<br />4th click: any slot (reset)'></div>")
			.appendTo(buttoncontainer).click(function()
		{
			var slots = pBank.find(".bnkSlot");
			if (emptyfilterstate === 0 || emptyfilterstate === 2 ) // Filter 
			{
				var wantshow = (emptyfilterstate === 0);
				slots.each(function()
				{
					// The style slot function should have initialized the count data for slots without an item
					if ($(this).data("count") > 0)
					{
						toggleSlot($(this), wantshow);
					}
					else
					{
						toggleSlot($(this), !wantshow);
					}
				});
				$(this).addClass("bnkButtonFocused");
				emptyfilterstate++;
			}
			else if (emptyfilterstate === 1)
			{
				slots.each(function()
				{
					if ($(this).data("count") >= Q.GameLimit.StackSize || $(this).data("ismarked"))
					{
						toggleSlot($(this), true);
					}
					else
					{
						toggleSlot($(this), false);
					}
				});
				emptyfilterstate++;
			}
			else
			{
				toggleSlot(slots, true);
				$(this).removeClass("bnkButtonFocused");
				emptyfilterstate = 0;
			}
			A.adjustAccountScrollbar();
		});
		
		// Button to filter tradeable items
		if (Settings.aIsPseudo !== true)
		{
			var tradefilterstate = 0;
			$("<div class='bnkButtonTrade bnkButton curToggle' title='Filter:<br />1st click: <dfn>tradeable</dfn> items<br />2nd click: bound items<br />3rd click: any items (reset).'></div>")
				.appendTo(buttoncontainer).click(function()
			{
				var slots = pBank.find(".bnkSlot");
				if (tradefilterstate === 0 || tradefilterstate === 1)
				{
					slots.each(function()
					{
						if ($(this).data("istradeable"))
						{
							toggleSlot($(this), tradefilterstate === 0);
						}
						else
						{
							toggleSlot($(this), tradefilterstate === 1);
						}
						if ($(this).data("count") === undefined)
						{
							toggleSlot($(this), false);
						}
					});
					$(this).addClass("bnkButtonFocused");
					pBank.addClass("bnkTradeable");
					tradefilterstate++;
				}
				else
				{
					toggleSlot(slots, true);
					$(this).removeClass("bnkButtonFocused");
					pBank.removeClass("bnkTradeable");
					tradefilterstate = 0;
				}
				A.adjustAccountScrollbar();
			});
		}
		
		if (Settings.aIsPseudo !== true && Settings.aIsCollection !== true)
		{
			// Button to filter cleanable items
			var cleanupfilterstate = 0;
			$("<div class='bnkButtonClean bnkButton curToggle' title='Filter:<br />"
				+ "1st click: <dfn>cleanable</dfn> items<br />2nd click: any items (reset).<br />"
				+ "Example: salvageable items, vendorable items, unopened bags.'></div>")
				.appendTo(buttoncontainer).click(function()
			{
				var thisbutton = $(this);
				var slots = pBank.find(".bnkSlot");
				if (cleanupfilterstate === 0)
				{
					Q.initializeCleanableFilter(function()
					{
						slots.each(function()
						{
							var itemid = $(this).data("itemid");
							if (itemid && $(this).data("skinid") === undefined) // Ignore transmuted items
							{
								if (Q.isCleanable(itemid))
								{
									$(this).addClass("bnkSlotMatchAlternate");
								}
							}
						});
						thisbutton.addClass("bnkButtonFocused");
						cleanupfilterstate++;
					});
				}
				else
				{
					slots.removeClass("bnkSlotMatchAlternate");
					thisbutton.removeClass("bnkButtonFocused");
					cleanupfilterstate = 0;
				}
				A.adjustAccountScrollbar();
			});
		}
		
		// Button to show rarity colored borders over items
		if (Settings.aIsPseudo !== true)
		{
			var isfilteringrarity = O.Options.bol_showRarity;
			var changeRarity = function(pRarityButton)
			{
				pBank.toggleClass("bnkRarity", isfilteringrarity);
				pRarityButton.toggleClass("bnkButtonFocused");
			};
			var raritybutton = $("<div class='bnkButtonRarity bnkButton curToggle' title='"
				+ "Show <dfn>rarity</dfn> colored boxes.<br />Change permanently at Options page, Account section.'></div>")
				.appendTo(buttoncontainer).click(function()
			{
				isfilteringrarity = !isfilteringrarity;
				changeRarity($(this));
			});
			if (O.Options.bol_showRarity)
			{
				changeRarity(raritybutton);
			}
		}
		
		// Button to condense bank and smaller slots
		var isbankcondense = O.Options.bol_condenseBank;
		var resizeSlots = function(pRarityButton)
		{
			pBank.toggleClass("bnkCondense", isbankcondense);
			pRarityButton.toggleClass("bnkButtonFocused");
			// Update bank 
			pBank.css({width: A.Metadata.Bank.NumSlotsHorizontal * B.getBankSlotWidth(isbankcondense)});
			A.adjustAccountScrollbar();
		};
		var raritybutton = $("<div class='bnkButtonCondense bnkButton curToggle' title='"
			+ "Toggle bank <dfn>size</dfn>.<br />Change permanently at Options page, Account section.'></div>")
			.appendTo(buttoncontainer).click(function()
		{
			isbankcondense = !isbankcondense;
			resizeSlots($(this));
		});
		if (O.Options.bol_condenseBank)
		{
			resizeSlots(raritybutton);
		}
		
		// Button to toggle informational card next to slots
		if (Settings.aWantCard)
		{
			var isbankcard = false;
			var cardbutton = $("<div class='bnkButtonCard bnkButton curToggle' title='"
				+ "Toggle info <dfn>cards</dfn>.'></div>")
				.appendTo(buttoncontainer).click(function()
			{
				isbankcard = !isbankcard;
				pBank.toggleClass("bnkCarded", isbankcard);
				$(this).toggleClass("bnkButtonFocused");
				A.adjustAccountScrollbar();
			}).trigger("click");
		}
		
		// Button to toggle all tabs
		var istabscollapsed = false;
		var collapsebutton = $("<div class='bnkButtonTab bnkButton curToggle' title='Expand/<dfn>Collapse</dfn> all tabs.'></div>")
			.appendTo(buttoncontainer).click(function()
		{
			B.toggleBankTab(pBank, istabscollapsed);
			$(this).toggleClass("bnkButtonFocused");
			istabscollapsed = !istabscollapsed;
		});
		if (Settings.aIsCollapsed)
		{
			collapsebutton.trigger("click");
		}
		
		// Button to increase or decrease bank width
		$("<div class='bnkButtonWideLess bnkButton curClick' title='<dfn>Decrease</dfn> bank width.'></div>")
			.appendTo(buttoncontainer).click(function()
		{
			var slotsize = B.getBankSlotWidth(isbankcondense);
			var minbankwidth = slotsize * 4;
			var oldwidth = pBank.width();
			if (oldwidth > minbankwidth)
			{
				pBank.css({width: oldwidth - slotsize});
				A.adjustAccountScrollbar();
			}
		});
		$("<div class='bnkButtonWideMore bnkButton curClick' title='<dfn>Increase</dfn> bank width.'></div>")
			.appendTo(buttoncontainer).click(function()
		{
			var slotsize = B.getBankSlotWidth(isbankcondense);
			var maxbankwidth = $("#accContent").width() - (slotsize * 2);
			var oldwidth = pBank.width();
			if (oldwidth < maxbankwidth)
			{
				pBank.css({width: oldwidth + slotsize});
				A.adjustAccountScrollbar();
			}
		});
		
		// Finally
		searchcontainer.css({width: searchcontainer.width() - buttoncontainer.width()});
		I.qTip.init(buttoncontainer.find(".bnkButton"));
		A.adjustAccountPanel();
	},
	getBankSearch: function(pSection)
	{
		return $("#accDishMenu_" + U.toFirstUpperCase(pSection)).find(".bnkSearch .bnkSearchInput").first();
	},
	refreshBankSearch: function(pSection)
	{
		B.getBankSearch(pSection).trigger("input");
	},
	
	/*
	 * Fills a bank tab with slots.
	 * @param jqobject pTab to fill.
	 * @param array pCatArr of the unlockables record.
	 * @param object pSettings for the slot fill function.
	 */
	fillTab: function(pTab, pCatArr, pSettings)
	{
		var Settings = pSettings || {};
		var slot, unlockobj;
		var numfetched = 0;
		var numtofetch = U.getObjectLength(pCatArr);
		var slotscontainer = B.getSlotsContainer(pTab);
		if (Settings.aIsCollapsed)
		{
			pTab.append(I.cThrobber);
		}
		
		var doGenerate = function()
		{
			for (var ii = 0; ii < pCatArr.length; ii++)
			{
				slot = B.createBankSlot(slotscontainer);
				unlockobj = pCatArr[ii];
				// Fill the slot with the item icon
				B.fillSlot(slot, unlockobj.i || unlockobj, {
					aUnlockAssoc: Settings.aUnlockAssoc,
					aUnlockObj: unlockobj,
					aComment: unlockobj.t,
					aLabel: unlockobj.l,
					aIsCatalog: Settings.aIsCatalog,
					aIsCustomCatalog: Settings.aIsCustomCatalog,
					aWantGemConvert: Settings.aWantGemConvert,
					aBind: Settings.aBind,
					aCallback: function()
					{
						numfetched++;
						A.setProgressBar(numfetched, numtofetch);
					}
				});
			}
		};
		
		// Prefetch items if this tab was manually expanded
		if (Settings.aIsCollapsed)
		{
			var itemids = [];
			for (var ii = 0; ii < pCatArr.length; ii++)
			{
				unlockobj = pCatArr[ii];
				itemids.push(unlockobj.i || unlockobj);
			}
			Q.getPricedItems(itemids, function()
			{
				I.removeThrobber(pTab);
				doGenerate();
			});
		}
		else
		{
			doGenerate();
		}
		
		// Also include button for custom tabs
		if (Settings.aIsCustomCatalog)
		{
			B.bindCatalogTab(pTab);
		}
	},
	
	/*
	 * Fills a bank tab with dyes (as bank slots).
	 * @param jqobject pTab.
	 * @param array pCatArr of unlockable objects, which are dyes.
	 * @param object pUnlockAssoc associative array to check against.
	 * @param string pCatArrName to determine dye rarity.
	 * @pre Data from the dye section of the account page was loaded.
	 */
	fillDyeTab: function(pTab, pCatArr, pUnlockAssoc, pCatArrName)
	{
		var slot, unlockobj;
		var slotscontainer = B.getSlotsContainer(pTab);
		var metadata = GW2T_DYES_METADATA;
		var translations = {};
		for (var i in metadata.Translations)
		{
			translations[i] = D.getObjectTranslation(metadata.Translations[i]);
		}
		
		for (var i = 0; i < pCatArr.length; i++)
		{
			slot = B.createBankSlot(slotscontainer);
			unlockobj = pCatArr[i];
			(function(iSlot, iUnlockObj, iUnlockID, iItemID, iWiki, iColors, iHue, iMaterial, iChatlink, iName)
			{
				// Include RGB info
				var irgb;
				var rgbarr = [];
				var hslarr = [];
				iColors.forEach(function(iHex)
				{
					irgb = U.convertHexToRGB(iHex);
					rgbarr.push(irgb);
					hslarr.push(U.convertRGBToHSL(irgb));
				});
				iUnlockObj["rgb"] = rgbarr;
				iUnlockObj["hsl"] = hslarr;
				// Color the bank slot as that dye
				iSlot.find(".bnkSlotIcon").css({background: iColors[0]});
				// Include name over the slot
				iSlot.append("<var class='bnkSlotDyeName'>" + iName + "</var>");
				// Set slot rarity depending on its tab
				var rarity = (metadata.Rarities[pCatArrName]) ? metadata.Rarities[pCatArrName] : metadata.Rarities.Default;
				iSlot.find(".bnkSlotIcon").addClass("bnkSlotRarity_" + rarity);
				// Label the price, if there is an associated dye item
				var count = (pUnlockAssoc[iUnlockID]) ? 1 : 0;
				if (count)
				{
					iSlot.data("count", count);
				}
				if (iItemID)
				{
					slot.addClass("bnkSlotTradeable");
					slot.data("istradeable", true);
					E.getPriceObject(iItemID, function(pPrice)
					{
						B.updateSlotPrice(iSlot, {
							aPrice: pPrice,
							aCount: count,
							aPaymentEnum: E.PaymentEnum.Coin
						});
						if (count)
						{
							// Fade the price label if already unlocked that dye
							iSlot.find(".bnkSlotPrice").addClass("accTrivial");
						}
					});
				}
				
				// Tooltip shows the different colors on different materials
				var tiphtml = "<div class='bnkDyePreview'>"
					+ "<aside class='bnkDyePreviewTitle'><var class='bnkDyePreviewName' style='color:" + iColors[0] + "'>" + iName + "</var> ("
						+ translations[iHue] + " " + translations[iMaterial] + ")</aside>"
					+ "<div class='bnkDyePreviewSwatches'>"
						+ "<aside class='bnkDyePreviewSwatch' style='background:" + iColors[0] + "'>"
							+ "<var class='bnkDyePreviewMaterial'>" + translations["Vibrant"] + "</var></aside>"
						+ "<aside class='bnkDyePreviewSwatch' style='background:" + iColors[1] + "'>"
							+ "<var class='bnkDyePreviewMaterial'>" + translations["Leather"] + "</var></aside>"
						+ "<aside class='bnkDyePreviewSwatch' style='background:" + iColors[2] + "'>"
							+ "<var class='bnkDyePreviewMaterial'>" + translations["Metal"] + "</var></aside>"
					+ "</div>"
				+ "</div>";
				iSlot.attr("title", tiphtml);
				I.qTip.init(iSlot);
				
				// Remember search keywords
				var keywords = (iName + " " + translations[iHue] + " " + translations[iMaterial]).toLowerCase();
				iSlot.data("keywords", keywords);
				
				// Bind slot click behavior
				iSlot.click(function(pEvent)
				{
					if (pEvent.which === I.ClickEnum.Left)
					{
						U.openExternalURL(U.getWikiSearchDefault(iWiki));
					}
				});
				// Bind context menu
				Q.bindItemSlotBehavior(iSlot, {
					aObject: iUnlockObj,
					aChatlink: iChatlink,
					aTradeableID: iItemID,
					aSearch: iWiki
				});
				
			})(slot, unlockobj, unlockobj.u, unlockobj.i, unlockobj.n,
				unlockobj.c, unlockobj.h, unlockobj.m, unlockobj.l, D.getObjectTranslation(unlockobj));
		}
	},
	
	/*
	 * Fills a slot with item icon and labels.
	 * @param jqobject pSlot to fill.
	 * @param int pItemID associated with the unlockable.
	 * @objparam object aUnlockAssoc to find the association.
	 * @objparam object aUnlockObj for slot info.
	 * @objparam string aComment HTML to append to the item tooltip, optional.
	 * @objparam string aLabel to append to slot label, optional.
	 * @objparam boolean aIsCatalog whether to use the user's possessions rather
	 * than unlockeds, optional.
	 */
	fillSlot: function(pSlot, pItemID, pSettings)
	{
		var Settings = pSettings || {};
		var unlocksassoc = Settings.aUnlockAssoc;
		var unlockobj = Settings.aUnlockObj;
		var unlockid = (typeof unlockobj === "number") ? pItemID : unlockobj.u;
		var tradeableid = (Settings.aIsCatalog && unlockobj.u) ? unlockobj.u : null;
		var wiki = unlockobj.n;
		var payment = unlockobj.p;
		
		Q.getItem(pItemID, function(iItem)
		{
			if (Settings.aIsCustomCatalog)
			{
				pSlot.addClass("bnkSlotCatalog");
				unlockid = pItemID;
				wiki = iItem.name;
			}
			var slotcoin, slotgem, slotgemvalue;
			if (payment)
			{
				slotcoin = payment["coin"];
				// Some items with a gem price may be marked to not be added to the tab display
				slotgem = payment["gem"];
				if (slotgem !== undefined)
				{
					if (slotgem < 0)
					{
						slotgem = 0; // Let the payment function create the price label rather than the style function
					}
					else
					{
						slotgemvalue = slotgem;
					}
				}
			}
			// Determine the item count number to display
			var entry = unlocksassoc[unlockid];
			var count = (entry) ? ((entry.oCount !== undefined) ? entry.oCount : 1) : 0;
			// Optional comment appended at the bottom of item tooltip
			var comment = Settings.aComment;
			var label = Settings.aLabel;
			// Catalog includes custom count
			entry = unlocksassoc[pItemID];
			if (Settings.aIsCatalog && entry)
			{
				count = entry.oCount;
				comment = A.getFoundString(entry);
			}
			// Style the slot
			B.styleBankSlot(pSlot, {
				aItem: iItem,
				aTradeableID: tradeableid,
				aPrice: slotcoin,
				aGem: slotgemvalue,
				aSlotMeta: {count: count},
				aComment: comment,
				aLabel: label,
				aWiki: wiki,
				aIsCustomCatalog: Settings.aIsCustomCatalog,
				aWantGemConvert: Settings.aWantGemConvert,
				aBind: Settings.aBind,
				aCallback: function()
				{
					// Include payment if the item cannot be obtained on the Trading Post
					if (payment && ((slotcoin === undefined && slotgem === undefined) || (slotcoin === 0 || slotgem === 0)))
					{
						B.updateSlotPayment(pSlot, payment, count);
					}
				}
			});
			if (Settings.aCallback)
			{
				Settings.aCallback();
			}
		});
	},
	
	/*
	 * Macro function for creating unlockables style banks.
	 * @param jqobject pBank to manipulate.
	 * @objparam object aHeaders containing category header translations.
	 * @objparam object aRecord containing categorized unlockable entries.
	 * @objparam array aUnlockeds IDs of user's unlocked unlockables from account API, or an associative array containing a count property.
	 * @objparam boolean aIsCatalog to use the user's possessions rather than unlockeds.
	 * @objparam boolean aIsLookup to generate unlocked slots only.
	 * @objparam boolean aIsCollapsed if all tabs should be initially collapsed.
	 * @objparam boolean aWantItems to prefetch item details for all items.
	 * @objparam boolean aWantPrices to prefetch TP prices for all items.
	 * @objparam boolean aWantSearchHighlight to use search highlight, optional.
	 * @objparam boolean aWantDefaultHelp to append the unlockables help message, optional.
	 * @objparam function aCallback to execute after generation.
	 * @objparam function aTabIterator to create a tab and execute at every category's iteration.
	 * @objparam string aIsCustomCatalog if is the default catalog with custom tabs.
	 * An unlockables record has arrays that hold entries with these properties:
	 * u: Unlockable ID (such as a skin ID, or mini ID)
	 * i: Item ID associated with that unlock
	 * n: Name of the unlockable.
	 * b: Tradeable array of item IDs, optional.
	 * p: Payment to acquire the associated item if the item is not tradeable.
	 */
	generateUnlockables: function(pBank, pSettings)
	{
		var Settings = pSettings || {};
		if (Settings.aIsCollapsed)
		{
			Settings.aWantPrices = false;
		}
		// Convert the API array of unlocks into an associative array
		var unlocksassoc = {};
		if (Settings.aIsCatalog)
		{
			unlocksassoc = A.Possessions;
		}
		else
		{
			if (Settings.aUnlockeds === undefined)
			{
				Settings.aUnlockeds = [];
				A.iterateRecord(Settings.aRecord, function(pEntry)
				{
					unlocksassoc[pEntry] = true;
				});
			}
			else
			{
				if (Array.isArray(Settings.aUnlockeds))
				{
					if (Settings.aUnlockeds.length)
					{
						// If unlockeds data is an array or assoc of object containing item IDs and additional info
						if (Settings.aUnlockeds[0].id !== undefined)
						{
							for (var i = 0; i < Settings.aUnlockeds.length; i++)
							{
								if (Settings.aUnlockeds[i].permanent !== false)
								{
									unlocksassoc[(Settings.aUnlockeds[i].id)] = true;
								}
							}
						}
						// If unlockeds data is an array of item IDs
						else
						{
							for (var i = 0; i < Settings.aUnlockeds.length; i++)
							{
								unlocksassoc[(Settings.aUnlockeds[i])] = true;
							}
						}
					}
				}
				else
				{
					unlocksassoc = Settings.aUnlockeds;
				}
			}
		}

		var container = B.getBankContainer(pBank);
		var headers = {};
		var record = {};
		var tab;
		var catarr, catobj;
		var unlockid;

		if (Settings.aIsCustomCatalog)
		{
			/*
			 * Add to the current unlockable database if provided custom tabs.
			 */
			var customdb = B.bindCatalog(pBank, unlocksassoc, Settings.aHeaders, Settings.aRecord);
			headers = customdb.oHeaders;
			record = customdb.oRecord;
		}
		else if (Settings.aIsLookup)
		{
			/*
			 * Records called with this boolean will be in the form of an array
			 * of item IDs rather array of objects. Reformat the record so it
			 * only contains items that is already unlocked (no locked slots
			 * will be generated).
			 */
			headers = Settings.aHeaders;
			for (var i in Settings.aRecord)
			{
				record[i] = [];
				catarr = Settings.aRecord[i];
				for (var ii = 0; ii < catarr.length; ii++)
				{
					if (unlocksassoc[(catarr[ii])])
					{
						record[i].push(catarr[ii]);
					}
				}
			}
		}
		else
		{
			/*
			 * For normal unlockables record.
			 */
			headers = Settings.aHeaders;
			record = Settings.aRecord;
		}
		
		var doGenerate = function()
		{
			/*
			 * Create tabs for each unlockable category.
			 */
			I.removeThrobber(pBank);
			var numsunlockedtotal = 0;
			var numintabstotal = 0;
			var numacquiredtotal = 0;
			var isheadersundefined = false;
			if (headers === undefined)
			{
				headers = {};
				isheadersundefined = true;
			}
			for (var i in record)
			{
				if (isheadersundefined)
				{
					headers[i] = {name_en: i};
				}
				catobj = headers[i];
				catarr = record[i];
				tab = (Settings.aTabIterator) ? Settings.aTabIterator(i) : B.createBankTab(pBank, {
					aTitle: D.getObjectName(catobj),
					aIsCollapsed: (Settings.aIsCollapsed !== undefined) ? Settings.aIsCollapsed : catobj.iscollapsed,
					aIsCustomCatalog: catobj.iscustomtab
				});
				(function(iTab, iCatObj, iCatArr, iCatArrName)
				{
					if (Settings.aIsDyes)
					{
						B.fillDyeTab(iTab, iCatArr, unlocksassoc, iCatArrName);
					}
					else
					{
						if (Settings.aIsCollapsed || iCatObj.iscollapsed)
						{
							iTab.find(".bnkTabSeparator").one("click", function()
							{
								B.fillTab(iTab, iCatArr, {
									aUnlockAssoc: unlocksassoc,
									aIsCatalog: Settings.aIsCatalog,
									aIsCollapsed: Settings.aIsCollapsed,
									aWantGemConvert: Settings.aWantGemConvert,
									aBind: Settings.aBind
								});
							});
						}
						else
						{
							B.fillTab(iTab, iCatArr, {
								aUnlockAssoc: unlocksassoc,
								aIsCatalog: Settings.aIsCatalog,
								aIsCustomCatalog: iCatObj.iscustomtab,
								aWantGemConvert: Settings.aWantGemConvert,
								aBind: Settings.aBind
							});
						}
					}
				})(tab, catobj, catarr, i);

				// For this ith tab, write the number of unlockables unlocked on the tab header
				var numunlocked = 0;
				var numacquired = 0;
				for (var ii = 0; ii < catarr.length; ii++)
				{
					unlockid = ((Settings.aIsCatalog) ? catarr[ii].i : catarr[ii].u) || catarr[ii];
					if (unlocksassoc[unlockid])
					{
						numunlocked++;
						numsunlockedtotal++;
						if (unlocksassoc[unlockid].oCount)
						{
							numacquired += unlocksassoc[unlockid].oCount;
						}
					}
				}
				var numintab = catarr.length;
				numintabstotal += numintab;
				B.updateTabTally(tab, numunlocked, numintab, numacquired);
				if (numacquired)
				{
					numacquiredtotal += numacquired;
				}
			}
			// Create bank menu
			var wantsearchhighlight = (Settings.aWantSearchHighlight === undefined) ? true : Settings.aWantSearchHighlight;
			B.createBankMenu(pBank, {
				aIsCollection: true,
				aWantSearchHighlight: wantsearchhighlight,
				aHelpMessage: $("#accHelpUnlockables").html(),
				aIsCustomCatalog: Settings.aIsCustomCatalog
			});
			B.updateBankTally(container, numsunlockedtotal, numintabstotal, numacquiredtotal);
			
			if (Settings.aCallback)
			{
				Settings.aCallback({
					aUnlockAssoc: unlocksassoc
				});
			}
		};
		
		/*
		 * Compile item IDs to bulk fetch item details and prices beforehand
		 */
		if (Settings.aWantItems === true || Settings.aWantPrices !== false)
		{
			var itemids = [];
			A.iterateRecord(record, function(pEntry)
			{
				if (isNaN(pEntry) === false)
				{
					itemids.push(pEntry);
				}
				else
				{
					if (pEntry.i)
					{
						itemids.push(pEntry.i);
					}
					else if (pEntry.u)
					{
						itemids.push(pEntry.u);
					}
				}
			});
			if (Settings.aWantItems === true && Settings.aWantPrices !== false)
			{
				Q.getPricedItems(itemids, function()
				{
					doGenerate();
				});
			}
			else if (Settings.aWantItems === true)
			{
				Q.getItems(itemids, function()
				{
					doGenerate();
				});
			}
			else if (Settings.aWantPrices !== false)
			{
				E.getPrices(itemids, function()
				{
					doGenerate();
				});
			}
		}
		else
		{
			doGenerate();
		}
	},
	
	/*
	 * Macro function to serve a catalog style bank to an account page's section.
	 * A catalog is a bank based on the account's entire inventory, bank, and 
	 * materials items possessions.
	 * @param string pSection name.
	 * @param object pSettings for the generate unlockables function.
	 */
	generateCatalog: function(pSection, pSettings)
	{
		var Settings = $.extend({
			aIsCatalog: true,
			aWantGem: true,
			aWantSearchHighlight: false
		}, pSettings);
		
		var sectionnameupper = U.toFirstUpperCase(pSection);
		var sectionnamelower = pSection.toLowerCase();
		if (V.requireCharacters(sectionnameupper))
		{
			return;
		}
		else if ( ! A.Data.Characters[0].bags)
		{
			A.printError(A.PermissionEnum.Inventories);
			return;
		}
		var dish = $("#accDish_" + sectionnameupper);
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var container = B.createBank(dish, {
			aIsCollection: (Settings.aIsCollection !== undefined) ? Settings.aIsCollection : true,
			aWantGem: Settings.aWantGem
		});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var fillCatalog = function()
		{
			Settings.aHeaders = U.getRecordHeader(pSection);
			Settings.aRecord = U.getRecordData(pSection);
			B.generateUnlockables(bank, Settings);
			/*
			 * Piggyback on the bank search bar (created by the generate unlockables
			 * function) and make it print the characters who have an item.
			 */
			Q.bindItemSearch(B.getBankSearch(pSection), {
				aFillerText: null,
				aCallback: function(pItem)
				{
					var itemname = "&quot;<a" + U.convertExternalAnchor(U.getWikiLinkLanguage(pItem.name)) + ">" + pItem.name + "</a>&quot;";
					if (A.Possessions[pItem.id])
					{
						var locations = A.formatPossessionLocations(A.Possessions[pItem.id]);
						I.print(itemname + " was found in:<br /><br />" + locations);
					}
					else
					{
						I.write("Nowhere in your account has the item " + itemname);
					}
				}
			});
		};
		
		U.getScript(U.URL_DATA[sectionnameupper], function()
		{
			Q.loadItemsSubdatabase(sectionnamelower, function()
			{
				/*
				 * Catalog is a custom unlockable whose collection is generated
				 * based on the user's bank and inventory contents rather than
				 * a list provided by the API.
				 */
				A.initializePossessions(function()
				{
					fillCatalog();
				});
			});
		});
	},
	
	/*
	 * Places a newly created tab of a custom catalog to the proper container.
	 * @param jqobject pBank.
	 * @param jqobject pTab.
	 * @param boolean pWantPrepend to place the tab on top.
	 */
	placeCatalogTab: function(pBank, pTab, pWantPrepend)
	{
		var tabcontainer = pBank.find(".bnkCatalogTabContainer");
		if ( ! tabcontainer.length)
		{
			tabcontainer = $("<div class='bnkCatalogTabContainer'></div>").prependTo(pBank);
		}
		if (pWantPrepend)
		{
			tabcontainer.prepend(pTab);
		}
		else
		{
			tabcontainer.append(pTab);
		}
	},
	
	/*
	 * Binds a custom tab of a catalog bank to have a button that shows the edit menu.
	 * @param jqobject pTab to bind.
	 */
	bindCatalogTab: function(pTab)
	{
		pTab.addClass("bnkCatalogTab");
		var edit = $("<kbd class='bnkCatalogTabEdit btnWindow' title='Click to <dfn>edit</dfn> this tab.<br />"
			+ "Click again to stop editing.<br />To edit custom slots, click the slot.'></kbd>").prependTo(pTab).click(function()
		{
			var bank = $(this).closest(".bnkBank");
			var currenttab = $(bank.data("currenttab"));
			var clickedtab = $(this).closest(".bnkTab").first();
			var tabeditor = bank.data("tabeditor");
			var tabheader = pTab.find(".bnkTabHeader");
			bank.find(".bnkTabHeader").removeClass("bnkCatalogTabHighlight");
			/*
			 * All custom tabs share the same editor menu that decides which
			 * tab to edit based on the bank object's current tab data.
			 * Clicking on the edit button next to a tab updates that tab as the
			 * current tab to be edited.
			 */
			if (clickedtab.is(currenttab) && tabeditor.is(":visible"))
			{
				// Hide the tab editor if is already editing it and user clicked edit again
				tabeditor.hide();
				bank.data("currenttab", null);
				tabheader.removeClass("bnkCatalogTabHighlight");
			}
			else if (clickedtab.is(currenttab) === false || tabeditor.is(":visible") === false)
			{
				// Show the tab editor if clicked edit on a different tab or isn't already editing
				tabeditor.show();
				bank.data("currenttab", $(this).closest(".bnkTab"));
				tabheader.addClass("bnkCatalogTabHighlight");
				// Update the name of the tab rename input
				var tabname = pTab.find(".bnkTabText").text();
				tabeditor.find(".bnkCatalogTabRename").val(tabname);
				tabeditor.find(".bnkCatalogSlotAdd").select().trigger("focus").trigger("click");
			}
			A.adjustAccountPanel();
		});
		I.qTip.init(edit);
	},
	
	/*
	 * A catalog's custom tab's slot when clicked on shows the slot editor rather
	 * than go to the wiki page.
	 * @param jqobject pSlot to bind.
	 */
	bindCatalogSlot: function(pSlot)
	{
		pSlot.unbind("click").click(function()
		{
			// Set the clicked slot as the current and highlight it
			var bank = $(this).closest(".bnkBank");
			bank.find(".bnkCatalogSlotHighlight").removeClass("bnkCatalogSlotHighlight");
			var currentslot = bank.data("currentslot");
			var sloteditor = bank.data("sloteditor");
			if ($(this).is(currentslot) && sloteditor.is(":visible"))
			{
				sloteditor.hide();
				bank.data("currentslot", null);
				$(this).removeClass("bnkCatalogSlotHighlight");
			}
			else if ($(this).is(currentslot) === false || sloteditor.is(":visible") === false)
			{
				// The slot editor appears next to the user's cursor rather than the bank menu
				sloteditor.css({left: I.posX, top: I.posY}).show();
				bank.data("currentslot", $(this));
				$(this).addClass("bnkCatalogSlotHighlight");
			}
			A.adjustAccountPanel();
		});
	},
	
	/*
	 * Saves the custom catalog to storage.
	 * @param jqobject pBank to extract custom tabs.
	 * Example structure of the stored custom catalog:
	 * [
	 *	{name: "My Tab", items: [123, 1234, 12345]},
	 *	{name: "My Tab 2", items: [321, 4321, 54321, 21]},
	 * ]
	 */
	saveCatalog: function(pBank)
	{
		var tabs = [];
		pBank.find(".bnkCatalogTab").each(function()
		{
			var items = [];
			var itemid;
			var slotscontainer = B.getSlotsContainer($(this)).first();
			slotscontainer.find(".bnkSlotCatalog").each(function()
			{
				itemid = $(this).data("itemid");
				if (itemid)
				{
					items.push(itemid);
				}
			});
			tabs.push({
				name: $(this).find(".bnkTabText").text(),
				items: items
			});
		});
		localStorage[O.Utilities.CustomCatalog.key] = JSON.stringify(tabs);
	},
	
	/*
	 * Binds additional behaviors to a bank which the user can add custom tabs to.
	 * @param jqobject pBank element.
	 * @param object pUnlockAssoc associative array of the account's possessions.
	 * @param object pHeaders original to extend.
	 * @param object pRecord original to extend.
	 */
	bindCatalog: function(pBank, pUnlockAssoc, pHeaders, pRecord)
	{
		/*
		 * Try to the retrieve the stored custom tabs if available and add them
		 * to the unlockables record.
		 */
		var headers = {};
		var record = {};
		var customitems = {};
		var itemid, defaulttab, customtab, tabkey;
		var customtabs = [];
		try
		{
			customtabs = JSON.parse(localStorage[O.Utilities.CustomCatalog.key]);
		}
		catch (e) {}
		
		// Create a list of custom items
		for (var i = 0; i < customtabs.length; i++)
		{
			customtab = customtabs[i];
			for (var ii = 0; ii < customtab.items.length; ii++)
			{
				customitems[(customtab.items[ii])] = true;
			}
		}
		// To avoid duplicate slots, remove items from the default list if the item's already in the custom list
		for (var i in pRecord)
		{
			defaulttab = pRecord[i];
			for (var ii = defaulttab.length - 1; ii >= 0; ii--)
			{
				if (customitems[(defaulttab[ii].i)])
				{
					defaulttab.splice(ii, 1);
				}
			}
		}
		
		// Convert the custom tabs object into the unlockables record format
		for (var i = 0; i < customtabs.length; i++)
		{
			customtab = customtabs[i];
			tabkey = "Tab_" + i;
			headers[tabkey] = {
				name_en: U.escapeHTML(customtab.name || ""),
				iscustomtab: true
			};
			record[tabkey] = [];
			// Reconstruct an unlockable entry using just the stored item ID
			for (var ii = 0; ii < customtab.items.length; ii++)
			{
				itemid = customtab.items[ii];
				if (itemid)
				{
					record[tabkey].push({
						i: itemid,
						n: null
					});
				}
			}
		}
		// Add the default unlockables to the custom unlockables, so that the custom ones are top ordered
		for (var i in pHeaders)
		{
			headers[i] = pHeaders[i];
		}
		for (var i in pRecord)
		{
			record[i] = pRecord[i];
		}
		
		/*
		 * New tab button.
		 */
		var newtabutton = $("<kbd class='bnkCatalogTabAdd btnWindow' title='<dfn>Add a custom bank tab.</dfn><br />"
			+ "To edit a custom tab or add an item to it, click the<img src=\"img/ui/edit.png\" />icon next to one.'></kbd>").appendTo(pBank)
			.click(function()
		{
			if (pBank.find(".bnkCatalogTab").length < A.Metadata.Bank.CustomTabsLimit)
			{
				var tab = B.createBankTab(pBank, {
					aTitle: D.getPhraseTitle("rename tab"),
					aIsCustomCatalog: true,
					aWantPrepend: true
				});
				B.fillTab(tab, [], {
					aUnlockAssoc: pUnlockAssoc,
					aIsCatalog: true,
					aIsCustomCatalog: true
				});
				// Automatically open the tab editor for the newly created tab
				tab.find(".bnkCatalogTabEdit").trigger("click");
			}
			else
			{
				I.write("Custom tabs limit reached.");
			}
		});
		I.qTip.init(newtabutton);
		
		// Create a menu to edit custom tabs and slots
		var sectionname = A.getDishName(pBank);
		var dishmenu = A.getDishMenu(sectionname);
		
		/*
		 * Tab editor.
		 */
		var tabeditor = $("<div class='bnkCatalogTabEditor'></div>").appendTo(dishmenu).hide();
		pBank.data("tabeditor", tabeditor);
		$("<div class='bnkCatalogMenuClose bnkButton curClick' title='<dfn>Close</dfn> the tab editor.'></div>")
			.appendTo(tabeditor).click(function()
		{
			var currenttab = pBank.data("currenttab");
			if (currenttab)
			{
				currenttab.find(".bnkTabHeader").removeClass("bnkCatalogTabHighlight");
			}
			pBank.data("currenttab", null);
			tabeditor.hide();
			A.adjustAccountPanel();
		});
		var slotadd = $("<input class='bnkCatalogSlotAdd bnkSearchInput' type='text' />").appendTo(tabeditor);
		Q.bindItemSearch(slotadd, {
			aFillerText: D.getPhraseTitle(D.orderModifier("item", "new")) + "...",
			aCallback: function(pItem)
			{
				var tab = pBank.data("currenttab");
				if (tab)
				{
					var slotscontainer = B.getSlotsContainer(tab);
					var slot = B.createBankSlot(slotscontainer);
					B.fillSlot(slot, pItem.id, {
						aUnlockAssoc: pUnlockAssoc,
						aUnlockObj: pItem.id,
						aIsCatalog: true,
						aIsCustomCatalog: true
					});
					B.saveCatalog(pBank);
				}
			}}
		);
		$("<input class='bnkCatalogTabRename bnkSearchInput' type='text' />").appendTo(tabeditor).change(function()
		{
			var tab = pBank.data("currenttab");
			if (tab)
			{
				tab.find(".bnkTabText").text($(this).val());
				B.saveCatalog(pBank);
			}
		}).click(function()
		{
			$(this).select();
		});
		var tabeditorbuttons = $("<aside class='bnkButtons'></aside>").appendTo(tabeditor);
		$("<div class='bnkCatalogTabUp bnkButton curClick' title='Move this tab <dfn>up</dfn>.'></div>")
			.appendTo(tabeditorbuttons).click(function()
		{
			var tab = pBank.data("currenttab");
			if (tab && tab.prev())
			{
				tab.insertBefore(tab.prev());
			}
			B.saveCatalog(pBank);
		});
		$("<div class='bnkCatalogTabDown bnkButton curClick' title='Move this tab <dfn>down</dfn>.'></div>")
			.appendTo(tabeditorbuttons).click(function()
		{
			var tab = pBank.data("currenttab");
			if (tab && tab.next())
			{
				tab.insertAfter(tab.next());
			}
			B.saveCatalog(pBank);
		});
		$("<div class='bnkCatalogTabDelete bnkButton curClick' title='<dfn>Delete</dfn> this custom bank tab.'></div>")
			.appendTo(tabeditorbuttons).click(function()
		{
			var tab = pBank.data("currenttab");
			var removeTab = function()
			{
				tab.remove();
				tabeditor.hide();
				A.adjustAccountPanel();
				B.saveCatalog(pBank);
			};
			if (tab)
			{
				// Show confirmation if the tab is not empty
				if (tab.find(".bnkSlot").length > 0)
				{
					if (confirm("Delete this custom tab?"))
					{
						removeTab();
					}
				}
				else
				{
					removeTab();
				}
			}
		});
		
		/*
		 * Slot editor.
		 */
		var sloteditor = $("<div class='bnkCatalogSlotEditor'></div>").appendTo(dishmenu).hide();
		pBank.data("sloteditor", sloteditor);
		$("<div class='bnkCatalogMenuClose bnkButton curClick' title='<dfn>Close</dfn> the slot editor.'></div>")
			.appendTo(sloteditor).click(function()
		{
			var currentslot = pBank.data("currentslot");
			if (currentslot)
			{
				currentslot.removeClass("bnkCatalogSlotHighlight");
			}
			pBank.data("currentslot", null);
			sloteditor.hide();
			A.adjustAccountPanel();
		});
		var sloteditorbuttons = $("<aside class='bnkButtons'></aside>").appendTo(sloteditor);
		$("<div class='bnkCatalogSlotLeft bnkButton curClick' title='Move this slot <dfn>left</dfn>.'></div>")
			.appendTo(sloteditorbuttons).click(function()
		{
			var slot = pBank.data("currentslot");
			if (slot && slot.prev())
			{
				slot.insertBefore(slot.prev());
			}
			B.saveCatalog(pBank);
		});
		$("<div class='bnkCatalogSlotRight bnkButton curClick' title='Move this slot <dfn>right</dfn>.'></div>")
			.appendTo(sloteditorbuttons).click(function()
		{
			var slot = pBank.data("currentslot");
			if (slot && slot.next())
			{
				slot.insertAfter(slot.next());
			}
			B.saveCatalog(pBank);
		});
		$("<div class='bnkCatalogSlotDelete bnkButton curClick' title='<dfn>Delete</dfn> this custom bank slot.'></div>")
			.appendTo(sloteditorbuttons).click(function()
		{
			var slot = pBank.data("currentslot");
			if (slot)
			{
				slot.remove();
				sloteditor.hide();
				A.adjustAccountPanel();
			}
			B.saveCatalog(pBank);
		});
		
		I.qTip.init(tabeditor.find(".bnkButton"));
		I.qTip.init(sloteditor.find(".bnkButton"));
		
		// Return the extended unlockables data for the generate function to use
		return {
			oHeaders: headers,
			oRecord: record
		};
	},
	
	/*
	 * Generates a Trading Post transactions style bank.
	 * @param string pSection account section name.
	 * @param enum pURL of the API endpoint.
	 */
	generateTransactions: function(pSection, pURL)
	{
		var section = U.toFirstUpperCase(pSection);
		var sectionlower = pSection.toLowerCase();
		var dish = $("#accDish_" + section);
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var container = B.createBank(dish, {
			aTitle: D.getWordCapital(sectionlower),
			aClass: "bnkBankTrading",
			aIsCollection: false,
			aWantGem: false
		});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var itemids = [];
		var numfetched = 0, numtofetch = 0;
		var calendar = {}, datestr, datearray, calkey, timesince, transaction, multitrans, transactionstr;
		var pricebuy, pricesell;
		var wantcollapsed = false;
		
		var fillTab = function(pTab, pMonthKey)
		{
			var tabnumfetched = 0, tabnumtofetch = U.getObjectLength(calendar[pMonthKey]);
			var slot;
			var slotscontainer = B.getSlotsContainer(pTab);
			var tabdata = []; // Contains the multi-transactions objects but will be chronologically sorted instead of by item ID
			for (var ii in calendar[pMonthKey])
			{
				multitrans = (calendar[pMonthKey])[ii];
				slot = B.createBankSlot(slotscontainer);
				slot.data("count", multitrans.oCount);
				tabdata.push(multitrans);
				(function(iSlot, iMultiTrans)
				{
					Q.getItem(iMultiTrans.oItemID, function(iItem)
					{
						pricebuy = (sectionlower === "buying" || sectionlower === "bought") ? iMultiTrans.oPrice : null;
						pricesell = (sectionlower === "selling" || sectionlower === "sold") ? iMultiTrans.oPrice : null;
						B.styleBankSlot(iSlot,
						{
							aItem: iItem,
							aComment: "<table class='bnkTransactionsTooltip'>" + iMultiTrans.oStampsTip + "</table>",
							aTransactionBuy: pricebuy,
							aTransactionSell: pricesell,
							aSlotMeta: {count: iMultiTrans.oCount},
							aCallback: function()
							{
								if (wantcollapsed)
								{
									tabnumfetched++;
									A.setProgressBar(tabnumfetched, tabnumtofetch);
								}
								else
								{
									numfetched++;
									A.setProgressBar(numfetched, numtofetch);
								}
							},
							aPriceCallback: function(pPrice)
							{
								if (sectionlower === "buying")
								{
									// If the item the user is buying is outbidded, then highlight it
									if (pPrice.oPriceBuy === iMultiTrans.oHighest)
									{
										iSlot.addClass("bnkSlotMatchAlternate");
									}
								}
								else if (sectionlower === "selling")
								{
									// If the item the user is selling is not outbidded, then highlight it
									if (pPrice.oPriceSell === iMultiTrans.oLowest)
									{
										iSlot.addClass("bnkSlotMatchAlternate");
									}
								}
							},
							aBind: function(pSlot, pItem)
							{
								pSlot.unbind("click").click(function(pEvent)
								{
									if (pEvent.which === I.ClickEnum.Left)
									{
										E.printListings(pItem.id);
									}
								});
							}
						});
					});
				})(slot, multitrans);
			}
			U.sortObjects(tabdata, {aKeyName: "oLatest"});
			pTab.data("transactions", tabdata);
			// Button next to each tab to print that tab's transactions in text list format
			var tabprint = $("<kbd class='bnkTransactionsPrint btnWindow' title='<dfn>Print</dfn> this month of transactions in chronological order.'></kbd>")
				.prependTo(pTab).click(function()
			{
				var clickedtab = $(this).closest(".bnkTab").first();
				var data = clickedtab.data("transactions");
				// Assume item is already fetched and cached, so the string order is sequential
				var str = "<div class='bnkTransactionsContainer'>";
				for (var i = data.length - 1; i >= 0; i--)
				{
					Q.getItem(data[i].oItemID, function(iItem)
					{
						if (data[i])
						{
							str += "<div class='bnkTransactionsBox'>"
								+ Q.getItemPreface(iItem, data[i].oCount)
								+ "<table class='bnkTransactionsTable'>" + data[i].oStamps + "</table>"
							+ "</div>";
						}
					});
				}
				str += "</div>";
				I.print(str, true);
				I.bindConsoleInput();
			});
			I.qTip.init(tabprint);
		};
		
		A.getTransactions(pURL, {aCallback: function(pData)
		{
			if (pData === null) // For the case that there are no current transactions
			{
				bank.empty();
				bank.append("<span class='bnkError'>" + D.getWordCapital("no")
					+ " " + D.getModifiedWord("transactions", "current") + ".</span>");
				return;
			}
			/*
			 * Categorize each transaction chronologically by its month; however,
			 * the items in the tab will be sorted by item ID.
			 */
			var nowms = (new Date()).getTime();
			for (var i = 0; i < pData.length; i++)
			{
				transaction = pData[i];
				// Example date string: "2000-01-01T13:59:59+00:00"
				datestr = transaction.purchased || transaction.created;
				datearray = datestr.split("-");
				calkey = datearray[0] + "-" + datearray[1]; // [0] is year, [1] is month
				if (calendar[calkey] === undefined)
				{
					calendar[calkey] = {};
				}
				// Remember time since purchased for historical transactions, or time since creation for current transactions
				timesince = (transaction.purchased)
					? T.formatMilliseconds((new Date(transaction.purchased)).getTime() - (new Date(transaction.created)).getTime())
					: T.formatMilliseconds(nowms - (new Date(transaction.created)).getTime());
				/*
				 * Transactions of the same item will be assigned to the same
				 * "slot" in the month associative array, accessed by the item ID.
				 * Transactions' metadata will still be accumulated in the stamp
				 * string for display in the slot tooltip.
				 */
				if ((calendar[calkey])[transaction.item_id] === undefined)
				{
					itemids.push(transaction.item_id);
					(calendar[calkey])[transaction.item_id] = {
						oLatest: transaction.purchased || transaction.created, // For chronological sorting
						oHighest: Number.NEGATIVE_INFINITY, // For outbid checking
						oLowest: Number.POSITIVE_INFINITY, // For outprice checking
						oItemID: transaction.item_id,
						oNumTransactions: 0,
						oCount: 0,
						oPrice: 0,
						oStamps: "",
						oStampsTip: ""
					};
					numtofetch++;
				}
				multitrans = (calendar[calkey])[transaction.item_id];
				multitrans.oCount += transaction.quantity;
				multitrans.oPrice += (transaction.price * transaction.quantity);
				multitrans.oNumTransactions += 1;
				transactionstr = "<tr>"
					+ "<td>" + transaction.quantity + " " + I.Symbol.Quantity + "&nbsp;</td>"
					+ "<td>" + E.formatCoinStringColored(transaction.price) + " =&nbsp;</td>"
					+ "<td>" + E.formatCoinStringColored(transaction.price * transaction.quantity) + "</td>"
					+ "<td>&nbsp;(" + timesince + ")</td>"
					+ "<td>&nbsp;@ " + (new Date(transaction.purchased || transaction.created)).toLocaleString() + "</td>"
				+ "</tr>";
				multitrans.oStamps += transactionstr;
				// Limit the number of transactions listed in the tooltip
				if (multitrans.oNumTransactions < Q.GameLimit.TooltipLines)
				{
					multitrans.oStampsTip += transactionstr;
				}
				if (transaction.price > multitrans.oHighest)
				{
					multitrans.oHighest = transaction.price;
				}
				if (transaction.price < multitrans.oLowest)
				{
					multitrans.oLowest = transaction.price;
				}
			}
			/*
			 * Automatically fills the tabs if the total number of slots to generate
			 * is less than the threshold, otherwise the user has to manually
			 * expand the tab headers to trigger the fill tabs function.
			 */
			Q.getPricedItems(itemids, function()
			{
				bank.empty();
				wantcollapsed = numtofetch > Q.GameLimit.FetchAPI;
				var tab, tabtitle, tabcapacity, tabcount, bankcapacity = 0, bankcount = 0;
				for (var i in calendar)
				{
					tabcapacity = 0, tabcount = 0;
					// The tab title is the year number and the month word
					calkey = i.split("-");
					tabtitle = T.formatLocal(
						new Date(Date.UTC(calkey[0], calkey[1], 1, 0, 0, 0)),
						{year: "numeric", month: "long"}
					);
					// Create bank tabs representing months
					tab = B.createBankTab(bank, {aTitle: tabtitle, aIsCollapsed: wantcollapsed});
					if (wantcollapsed)
					{
						(function(iTab, iMonthKey)
						{
							iTab.find(".bnkTabSeparator").one("click", function()
							{
								fillTab(iTab, iMonthKey);
							});
						})(tab, i);
					}
					else
					{
						fillTab(tab, i);
					}
					// Sum tab capacity and slot count
					for (var ii in calendar[i])
					{
						tabcapacity++;
						tabcount += (calendar[i])[ii].oCount;
					}
					bankcapacity += tabcapacity;
					bankcount += tabcount;
					B.updateTabTally(tab, tabcapacity, tabcapacity, tabcount);
				}
				B.updateBankTally(container, bankcapacity, bankcapacity, bankcount);
				B.createBankMenu(bank, {
					aHelpMessage: $("#accHelpTransactions").html()
				});
			});
		}});
	}
};
Q = {
/* =============================================================================
 * @@Quantify items, attributes, traits, and achievements
 * ========================================================================== */

	Boxes: {
	/*
	 * Associative arrays for container objects of retrieved raw API data (oData),
	 * analyzed data (oHTML), and other optional properties, accessed by the ID
	 * number of the datum.
	 */
		Items: {},
		Skins: {},
		Guilds: {},
		Achievements: {},
		Titles: {},
		Specializations: {},
		Traits: {},
		Skills: {}
	},
	isBoxedFully: {}, // Whether all data has been stored for that API type
	RetrievedDatabases: {}, // Stores names of retrieved items databases to avoid redoing
	SearchDatabase: null, // Search array for all items
	CleanableFilter: null, // Associative array of cleanable items to be used by the bank filters, not the cleanup tool
	AccessEnum:
	{
		HeartOfThorns: "HoT",
		PathOfFire: "PoF",
		GW2: "GuildWars2",
		HoT: "HeartOfThorns",
		PoF: "PathOfFire",
		Max: "HeartOfThorns"
	},
	ItemEnum: // Corresponds to item details type property
	{
		Gathering: "Gathering",
		Tool: "Tool",
		Gizmo: "Gizmo",
		Bag: "Bag",
		Back: "Back",
		Armor: "Armor",
		Weapon: "Weapon",
		Trinket: "Trinket",
		UpgradeComponent: "UpgradeComponent",
		Consumable: "Consumable",
		Container: "Container",
		CraftingMaterial: "CraftingMaterial",
		MiniPet: "MiniPet",
		Trophy: "Trophy"
	},
	ItemRank:
	{
		Gathering: "A",
		Tool: "B",
		Gizmo: "C",
		Bag: "D",
		Back: "E",
		Armor: "F",
		Weapon: "G",
		Trinket: "H",
		UpgradeComponent: "I",
		Consumable: "J",
		Container: "K",
		CraftingMaterial: "L",
		MiniPet: "M",
		Trophy: "N"
	},
	RarityEnum: // Corresponds to API names for rarity levels
	{
		Junk: "Junk",
		Basic: "Basic",
		Fine: "Fine",
		Masterwork: "Masterwork",
		Rare: "Rare",
		Exotic: "Exotic",
		Ascended: "Ascended",
		Legendary: "Legendary"
	},
	RarityNumber: // Corresponds to API names for rarity levels
	{
		Junk: 1,
		Basic: 2,
		Fine: 3,
		Masterwork: 4,
		Rare: 5,
		Exotic: 6,
		Ascended: 7,
		Legendary: 8
	},
	RarityRank:
	{
		Junk: "A",
		Basic: "B",
		Fine: "C",
		Masterwork: "D",
		Rare: "E",
		Exotic: "F",
		Ascended: "G",
		Legendary: "H"
	},
	WeightRank:
	{
		Light: "A",
		Medium: "B",
		Heavy: "C"
	},
	ArmorRank:
	{
		HelmAquatic: "A",
		Helm: "B",
		Shoulders: "C",
		Coat: "D",
		Gloves: "E",
		Leggings: "F",
		Boots: "G"
	},
	WeaponRank:
	{
		Axe: "A",
		Dagger: "B",
		Mace: "C",
		Pistol: "D",
		Scepter: "E",
		Sword: "F",
		Focus: "G",
		Shield: "H",
		Torch: "I",
		Warhorn: "J",
		Greatsword: "K",
		Hammer: "L",
		LongBow: "M",
		Rifle: "N",
		ShortBow: "O",
		Staff: "P",
		Harpoon: "Q",
		Speargun: "R",
		Trident: "S"
	},
	TrinketRank:
	{
		Amulet: "A",
		Accessory: "B",
		Ring: "C"
	},
	RunePieces:
	{
		Masterwork: 2,
		Rare: 4,
		Exotic: 6
	},
	GameLimit:
	{
		UnknownItem: 8055, // ID of an "unknown" item
		DailyAP: 15000,
		FetchAPI: 800, // Max items before a function resorts to on demand downloads
		TooltipLines: 100, // Text lines in a tooltip window
		LevelMax: 80,
		StackSize: 250,
		EctoSalvageLevel: 68
	},
	cSEARCH_LIMIT: 200, // Inventory search throttle limit
	Context: // Bank slots context menu data
	{
		Item: null,
		ItemName: null,
		ItemID: null,
		ItemSearch: null
	},
	isFauxInitialized: false,
	
	/*
	 * Loads a database file containing item details objects precached from API.
	 * @param string pName of the database.
	 * @param function pCallback to execute after success.
	 * @pre The database files exist in the proper directory and suffixed with
	 * the supported language nick.
	 */
	loadItemsSubdatabase: function(pName, pCallback)
	{
		if (Q.RetrievedDatabases[pName])
		{
			pCallback();
		}
		else
		{
			$.getJSON(U.getCacheURL(pName), function(pData)
			{
				Q.RetrievedDatabases[pName] = true;
				Q.initializeBoxes("items", pData);
			}).always(function()
			{
				// Execute callback regardless of success, in case of failed retrieval
				pCallback();
			});
		}
	},
	
	/*
	 * Loads the search database to search by item name.
	 * @param function pCallback to execute after success.
	 */
	loadItemsSearch: function(pCallback)
	{
		if (Q.SearchDatabase)
		{
			pCallback();
		}
		else
		{
			$.getJSON("cache/search_" + D.langPartiallySupported + I.cJSON, function(pData)
			{
				Q.SearchDatabase = pData;
				pCallback();
			});
		}
	},
	
	/*
	 * Sets an object with an item rarity CSS class. Removes all if level is not provided.
	 * @param jqobject pEntry to remove.
	 * @param string pLevel of rarity.
	 */
	setRarityClass: function(pEntry, pLevel)
	{
		for (var i in Q.RarityEnum)
		{
			pEntry.removeClass("rarity_" + i);
		}
		if (Q.RarityEnum[pLevel] !== undefined)
		{
			pEntry.addClass("rarity_" + pLevel);
		}
	},
	
	/*
	 * Gets a rarity CSS class from a rarity name.
	 * @param string pRarity.
	 * @returns string CSS class.
	 */
	getRarityClass: function(pRarity)
	{
		return "rarity_" + pRarity;
	},
	
	/*
	 * Gets the translated type name of an item.
	 * @param object pItem details from API.
	 * @returns string translated type.
	 */
	getItemType: function(pItem)
	{
		var det = pItem.details;
		if (det)
		{
			var type = pItem.type;
			// These top level types have overriding priority
			var validtypes = {
				Back: 1,
				Consumable: 1,
				Container: 1,
				CraftingMaterial: 1,
				Gathering: 1,
				Gizmo: 1,
				MiniPet: 1,
				Trophy: 1,
				UpgradeComponent: 1
			};
			if (validtypes[type])
			{
				return "<br />" + D.getString(type) + "<br />";
			}
			else if (det.type && det.type !== "Default") // Else use the subtype in the details property object
			{
				return D.getString(det.type) + "<br />";
			}
		}
		return "";
	},
	
	/*
	 * Standardizes attribute names to the base attribute object's keys.
	 * @param string pString.
	 * @returns string attribute name proper.
	 */
	getAttributeString: function(pString)
	{
		// Correct naming inconsistency of the attributes property in item API
		var correction = { 
			CritDamage: "Ferocity",
			Healing: "HealingPower",
			ConditionDuration: "Expertise",
			BoonDuration: "Concentration"
		};
		if (correction[pString])
		{
			return correction[pString];
		}
		return pString;
	},
	getAttributeTranslation: function(pString)
	{
		return D.getString(Q.getAttributeString(pString));
	},
	
	/*
	 * Looks for attribute points in an item and adds them to an attributes-containing object.
	 * @param object pAttrObj.
	 * @objparam object aItem to find attributes.
	 * @objparam object aRuneSets numbers of runes equipped, optional.
	 * @objparam object aStats selectable stats that the player had chosen for that equipment, used in place of item.
	 * @pre Account page's script has been loaded, which contains attribute association.
	 * Properties this function looks for:
	 * item.details.infix_upgrade.attributes // [{attribute: "Abc", "modifier": 123}, ...] language independent
	 * item.details.bonuses // ["+123 Abc", ...] language dependent
	 * item.details.infix_upgrade.buff.description // "+123 Abc\n+123 Abc..." language dependent
	 * stats.attributes // {"Abc": 123, ...}
	 */
	sumItemAttribute: function(pAttrObj, pSettings)
	{
		var Settings = pSettings || {};
		var det, attrstr, points, keyextracted, keyproper;
		// This object translates the current language extracted attribute name to the proper key name
		var assocobj = A.Attribute["KeyDescription_" + D.langFullySupported];
		// Reuseable function to parse array of attribute strings which are language dependent
		var sumAttributeArray = function(pArray)
		{
			var length = pArray.length;
			var runepieces = 0;
			// Special case if summing for a rune
			if (Settings.aRuneSets && Settings.aRuneSets[Settings.aItem.id])
			{
				// Don't re-sum if already did
				if (Settings.aRuneSets[Settings.aItem.id].issummed === true)
				{
					return;
				}
				runepieces = Settings.aRuneSets[Settings.aItem.id].numslotted;
				if (runepieces < length)
				{
					// For example if equipped three runes of same type, but only two possible effects
					length = runepieces;
				}
			}
			
			for (var i = 0; i < length; i++)
			{
				attrstr = pArray[i];
				points = U.stripToNumbers(attrstr);
				// The attribute key name shall be whatever that remains after stripping the description of non-letter characters
				keyextracted = (attrstr.replace(/[\s0-9%,.\-+']/g, "")).toLowerCase();
				if (assocobj[keyextracted])
				{
					keyproper = assocobj[keyextracted];
					/*
					 * Skip an anomaly in the API details for "infused" items
					 * that contains agony attribute in the description (being
					 * redundant because of infusion slots).
					 */
					if (keyproper === "AgonyResistance" && det.infusion_slots)
					{
						continue;
					}
					pAttrObj[keyproper] += points;
				}
			}
			if (Settings.aRuneSets && Settings.aRuneSets[Settings.aItem.id])
			{
				// Mark the rune to avoid resumming it
				Settings.aRuneSets[Settings.aItem.id].issummed = true;
			}
		};
		
		// For items themselves or runes
		var item = Settings.aItem;
		if (item && item.details)
		{
			det = item.details;
			
			// Non-rune items
			if (det.infix_upgrade && det.infix_upgrade.attributes)
			{
				det.infix_upgrade.attributes.forEach(function(iAttr)
				{
					var attrname = A.Attribute.KeyAttributes[iAttr.attribute];
					if (attrname)
					{
						pAttrObj[attrname] += iAttr.modifier;
					}
				});
			}
			// Runes
			if (det.bonuses)
			{
				sumAttributeArray(det.bonuses);
			}
			// Armor and shield that have defense attribute (adds to armor)
			if (det.defense !== undefined)
			{
				pAttrObj["Armor"] += det.defense;
			}
		}
		
		// For selectable-stats equipment
		if (Settings.aStats)
		{
			var selectattr = Settings.aStats.attributes;
			if (selectattr)
			{
				for (var i in selectattr)
				{
					pAttrObj[Q.getAttributeString(i)] += selectattr[i];
				}
			}
		}
	},
	
	/*
	 * Adds the attribute points of one attributes-containing object to another.
	 * @param object pAttrMain destination.
	 * @param object pAttrAdd source.
	 */
	sumAttributeObject: function(pAttrMain, pAttrAdd)
	{
		for (var i in pAttrMain)
		{
			pAttrMain[i] += pAttrAdd[i];
		};
	},
	
	/*
	 * Uses an attributes-containing object and calculates it with the base stats.
	 * @param object pAttrObj for adding geared stats.
	 * @param object pCharacter for calculating base stats.
	 * @param boolean pWantValue whether to return an object with numbers instead of formatted strings.
	 * @returns object attributes as string representation of the numbers.
	 */
	calculateAttributes: function(pAttrObj, pCharacter, pWantValue)
	{
		var attrobj = {};
		var level = pCharacter.level;
		var profession = pCharacter.oCharProfession;
		var constants = A.Attribute.Constants;
		var baseattr = A.Attribute.PrimaryPoints[level - 1];
		var precisiondivisor = A.Attribute.PrecisionDivisor[level - 1];
		var secondarydivisor = precisiondivisor / A.Attribute.SecondaryDivisorRatio;
		/*
		 * Calculate the health by adding converted base vitality with the base
		 * health points, then add it with the object's.
		 */
		var profhealth = 0;
		var levelprev = 0;
		var healthtype = A.Metadata.Profession[profession].health;
		var healthgrowth = A.Attribute.HealthGrowth[healthtype];
		var healthtier = 0;
		for (var i in healthgrowth)
		{
			healthtier = parseInt(i);
			if (healthtier <= level)
			{
				profhealth += (healthtier - levelprev) * healthgrowth[i];
				levelprev = healthtier;
			}
			else
			{
				profhealth += (level - levelprev) * healthgrowth[i];
				break;
			}
		}
		/*
		 * Use simple additions (with base attribute if available) and ratios to
		 * get these attributes. This object contains unformatted raw numbers.
		 */
		var attrnew = {
			Power:				baseattr + pAttrObj.Power,
			Toughness:			baseattr + pAttrObj.Toughness,
			Armor:				baseattr + pAttrObj.Armor + pAttrObj.Toughness,
			Vitality:			baseattr + pAttrObj.Vitality,
			Health:				(baseattr / constants.VITALITY_IN_HEALTH) + profhealth + pAttrObj.Health + (pAttrObj.Vitality / constants.VITALITY_IN_HEALTH),
			Precision:			baseattr + pAttrObj.Precision,
			CriticalChance:		constants.BASE_CRITICALCHANCE + pAttrObj.CriticalChance + (pAttrObj.Precision / precisiondivisor),
			Ferocity:			pAttrObj.Ferocity,
			CriticalDamage:		constants.BASE_CRITICALDAMAGE + pAttrObj.CriticalDamage + (pAttrObj.Ferocity / secondarydivisor),
			ConditionDamage:	pAttrObj.ConditionDamage,
			HealingPower:		pAttrObj.HealingPower,
			Expertise:			pAttrObj.Expertise,
			ConditionDuration:	pAttrObj.ConditionDuration + (pAttrObj.Expertise / secondarydivisor),
			Concentration:		pAttrObj.Concentration,
			BoonDuration:		pAttrObj.BoonDuration + (pAttrObj.Concentration / secondarydivisor),
			AgonyResistance:	pAttrObj.AgonyResistance,
			MagicFind:			pAttrObj.MagicFind
		};
		// Return raw values if requested
		if (pWantValue)
		{
			return attrnew;
		}
		// Otherwise format the values as strings
		for (var i in attrnew)
		{
			attrobj[i] = (A.Attribute.KeyType[i]) ? U.formatPercentage(attrnew[i], 2, 1) : parseInt(attrnew[i]).toLocaleString();
		}
		return attrobj;
	},
	
	/*
	 * Looks through a character object's equipment property and tally the
	 * number of same runes.
	 * @param object pCharacter.
	 * @returns object with rune item ID and count.
	 */
	countRuneSets: function(pCharacter)
	{
		var equip = pCharacter.equipment;
		var armorcount = 0;
		if (equip)
		{
			var obj = {};
			for (var i = 0; i < equip.length; i++)
			{
				// If it is an armor slot and has upgrades
				if (A.Equipment.ArmorSlots[(equip[i].slot)] && equip[i].upgrades)
				{
					var runeid = equip[i].upgrades[0];
					if (obj[runeid] === undefined)
					{
						obj[runeid] = {
							numslotted: 0,
							issummed: false // Whether the rune's attributes (if it is equipped) have been summed yet
						};
					}
					obj[runeid].numslotted = obj[runeid].numslotted + 1;
					armorcount++;
				}
				if (armorcount === A.Equipment.NumArmorSlots)
				{
					break;
				}
			}
			return obj;
		}
		return null;
	},
	
	/*
	 * Formats the text of a rune's bonuses.
	 * @param object pItem details from API.
	 * @param object or int pRuneSets numbers of runes equipped, optional.
	 * @returns string HTML.
	 */
	getRuneBonus: function(pItem, pRuneSets)
	{
		var str = "";
		var det = pItem.details;
		var runeith = 0;
		var runemax = Q.RunePieces[pItem.rarity];
		var runepieces = (pRuneSets && pRuneSets[pItem.id]) ? pRuneSets[pItem.id].numslotted : null;
		if (typeof pRuneSets === "number")
		{
			runepieces = pRuneSets;
		}
		if (runepieces > runemax)
		{
			runepieces = runemax; // Prevent overcounting of bonuses if equipped too many of same runes
		}
		
		var runecolor = "";
		if (det.bonuses)
		{
			str += (runepieces !== null) ? "" : "<br />";
			str += "<span class='itmGrayed'>";
			if (runepieces !== null)
			{
				str += "<var class='itmBuff'>" + pItem.name + " (" + runepieces + "/" + runemax + ")</var><br />";
			}
			for (var i in det.bonuses)
			{
				// Colorize the bonus line if the rune is equipped
				runecolor = (runeith < runepieces) ? " class='itmBuff'" : "";
				runeith++;
				str += "<var" + runecolor + ">(" + runeith + "): " + det.bonuses[i] + "</var><br />";
			}
			str += "</span>";
		}
		return str;
	},
	
	/*
	 * Gets the description of the buff property of an item.
	 * @param object or string pItem details from API or the description itself.
	 * @returns string description.
	 */
	formatItemDescription: function(pItem)
	{
		try
		{
			var desc = (typeof pItem === "string") ? pItem : pItem.details.infix_upgrade.buff.description;
			/*
			 * Item details' description may be pretagged with XML that colorizes
			 * a portion of text. Example: <c=@flavor>Description</c>
			 * If a tag exists, it shall have the "=@flavor" replaced with " class='.itmColor_flavor'"
			 */
			if (desc.indexOf("<c=@") !== -1)
			{
				desc = desc.replace(/<c=@abilitytype>/g, "<c class='itmColor_abilitytype'>");
				desc = desc.replace(/<c=@flavor>/g, "<c class='itmColor_flavor'>");
				desc = desc.replace(/<c=@reminder>/g, "<c class='itmColor_reminder'>");
				desc = desc.replace(/<c=@warning>/g, "<c class='itmColor_warning'>");
			}
			if (desc.indexOf("\n") !== -1)
			{
				return desc.replace(/\n/g, "<br />");
			}
			else
			{
				return desc;
			}
		}
		catch (e) {}
		return "";
	},
	
	/*
	 * Tells whether an item can be traded and has price on the Trading Post.
	 * @param int or object pItem ID of an item, or the item itself.
	 * @returns boolean.
	 * @pre Item was analyzed if requesting by ID.
	 */
	isTradeable: function(pItem)
	{
		if (pItem === undefined)
		{
			return false;
		}
		// If item is an ID
		if (typeof pItem === "number")
		{
			var box = Q.getBoxedItem(pItem);
			// Assume item is tradeable, unless it was analyzed not to be so
			if (box)
			{
				return (box.oIsTradeable === false) ? false : true;
			}
		}
		// If item is an item details object
		if (pItem.flags)
		{
			var flag;
			for (var i = 0; i < pItem.flags.length; i++)
			{
				flag = pItem.flags[i];
				if (flag === "AccountBound" || flag === "SoulbindOnAcquire")
				{
					return false;
				}
			}
		}
		return true;
	},
	
	/*
	 * Retrieves item details from API if haven't already, then execute callback
	 * function. Basically a wrapper for getJSON with item ID function.
	 * @param int pItemID to get item.
	 * @param function pCallback to execute after successful retrieval.
	 * @param int pReplaceID to use instead of item in case of retrieval error.
	 * @returns jqXHR object.
	 * @pre Method chaining is at most one level with "fail" function call only.
	 */
	getItem: function(pItemID, pCallback, pReplaceID)
	{
		var box = Q.getBoxedItem(pItemID);
		if (box)
		{
			pCallback(box.oData);
			// Dummy fail jqxhr function that never executes because the item was successfully cached
			return {fail: function() {}};
		}
		else
		{
			var jqxhr = $.ajax({
				dataType: "json",
				url: U.getAPIItem(pItemID),
				cache: true,
				success: function(pItem)
				{
					var itemid = pItem.id;
					// If item does not exist in API, use dummy item as the non-existent item
					if (pReplaceID && Q.Boxes.Items[Q.GameLimit.UnknownItem] === undefined)
					{
						itemid = pReplaceID;
						Q.Boxes.Items[Q.GameLimit.UnknownItem] = {oData: pItem};
					}
					if (Q.Boxes.Items[itemid] === undefined)
					{
						Q.Boxes.Items[itemid] = {oData: pItem};
					}
					pCallback(pItem);
				},
				error: function()
				{
					var unidentified = Q.createUnidentified(pItemID);
					pCallback(unidentified);
				}
			});
			return jqxhr;
		}
	},
	getPricedItems: function(pItemIDs, pCallback, pWantCache)
	{
		// Combine item details and TP price retrieval in one call
		Q.getItems(pItemIDs, function()
		{
			E.getPrices(pItemIDs, function()
			{
				pCallback();
			}, pWantCache);
		});
	},
	
	/*
	 * Creates a placeholder item which is missing in the items API.
	 * @param int pItemID of missing item.
	 * @returns object item.
	 */
	createUnidentified: function(pItemID)
	{
		var item = {
			name: "" + pItemID,
			description: "<c=@warning>The items API is missing this item. It may be content that is too old or too new.</c>",
			type: "Weapon",
			level: 0,
			rarity: "Fine",
			vendor_value: 0,
			default_skin: 2851,
			game_types: ["Activity", "Wvw", "Dungeon", "Pve"],
			flags: ["NoSell", "SoulbindOnAcquire", "SoulBindOnUse"],
			restrictions: [],
			id: pItemID,
			chat_link: "[&AgF3HwAA]",
			icon: "https://render.guildwars2.com/file/216B62605406DA976965A880F426F03ED6AFC178/61771.png",
			details: {
				type: "SmallBundle",
				damage_type: "Physical",
				min_power: 0,
				max_power: 0,
				defense: 0,
				infusion_slots: [],
				secondary_suffix_item_id: ""
			}
		};
		if (Q.Boxes.Items[pItemID] === undefined)
		{
			Q.Boxes.Items[pItemID] = {oData: item};
		}
		return item;
	},
	
	/*
	 * Adds a faux item to the cache using simplified data.
	 * @param object pData containing multilingual name and description, type, rarity, and icon.
	 */
	createFaux: function(pData)
	{
		var id = U.stripToVariable(D.getObjectDefaultName(pData)).toLowerCase(); // Use the encoded default name as the item ID
		if (Q.Boxes.Items[id] === undefined)
		{
			var item = $.extend({
				name: D.getObjectName(pData) || "Unnamed Item",
				description: D.getObjectDesc(pData) || "",
				type: pData.type || "Consumable",
				level: (pData.level) ? pData.level : 0,
				rarity: pData.rarity || "Basic",
				vendor_value: 0,
				game_types: ["Pvp", "PvpLobby", "Wvw", "Dungeon", "Pve"],
				flags: ["AccountBound", "NoSell", "DeleteWarning", "AccountBindOnUse"],
				restrictions: [],
				id: id,
				chat_link: "[&AgF3HwAA]",
				icon: (pData.icon) ? pData.icon : "img/faux/" + id + I.cPNG,
				details: {}
			}, pData);
			// Enter into cache
			Q.Boxes.Items[id] = {};
			Q.Boxes.Items[id].oData = item;
		}
	},
	initializeFaux: function()
	{
		// Initialize the standard set of faux items
		if (Q.isFauxInitialized)
		{
			return;
		}
		for (var i in H.Faux)
		{
			Q.createFaux(H.Faux[i]);
		}
	},
	
	/*
	 * Sorts an array of item IDs by item type, subtype, and other properties.
	 * @param intarray pItemIDs
	 * @param function pCallback with sorted items and IDs, or the items database for return.
	 */
	sortItems: function(pItemIDs, pCallback)
	{
		var isasync = false;
		var categorizeItem = function(pItem)
		{
			var itemrank = Q.ItemRank[pItem.type] || "0";
			var name = pItem.name;
			var type = pItem.type;
			var subtype = (pItem.details && pItem.details.type) ? pItem.details.type : "";
			var rarity = pItem.rarity;
			var rarityrank = Q.RarityRank[rarity];
			var desc = (pItem.description) ? pItem.description.toLowerCase() : "";
			var midstr = "?" + subtype;
			if (type === "Armor")
			{
				midstr = Q.WeightRank[pItem.details.weight_class] + "_" + Q.ArmorRank[subtype];
			}
			else if (type === "Weapon")
			{
				midstr = Q.WeaponRank[subtype];
			}
			else if (type === "Trinket")
			{
				midstr = Q.TrinketRank[subtype];
			}
			else if (desc.indexOf("decoration") !== -1)
			{
				midstr = "Decoration";
			}
			else if (desc.indexOf("recipe") !== -1)
			{
				midstr = "Recipe";
			}

			return itemrank + "_" + midstr + "_" + rarityrank + "_" + U.stripToAlphanumeric(name);
		};
		
		var startSort = function()
		{
			var items = [], id, item, retitems = [], retids = [];
			// Create an array of objects for the sort function
			for (var i = 0; i < pItemIDs.length; i++)
			{
				id = pItemIDs[i];
				item = (isasync) ? ((Q.Boxes.Items[id]) ? Q.Boxes.Items[id].oData : null) : pCallback[id];
				if (item)
				{
					items.push({
						oData: item,
						oType: categorizeItem(item)
					});
				}
			}
			// Sort then return as plain array of IDs
			U.sortObjects(items, {aKeyName: "oType"});
			items.forEach(function(iObject)
			{
				retitems.push(iObject.oData);
				retids.push(iObject.oData.id);
			});
			if (isasync)
			{
				pCallback(retitems, retids);
			}
			else
			{
				return {
					oItems: retitems,
					oIDs: retids
				};
			}
		};
		
		// Asynchronous if database is not provided
		if (typeof pCallback === "function")
		{
			isasync = true;
			Q.getItems(pItemIDs, function()
			{
				startSort();
			});
		}
		else
		{
			// If callback parameter is an items database
			return startSort();
		}
	},
	
	/*
	 * Gets the cleanup category of an item, if not cleanable then null.
	 * @param object pItem details.
	 * @param boolean pIsFilter if called by a filter action rather than collate.
	 * Calling without this boolean assumes it is for filtering inventory items.
	 * @returns string category.
	 */
	categorizeCleanableItem: function(pItem, pIsFilter)
	{
		var name = pItem.name.toLowerCase();
		var desc = (pItem.description) ? pItem.description.toLowerCase() : "";
		
		// These language-independent filters supplement the cleanup filter associative array
		if (pIsFilter)
		{
			if (pItem.type === Q.ItemEnum.UpgradeComponent || pItem.type === Q.ItemEnum.CraftingMaterial)
			{
				return "Combine";
			}
			if ((pItem.type === Q.ItemEnum.Armor || pItem.type === Q.ItemEnum.Weapon)
				&& Q.RarityNumber[pItem.rarity] < Q.RarityNumber.Rare)
			{
				return "Junk";
			}
			return null; // Do not proceed with other filters
		}
		
		// These filters are for the collate function
		if (desc.indexOf("decoration") !== -1)
		{
			if (pItem.type === Q.ItemEnum.Gizmo || pItem.type === Q.ItemEnum.Consumable || pItem.type === Q.ItemEnum.Trophy)
			{
				return "Decoration";
			}
		}
		if (desc.indexOf("value as part of a collection") !== -1)
		{
			return "Collection";
		}
		if (name.indexOf("recipe") !== -1)
		{
			return "Recipe";
		}
		if (pItem.rarity === Q.RarityEnum.Rare && pItem.level && pItem.level > Q.GameLimit.EctoSalvageLevel)
		{
			if (pItem.type === Q.ItemEnum.Weapon || pItem.type === Q.ItemEnum.Armor || pItem.type === Q.ItemEnum.Trinket || pItem.type === Q.ItemEnum.Back)
			{
				if (pItem.flags.indexOf("NoSalvage") === -1)
				{
					return "Rare";
				}
			}
		}
		if (pItem.type === Q.ItemEnum.Container)
		{
			if (pItem.rarity === Q.RarityEnum.Ascended)
			{
				return "ContainerAscended";
			}
			if (name.indexOf("weapon") !== -1 || name.indexOf("armor") !== -1 || name.indexOf("skin") !== -1)
			{
				return "ContainerGear";
			}
			if (pItem.rarity === Q.RarityEnum.Rare || pItem.rarity === Q.RarityEnum.Exotic)
			{
				if (name.indexOf("gear") !== -1 
					|| desc.indexOf("weapon") !== -1 || desc.indexOf("armor") !== -1 || desc.indexOf("gear") !== -1 || desc.indexOf("skin") !== -1)
				{
					return "ContainerGear";
				}
			}
			return "Container";
		}
		if (pItem.type === Q.ItemEnum.Trophy)
		{
			if (desc.indexOf("salvage item") !== -1)
			{
				return "Salvage";
			}
			if (desc.indexOf("used to") !== -1 || desc.indexOf("to make") !== -1)
			{
				return "Combine";
			}
			if (pItem.rarity === Q.RarityEnum.Junk)
			{
				return "Junk";
			}
			if (pItem.rarity !== "Legendary" &&
				(Q.isTradeable(pItem) === false
				|| desc.indexOf("event item") !== -1
				|| desc.indexOf("task item") !== -1
				|| (pItem.vendor_value > 0 && pItem.flags.indexOf("NoSell") === -1)))
			{
				return "Collection";
			}
		}
		if (pItem.type === Q.ItemEnum.Gizmo)
		{
			if (desc.indexOf("combine") !== -1 && desc.indexOf("tier") === -1)
			{
				return "Combine";
			}
		}
		if (pItem.type === Q.ItemEnum.Consumable)
		{
			if (pItem.details.type === "Food" || pItem.details.type === "Utility")
			{
				return "Food";
			}
			if (pItem.details.type === "Transmutation")
			{
				return "Skin";
			}
			return "Consumable";
		}
		
		// No match so return none
		return null;
	},
	
	/*
	 * Initializes the filter used by the bank menu button that highlights
	 * cleanable items.
	 * @param function pCallback after initialization.
	 */
	initializeCleanableFilter: function(pCallback)
	{
		var section = "Cleanup";
		if (Q.CleanableFilter !== null)
		{
			pCallback();
		}
		else
		{
			U.getScript(U.URL_DATA.Cleanup, function()
			{
				Q.CleanableFilter = {};
				var record = U.getRecordData(section), catarr;
				for (var i in record)
				{
					// Exclude some categories
					if (i === "Food")
					{
						continue;
					}
					catarr = record[i];
					for (var ii = 0; ii < catarr.length; ii++)
					{
						Q.CleanableFilter[(catarr[ii])] = true;
					}
				}
				pCallback();
			});
		}
	},
	
	/*
	 * Tells if an item as shown in a bank or inventory can salvaged, vendored, or destroyed.
	 * @param int pItemID
	 * @returns boolean
	 * @pre Cleanup filter was initialized.
	 */
	isCleanable: function(pItemID)
	{
		return (Q.CleanableFilter[pItemID] || Q.categorizeCleanableItem(Q.getCachedItem(pItemID), true));
	},
	
	/*
	 * Lightweight preliminary function to check if the requested item has
	 * already been analyzed, and simply retrieve the cache if available,
	 * otherwise proceed with the actual analysis function.
	 * @param object pItem item details.
	 * @param object pSettings.
	 */
	scanItem: function(pItem, pSettings)
	{
		var Settings = pSettings || {};
		var itemmeta = Settings.aItemMeta || {};
		var box = Q.getBoxedItem(pItem.id);
		
		if (box && box.oHTML)
		{
			if (itemmeta.upgrades || itemmeta.infusions || itemmeta.skin || itemmeta.slot || itemmeta.bound_to
				|| Settings.aWantAttr || Settings.aComment)
			{
				Q.analyzeItem(pItem, pSettings);
			}
			else
			{
				// Only use the cached analysis if the item is fresh (unupgraded, untransmuted, unsoulbound, not commented)
				if (Settings.aElement)
				{
					var elm = $(Settings.aElement);
					elm.attr("title", box.oHTML);
					I.qTip.init(elm);
				}
				// Execute callback if provided
				if (Settings.aCallback)
				{
					Settings.aCallback(box);
				}
			}
		}
		else
		{
			Q.analyzeItem(pItem, pSettings);
		}
	},
	
	/*
	 * Generates item tooltip HTML, compiles attributes, and retrieves linked
	 * upgrades and skins if available.
	 * @param object pItem details retrieved from API.
	 * @objparam jqobject aElement to bind tooltip.
	 * @objparam object aItemMeta contains information about the item's upgrades,
	 * infusions, skins, and bindings, which are found in characters and bank API.
	 * @objparam object aRuneSets containing counts of runes associated with rune's item ID.
	 * @objparam string aSoulbound name of character the item is bound to.
	 * @objparam function aCallback what to do after the tooltip generation
	 * completes. This provides an object containing additionally retrieved
	 * API objects like upgrades and skin.
	 */
	analyzeItem: function(pItem, pSettings)
	{
		var Settings = pSettings || {};
		// These will hold retrieved API objects, if a callback was requested
		var infusionobjs = [];
		var upgradeobjs = [];
		var skinobj = null;
		var attrobj = null; // Holds attribute points
		var isitemmeta = false;
		var istradeable = true;
		/* Example structure of aItemMeta object:
			{
				"id": 68390,
				"slot": "Coat",
				"count": 8,
				"binding": "Character",
				"bound_to": "Character Name"
				"upgrades": [24693],
				"infusions": [70852, 49433],
				"skin": 2346
			}
		 */
		if (Settings.aItemMeta)
		{
			isitemmeta = true;
		}
		Settings.aItemMeta = Settings.aItemMeta || {}; // If not provided then initialize as a blank object with undefined properties
		// Initialize attribute object if requested
		if (Settings.aWantAttr && A.isAccountInitialized)
		{
			attrobj = new A.Attribute.Base();
		}
		
		var item = pItem;
		var type = item.type;
		var subtype = "";
		var det = item.details;
		var buff = (det && det.infix_upgrade && det.infix_upgrade.buff) ? det.infix_upgrade.buff : null;
		var isweapon = (type === "Weapon");
		var isequipment = (isweapon || type === "Armor" || type === "Trinket" || type === "Back");
		var isbackitem = (type === "Back");
		var istrinket = (type === "Trinket" || isbackitem);
		var isascended = (item.rarity === Q.RarityEnum.Ascended || item.rarity === Q.RarityEnum.Legendary);
		var isdouble = false;
		var isvendorable = true;
		var isaccountbound = false;
		var issoulbound = false;
		var numfetched = 0;
		var numtofetch = 0;
		if (det && det.type)
		{
			subtype = det.type;
			if (type === "Weapon") // Only weapons can have two upgrade slots
			{
				isdouble = (subtype === "Greatsword" || subtype === "Hammer" || subtype === "LongBow"
					|| subtype === "ShortBow" || subtype === "Rifle" || subtype === "Staff"
					|| subtype === "Harpoon" || subtype === "Speargun" || subtype === "Trident");
			}
		}
		
		// NAME
		var namestr = "";
		var rarity = (item.rarity !== undefined) ? item.rarity : Q.RarityEnum.Basic;
		namestr = "<aside class='itmName " + Q.getRarityClass(rarity)
			+ "'><img class='itmIcon itmIconMain' src='" + item.icon + "' />" + U.escapeHTML(item.name) + "</aside>";
		
		// WEAPON STRENGTH
		var damagestr = "";
		if (det && det.min_power !== undefined && det.max_power !== undefined)
		{
			damagestr += "<span class='itmText'>" + D.getString("WeaponStrength") + ":</span> <span class='itmAttr'>"
				+ (det.min_power).toLocaleString() + " - " + (det.max_power).toLocaleString() + "</span><br />";
		}
		
		// DEFENSE
		var defensestr = "";
		if (det && det.defense > 0)
		{
			defensestr += "<span class='itmText'>" + D.getString("Defense") + ":</span> <span class='itmAttr'>" + (det.defense).toLocaleString() + "</span><br />";
		}
		
		// ATTRIBUTES
		var attrstr = "";
		var statsbrktop = "";
		if (det && det.infix_upgrade)
		{
			var attr = det.infix_upgrade.attributes;
			attrstr += "<aside class='itmAttr'>";
			
			if (det.infix_upgrade !== undefined)
			{
				// Armors, weapons, trinkets
				if (isequipment)
				{
					if (buff && buff.description && buff.description.indexOf("\n") === -1) // Disallow multi-line buff descriptions
					{
						attrstr += U.escapeHTML(buff.description) + "<br />";
					}
					attr.forEach(function(iStats)
					{
						attrstr += "+" + parseInt(iStats.modifier) + " " + Q.getAttributeTranslation(iStats.attribute) + "<br />";
					});
				}
				// Sigils
				else if (buff)
				{
					attrstr += "<span class='itmBuff'>" + Q.formatItemDescription(item) + "</span>";
					statsbrktop = "<br />";
				}
				// Runes
				else if (det.bonuses && det.type === "Rune")
				{
					attrstr += Q.getRuneBonus(item);
				}
			}
			
			attrstr = statsbrktop + attrstr;
			attrstr += "</aside>";
		}
		// Selectable stats equipment
		else if (Settings.aItemMeta.stats)
		{
			var selectattr = Settings.aItemMeta.stats.attributes;
			attrstr += "<aside class='itmAttr'>";
			for (var i in selectattr)
			{
				// Example output: +63 Condition Damage
				attrstr += "+" + selectattr[i] + " " + Q.getAttributeTranslation(i) + "<br />";
			}
			attrstr += "</aside>";
		}
		// Foods and Utilities
		else if (type === "Consumable")
		{
			attrstr += D.getString("DoubleClickToConsume") + "<br />";
			if (det.duration_ms !== undefined)
			{
				var consumeimgsrc = det.icon || ("img/account/item/nourishment" + ((det.type === "Food" || det.type === "Utility") ? ("_" + (det.type).toLowerCase()) : "") + I.cPNG);
				var consumetypestr = det.name || ((det.type === "Immediate") ? D.getString("Boost") : D.getString("Nourishment"));
				var consumedurstr = (det.duration_ms > 0) ? (" (" + T.formatTooltipTimeMS(det.duration_ms, true) + ")") : "";
				attrstr += "<span class='itmConsumableLine'><img class='itmIcon itmConsumableIcon' src='" + consumeimgsrc + "' /> "
					+ "<var class='itmGrayed itmConsumableDesc'>" + consumetypestr + consumedurstr + ": " + Q.formatItemDescription(det.description) + "</var></span>";
			}
			else if (det.type === "Booze")
			{
				attrstr += D.getString("ExcessiveAlcohol") + "<br />";
			}
		}
		// Sum attribute points if requested
		if (attrobj)
		{
			Q.sumItemAttribute(attrobj, {aItem: item, aStats: Settings.aItemMeta.stats});
		}
		
		// RARITY
		var raritystr = "";
		if (isequipment)
		{
			// Back item will have a beginning line break because of its type name
			raritystr = D.getString(item.rarity) + ((isbackitem) ? "" : "<br />");
		}
		
		// WEIGHT
		var weightstr = "";
		if (det && det.weight_class)
		{
			weightstr = D.getString(det.weight_class) + "<br />";
		}
		
		// TYPE
		var typestr = Q.getItemType(item);
		
		// LEVEL
		var levelstr = "";
		if (item.level > 1)
		{
			levelstr += D.getString("RequiredLevel") + ": " + item.level + "<br />";
		}
		
		// DESCRIPTION
		/*
		 * Item details' description may be pretagged with XML that colorizes
		 * a portion of text. Example: <c=@flavor>Description</c>
		 * If a tag exists, it shall have the "=@flavor" replaced with " class='.itmColor_flavor'"
		 */
		var desctopstr = "";
		var descbottomstr = "";
		var desc = item.description || "";
		desc = Q.formatItemDescription(desc);
		if (item.description)
		{
			desc = "<aside>" + desc + "</aside>";
			if (isequipment)
			{
				descbottomstr = desc;
			}
			else
			{
				desctopstr = desc;
			}
		}
		
		// SELECTABLE STATS
		var selectstatsstr = "";
		if (isequipment)
		{
			// If the item does not have attributes nor are attributes assigned yet
			if (det && det.infix_upgrade === undefined && Settings.aItemMeta.stats === undefined)
			{
				selectstatsstr = D.getString("DoubleClickToSelectStats") + "<br />";
			}
		}
		
		// FLAGS
		var flagsstr = "";
		var flagsobj = {};
		var addFlag = function(pFlagName)
		{
			flagsstr += D.getString(pFlagName) + "<br />";
		};
		if (item.flags)
		{
			// Convert the flags array to an associative array for easier reading
			item.flags.forEach(function(iFlag)
			{
				flagsobj[iFlag] = true;
			});
			// Uniqueness flag
			if (flagsobj["Unique"])
			{
				addFlag("Unique");
			}
			// Binding flags for custom items (equipped items or in bound in inventory)
			if (isitemmeta && Settings.aItemMeta.binding)
			{
				istradeable = false;
				if (Settings.aItemMeta.binding === "Character" && Settings.aItemMeta.bound_to)
				{
					flagsstr += "<var class='itmColor_warning'>" + D.getString("SoulboundToCharacter")
						+ ": " + Settings.aItemMeta.bound_to + "</var><br />";
				} 
				else if (Settings.aItemMeta.binding === "Account")
				{
					addFlag("AccountBound");
				}
			}
			else // Binding flags for fresh items
			{
				// "SoulbindOnAcquire" flag shall override "SoulBindOnUse"
				if (flagsobj["SoulbindOnAcquire"])
				{
					issoulbound = true;
					istradeable = false;
					addFlag("SoulbindOnAcquire");
				}
				else if (flagsobj["SoulBindOnUse"] && issoulbound === false)
				{
					addFlag("SoulBindOnUse");
				}
				// "AccountBound" flag shall override "AccountBindOnUse"
				if (flagsobj["AccountBound"]) 
				{
					isaccountbound = true;
					istradeable = false;
					addFlag("AccountBound");
				}
				else if (flagsobj["AccountBindOnUse"] && isaccountbound === false)
				{
					addFlag("AccountBindOnUse");
				}
			}
			// Vendorability flag
			if (flagsobj["NoSell"])
			{
				isvendorable = false;
			}
		}
		
		// CHARACTER BINDING
		var charbindstr = "";
		if (Settings.aSoulbound)
		{
			charbindstr = D.getString("SoulboundToCharacter") + ": " + U.escapeHTML(Settings.aSoulbound);
		}
		
		// ADDED COMMENT
		var commentstr = "";
		if (Settings.aComment)
		{
			commentstr = "<aside>" + Settings.aComment + "</aside>";
		}
		
		// VENDOR PRICE
		var vendorstr = "";
		var vendorvalue = 0;
		if (item.vendor_value > 0 && isvendorable)
		{
			// If stack count is included then multiply vendor price for one item by that number
			vendorvalue = (Settings.aItemMeta.count) ? Settings.aItemMeta.count * item.vendor_value : item.vendor_value;
			vendorstr = E.formatCoinString(vendorvalue, {aWantColor: true, aWantSpace: true});
		}
		
		/*
		 * Upgrades and transmutations requires loading AJAX, so they must be
		 * done last and checked that every requests have been fulfilled then
		 * the tooltip HTML generation is finalized.
		 */
		// UPGRADES
		var upgradebrk = "";
		var infusionslot;
		var infusiontype = "";
		var preinfusions = [];
		var infusionstr = [];
		var preupgrades = [];
		var upgradestr = [];
		if (isequipment)
		{
			if (isascended || (isascended && istrinket) === false)
			{
				upgradebrk = "<br />";
			}
			
			if (isascended)
			{
				if (det && det.infusion_slots)
				{
					for (var i = 0; i < det.infusion_slots.length; i++)
					{
						infusionslot = det.infusion_slots[i];
						infusiontype = (det.type === "Amulet") ? "Enrichment" : "Infusion";
						infusionstr.push("<img class='itmSlotIcon' src='img/account/item/" + infusiontype.toLowerCase() + ".png' /> "
							+ D.getString("Unused" + infusiontype + "Slot") + "<br /><br />");
						if (infusionslot.item_id !== undefined && Settings.aItemMeta.infusions === undefined)
						{
							preinfusions.push(infusionslot.item_id);
							numtofetch++;
						}
						else
						{
							preinfusions.push(null);
						}
					}
				}
			}
			if ((isascended && istrinket) === false)
			{
				var unupgradedslot = "<img class='itmSlotIcon' src='img/account/item/upgrade.png' /> "
					+ D.getString("UnusedUpgradeSlot") + "<br /><br />";
				upgradestr.push(unupgradedslot);
				upgradestr.push((isdouble) ? unupgradedslot : "");
				if (det && det.suffix_item_id && Settings.aItemMeta.upgrades === undefined)
				{
					preupgrades.push(det.suffix_item_id);
					numtofetch++;
				}
				else
				{
					preupgrades.push(null);
					if (isdouble)
					{
						preupgrades.push(null);
					}
				}
			}
		}
		
		// OVERWRITE INFUSIONS AND UPGRADES
		if (Settings.aItemMeta.infusions)
		{
			for (var i = 0; i < Settings.aItemMeta.infusions.length; i++)
			{
				if (i < preinfusions.length)
				{
					preinfusions[i] = Settings.aItemMeta.infusions[i];
					if (preinfusions[i])
					{
						numtofetch++;
					}
				}
			}
		}
		if (Settings.aItemMeta.upgrades)
		{
			for (var i = 0; i < Settings.aItemMeta.upgrades.length; i++)
			{
				if (i < preupgrades.length)
				{
					preupgrades[i] = Settings.aItemMeta.upgrades[i];
					if (preupgrades[i])
					{
						numtofetch++;
					}
				}
			}
		}
		
		// TRANSMUTATION
		var transmstr = "";
		if (Settings.aItemMeta.skin)
		{
			numtofetch++;
		}
		
		/*
		 * Final actions and binding to be done after the tooltip HTML has been
		 * formatted and additional AJAX HTML included.
		 */
		var finalizeTooltip = function()
		{
			if (numfetched !== numtofetch)
			{
				return;
			}
			var html = "<div class='itmTooltip'>"
				+ namestr
				+ damagestr
				+ defensestr
				+ attrstr
				+ desctopstr
				+ upgradebrk
				+ ((isweapon) ? (upgradestr.join("") + infusionstr.join("")) : (infusionstr.join("") + upgradestr.join("")))
				+ transmstr
				+ raritystr
				+ weightstr
				+ typestr
				+ levelstr
				+ descbottomstr
				+ selectstatsstr
				+ flagsstr
				+ charbindstr
				+ vendorstr
				+ commentstr
			+ "</div>";
			// Bind tooltip if provided an element
			if (Settings.aElement)
			{
				var elm = $(Settings.aElement);
				elm.attr("title", html);
				I.qTip.init(elm);
			}
			/*
			 * This object is the result of the analysis, containing tooltip
			 * information and additionally retrieved slotted items.
			 */
			var box = {
				oData: item,
				oInfusions: infusionobjs,
				oUpgrades: upgradeobjs,
				oSkin: skinobj,
				oAttr: attrobj,
				oHTML: html,
				oIsTradeable: istradeable
			};
			// Cache the item only if it's not custom (no upgrades or transmutations)
			if (isitemmeta === false && Settings.aComment === undefined)
			{
				Q.Boxes.Items[item.id] = box;
			}
			// Execute callback if provided
			if (Settings.aCallback)
			{
				Settings.aCallback(box);
			}
			// Already succeeded, so prevent recalling this subfunction
			numfetched = null;
		};
		
		/*
		 * Fetch additional data like slotted upgrades and transmutations.
		 */
		// SLOTTED INFUSIONS
		for (var i = 0; i < preinfusions.length; i++)
		{
			if (preinfusions[i] === null)
			{
				continue;
			}
			(function(iIndex, iInfusionID)
			{
				Q.getItem(iInfusionID, function(iData)
				{
					infusionstr[iIndex] = "<span class='itmUpgrade'><img class='itmSlotIcon' src='" + iData.icon + "' /> " + iData.name + "<br />"
						+ iData.details.infix_upgrade.buff.description + "</span><br /><br />";
					if (Settings.aCallback)
					{
						infusionobjs.push(iData);
					}
					if (attrobj)
					{
						Q.sumItemAttribute(attrobj, {aItem: iData});
					}
					numfetched++;
					finalizeTooltip();
				}).fail(function()
				{
					numtofetch--;
					finalizeTooltip();
				});
			})(i, preinfusions[i]);
		}
		
		// SLOTTED UPGRADES
		for (var i = 0; i < preupgrades.length; i++)
		{
			if (preupgrades[i] === null)
			{
				continue;
			}
			(function(iIndex, iUpgradeID)
			{
				Q.getItem(iUpgradeID, function(iData)
				{
					var upgdesc = "";
					if (iData.details.type === "Rune")
					{
						var runepieces = 0;
						if (det.type === "HelmAquatic")
						{
							// Count the rune in the aquatic helm for its own slotted description
							runepieces = (Settings.aRuneSets && Settings.aRuneSets[iData.id]) ? (1 + Settings.aRuneSets[iData.id].numslotted) : 1;
						}
						else if (Settings.aRuneSets)
						{
							runepieces = Settings.aRuneSets;
						}
						upgdesc = Q.getRuneBonus(iData, runepieces);
						if (attrobj)
						{
							Q.sumItemAttribute(attrobj, {aItem: iData, aRuneSets: Settings.aRuneSets});
						}
					}
					else
					{
						upgdesc = iData.name + "<br />" + Q.formatItemDescription(iData);
						if (attrobj)
						{
							Q.sumItemAttribute(attrobj, {aItem: iData});
						}
					}
					
					upgradestr[iIndex] = "<aside class='itmUpgrade'><img class='itmSlotIcon' src='" + iData.icon + "' /> " + upgdesc + "</aside><br />";
					if (Settings.aCallback)
					{
						upgradeobjs.push(iData);
					}
					numfetched++;
					finalizeTooltip();
				}).fail(function()
				{
					numtofetch--;
					finalizeTooltip();
				});
			})(i, preupgrades[i]);
		}
		
		// TRANSMUTED
		if (Settings.aItemMeta.skin)
		{
			Q.getSkins(Settings.aItemMeta.skin, function()
			{
				var skinbox = Q.getBoxedSkin(Settings.aItemMeta.skin);
				if (skinbox)
				{
					var skin = skinbox.oData;
					namestr = "<aside class='itmName " + Q.getRarityClass(rarity)
						+ "'><img class='itmIcon itmIconMain' src='" + skin.icon + "' />" + U.escapeHTML(skin.name) + "</aside>";
					transmstr = "<aside='itmTransmute'>" + D.getString("Transmuted") + "<br />" + U.escapeHTML(item.name) + "</aside><br /><br />";
					if (Settings.aCallback)
					{
						skinobj = skin;
					}
					numfetched++;
					finalizeTooltip();
				}
				else
				{
					numtofetch--;
					finalizeTooltip();
				}
			});
		}
		
		// In case no fetching is needed at all
		if (numfetched === numtofetch)
		{
			finalizeTooltip();
		}
	},
	
	/*
	 * Puts all data entries of an API database into boxes.
	 * @param string pType
	 */
	initializeBoxes: function(pType, pDatabase)
	{
		var type = U.toFirstUpperCase(pType);
		for (var i in pDatabase)
		{
			if ((Q.Boxes[type])[i] === undefined)
			{
				(Q.Boxes[type])[i] = {};
			}
			(Q.Boxes[type])[i].oData = pDatabase[i];
		}
	},
	
	/*
	 * Macro function to retrieve and cache API data with IDs.
	 * @param string pType name of the API endpoint.
	 * @param intarray or int pIDs, or "true" if want fetch of entire API of that type
	 * @param function pCallback
	 */
	getBoxes: function(pType, pIDs, pCallback)
	{
		var ids = pIDs;
		var idstofetch = [];
		var cache = Q.Boxes[pType];
		var getData = function()
		{
			// Filter out duplicates if provided an array
			ids = U.getUnique(ids);
			// Filter out cached data
			for (var i in ids)
			{
				if (cache[ids[i]] === undefined)
				{
					idstofetch.push(ids[i]);
				}
			}
			// Fetch
			U.fetchAPI(U.getAPIURL(pType), idstofetch, {
				aCallback: function(pData)
				{
					for (var i in pData)
					{
						var ithdata = pData[i];
						cache[ithdata.id] = {};
						cache[ithdata.id].oData = ithdata;
					}
					pCallback();
				}
			});
		};
		// If provided a single ID
		if (typeof pIDs === "number")
		{
			var id = pIDs;
			if (cache[id])
			{
				pCallback();
			}
			else
			{
				U.getJSON(U.getAPI(pType.toLowerCase(), id), function(pData)
				{
					cache[id] = {};
					cache[id].oData = pData;
					pCallback();
				}).fail(function()
				{
					pCallback();
				});
			}
		}
		// If no IDs to fetch
		else if (pIDs.length === 0)
		{
			pCallback();
		}
		// If provided array of IDs
		else
		{
			// If provided as so then regard as all possible IDs
			if (pIDs === true)
			{
				if (Q.isBoxedFully[pType])
				{
					pCallback();
				}
				else
				{
					Q.isBoxedFully[pType] = true;
					U.getJSON(U.getAPI(pType), function(pArray)
					{
						ids = pArray;
						getData();
					});
				}
			}
			else
			{
				getData();
			}
		}
	},
	getItems: function(pIDs, pCallback)
	{
		Q.getBoxes("Items", pIDs, pCallback);
	},
	getSkins: function(pIDs, pCallback)
	{
		Q.getBoxes("Skins", pIDs, pCallback);
	},
	getAchievements: function(pIDs, pCallback)
	{
		Q.getBoxes("Achievements", pIDs, pCallback);
	},
	getTitles: function(pIDs, pCallback)
	{
		Q.getBoxes("Titles", pIDs, pCallback);
	},
	getSpecializations: function(pIDs, pCallback)
	{
		Q.getBoxes("Specializations", pIDs, pCallback);
	},
	getTraits: function(pIDs, pCallback)
	{
		Q.getBoxes("Traits", pIDs, pCallback);
	},
	getSkills: function(pIDs, pCallback)
	{
		Q.getBoxes("Skills", pIDs, pCallback);
	},
	getBoxedItem: function(pID)
	{
		return Q.Boxes.Items[pID];
	},
	getBoxedSkin: function(pID)
	{
		return Q.Boxes.Skins[pID];
	},
	getBoxedAchievement: function(pID)
	{
		return Q.Boxes.Achievements[pID];
	},
	getBoxedTitle: function(pID)
	{
		return Q.Boxes.Titles[pID];
	},
	getBoxedSpecialization: function(pID)
	{
		return Q.Boxes.Specializations[pID];
	},
	getBoxedTrait: function(pID)
	{
		return Q.Boxes.Traits[pID];
	},
	getBoxedSkill: function(pID)
	{
		return Q.Boxes.Skills[pID];
	},
	getCachedItem: function(pID)
	{
		var box = Q.getBoxedItem(pID);
		if (box)
		{
			return box.oData;
		}
		return null;
	},
	
	/*
	 * Lightweight preliminary function to check if the requested data had been
	 * analyzed, with HTML ready for showing.
	 * @param object pBox
	 * @param object pSettings
	 */
	scanData: function(pType, pBox, pSettings)
	{
		var Settings = pSettings || {};
		if (pBox && pBox.oHTML)
		{
			if (Settings.aElement)
			{
				var elm = $(Settings.aElement);
				elm.attr("title", pBox.oHTML);
				I.qTip.init(elm);
			}
			// Execute callback if provided
			if (Settings.aCallback)
			{
				Settings.aCallback(pBox);
			}
		}
		else
		{
			(Q["analyze" + pType])(pBox.oData, pSettings);
		}
	},
	scanAchievement: function(pID, pSettings)
	{
		Q.scanData("Achievement", Q.getBoxedAchievement(pID), pSettings);
	},
	scanSpecialization: function(pID, pSettings)
	{
		Q.scanData("Specialization", Q.getBoxedSpecialization(pID), pSettings);
	},
	scanTrait: function(pID, pSettings)
	{
		Q.scanData("Trait", Q.getBoxedTrait(pID), pSettings);
	},
	scanSkill: function(pID, pSettings)
	{
		Q.scanData("Skill", Q.getBoxedSkill(pID), pSettings);
	},
	
	/*
	 * Generates achievement tooltip HTML
	 * @param object pAchievement details retrieved from API.
	 * @objparam jqobject aElement to bind tooltip.
	 * @objparam boolean aWantIcon whether to include achievement's icon.
	 * @objapram boolean aWantCard whether to format for bank cards.
	 * @objparam object aAchievement processed object, optional.
	 * @objparam function aCallback what to do after the tooltip generation.
	 */
	analyzeAchievement: function(pAchievement, pSettings)
	{
		var Settings = pSettings || {};
		var ach = pAchievement;
		var iconstr = "";
		var namestr = "<aside class='itmName achName'>" + U.escapeHTML(ach.name) + "</aside>";
		var descstr = "";
		var instructstr = "";
		var reqstr = "";
		var countstr = "";
		var tierstr = "";
		var pointsstr = "";
		var searchpointsstr = "";
		
		if (Settings.aWantIcon && ach.icon)
		{
			iconstr = "<img class='achIcon' src='" + ach.icon + "'/ >";
		}
		if (ach.instruction)
		{
			instructstr = "<aside class='achInstruction'>" + ach.instruction + "</aside>";
		}
		if (ach.description)
		{
			descstr = "<aside class='achDescription'>" + ach.description + "</aside>";
		}
		if (ach.requirement)
		{
			reqstr = "<aside class='achRequirement'>" + ach.requirement + "</aside>";
		}
		if (Settings.aWantCard)
		{
			return namestr + ((ach.instruction) ? instructstr : ((reqstr.length) ? reqstr : descstr));
		}
		
		if (pAchievement.tiers)
		{
			var processedach = Settings.aAchievement || Q.processAchievement(pAchievement);
			var tierword = D.getWordCapital("tier");
			countstr = "<aside class='achCount'>" + processedach.oAPCountCurrent.toLocaleString()
				+ " / " + processedach.oAPCountPossible.toLocaleString() + " " + D.getWordCapital("completion")
				+ " (" + U.convertRatioToPercent(processedach.oAPCountCurrent / processedach.oAPCountPossible) + ")</aside>";
			tierstr = "<aside class='achTier'>" + tierword + " " + processedach.oAPTierCurrent + " "
				+ D.getWord("of") + " " + processedach.oAPTierPossible + " " + tierword + "</aside>";
			pointsstr = "<aside class='achPoints'>" + ((processedach.oAPPointPossible > 0)
				? (processedach.oAPPointCurrent + " / " + processedach.oAPPointPossible) : "0") + " <img src='img/ui/ap.png' /></aside";
			searchpointsstr = "<var class='achSearchPoints'>" + ((processedach.oAPPointCurrent === processedach.oAPPointPossible)
				? "" : (processedach.oAPPointCurrent + " / ")) + E.formatAchievement(processedach.oAPPointPossible) + "</var>";
		}
		
		var html = "<div class='itmTooltip " + (Settings.aClass || "") + "'>"
			+ "<div class='achWrap'>"
				+ iconstr
				+ "<div class='achText'>"
					+ namestr
					+ reqstr
					+ instructstr
					+ descstr
					+ countstr
					+ tierstr
					+ pointsstr
				+ "</div>"
			+ "</div>"
		+ "</div>";
		// Bind tooltip if provided an element
		if (Settings.aElement)
		{
			var elm = $(Settings.aElement);
			elm.attr("title", html);
			I.qTip.init(elm);
		}
		var box = Q.getBoxedAchievement(ach.id) || {};
		box.oHTML = html;
		box.oSearchPoints = searchpointsstr; // For displaying in the achievements search results
		if (Settings.aCallback)
		{
			Settings.aCallback(box);
		}
		else
		{
			return html;
		}
	},
	
	/*
	 * Gets the computed points, counts, and tiers of an achievement.
	 * @param object pAchievement
	 * @param object pAccountAch account unlocks for getting progress, optional.
	 * @returns object
	 */
	processAchievement: function(pAchievement, pAccountAch)
	{
		var tiers = pAchievement.tiers;
		var currentpoints = 0;
		var possiblepoints = 0;
		var currentcount = (pAccountAch && pAccountAch.current !== undefined) ? pAccountAch.current : 0;
		var possiblecount = tiers[tiers.length - 1].count;
		var currenttier = 0;
		var possibletiers = tiers.length;
		tiers.forEach(function(iTier)
		{
			if (pAccountAch && pAccountAch.current >= iTier.count)
			{
				currenttier++;
				currentpoints += iTier.points;
			}
			possiblepoints += iTier.points;
		});
		
		return {
			oAPPointCurrent: currentpoints,
			oAPPointPossible: possiblepoints,
			oAPCountCurrent: currentcount,
			oAPCountPossible: possiblecount,
			oAPTierCurrent: currenttier,
			oAPTierPossible: possibletiers
		};
	},
	
	/*
	 * Gives tooltip to elements with data-ach attribute.
	 * @param jqobject or string pSelector
	 */
	bindAchievement: function(pSelector)
	{
		var ids = [];
		var elms = [];
		$(pSelector).each(function()
		{
			var id = parseInt($(this).attr("data-ach"));
			if (id)
			{
				ids.push(id);
				elms.push($(this));
			}
		});
		Q.getAchievements(ids, function()
		{
			for (var i = 0; i < elms.length; i++)
			{
				Q.scanAchievement(ids[i], {aElement: elms[i]});
			}
		});
	},
	
	/*
	 * Formats a trait or skill object to be used in tooltips.
	 * @param object pTrait details retrieved from API.
	 * @returns string content for tooltip window.
	 */
	formatSkillTrait: function(pTrait)
	{
		var formatFact = function(pFact)
		{
			var text = pFact.text;
			var type = pFact.type;
			var value = pFact.value;
			var attrtarget = (pFact.target !== undefined) ? Q.getAttributeTranslation(pFact.target) : "";
			var attrsource = (pFact.source !== undefined) ? Q.getAttributeTranslation(pFact.source) : "";
			var buffconv = (type === "BuffConversion") ? D.getString("GainBasedPercentage").replace("{0}", attrsource).replace("{1}", attrtarget) : "";
			var icon = "<img class='trtFactIcon' src='" + pFact.icon + "' />";
			var prefixicon = (pFact.prefix && pFact.prefix.icon) ? "<img class='trtFactIcon' src='" + pFact.prefix.icon + "' />" : "";
			var desc = pFact.description;
			var stacks = (pFact.apply_count > 1) ? "<var class='trtStacks'>" + pFact.apply_count + "</var>" : "";
			var duration = (pFact.duration !== undefined) ? (pFact.duration + " " + D.getWord("seconds")) : "";
			var durationabbr = (pFact.duration !== undefined) ? " (" + T.formatTooltipTime(pFact.duration) + ")" : "";
			var status = pFact.status;
			var combofield = pFact.field_type;
			var combofinisher = pFact.finisher_type;
			var percent = pFact.percent + "%";
			var hitcount = pFact.hit_count + "x";
			var distance = pFact.distance;
			
			var wrap = function(pIcon, pText)
			{
				return "<var class='trtFactIcons'>" + pIcon + "</var><var class='trtFactText'>" + pText + "</var>";
			};
			
			var facttype = {
				AttributeAdjust: function(){
					return wrap(icon, "+" + value + " " + attrtarget);},
				Buff: function(){
					return wrap(stacks + icon, status + durationabbr + ": " + desc);},
				BuffConversion: function(){
					return wrap(icon, buffconv);},
				ComboField: function(){
					return wrap(icon, text + ": " + combofield);},
				ComboFinisher: function(){
					return wrap(icon, text + ": " + combofinisher + " (" + percent + ")");},
				Damage: function(){
					return wrap(icon, text + ": " + hitcount);},
				Distance: function(){
					return wrap(icon, text + ": " + distance);},
				Duration: function(){
					return wrap(icon, text + ": " + duration);},
				Heal: function(){
					return wrap(icon, text + ": " + hitcount);},
				HealingAdjust: function(){
					return wrap(icon, text + ": " + hitcount);},
				NoData: function(){
					return wrap(icon, text);},
				Number: function(){
					return wrap(icon, text + ": " + value);},
				Percent: function(){
					return wrap(icon, text + ": " + percent);},
				PrefixedBuff: function(){
					return wrap(icon + prefixicon, status + durationabbr + ": " + desc);},
				Radius: function(){
					return wrap(icon, text + ": " + distance);},
				Range: function(){
					return wrap(icon, text + ": " + value);},
				Time: function(){
					return wrap(icon, text + ": " + duration);},
				Unblockable: function(){
					return wrap(icon, text);}
			};
			
			if (facttype[type])
			{
				return "<span class='trtFactLine'>" + facttype[type]() + "</span>";
			}
			return "";
		};
		
		var name = "<span class='trtName'>" + pTrait.name + "</span>";
		var desc = "<span class='trtDesc'>" + Q.formatItemDescription(pTrait.description) + "</span>";
		var recharge = "";
		var facts = "";
		var factsinner = "";
		if (pTrait.facts && pTrait.facts.length > 0)
		{
			facts += "<aside class='trtFacts'>";
			pTrait.facts.forEach(function(iFact)
			{
				if (iFact.type === "Recharge")
				{
					recharge = "<span class='trtRecharge'>" + iFact.value + "<img class='trtRechargeIcon' src='" + iFact.icon + "' /></span>";
				}
				else
				{
					factsinner += formatFact(iFact);
				}
			});
			// Don't include facts element if no fact lines were added
			facts = (factsinner === "") ? "" : (facts + factsinner + "</aside>");
		}
		
		return recharge + name + desc + facts;
	},
	
	/*
	 * Generates skill or trait tooltip HTML.
	 * @param string pType cache as skill or trait.
	 * @param object pData details retrieved from API.
	 * @objparam jqobject aElement to bind tooltip.
	 */
	analyzeSkillTrait: function(pType, pData, pSettings)
	{
		var Settings = pSettings || {};
		var content = Q.formatSkillTrait(pData);
		
		// Calculate an extra tooltip's height by actually making it then measuring its height
		var computeOffset = function(pContent)
		{
			var nullcon = $("#itemNull").empty();
			var height = $(pContent).appendTo(nullcon).height();
			nullcon.empty(); // Served its purpose, so delete the element
			return height;
		};
		
		// Include additional tooltips if trait has a skills array
		var skilltooltips = "";
		var offsetcumulative = 6;
		var offsetbetween = 20;
		if (pData.skills)
		{
			pData.skills.forEach(function(iSkill)
			{
				/*
				 * A trait may contain skill tooltips above its own tooltip. To
				 * position them like in game, the vertical offsets need to be
				 * computed so the extra tooltips float by absolute position,
				 * even though all the tooltips share a single container.
				 */
				var dummytooltip = "<div class='qTip'><div class='trtTooltip'>" + Q.formatSkillTrait(iSkill) + "</div></div>";
				offsetcumulative += computeOffset(dummytooltip) + offsetbetween;
				// Write the actual extra skill tooltip
				skilltooltips += "<div class='trtTooltip trtTooltipExtra' style='margin-top:" + "-" + offsetcumulative + "px" + "'>"
					+ Q.formatSkillTrait(iSkill) + "</div>";
			});
		}
		
		var html = "<div class='trtTooltipBorder'>" + I.Symbol.Filler + "</div>"
			+ skilltooltips + "<div class='trtTooltip'>" + content + "</div>";
		var box = (Q.Boxes[pType])[pData.id];
		if (box)
		{
			box.oHTML = html;
		}
		if (Settings.aElement)
		{
			var elm = $(Settings.aElement);
			elm.attr("title", html);
			I.qTip.init(elm);
			elm.click(function()
			{
				I.prettyJSON(pData);
			});
		}
	},
	analyzeTrait: function(pTrait, pSettings)
	{
		Q.analyzeSkillTrait("Traits", pTrait, pSettings);
	},
	analyzeSkill: function(pSkill, pSettings)
	{
		Q.analyzeSkillTrait("Skills", pSkill, pSettings);
	},
	
	/*
	 * Retrieves and caches guild details.
	 * @param array pIDs of guilds
	 * @param function pCallback
	 * @param boolean pWantCache true if undefined.
	 */
	getGuilds: function(pIDs, pCallback, pWantCache)
	{
		var ids = (Array.isArray(pIDs)) ? pIDs : [pIDs];
		var wantcache = (pWantCache !== undefined) ? pWantCache : true;
		var idstofetch = [];
		// Only fetch those not already cached
		if (wantcache)
		{
			for (var i in ids)
			{
				var id = ids[i];
				if (Q.Boxes.Guilds[id] === undefined)
				{
					idstofetch.push(id);
				}
			}
			if (idstofetch.length === 0)
			{
				pCallback();
				return;
			}
		}
		else
		{
			idstofetch = ids;
		}
		
		// Guild details cannot be bulk fetched, so retrieve them one by one
		var numfetched = 0;
		var numtofetch = ids.length;
		for (var i in idstofetch)
		{
			U.getJSON(U.URL_API.Guild + idstofetch[i], function(pData)
			{
				pData.oTag = "[" + pData.tag + "]";
				Q.Boxes.Guilds[pData.id] = pData;
				numfetched++;
				if (numfetched === numtofetch)
				{
					pCallback();
				}
			}, wantcache).fail(function()
			{
				numfetched--;
			});
		}
	},
	getCachedGuild: function(pID)
	{
		var guild = Q.Boxes.Guilds[pID];
		if (guild)
		{
			return guild;
		}
		return null;
	},
	
	/*
	 * Initializes the context menu that is shown for all banks' slots.
	 */
	initializeItemContextMenu: function()
	{
		I.styleContextMenu("#itmContext");
		$("#itmContext").click(function()
		{
			$(this).hide();
		});
		// The context variables should be assigned by the function that styles the bank slot
		$("#itmContextWiki").click(function()
		{
			U.openExternalURL(U.getWikiLinkLanguage(Q.Context.ItemName));
		});
		$("#itmContextYouTube").click(function()
		{
			U.openExternalURL(U.getYouTubeLink(Q.Context.ItemSearch));
		});
		$("#itmContextTrading").click(function()
		{
			U.openExternalURL(U.getTradingItemLink(Q.Context.ItemID, Q.Context.ItemName));
		});
		$("#itmContextTradingSearch").click(function()
		{
			E.printListings(Q.Context.ItemID);
		});
		$("#itmContextInfo").click(function()
		{
			if (Q.Context.Item)
			{
				if (Q.Context.Item.name)
				{
					Q.printItemInfo(Q.Context.Item);
				}
				else
				{
					I.prettyJSON(Q.Context.Item);
				}
			}
			else
			{
				I.print("No information available.");
			}
		});
		I.bindClipboard("#itmContextChatlink");
	},
	
	/*
	 * Binds an element that represents a game item to have a context menu.
	 * @param jqobject pSlot to bind.
	 * @objparam object aItem from item details API.
	 * @objparam object aObject non-item object for printing the slot's information, optional.
	 * @objparam string aSearch for wiki search link, optional.
	 * @objparam int aTradeableID for TP webpage, optional.
	 */
	bindItemSlotBehavior: function(pSlot, pSettings)
	{
		var Settings = pSettings || {};
		// Right click on the item slot shows context menu
		pSlot.contextmenu(function(pEvent)
		{
			pEvent.preventDefault();
			var chatlink;
			if (Settings.aItem)
			{
				Q.Context.Item = Settings.aItem;
				Q.Context.ItemName = Settings.aItem.name;
				Q.Context.ItemID = Settings.aTradeableID || Settings.aItem.id;
				Q.Context.ItemSearch = Settings.aSearch || Settings.aItem.name;
				chatlink = Settings.aItem.chat_link + " " + Q.Context.ItemSearch;
			}
			else
			{
				Q.Context.Item = Settings.aObject;
				Q.Context.ItemName = Settings.aSearch;
				Q.Context.ItemID = Settings.aTradeableID;
				Q.Context.ItemSearch = Settings.aSearch;
				chatlink = Settings.aChatlink || "No chatlink available.";
			}
			I.updateClipboard("#itmContextChatlink", chatlink);
			I.showContextMenu("#itmContext");
		});
		// Bind the click to go to wiki behavior if requested
		if (Settings.aWantClick)
		{
			pSlot.click(function(pEvent)
			{
				if (pEvent.which === I.ClickEnum.Left)
				{
					U.openExternalURL(U.getWikiSearchLanguage(Settings.aItem.name));
				}
			});
		}
	},
	
	/*
	 * Binds an input bar to search for items (or a database for objects) by name.
	 * @param jqobject pElement to bind.
	 * @objparam string aFillerText to display over the input bar, provide null for no text, optional.
	 * @objparam string aInfo search usage, optional.
	 * @objparam string aResultsClass CSS class for results container element, optional.
	 * @objparam int aResultsLimit max number of results to show, optional.
	 * @objparam boolean aIsSelect whether to emulate the <select> functionality, requires aDatabase, optional.
	 * @objparam boolean aIsInline whether the search box does not take all available width, optional.
	 * @objparam boolean aWantEnter whether to bind the default Enter key event, optional.
	 * @objparam boolean aWantClose whether to close the search results after clicking, optional.
	 * @objparam object aSubset associative array of item IDs to limit the search, optional.
	 * @objparam objarray aDatabase custom search database to use instead of items search, optional.
	 * @objparam object aAchievements account's achievement unlocks, optional.
	 * @objparam function aCallback to execute after the user selects an item.
	 * @objparam function aCancel to execute when user clicks on the close button, optional.
	 * @pre Input bar has a parent container element in order to position the results list.
	 * Item search database format: [[int_itemid, str_keywords], ...]
	 * Custom search database format: [{name: "", icon: "", keywords: ""}, ...]
	 * keywords is the searchable name of the result in lowercase.
	 */
	bindItemSearch: function(pElement, pSettings)
	{
		var Settings = pSettings || {};
		var elm = $(pElement).wrap("<span class='itmSearchContainer " + ((Settings.aIsInline) ? "itmSearchInline" : "") + "'></span>");
		var isitemsearch = (Settings.aDatabase === undefined);
		var queryminchar = (D.isLanguageLogographic || !isitemsearch) ? 1 : 2;
		var queryminitemidlength = 4;
		var resultslimit = Settings.aResultsLimit || O.Options.int_numTradingResults;
		var resultscontainer = $("<div class='itmSearchResultContainer jsHidable'></div>").insertAfter(elm).hide();
		var resultsscroll = $("<div class='itmSearchResultScroll cntPopup jsScrollable'></div>").appendTo(resultscontainer);
		var resultslist = $("<div class='itmSearchResultList'></div>").appendTo(resultsscroll);
		var notfoundstr = "<var class='itmSearchResultNone'>" + D.getPhraseOriginal("Not found") + "." + "</var>";
		var itemsearchdb, customsearchdb = [], searchindexes = [], isdirectionchanged, searchtimestamp;
		var resultsarrall = [];
		
		if (Settings.aFillerText !== null)
		{
			I.bindInputBarText(elm, (Settings.aIsSelect) ? I.Symbol.TriDown + " " + Settings.aFillerText : Settings.aFillerText);
		}
		if (Settings.aResultsClass)
		{
			resultsscroll.addClass(Settings.aResultsClass);
		}
		I.bindScrollbar(resultsscroll);
		// Pseudo <select> element shows the entire database when clicked
		if (Settings.aIsSelect)
		{
			resultsarrall = Settings.aDatabase;
		}
		// Initialize custom search database
		if (Settings.aDatabase)
		{
			for (var i in Settings.aDatabase)
			{
				var ithobj = Settings.aDatabase[i];
				customsearchdb.push([ithobj, ithobj.keywords || ithobj.name.toLowerCase()]);
			}
		}
		
		// Toggles display of the results container popup
		var resetSearch = function()
		{
			isdirectionchanged = true;
			searchindexes = [];
		};
		var toggleResults = function(pBoolean, pMessage)
		{
			resultslist.empty().removeData("selectedresult");
			resultscontainer.toggle(pBoolean);
			if (pMessage)
			{
				resultslist.html(pMessage);
			}
			if (pBoolean === false)
			{
				resetSearch();
				I.qTip.hide();
			}
		};
		var searchinfo = "<br />" + ((isitemsearch) ? "Right click an item for menu.<br />Type a number to search by item ID." : (Settings.aInfo || ""));
		var searchclose = $("<ins class='itmSearchClose btnWindow btnClose' "
			+ "title='<dfn>Close the search results.</dfn>" + searchinfo + "'></ins>")
			.appendTo(resultscontainer).click(function()
		{
			if (Settings.aCancel)
			{
				Settings.aCancel();
			}
			toggleResults(false);
		});
		I.qTip.init(searchclose);
		
		// Standard behavior when clicked on a search result
		var bindResultClick = function(pResultsList, pResultEntry, pDataEntry, pCloseResults)
		{
			pResultEntry.click(function()
			{
				if (Settings.aCallback)
				{
					Settings.aCallback(pDataEntry);
					if (pCloseResults || Settings.aWantClose)
					{
						toggleResults(false);
					}
				}
				pResultsList.removeData("selectedresult");
			});
		};
		
		// Fills the results list with downloaded API data for each result item
		var renderSearch = function(pResults, pQuery)
		{
			if (pResults.length === 0)
			{
				toggleResults(true, notfoundstr);
				return;
			}
			
			toggleResults(true);
			if (isitemsearch)
			{
				// A new search updates the timestamp, only the earliest results are allowed to be shown
				searchtimestamp = (new Date()).getTime();
				// Create an ordered list that acts as containers for each result entry
				resultslist.append(I.cThrobber);
				for (var i = 0; i < pResults.length; i++)
				{
					resultslist.append("<span class='itmSearchResultLine itmSearchResultLine_" + pResults[i] + "'></span>");
				}
				(function(iTimestamp)
				{
					Q.getPricedItems(pResults, function()
					{
						// Prevent older searches from entering the results because of API retrieval lag
						if (iTimestamp === searchtimestamp)
						{
							I.removeThrobber(resultslist);
							for (var i = 0; i < pResults.length; i++)
							{
								var itemid = pResults[i];
								var item = Q.getCachedItem(itemid);
								if (item === null)
								{
									continue;
								}
								var resultentry = $("<dfn class='itmSearchResultEntry " + Q.getRarityClass(item.rarity) + "' data-id='" + itemid + "'>"
									+ "<img src='" + item.icon + "'>"
									+ U.highlightSubstring(item.name, pQuery) + "</dfn>").appendTo(resultslist.find(".itmSearchResultLine_" + itemid));
								bindResultClick(resultslist, resultentry, item, true);
								
								I.updateScrollbar(resultsscroll);
								// Tooltip for the listed item
								Q.scanItem(item, {aElement: resultentry});
								Q.bindItemSlotBehavior(resultentry, {aItem: item});
								// Also include price next to tradeable items
								var priceobj = E.getCachedPrice(itemid);
								if (priceobj)
								{
									var pricestr = "<span class='itmSearchResultPrice'>" + E.formatCoinStringSlot(priceobj.oPriceSell)
										+ " <var class='cssFaded'>" + E.formatCoinStringSlot(priceobj.oPriceBuy) + "</var></span>";
									resultentry.append(pricestr);
								}
							}
						}
					}, true);
				})(searchtimestamp);
			}
			else
			{
				for (var i = 0; i < pResults.length; i++)
				{
					var resultentry = $("<span class='itmSearchResultLine'><dfn class='itmSearchResultEntry'>"
						+ "<img src='" + (pResults[i].icon || "img/ui/sixteen/bullet.png") + "' />"
						+ U.highlightSubstring(pResults[i].name, pQuery) + "</dfn></span>").appendTo(resultslist);
					bindResultClick(resultslist, resultentry, pResults[i]);
					
					// Custom features for custom database
					if (Settings.aAchievements)
					{
						(function(iResult, iEntry)
						{
							var achid = iResult.id;
							Q.analyzeAchievement(iResult, {
								aAchievement: Q.processAchievement(iResult, Settings.aAchievements[achid]),
								aElement: iEntry,
								aCallback: function(pBox)
								{
									iEntry.append(pBox.oSearchPoints);
								}
							});
						})(pResults[i], resultentry.find(".itmSearchResultEntry").first());
					}
				}
				I.updateScrollbar(resultsscroll);
			}
			// Traversal buttons
			if (pResults.length === resultslimit)
			{
				$("<span class='itmSearchResultNext curClick'>" + D.getWordCapital("next") + " &gt;</span>")
					.prependTo(resultslist).click(function()
				{
					if (isdirectionchanged === false)
					{
						isdirectionchanged = true;
						executeSearch(searchindexes[searchindexes.length - 1]);
					}
					executeSearch(searchindexes[searchindexes.length - 1]);
				});
			}
			if (searchindexes.length > 1)
			{
				$("<span class='itmSearchResultPrev curClick'>&lt; " + D.getWordCapital("previous") + "</span>")
					.prependTo(resultslist).click(function()
				{
					if (isdirectionchanged === true)
					{
						searchindexes.pop();
						isdirectionchanged = false;
					}
					searchindexes.pop();
					executeSearch(searchindexes[searchindexes.length - 1]);
					searchindexes.pop();
				});
			}
		};
		
		// Searches the search database for matching items' names
		var executeSearch = function(pIndex)
		{
			var startingindex = (pIndex === undefined) ? 0 : pIndex;
			var query = elm.val().toLowerCase();
			var entry, subqueries, result, searchname, ismatch;
			var resultsarr = [];
			var searchdatabase = (isitemsearch) ? itemsearchdb : customsearchdb;
			
			// For emulating the <select> input, show all possible items
			if (Settings.aIsSelect && !query.length)
			{
				renderSearch(resultsarrall, "");
				return;
			}
			else
			{
				// If query is empty or below minimum length
				if (query.length < queryminchar)
				{
					toggleResults(false);
					return;
				}
				// If query is an integer, assume it is an item ID
				if (U.isInteger(query) && Settings.aDatabase === undefined && query.length >= queryminitemidlength)
				{
					renderSearch([parseInt(query)], query);
					return;
				}
			}

			// Else proceed with regular search through the database
			for (var i = startingindex; i < searchdatabase.length; i++)
			{
				entry = searchdatabase[i];
				subqueries = query.split(" ");
				result = entry[0];
				searchname = entry[1];
				// Search using every space separated substrings in the query
				ismatch = true;
				for (var ii = 0; ii < subqueries.length; ii++)
				{
					if (searchname.indexOf(subqueries[ii]) === -1)
					{
						ismatch = false;
						continue;
					}
				}
				if (ismatch)
				{
					// Only include in result if every subquery was found in the item's name
					resultsarr.push(result);
				}
				// Show the results if found enough matching items
				if (resultsarr.length >= resultslimit)
				{
					if (pIndex !== undefined || searchindexes.length === 0)
					{
						searchindexes.push(i+1);
					}
					renderSearch(resultsarr, query);
					return;
				}
			}
			// In case number of items found is below the limit
			if (pIndex !== undefined || searchindexes.length === 0)
			{
				searchindexes.push(startingindex);
			}
			renderSearch(resultsarr, query);
		};
		
		// Select an entry from the result list when user presses up or down arrow key
		var executeArrowKey = function(pDirection)
		{
			var selectedresult = resultslist.data("selectedresult") || resultslist.find(".itmSearchResultEntry").first().parent();
			if (selectedresult && selectedresult.length)
			{
				var nextresult = (pDirection) ? selectedresult.next() : selectedresult.prev();
				if (nextresult && nextresult.hasClass("itmSearchResultLine"))
				{
					resultslist.find(".itmSearchSelected").removeClass("itmSearchSelected");
					resultslist.data("selectedresult", nextresult);
					nextresult.addClass("itmSearchSelected");
					I.scrollToElement(nextresult, {
						aContainer: resultsscroll,
						aOffset: -(resultsscroll.height() / 2) // Scroll so the entry appears in the middle of the results window
					});
				}
			}
		};
		
		// Bind the search only after the user has clicked on the search bar
		elm.one("click", function()
		{
			toggleResults(true);
			resultslist.append(I.cThrobber);
			var bindSearch = function()
			{
				// Initialize the item search if used
				if (isitemsearch)
				{
					if (Settings.aSubset)
					{
						itemsearchdb = [];
						for (var i = 0; i < Q.SearchDatabase.length; i++)
						{
							if (Settings.aSubset[((Q.SearchDatabase[i])[0])])
							{
								itemsearchdb.push(Q.SearchDatabase[i]);
							}
						}
					}
					else
					{
						itemsearchdb = Q.SearchDatabase;
					}
				}
				
				toggleResults(false);
				// Bind search execution
				elm.on("input", $.throttle(E.cSEARCH_LIMIT, function()
				{
					executeSearch();
				})).click(function()
				{
					executeSearch();
					$(this).select();
				}).onEscapeKey(function()
				{
					toggleResults(false);
				});
				// Bind the enter key event to autoselect the first search result entry
				if (Settings.aWantEnter !== false)
				{
					elm.onEnterKey(function()
					{
						// Use the selected entry or the first entry in the results list if haven't selected any
						var selectedresult = resultslist.data("selectedresult") || resultslist.find(".itmSearchResultEntry").first().parent();
						if (selectedresult && selectedresult.length)
						{
							selectedresult.find(".itmSearchResultEntry").trigger("click");
						}
					}).onArrowDownKey(function()
					{
						executeArrowKey(true);
					}).onArrowUpKey(function()
					{
						executeArrowKey(false);
					});
				}
				// Execute search in case the user typed something during the database load
				elm.trigger("input");
			};
			
			// Load the items database if using items search
			if (isitemsearch)
			{
				Q.loadItemsSearch(function()
				{
					bindSearch();
				});
			}
			else
			{
				bindSearch();
			}
		}).click(function()
		{
			resetSearch();
		});
	},
	
	/*
	 * Gets HTML containing an item's icon and colorized name, for use in printing.
	 * @param object pItem details.
	 * @param int pCount of item stack, optional.
	 * @returns string.
	 */
	getItemPreface: function(pItem, pCount)
	{
		var countstr = (pCount > 1) ? (pCount + " ") : "";
		var itemname = U.escapeHTML(pItem.name);
		return "<div class='itmPreface'>"
			+ "<aside class='itmPrefaceLeft'>"
				+ "<a class='itmPrefaceIcon'" + U.convertExternalAnchor(U.getWikiItemDefault(pItem)) + "'>"
					+ "<img class='itmPrefaceIconImage' src='" + pItem.icon + "' /></a> "
				+ "<var class='itmPrefaceName " + Q.getRarityClass(pItem.rarity) + "'>" + countstr + itemname + "</var>"
			+ "</aside>"
			+ "<aside class='itmPrefaceRight'>"
				+ "<input class='cssInputText' type='text' value='" + itemname + "' /><br />"
				+ "<input class='cssInputText' type='text' value='" + U.escapeHTML(pItem.chat_link) + "' /><br />"
				+ "<input class='cssInputText' type='text' value='" + pItem.id + "' />"
			+ "</aside>"
		+ "</div>";
	},
	
	/*
	 * Prints an item's details in standard format.
	 * @object pItem from API items.
	 * @boolean pWantListings whether to include Trading Post results too.
	 */
	printItemInfo: function(pItem, pWantListings)
	{
		I.print(Q.getItemPreface(pItem));
		I.prettyJSON(pItem);
		if (Q.isTradeable(pItem) && pWantListings)
		{
			E.printListings(pItem.id, false);
		}
		I.bindConsoleInput();
	}
};
E = {
/* =============================================================================
 * @@Economy Trading Post and money
 * ========================================================================== */

	Exchange:
	{
		COPPER_IN_SILVER: 100,
		COPPER_IN_GOLD: 10000,
		SILVER_IN_GOLD: 100,
		
		CENTS_IN_DOLLAR: 100,
		
		GEM_PER_DOLLAR: 0.80,
		DOLLAR_PER_GEM: 1.25,
		
		GEM_SAMPLE: 100, // 100 gem
		COIN_SAMPLE: 1000000, // 100 gold
		
		TAX_LIST: 0.05,
		TAX_SOLD: 0.10,
		TAX_TOTAL: 0.15,
		TAX_INVERSE: 0.85,
		
		// These variable ratios will be set by API functions
		GemInCoin: 0,
		CoinInGem: 0
	},
	
	// Timings in milliseconds
	cREFRESH_LIMIT: 5000, // Time before user is allowed to refresh all outputs again
	cSEARCH_LIMIT: 750, // Time before "as you type" search executes again
	cEXCHANGE_LIMIT: 250, // Time before "as you type" exchange executes again
	
	isTradingCalculatorsInitialized: false,
	ItemsArray: [],
	RefreshTimeout: {},
	ProgressTimeout: {},
	ProgressWait: 0,
	ProgressTick: 0,
	SwapIndex: -1,
	
	CalculatorHistoryArray: new Array(64),
	CalcHistoryIndex: 0,
	
	Pricelist: {}, // Associative array of price objects
	Paylist: {}, // To be used by audit function, associative array accessed by item ID containing payment (a price object, gem, karma, or other currencies)
	/*
	 * Associative array of functions that format the payment of an item.
	 * The function names correspond to the object key in unlockables records.
	 */
	PaymentFormat:
	{
		coin: function(pAmount) { return E.formatCoinStringShort(pAmount); },
		gem: function(pAmount) { return E.formatGemString(pAmount, true); },
		karma: function(pAmount) { return E.formatKarmaString(pAmount, true); },
		laurel: function(pAmount) { return E.formatLaurelString(pAmount, true); },
		token: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_token'></ins>"; },
		mastery: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_mastery'></ins>"; },
		achievement: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_achievement'></ins>"; },
		monument: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_monument'></ins>"; },
		craft: function() { return "<ins class='s16 s16_craft'></ins>"; },
		pvp: function() { return "<ins class='s16 s16_pvp'></ins>"; },
		starting: function() { return "<ins class='s16 s16_starting'></ins>"; },
		spirit: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_spirit'></ins>"; },
		cob: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_cob'></ins>"; },
		blticket: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_blticket'></ins>"; },
		bubble: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_bubble'></ins>"; },
		badge: function(pAmount) { return ((pAmount === 0) ? "" : pAmount.toLocaleString()) + "<ins class='s16 s16_badge'></ins>"; },
		proof: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_proof'></ins>"; },
		testimony: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_testimony'></ins>"; },
		commendation: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_commendation'></ins>"; },
		provisioner: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_provisioner'></ins>"; },
		contract: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_contract'></ins>"; },
		trader: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_trader'></ins>"; },
		mosaic: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_mosaic'></ins>"; },
		skirmish: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_skirmish'></ins>"; },
		league: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_league'></ins>"; },
		glory: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_glory'></ins>"; },
		dungeon_ac: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_dungeon_ac'></ins>"; },
		dungeon_arah: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_dungeon_arah'></ins>"; },
		dungeon_cm: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_dungeon_cm'></ins>"; },
		dungeon_se: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_dungeon_se'></ins>"; },
		dungeon_ta: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_dungeon_ta'></ins>"; },
		dungeon_hotw: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_dungeon_hotw'></ins>"; },
		dungeon_cof: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_dungeon_cof'></ins>"; },
		dungeon_coe: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_dungeon_coe'></ins>"; },
		fotm_relic: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_fotm_relic'></ins>"; },
		fotm_pristine: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_fotm_pristine'></ins>"; },
		matrix: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_matrix'></ins>"; },
		magnetite: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_magnetite'></ins>"; },
		gaeting: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_gaeting'></ins>"; },
		map_dt: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_dt'></ins>"; },
		key_dt: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_key_dt'></ins>"; },
		map_sw: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_sw'></ins>"; },
		key_sw: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_key_sw'></ins>"; },
		map_vb: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_vb'></ins>"; },
		key_vb: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_key_vb'></ins>"; },
		map_ab: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_ab'></ins>"; },
		key_ab: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_key_ab'></ins>"; },
		map_td: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_td'></ins>"; },
		key_td: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_key_td'></ins>"; },
		map_ds: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_ds'></ins>"; },
		key_ds: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_key_ds'></ins>"; },
		magic: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_magic'></ins>"; },
		map_bs: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_bs'></ins>"; },
		map_eb: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_eb'></ins>"; },
		map_bf: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_bf'></ins>"; },
		map_ld: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_ld'></ins>"; },
		map_dm: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_dm'></ins>"; },
		map_sl: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_sl'></ins>"; },
		volatile: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_volatile'></ins>"; },
		map_di: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_di'></ins>"; }
	},
	PaymentEnum:
	{
		Coin: "Coin",
		Gem: "Gem"
	},
	formatPayment: function(pName, pAmount)
	{
		var paymentfunction = E.PaymentFormat[pName];
		return paymentfunction ? paymentfunction(pAmount) : "unknown";
	},
	formatAchievement: function(pAmount)
	{
		return E.formatPayment("achievement", pAmount);
	},	
	
	/*
	 * Gets the first payment amount from an object.
	 * @param object pObject
	 * @returns int
	 */
	getPaymentAmount: function(pObject)
	{
		for (var i in pObject.p)
		{
			return pObject.p[i];
		}
		return 0;
	},
	
	/*
	 * Parses a period separated string representing those units.
	 * @param string pString to parse.
	 * @returns int the money in copper value for calculating.
	 * @pre String does not contain negative numbers.
	 */
	parseCoinString: function(pString)
	{
		if (pString === undefined || pString === null)
		{
			return 0;
		}
		
		var str = pString.replace(/[^0-9.-]/gi, "").split("."); // Only allow numbers, negative sign, and period separators
		var len = str.length;
		var copper = 0, silver = 0, gold = 0;
		
		if (len === 0)
		{
			return 0;
		}
		if (len === 1)
		{
			silver = parseInt(str[0]);
		}
		
		if (len >= 2)
		{
			copper = parseInt(str[len-1]);
			silver = parseInt(str[len-2]);
		}
		if (len === 2 && str[len-1].length === 1)
		{
			copper = copper * T.cBASE_10; // 0.1 = 10 copper
		}
		if (len >= 3)
		{
			gold = parseInt(str[len-3]);
		}
		
		if ( ! isFinite(copper)) { copper = 0; }
		if ( ! isFinite(silver)) { silver = 0; }
		if ( ! isFinite(gold)) { gold = 0; }
		
		return parseInt(copper + (silver * E.Exchange.COPPER_IN_SILVER) + (gold * E.Exchange.COPPER_IN_GOLD));
	},
	parseGemString: function(pString)
	{
		if (pString === undefined || pString === null)
		{
			return 0;
		}
		if ( ! isFinite(parseInt(pString)))
		{
			return 0;
		}
		return parseInt(pString);
	},
	
	/*
	 * Parses a period separated dollars and cents string.
	 * @param string pString to parse.
	 * @returns int the money in cent value for calculating.
	 * @pre String does not contain negative numbers.
	 */
	parseMoneyString: function(pString)
	{
		if (pString === undefined || pString === null)
		{
			return 0;
		}
		
		var str = pString.split(".");
		var len = str.length;
		var cent = 0, dollar = 0;
		
		if (len === 0)
		{
			return 0;
		}
		if (len === 1)
		{
			dollar = parseInt(str[0]);
		}
		
		if (len >= 2)
		{
			cent = parseInt(str[len-1]);
			dollar = parseInt(str[len-2]);
		}
		if (len >= 2 && str[len-1].length === 1)
		{
			cent = cent * T.cBASE_10; // 0.1 = 10 cent
		}
		else if (len >= 2 && str[len-1].length >= 2)
		{
			cent = parseInt(cent.toString().substring(0, 2)); // Only accept first two digits of cent
		}
		
		if ( ! isFinite(cent)) { cent = 0; }
		if ( ! isFinite(dollar)) { dollar = 0; }
		
		return parseInt(cent + (dollar * E.Exchange.CENTS_IN_DOLLAR));
	},
	
	/*
	 * Converts a coin amount in copper to a period separated string.
	 * @param int pAmount of copper.
	 * @objparam boolean aWantColor whether to include the coin image instead of periods.
	 * @objparam boolean aWantBig whether to use big coin text and icons.
	 * @objparam boolean aWantSpace whether to separate the different coins with spaces.
	 * @objparam boolean aWantShort whether to truncate lower denominations.
	 * @returns string coin for displaying.
	 */
	formatCoinString: function(pAmount, pSettings)
	{
		var amount = (pAmount === undefined || isFinite(pAmount) === false) ? 0 : parseInt(pAmount);
		var Settings = pSettings || {};
		
		var sep = ".";
		var sg0 = ""; var ss0 = ""; var sc0 = "";
		var sg1 = ""; var ss1 = ""; var sc1 = "";
		// Because the coin image is not text copyable, include additional hidden selectable text
		var abbrg = ""; var abbrs = ""; var abbrc = "";
		if (Settings.aWantCopy !== false)
		{
			abbrg = "<abbr class='cssCopyText'>" + D.getString("CoinGold") + "&nbsp;</abbr>";
			abbrs = "<abbr class='cssCopyText'>" + D.getString("CoinSilver") + "&nbsp;</abbr>";
			abbrc = "<abbr class='cssCopyText'>" + D.getString("CoinCopper") + "&nbsp;</abbr>";
		}
		
		if (Settings.aWantColor)
		{
			// Instead of period separating the currency units, use the coin images
			sep = "";
			sg0 = "<gold>"; ss0 = "<silver>"; sc0 = "<copper>";
			sg1 = "</gold>" + abbrg + "<goldcoin></goldcoin>";
			ss1 = "</silver>" + abbrs + "<silvercoin></silvercoin>";
			sc1 = "</copper>" + abbrc + "<coppercoin></coppercoin>";
		}
		if (Settings.aWantBig)
		{
			sep = "";
			sg0 = "<gold>"; ss0 = "<silver>"; sc0 = "<copper>";
			sg1 = "</gold>" + abbrg + "<img src='img/ui/coin_gold.png' />";
			ss1 = "</silver>" + abbrs + "<img src='img/ui/coin_silver.png' />";
			sc1 = "</copper>" + abbrc + "<img src='img/ui/coin_copper.png' />";
		}
		if (Settings.aWantSpace)
		{
			sep = " ";
		}
		
		var gold = Math.abs(Math.floor(amount / E.Exchange.COPPER_IN_GOLD));
		var silver = Math.abs(Math.floor(amount / E.Exchange.SILVER_IN_GOLD) % E.Exchange.COPPER_IN_SILVER);
		var copper = Math.abs(amount % E.Exchange.COPPER_IN_SILVER);
		var goldstr = (Settings.aWantColor || Settings.aWantBig || Settings.aWantShort) ? gold.toLocaleString() : gold;
		var silverstr = silver;
		var copperstr = copper;
		var sign = (amount < 0) ? I.Symbol.Negative : "";
		
		// Leading zero for units that are right side of the leftmost unit
		if ( ! Settings.aWantColor && (gold > 0 && silver < T.cBASE_10))
		{
			silverstr = "0" + silver;
		}
		if ( ! Settings.aWantColor && ((silver > 0 && copper < T.cBASE_10) || (copper < T.cBASE_10)))
		{
			copperstr = "0" + copper;
		}
		// For short version exclude copper if showing gold and silver, or is zero
		if (Settings.aWantShort)
		{
			if (gold > 0 || (copper === 0 && amount > 0))
			{
				sc0 = "";
				copperstr = "";
				sc1 = "";
			}
			if (silver === 0)
			{
				ss0 = "";
				silverstr = "";
				ss1 = "";
			}
		}
		
		// Returns
		if (gold > 0)
		{
			return sign + sg0 + goldstr + sg1 + sep + ss0 + silverstr + ss1 + sep + sc0 + copperstr + sc1;
		}
		if (silver > 0)
		{
			return sign + ss0 + silverstr + ss1 + sep + sc0 + copperstr + sc1;
		}
		if (Settings.aWantColor)
		{
			// No 0 silver prefix for copper-only price if showing color
			return sc0 + copperstr + sc1;
		}
		return sign + ss0 + "0" + sep + ss1 + sc0 + copperstr + sc1;
	},
	formatCoinStringColored: function(pAmount)
	{
		return E.formatCoinString(pAmount, {aWantColor: true});
	},
	formatCoinStringShort: function(pAmount)
	{
		return E.formatCoinString(pAmount, {aWantColor: true, aWantShort: true});
	},
	formatCoinStringSlot: function(pAmount)
	{
		return E.formatCoinString(pAmount, {aWantColor: true, aWantShort: true, aWantCopy: false});
	},
	
	/*
	 * Converts a money amount in cents to dollars period separated cents string.
	 * @param int pAmount of cents.
	 * @returns string money for displaying.
	 */
	formatMoneyString: function(pAmount, pWantColor)
	{
		if (pAmount === undefined || isFinite(pAmount) === false)
		{
			return "0.00";
		}
		pAmount = parseInt(pAmount);
		
		var dollar = Math.abs(Math.floor(pAmount / E.Exchange.CENTS_IN_DOLLAR));
		var cent = Math.abs(pAmount % E.Exchange.CENTS_IN_DOLLAR);
		var sign = (pAmount < 0) ? I.Symbol.Negative : "";
		
		if (cent < T.cBASE_10)
		{
			cent = "0" + cent;
		}
		var sm0 = (pWantColor) ? "<money>" : "";
		var sm1 = (pWantColor) ? "</money>" : "";
		return sm0 + sign + "$" + dollar + "." + cent + sm1;
	},
	
	/*
	 * Formats a currency amount and appends a currency unit icon.
	 * @param string pCurrency as defined in the CSS as a custom HTML tag that
	 * has color attribute associated with that currency.
	 * @param int pAmount.
	 * @param boolean pWantColor whether to colorize the amount.
	 * @returns HTML string.
	 */
	formatCurrencyString: function(pCurrency, pAmount, pWantColor)
	{
		if (pAmount === undefined || isFinite(pAmount) === false)
		{
			return "0";
		}
		pAmount = parseInt(pAmount);
		
		var c = pCurrency;
		var s0 = "";
		var s1 = "";
		var s2 = "<" + c + "unit></" + c + "unit>";
		if (pWantColor)
		{
			s0 = "<" + c + ">";
			s1 = "</" + c + ">";
		}
		return s0 + pAmount.toLocaleString() + s1 + s2;
	},
	formatKarmaString: function(pAmount, pWantColor)
	{
		return E.formatCurrencyString("karma", pAmount, pWantColor);
	},
	formatLaurelString: function(pAmount, pWantColor)
	{
		return E.formatCurrencyString("laurel", pAmount, pWantColor);
	},
	formatGemString: function(pAmount, pWantColor)
	{
		return E.formatCurrencyString("gem", pAmount, pWantColor);
	},
	
	/*
	 * Animates the input box's value or the box itself depending on difference.
	 * @param int pOldValue for comparison.
	 * @param int pNewValue for comparison.
	 * @param jqobject pInput to manipulate.
	 */
	animateValue: function(pInput, pOldValue, pNewValue)
	{
		if (pNewValue < pOldValue)
		{
			// Red if value went down
			pInput.css({color: "#ff2200"}).animate({color: "#ffeebb"}, 5000);
		}
		else if (pNewValue > pOldValue )
		{
			// Green if value went up
			pInput.css({color: "#44dd44"}).animate({color: "#ffeebb"}, 5000);
		}
		else
		{
			// Round the box if no change
			pInput.css({"border-radius": 32}).animate({"border-radius": 4}, 1000);
		}
	},
	
	/*
	 * Updates the coin to gem ratio and executes a callback. Use the convert
	 * functions in the callback.
	 */
	updateCoinInGem: function(pCallback)
	{
		$.getJSON(U.URL_API.GemPrice + E.Exchange.COIN_SAMPLE, function(pData)
		{
			if (pData.quantity !== undefined)
			{
				E.Exchange.CoinInGem = E.Exchange.COIN_SAMPLE / pData.quantity;
				pCallback();
			}
		}).fail(function()
		{
			pCallback();
		});
	},
	updateGemInCoin: function(pCallback)
	{
		$.getJSON(U.URL_API.CoinPrice + E.Exchange.GEM_SAMPLE, function(pData)
		{
			if (pData.quantity !== undefined)
			{
				E.Exchange.GemInCoin = E.Exchange.GEM_SAMPLE / pData.quantity;
				pCallback();
			}
		}).fail(function()
		{
			pCallback();
		});
	},
	updateExchangeRatios: function(pCallback)
	{
		E.updateCoinInGem(function()
		{
			E.updateGemInCoin(function()
			{
				pCallback();
			});
		});
	},
	
	/*
	 * Converts a currency using the updated exchange rate.
	 */
	convertGemToCoin: function(pAmount)
	{
		return Math.round(pAmount * E.Exchange.CoinInGem);
	},
	convertCoinToGem: function(pAmount)
	{
		return Math.round(pAmount * E.Exchange.GemInCoin);
	},
	convertGemToMoney: function(pAmount)
	{
		return Math.round(pAmount * E.Exchange.DOLLAR_PER_GEM);
	},
	convertMoneyToGem: function(pAmount)
	{
		return Math.floor(pAmount * E.Exchange.GEM_PER_DOLLAR);
	},
	formatGemToCoin: function(pAmount)
	{
		return E.formatCoinStringShort(E.convertGemToCoin(pAmount));
	},
	formatCoinToGem: function(pAmount)
	{
		return E.formatGemString(E.convertCoinToGem(pAmount), true);
	},
	formatGemToMoney: function(pAmount)
	{
		return E.formatMoneyString(E.convertGemToMoney(pAmount), true);
	},
	formatMoneyToGem: function(pAmount)
	{
		return E.formatGemString(E.convertMoneyToGem(pAmount), true);
	},
	
	/*
	 * Converts gem to coin or coin to gem with the input as the parameter, and
	 * the output as the argument in the callback.
	 */
	getGemFromCoin: function(pCoin, pCallback)
	{
		// INPUT amount of coin results in OUTPUT amount of gems
		$.getJSON(U.URL_API.GemPrice + pCoin, function(pData)
		{
			if (pData.quantity !== undefined)
			{
				var currentgem = parseInt(pData.quantity);
				pCallback(currentgem);
			}
		}).fail(function()
		{
			pCallback(0);
		});
	},
	getGemFromCoinInverse: function(pCoin, pCallback)
	{
		// OUTPUT amount of gems in order to buy INPUT amount of coin
		E.updateGemInCoin(function()
		{
			if (E.Exchange.GemInCoin !== 0)
			{
				pCallback(E.convertCoinToGem(pCoin));
			}
		});
	},
	getCoinFromGem: function(pGem, pCallback)
	{
		// INPUT amount of gems results in OUTPUT amount of coin
		$.getJSON(U.URL_API.CoinPrice + pGem, function(pData)
		{
			if (pData.quantity !== undefined)
			{
				var currentcoin = parseInt(pData.quantity);
				pCallback(currentcoin);
			}
		}).fail(function()
		{
			pCallback(0);
		});
	},
	getCoinFromGemInverse: function(pGem, pCallback)
	{
		// OUTPUT amount of coin in order to buy INPUT amount of gems
		E.updateCoinInGem(function()
		{
			pCallback(E.convertGemToCoin(pGem));
		});
	},
	
	/*
	 * Deducts Trading Post tax from a value.
	 * @param int pAmount of copper.
	 * @returns int taxed value.
	 */
	deductTax: function(pAmount)
	{
		return Math.floor(pAmount - (pAmount * E.Exchange.TAX_TOTAL));
	},
	
	/*
	 * Reads a price object that was returned from API and returns a processed object.
	 * @param object pPriceData.
	 * @param object pCount quantity of the items, optional.
	 * @returns object.
	 */
	processPrice: function(pPriceData, pCount)
	{
		var count = (pCount === undefined) ? 1 : pCount;
		var isarray = Array.isArray(pPriceData);
		var pricebuy = ((isarray) ? pPriceData[0] : pPriceData.buys.unit_price) * count;
		var pricesell = ((isarray) ? (pPriceData[1] || pPriceData[0]) : (pPriceData.sells.unit_price || pPriceData.buys.unit_price)) * count;
		return {
			oPriceBuy: pricebuy,
			oPriceSell: pricesell,
			oPriceBuyTaxed: E.deductTax(pricebuy),
			oPriceSellTaxed: E.deductTax(pricesell)
		};
	},
	createPrice: function(pPrice, pCount)
	{
		var count = (pCount === undefined) ? 1 : pCount;
		var price = (pPrice === undefined) ? 0 : (pPrice * count);
		return {
			oPriceBuy: price,
			oPriceSell: price,
			oPriceBuyTaxed: E.deductTax(price),
			oPriceSellTaxed: E.deductTax(price)
		};
	},
	createPricePlain: function(pPrice, pCount)
	{
		var count = (pCount === undefined) ? 1 : pCount;
		var price = (pPrice === undefined) ? 0 : (pPrice * count);
		return {
			oPriceBuy: price,
			oPriceSell: price,
			oPriceBuyTaxed: price,
			oPriceSellTaxed: price
		};
	},
	createPriceBound: function(pPrice, pCount)
	{
		if (E.isPriceObject(pPrice))
		{
			return {
				oPriceBuy: pPrice.oPriceBuy,
				oPriceSell: pPrice.oPriceSell,
				oPriceBuyTaxed: 0,
				oPriceSellTaxed: 0
			};
		}
		// If provided a numerical price instead of object
		var count = (pCount === undefined) ? 1 : pCount;
		var price = (pPrice === undefined) ? 0 : (pPrice * count);
		return {
			oPriceBuy: price,
			oPriceSell: price,
			oPriceBuyTaxed: 0,
			oPriceSellTaxed: 0
		};
	},
	addPrice: function(pPriceA, pPriceB)
	{
		return {
			oPriceBuy: pPriceA.oPriceBuy + pPriceB.oPriceBuy,
			oPriceSell: pPriceA.oPriceSell + pPriceB.oPriceSell,
			oPriceBuyTaxed: pPriceA.oPriceBuyTaxed + pPriceB.oPriceBuyTaxed,
			oPriceSellTaxed: pPriceA.oPriceSellTaxed + pPriceB.oPriceSellTaxed
		};
	},
	recountPrice: function(pPrice, pCount)
	{
		return {
			oPriceBuy: pPrice.oPriceBuy * pCount,
			oPriceSell: pPrice.oPriceSell * pCount,
			oPriceBuyTaxed: pPrice.oPriceBuyTaxed * pCount,
			oPriceSellTaxed: pPrice.oPriceSellTaxed * pCount
		};
	},
	isPriceObject: function(pPrice)
	{
		if (pPrice.oPriceBuy !== undefined)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Retrieves the Trading Post prices for an item.
	 * @param int pItemID.
	 * @param function pCallback to execute after retrieval.
	 * @param boolean pWantCache whether to cache the price or always use freshest, optional.
	 * @returns object processed price.
	 */
	getPrice: function(pItemID, pCallback, pWantCache)
	{
		var wantcache = (pWantCache !== undefined) ? pWantCache : false;
		if (Q.isTradeable(pItemID))
		{
			$.ajax({
				dataType: "json",
				url: U.getAPIPrice(pItemID),
				cache: wantcache,
				success: function(pData)
				{
					E.Pricelist[pData.id] = priceobj;
					if (pCallback)
					{
						var priceobj = E.processPrice(pData);
						pCallback(priceobj);
					}
				}
			});
		}
	},
	getCachedPrice: function(pItemID)
	{
		var priceobj = E.Pricelist[pItemID];
		if (priceobj)
		{
			return priceobj;
		}
		return null;
	},
	getPrices: function(pItemIDs, pCallback, pWantCache)
	{
		var tradeableids = [];
		var itemid;
		// Check if item IDs are tradeable beforehand
		if (pItemIDs && pItemIDs.length)
		{
			for (var i = 0; i < pItemIDs.length; i++)
			{
				itemid = pItemIDs[i];
				if (Q.Boxes.Items[itemid] === undefined ||
					(Q.Boxes.Items[itemid] && Q.isTradeable(Q.Boxes.Items[itemid].oData)))
				{
					tradeableids.push(itemid);
				}
			}
		}
		
		U.fetchAPI(U.URL_API.ItemPrice, tradeableids, {
			aWantCache: pWantCache,
			aCallback: function(pData, pFailedIDs)
		{
			var pricedb = {};
			if (pData)
			{
				// Add prices to database for later uses
				pData.forEach(function(iData)
				{
					var priceobj = E.processPrice(iData);
					pricedb[iData.id] = priceobj;
					E.Pricelist[iData.id] = priceobj;
				});
				pCallback(pricedb, pFailedIDs);
			}
			else
			{
				pCallback();
			}
		}});
	},
	getPriceObject: function(pItemID, pCallback)
	{
		// To be used after get prices function was called
		if (E.Pricelist[pItemID])
		{
			pCallback(E.Pricelist[pItemID]);
		}
		else
		{
			E.getPrice(pItemID, function(pData)
			{
				pCallback(pData);
			});
		}
	},
	
	/*
	 * Get the current buy orders and sell listings.
	 * @param int pItemID.
	 * @param function pCallback to execute after retrieval.
	 * @param boolean pWantCache whether to cache the price or always use freshest, optional.
	 * @returns object listings.
	 */
	getListings: function(pItemID, pCallback, pWantCache)
	{
		var wantcache = (pWantCache !== undefined) ? pWantCache : false;
		if (Q.isTradeable(pItemID))
		{
			$.ajax({
				dataType: "json",
				url: U.getAPIListings(pItemID),
				cache: wantcache,
				success: function(pData)
				{
					if (pCallback)
					{
						pCallback(pData);
					}
				},
				error: function()
				{
					I.removeThrobber(I.getConsole());
					I.print("Item is not on the Trading Post.");
				}
			});
		}
		else
		{
			I.clear();
			I.write("Item is not tradeable.");
		}
	},
	
	/*
	 * Formats a Trading Post listings API object into HTML tables.
	 * @param object pItem details retrieved from API.
	 * @param object pListings.
	 * @returns string HTML.
	 */
	formatListings: function(pItem, pListings)
	{
		var str = "";
		var priceword = D.getWordCapital("price");
		var byword = D.getWord("by");
		var buys = "", sells = "";
		var supply = 0;
		var demand = 0;
		var suppliers = 0;
		var demanders = 0;
		// Buys and Sells tables
		pListings.buys.forEach(function(iEntry)
		{
			buys += "<tr><td>" + iEntry.quantity + " " + D.getWordCapital("ordered") + "</td><td>" + E.formatCoinStringColored(iEntry.unit_price) + "</td></tr>";
			demand += iEntry.quantity;
			demanders += iEntry.listings;
		});
		buys += "</tbody></table>";
		pListings.sells.forEach(function(iEntry)
		{
			sells += "<tr><td>" + iEntry.quantity + " " + D.getWordCapital("available") + "</td><td>" + E.formatCoinStringColored(iEntry.unit_price) + "</td></tr>";
			supply += iEntry.quantity;
			suppliers += iEntry.listings;
		});
		sells += "</tbody></table>";
		// Headers
		var demandstr = "<span class='trsListingsDemand'>" + D.getWordCapital("demand") + ": "
			+ demand.toLocaleString() + " " + byword + " " + demanders.toLocaleString() + "</span>";
		var supplystr = "<span class='trsListingsSupply'>" + D.getWordCapital("supply") + ": "
			+ supply.toLocaleString() + " " + byword + " " + suppliers.toLocaleString() + "</span>";
		var buysheader = "<table class='trsListingsBuys'><thead><tr><th>" + demandstr + "</th><th>" + priceword + "</th></tr></thead><tbody>";
		var sellsheader = "<table class='trsListingsSells'><thead><tr><th>" + supplystr + "</th><th>" + priceword + "</th></tr></thead><tbody>";
		// Combine HTML
		str += "<div class='trsListings'>" + buysheader + buys + sellsheader + sells + "</div>";
		return str;
	},
	
	/*
	 * Retrieves listings for an item and prints them to the console.
	 * @param int pItemID.
	 * @param boolean pWantPlain whether to just print the listing.
	 */
	printListings: function(pItemID, pWantPlain)
	{
		if (pWantPlain !== false)
		{
			I.print(I.cThrobber, true);
		}
		Q.getItem(pItemID, function(pItem)
		{
			E.getListings(pItemID, function(pListing)
			{
				if (pWantPlain !== false)
				{
					I.clear();
					I.print(Q.getItemPreface(pItem));
				}
				I.print(E.formatListings(pItem, pListing));
				I.bindConsoleInput();
			});
		});
	},
	
	/*
	 * Calculates the trading calculator's output textboxes using input textboxes' values.
	 * @param jqobject pEntry trading calculator HTML parent.
	 */
	calculateTrading: function(pEntry)
	{
		// Computable data
		var buy = E.parseCoinString(pEntry.find(".trdBuy").val());
		var sell = E.parseCoinString(pEntry.find(".trdSell").val());
		var quantity = T.parseQuantity(pEntry.find(".trdQuantity").val());
		
		// Output elements
		var cost = pEntry.find(".trdCost");
		var tax = pEntry.find(".trdTax");
		var revenue = pEntry.find(".trdRevenue");
		var profit = pEntry.find(".trdProfit");
		var breakpoint = pEntry.find(".trdBreak");
		var margin = pEntry.find(".trdMargin");
		
		var profitamount = (sell - (sell * E.Exchange.TAX_TOTAL) - buy) * quantity;
		var revenueamount = (sell - (sell * E.Exchange.TAX_SOLD)) * quantity;
		var costamount = buy * quantity;
		var listamount = (sell * E.Exchange.TAX_LIST) * quantity;
		var taxamount = (sell * E.Exchange.TAX_SOLD) * quantity;
		
		// Do calculation and put them in outputs
		cost.val(I.Symbol.Negative + E.formatCoinString(Math.round(
			costamount
		)));
		tax.val(I.Symbol.Negative + E.formatCoinString(Math.round(
			listamount
			)) + " + −" + E.formatCoinString(Math.round(
			taxamount
		)));
		breakpoint.val(E.formatCoinString(Math.round(
			buy / E.Exchange.TAX_INVERSE
		)));
		revenue.val(E.formatCoinString(Math.round(
			revenueamount
		)));
		profit.val(E.formatCoinString(Math.round(
			profitamount
		)));
		margin.val(U.convertRatioToPercent(
			(revenueamount / (costamount + listamount)) - 1, 2
		));

		// Color the output numbers depending on sign
		$([profit, margin]).each(function()
		{
			var roundedprofit = Math.round(profitamount);
			$(this).removeClass("trdZero trdGain trdLoss");
			if (roundedprofit === 0) { $(this).addClass("trdZero"); }
			else if (roundedprofit > 0) { $(this).addClass("trdGain"); }
			else if (roundedprofit < 0) { $(this).addClass("trdLoss"); }
		});
	},
	
	/*
	 * Gets an array of all item IDs in the calculators, for use in bulk fetching.
	 * @returns array
	 * @pre Used Textlist is initialized.
	 */
	getTradingIDs: function()
	{
		var idstofetch = [];
		X.Textlists.TradingItem.value.forEach(function(iID)
		{
			var id = parseInt(iID);
			if (isFinite(parseInt(id)))
			{
				idstofetch.push(id);
			}
		});
		return idstofetch;
	},
	
	/*
	 * Retrieves non-price information about the item and updates those boxes.
	 * @param jqobject pEntry trading calculator HTML parent.
	 */
	updateTradingDetails: function(pEntry)
	{
		var name = pEntry.find(".trdName").val();
		var id = pEntry.find(".trdItem").val();
		if (isFinite(parseInt(id)) === false || name.length === 0)
		{
			return;
		}
		
		Q.getItem(id, function(pItem)
		{
			var icon = pEntry.find(".trdIcon");
			Q.setRarityClass(pEntry.find(".trdName"), pItem.rarity);
			pEntry.attr("data-rarity", pItem.rarity);
			pEntry.find(".trdLink").val(pItem.chat_link || "");
			icon.attr("src", pItem.icon);
			icon.unbind("click").click(function()
			{
				Q.printItemInfo(pItem);
			});
			Q.scanItem(pItem, {aElement: icon, aCallback: function(pBox)
			{
				pEntry.data("istradeable", pBox.oIsTradeable);
			}});
		});
	},
	
	/*
	 * Retrieves prices from API and updates those boxes.
	 * @param jqobject pEntry trading calculator HTML parent.
	 * @param boolean pWantCache whether to use prefetched prices.
	 */
	updateTradingPrices: function(pEntry, pWantCache)
	{
		var name = pEntry.find(".trdName").val();
		var id = pEntry.find(".trdItem").val();
		if (isFinite(parseInt(id)) === false || name.length === 0)
		{
			return;
		}
		
		var previousbuy = 0, previoussell = 0;
		var currentbuy = 0, currentsell = 0;
		var nameelm = pEntry.find(".trdName");
		var buyelm = pEntry.find(".trdCurrentBuy");
		var sellelm = pEntry.find(".trdCurrentSell");
		var buylowelm = pEntry.find(".trdNotifyBuyLow");
		var buyhighelm = pEntry.find(".trdNotifyBuyHigh");
		var selllowelm = pEntry.find(".trdNotifySellLow");
		var sellhighelm = pEntry.find(".trdNotifySellHigh");
		var buylow = E.parseCoinString(buylowelm.val());
		var buyhigh = E.parseCoinString(buyhighelm.val());
		var selllow = E.parseCoinString(selllowelm.val());
		var sellhigh = E.parseCoinString(sellhighelm.val());
		var wantcache = (pWantCache !== false) ? true : false;
		var icon = pEntry.find(".trdIcon");
		icon = (icon.length && icon.attr("src").length) ? icon.attr("src") : "img/notification/tp.png";
		
		if (pEntry.data("istradeable") === false)
		{
			buyelm.val("");
			sellelm.val("");
			if (X.getChecklistItem(X.Checklists.TradingOverwrite, U.getSubintegerFromHTMLID(pEntry))
					=== X.ChecklistEnum.Checked)
			{
				pEntry.find(".trdBuy").val("").trigger("input");
				pEntry.find(".trdSell").val("").trigger("input");
			}
			return;
		}
		
		var updatePrice = function(pPriceObj)
		{
			if (!pPriceObj)
			{
				buyelm.val(I.Symbol.Ellipsis);
				sellelm.val(I.Symbol.Ellipsis);
				return;
			}
			previousbuy = E.parseCoinString(pEntry.find(".trdCurrentBuy").first().val());
			previoussell = E.parseCoinString(pEntry.find(".trdCurrentSell").first().val());
			currentbuy = pPriceObj.oPriceBuy;
			currentsell = pPriceObj.oPriceSell;
			buyelm.val(E.formatCoinString(currentbuy));
			sellelm.val(E.formatCoinString(currentsell));
			
			// Overwrite calculator buy and sell prices if opted
			if (X.getChecklistItem(X.Checklists.TradingOverwrite, U.getSubintegerFromHTMLID(pEntry)) === X.ChecklistEnum.Checked)
			{
				pEntry.find(".trdBuy").val(buyelm.val()).trigger("input");
				pEntry.find(".trdSell").val(sellelm.val()).trigger("input");
			}
			
			// Animate prices that have changed
			E.animateValue(buyelm, previousbuy, currentbuy);
			E.animateValue(sellelm, previoussell, currentsell);
			
			// Notify if tracked price is within range
			if (X.isChecked(X.Checklists.TradingNotify, pEntry))
			{
				nameelm.removeClass("trdMatched");
				var phrase;
				
				if (currentbuy <= buylow && buylow !== 0 && currentbuy !== 0)
				{
					nameelm.addClass("trdMatched");
					buylowelm.addClass("trdMatched");
					phrase = D.getPhraseTitle("buy low") + " " + name;
					D.speak(phrase);
					I.notify({
						aTitle: name,
						aBody: phrase,
						aIcon: icon
					});
				}
				else
				{
					buylowelm.removeClass("trdMatched");
				}

				if (currentbuy >= buyhigh && buyhigh !== 0 && currentbuy !== 0)
				{
					nameelm.addClass("trdMatched");
					buyhighelm.addClass("trdMatched");
					phrase = D.getPhraseTitle("buy high") + " " + name;
					D.speak(phrase);
					I.notify({
						aTitle: name,
						aBody: phrase,
						aIcon: icon
					});
				}
				else
				{
					buyhighelm.removeClass("trdMatched");
				}

				if (currentsell <= selllow && selllow !== 0 && currentsell !== 0)
				{
					nameelm.addClass("trdMatched");
					selllowelm.addClass("trdMatched");
					phrase = D.getPhraseTitle("sell low") + " " + name;
					D.speak(phrase);
					I.notify({
						aTitle: name,
						aBody: phrase,
						aIcon: icon
					});
				}
				else
				{
					selllowelm.removeClass("trdMatched");
				}

				if (currentsell >= sellhigh && sellhigh !== 0 && currentsell !== 0)
				{
					nameelm.addClass("trdMatched");
					sellhighelm.addClass("trdMatched");
					phrase = D.getPhraseTitle("sell high") + " " + name;
					D.speak(phrase);
					I.notify({
						aTitle: name,
						aBody: phrase,
						aIcon: icon
					});
				}
				else
				{
					sellhighelm.removeClass("trdMatched");
				}
			}
		};
		
		if (wantcache)
		{
			updatePrice(E.getCachedPrice(id));
		}
		else
		{
			E.getPrice(id, function(pPriceObj)
			{
				updatePrice(pPriceObj);
			});
		}
	},
	updateAllTradingDetails: function()
	{
		Q.getItems(E.getTradingIDs(), function()
		{
			$("#trdList .trdEntry").each(function() { E.updateTradingDetails($(this)); });
		});
	},
	updateAllTradingPrices: function()
	{
		E.getPrices(E.getTradingIDs(), function()
		{
			$("#trdList .trdEntry").each(function() { E.updateTradingPrices($(this)); });
		});
	},
	
	/*
	 * Erases unneeded data from the calculator.
	 * @param jqobject pEntry of a calculator.
	 */
	clearCalculator: function(pEntry)
	{
		Q.setRarityClass(pEntry.find(".trdName"));
		pEntry.find(".trdIcon").attr("src", U.URL_IMG.Placeholder);
		pEntry.find(".trdItem").val("").trigger("change");
		pEntry.find(".trdCurrentBuy").val("");
		pEntry.find(".trdCurrentSell").val("");
		pEntry.find(".trdLink").val("");
		
		pEntry.find(".trdNotifyBuyLow").val("").trigger("change");
		pEntry.find(".trdNotifyBuyHigh").val("").trigger("change");
		pEntry.find(".trdNotifySellLow").val("").trigger("change");
		pEntry.find(".trdNotifySellHigh").val("").trigger("change");
		E.clearMatched(pEntry);
	},
	clearMatched: function(pEntry)
	{
		pEntry.find(".trdName").removeClass("trdMatched");
		pEntry.find(".trdNotifyBuyLow").removeClass("trdMatched");
		pEntry.find(".trdNotifyBuyHigh").removeClass("trdMatched");
		pEntry.find(".trdNotifySellLow").removeClass("trdMatched");
		pEntry.find(".trdNotifySellHigh").removeClass("trdMatched");
	},
	
	/*
	 * Generates calculators and binds behavior.
	 */
	initializeTrading: function()
	{
		var i;
		var entry = "";
		var name, buy, sell, quantity;
		
		for (i = 0; i < O.Options.int_numTradingCalculators; i++)
		{
			entry = "#trdEntry_" + i;
			// Generate individual calculators
			$("#trdList").append(
				"<div id='trdEntry_" + i + "' class='trdEntry'>"
					+ "<div class='trdAccordion trdAccordionShut'>"
						+ "<abbr><img class='trdIcon' src='" + U.URL_IMG.Placeholder + "' /></abbr>"
							+ "<div class='trdResultsFocus'><input class='trdName' type='text' /></div>"
						+ "<div class='trdButtons'>"
							+ "<button class='trdSearch' tabindex='-1'>S</button><button class='trdListings' tabindex='-1'>$</button><br />"
						+ "</div>"
						+ "<div class='trdExpand'>"
							+ "<abbr>$~O</abbr><input class='trdBuy' type='text' />"
							+ "<abbr>−$~</abbr><input class='trdCost trdOutput' type='text' tabindex='-1' /><br />"
							+ "<abbr>O~$</abbr><input class='trdSell' type='text' />"
							+ "<abbr>$=$</abbr><input class='trdBreak trdOutput' type='text' tabindex='-1' /><br />"
							+ "<abbr>×</abbr><input class='trdQuantity' type='text' />"
							+ "<abbr>−$%</abbr><input class='trdTax trdOutput' type='text' tabindex='-1' /><br />"
							+ "<abbr>+$</abbr><input class='trdProfit trdOutput' type='text' tabindex='-1' />"
							+ "<abbr>=$</abbr><input class='trdRevenue trdOutput' type='text' tabindex='-1' /><br />"
							+ "<abbr>+$%</abbr><input class='trdMargin trdOutput' type='text' tabindex='-1' />"
							+ "<abbr>[]</abbr><input class='trdLink trdOutput' type='text' tabindex='-1' />"
							+ "<input class='trdItem trdOutput' type='text' /><br />"
							+ "<abbr>$~!</abbr>"
								+ "<input class='trdNotifyBuyHigh' type='text' />"
								+ "<input class='trdCurrentBuy trdOutput' type='text' tabindex='-1' />"
								+ "<input class='trdNotifyBuyLow' type='text' />"
								+ "<label title='<dfn>" + D.getWordCapital("overwrite") + "</dfn>: Replace your buy and sell prices with the current prices when refreshing.'>"
									+ "<input class='trdOverwrite' type='checkbox' tabindex='-1' />" + I.Symbol.Filler + "</label><br />"
							+ "<abbr>!~$</abbr>"
								+ "<input class='trdNotifySellHigh' type='text' />"
								+ "<input class='trdCurrentSell trdOutput' type='text' tabindex='-1' />"
								+ "<input class='trdNotifySellLow' type='text' />"
								+ "<label title='<dfn>" + D.getWordCapital("notify") + "</dfn>: Turn on sound notification for this item.'>"
									+"<input class='trdNotify' type='checkbox' tabindex='-1' />" + I.Symbol.Filler + "</label>"
						+ "<br /><br /></div>"
					+ "</div>"
					+ "<div class='trdPreview'>"
						+ "<input class='trdCurrentBuy trdOutput' type='text' tabindex='-1' />"
						+ "<input class='trdCurrentSell trdOutput' type='text' tabindex='-1' />"
						+ "<div class='btnSwap'>"
							+ "<button class='btnSwapUp' tabindex='-1'></button><button class='btnSwapDown' tabindex='-1'></button>"
						+ "</div>"
					+ "</div>"
				+ "</div>"
			);
			I.qTip.init($(entry + " .trdOverwrite").parent());
			I.qTip.init($(entry + " .trdNotify").parent());
			X.rewrapCheckboxes();
			
			name = $(entry + " .trdName");
			buy = $(entry + " .trdBuy");
			sell = $(entry + " .trdSell");
			quantity = $(entry + " .trdQuantity");
			
			// Bind click to select all text behavior
			I.bindInputSelect(entry + " input");
			
			// Bind search button behavior for ith calculator
			$(entry + " .trdListings").click(function()
			{
				if (I.isConsoleShown() === false)
				{
					var id = $(this).closest(".trdEntry").find(".trdItem").val();
					E.printListings(id);
				}
			}).dblclick(function()
			{
				var query = $(this).closest(".trdEntry").find(".trdName").val();
				U.openExternalURL(U.getWikiLinkLanguage(query));
			});
			$(entry + " .trdSearch").click(function()
			{
				var id = $(this).closest(".trdEntry").find(".trdItem").val();
				var query = $(this).closest(".trdEntry").find(".trdName").val();
				if (id.length === 0)
				{
					U.openExternalURL(U.getTradingSearchLink(query));
				}
				else
				{
					U.openExternalURL(U.getTradingItemLink(id, query));
				}
			});
			
			// Bind input textboxes calculate behavior
			$([buy, sell, quantity]).each(function()
			{
				$(this).on("input", function()
				{
					E.calculateTrading($(this).parent());
				});
			});
			
			// Bind current buy/sell prices change auto flanking
			$(entry + " .trdCurrentBuy, " + entry + " .trdCurrentSell").each(function()
			{
				$(this).dblclick(function()
				{
					var price = E.parseCoinString($(this).val());
					if (price !== 0)
					{
						// Assume the inputs are siblings
						$(this).prev().val(E.formatCoinString(price + 1)).trigger("change");
						$(this).next().val(E.formatCoinString(price - 1)).trigger("change");
						E.updateTradingPrices($(this).closest(".trdEntry"), false);
						D.stopSpeech();
					}
				});
			});
			
			// Initial registering of the swap index variable
			$(entry + " .btnSwap").hover(
				function()
				{
					$(this).closest(".trdEntry").find(".trdName").addClass("trdHovered");
					E.SwapIndex = U.getSubintegerFromHTMLID($(this).closest(".trdEntry"));
				},
				function()
				{
					$(".trdName").removeClass("trdHovered");
				}
			);
			
			// Bind swap up/down buttons to swap data between calculators (for manual rearranging)
			$(entry + " .btnSwapUp, " + entry + " .btnSwapDown").each(function()
			{
				$(this).click(function()
				{
					var i = E.SwapIndex;
					var isUp = ($(this).hasClass("btnSwapUp")) ? true : false;
					
					// Do not allow swapping outside of range
					if (isUp && i === 0)
					{
						return;
					}
					if ( ! isUp === $(".trdEntry").length - 1) 
					{
						return;
					}
					
					var j = isUp ? (i-1) : (i+1);
					var calcA = $("#trdEntry_" + i);
					var calcB = $("#trdEntry_" + j);
					
					// Swap item icon
					var imgA = calcA.find(".trdIcon").attr("src");
					var imgB = calcB.find(".trdIcon").attr("src");
					calcA.find(".trdIcon").attr("src", imgB);
					calcB.find(".trdIcon").attr("src", imgA);
					
					// Swap text data from inputs
					var dataA = [];
					var dataB = [];
					var counterA = 0;
					var counterB = 0;
					calcA.find("input[type='text']").each(function()
					{
						dataA.push($(this).val());
					});
					calcB.find("input[type='text']").each(function()
					{
						dataB.push($(this).val());
					});
					calcA.find("input[type='text']").each(function()
					{
						$(this).val(dataB[counterA]).trigger("change");
						counterA++;
					});
					calcB.find("input[type='text']").each(function()
					{
						$(this).val(dataA[counterB]).trigger("change");
						counterB++;
					});
					// Swap rarity color code of the item name
					var rarityA = calcA.attr("data-rarity");
					var rarityB = calcB.attr("data-rarity");
					calcA.attr("data-rarity", rarityB);
					calcB.attr("data-rarity", rarityA);
					Q.setRarityClass(calcA.find(".trdName"), rarityB);
					Q.setRarityClass(calcB.find(".trdName"), rarityA);
					// Clear matched price styles
					E.clearMatched(calcA);
					E.clearMatched(calcB);
					calcA.find(".trdName").removeClass("trdHovered");
					calcB.find(".trdName").addClass("trdHovered");
					
					// Adjust swap index
					E.SwapIndex = isUp ? (E.SwapIndex-1) : (E.SwapIndex+1);
				});
			});
			
			// Bind name search box behavior
			(function(iEntry)
			{
				Q.bindItemSearch($(name), {
					aFillerText: null,
					aWantEnter: false,
					aResultsClass: "trdResultsContainer",
					aCallback: function(pItem)
					{
						// Change triggers the storage, input triggers the calculation
						iEntry.find(".trdItem").val(pItem.id).trigger("change");
						iEntry.find(".trdName").val(pItem.name).trigger("change");
						E.updateTradingDetails(iEntry);
						E.updateTradingPrices(iEntry, false);
					}}
				);
			})($(entry));
			$(name).change(function()
			{
				var query = $(this).val();
				var entryinner = $(this).closest(".trdEntry");
				if (query.length < 1)
				{
					E.clearCalculator(entryinner);
				}
			}).onEnterKey(function()
			{
				U.openExternalURL(U.getTradingSearchLink($(this).val()));
			});
		}
		
		// Set the first entry with initial text as an example
		entry = "#trdEntry_" + 0;
		$(entry + " .trdIcon").attr("src", "img/ui/question.png");
		$(entry + " .trdName").val("Kudzu");
		$(entry + " .trdBuy").val("4500.37.68");
		$(entry + " .trdSell").val("550037.68");
		$(entry + " .trdQuantity").val("1");
		$(entry).css("margin-bottom", "6px");
		
		// Set tooltip only for the first entry
		var tip = function(pBoxName, pWord, pInfo)
		{
			if (pInfo === undefined)
			{
				pInfo = "";
			}
			else
			{
				pInfo = ": " + pInfo;
			}
			$(entry + " .trd" + pBoxName).attr("title", "<dfn>" + D.getPhraseTitle(pWord) + "</dfn>" + pInfo);
		};
		tip("Name", "name");
		tip("Buy", "your buy");
		tip("Sell", "your sell");
		tip("Quantity", "quantity");
		tip("Cost", "cost", "Money needed to buy the items.");
		tip("Break", "breakpoint" , "Sell higher than this to make a profit.");
		tip("Tax", "tax", "Pay 5% fee of sell price to list, and deduct 10% tax of sell price when sold.");
		tip("Profit", "profit", "Gains after losses from buying and tax.");
		tip("Margin", "margin", "Revenue over cost and fee.");
		tip("Revenue", "revenue", "What you will receive at the trader.");
		tip("Link", "chatlink", "Paste this in game chat to see the item.");
		tip("Item", "ID", "API item number.");
		tip("NotifyBuyLow", "notify if current buy < this buy");
		tip("NotifyBuyHigh", "notify if this buy < current buy");
		tip("NotifySellLow", "notify if current sell < this sell");
		tip("NotifySellHigh", "notify if this sell < current sell");
		tip("CurrentBuy", "current buy", "Double click to flank price.");
		tip("CurrentSell", "current sell", "Double click to flank price.");
		I.qTip.init($(entry + " input"));
		
		// Initialize storage behavior of the input textboxes
		X.initializeTextlist(X.Textlists.TradingItem, $("#trdList .trdItem"), null, 16);
		X.initializeTextlist(X.Textlists.TradingName, $("#trdList .trdName"), null, 64);
		X.initializeTextlist(X.Textlists.TradingBuy, $("#trdList .trdBuy"), null, 16);
		X.initializeTextlist(X.Textlists.TradingSell, $("#trdList .trdSell"), null, 16);
		X.initializeTextlist(X.Textlists.TradingQuantity, $("#trdList .trdQuantity"), null, 16);
		X.initializeTextlist(X.Textlists.NotifyBuyLow, $("#trdList .trdNotifyBuyLow"), null, 16);
		X.initializeTextlist(X.Textlists.NotifyBuyHigh, $("#trdList .trdNotifyBuyHigh"), null, 16);
		X.initializeTextlist(X.Textlists.NotifySellLow, $("#trdList .trdNotifySellLow"), null, 16);
		X.initializeTextlist(X.Textlists.NotifySellHigh, $("#trdList .trdNotifySellHigh"), null, 16);
		
		X.initializeCheckboxlist(X.Checklists.TradingOverwrite, $("#trdList .trdOverwrite"), X.ChecklistJob.CheckAll, null, false);
		X.initializeCheckboxlist(X.Checklists.TradingNotify, $("#trdList .trdNotify"), X.ChecklistJob.CheckAll, null, false);
		
		// Trigger input textboxes to make the output textboxes update
		$("#trdList .trdSell").trigger("input");
		E.updateAllTradingDetails();
		
		// Bind toggle button to switch between accordion view or open list view of the calculators
		$("#trdToggle").click(function()
		{
			if ($("#trdEntry_0 .trdBuy").is(":visible"))
			{
				$(".trdAccordion").addClass("trdAccordionShut").removeClass("trdAccordionOpen");
				$(".trdPreview").removeClass("cssHidden");
			}
			else
			{
				$(".trdAccordion").removeClass("trdAccordionShut").addClass("trdAccordionOpen");
				$(".trdPreview").addClass("cssHidden");
			}
		});
		
		// Bind refresh button to re-download API data to refresh the calculators
		D.verifyNativeTTS();
		$("#trdRefresh, #trdRefreshMirror").click($.throttle(E.cREFRESH_LIMIT, function()
		{
			E.loopRefresh(true);
		}));
		$("#trdPause").click(function()
		{
			E.cancelLoopRefresh();
		});
		$("#trdMute").click(function()
		{
			D.stopSpeech();
		});
		// Button to print all saved calculator data to console as Comma Separated Values (CSV)
		$("#trdPrint").click(function()
		{
			I.clear();
			var length = X.Textlists.TradingItem.value.length;
			var str = "ItemID,Name,Buy,Sell,Quantity,BuyLow,BuyHigh,SellLow,SellHigh<br />";
			for (var i = 0; i < length; i++)
			{
				str += U.escapeHTML(
					X.Textlists.TradingItem.value[i] + "," +
					X.Textlists.TradingName.value[i] + "," +
					X.Textlists.TradingBuy.value[i] + "," +
					X.Textlists.TradingSell.value[i] + "," +
					X.Textlists.TradingQuantity.value[i] + "," +
					X.Textlists.NotifyBuyLow.value[i] + "," +
					X.Textlists.NotifyBuyHigh.value[i] + "," +
					X.Textlists.NotifySellLow.value[i] + "," +
					X.Textlists.NotifySellHigh.value[i])
				+ "<br />";
			}
			Z.createFile(str.replace(/<br \/>/g, "\r\n"), "tp.csv");
			I.print(str);
		});
	},
	
	/*
	 * Updates the respective exchanges using the input from top row.
	 */
	updateCoinTo: function(pWantAnimate)
	{
		var previousgem = 0, currentgem = 0;
		var previousmoney = 0, currentmoney = 0;
		var previousgeminverse = 0, currentgeminverse = 0;
		var previousmoneyinverse = 0, currentmoneyinverse = 0;
		var cointo = $("#trdExchange .trdCoinTo");
		var cointogem = $("#trdExchange .trdCoinToGem");
		var cointomoney = $("#trdExchange .trdCoinToMoney");
		var cointogeminverse = $("#trdExchange .trdCoinToGemInverse");
		var cointomoneyinverse = $("#trdExchange .trdCoinToMoneyInverse");
		
		var cointoamount = E.parseCoinString(cointo.val());
		if (cointoamount === 0 || cointo.val() === "")
		{
			cointogem.val("");
			cointomoney.val("");
			cointogeminverse.val("");
			cointomoneyinverse.val("");
		}
		else
		{
			// User's coin to gem
			E.getGemFromCoin(cointoamount, function(pGem)
			{
				previousgem = parseInt(cointogem.val());
				previousmoney = E.parseMoneyString(cointomoney.val());
				currentgem = pGem;
				currentmoney = Math.round(currentgem * E.Exchange.DOLLAR_PER_GEM);

				cointogem.val(currentgem);
				cointomoney.val(E.formatMoneyString(currentmoney));
				if (pWantAnimate === undefined || pWantAnimate)
				{
					E.animateValue(cointogem, previousgem, currentgem);
					E.animateValue(cointomoney, previousmoney, currentmoney);
				}
				
				if (currentgem === 0)
				{
					// Got here if value is too low be exchanged
					cointogem.val("0");
					cointomoney.val("0");
				}
			});
			
			// Gem to user's coin
			E.getGemFromCoinInverse(cointoamount, function(pGem)
			{
				previousgeminverse = parseInt(cointogeminverse.val());
				previousmoneyinverse = E.parseMoneyString(cointomoneyinverse.val());

				currentgeminverse = pGem;
				currentmoneyinverse = Math.round(currentgeminverse * E.Exchange.DOLLAR_PER_GEM);
				cointogeminverse.val(currentgeminverse);
				cointomoneyinverse.val(E.formatMoneyString(currentmoneyinverse));

				if (pWantAnimate === undefined || pWantAnimate)
				{
					E.animateValue(cointogeminverse, previousgeminverse, currentgeminverse);
					E.animateValue(cointomoneyinverse, previousmoneyinverse, currentmoneyinverse);
				}
			});
		}
	},
	updateGemTo: function(pWantAnimate)
	{
		var previouscoin = 0, currentcoin = 0;
		var previousmoney = 0, currentmoney = 0;
		var previouscoininverse = 0, currentcoininverse = 0;
		var gemto = $("#trdExchange .trdGemTo");
		var gemtocoin = $("#trdExchange .trdGemToCoin");
		var gemtomoney = $("#trdExchange .trdGemToMoney");
		var gemtocoininverse = $("#trdExchange .trdGemToCoinInverse");
		
		var gemtoamount = gemto.val();
		if (gemtoamount === 0 || gemto.val() === "")
		{
			gemtocoin.val("");
			gemtomoney.val("");
			gemtocoininverse.val("");
		}
		else
		{
			// User's gem to coin
			E.getCoinFromGem(gemtoamount, function(pCoin)
			{
				previouscoin = E.parseCoinString(gemtocoin.val());
				previousmoney = E.parseMoneyString(gemtomoney.val());
				currentcoin = pCoin;
				currentmoney = parseInt(gemtoamount * E.Exchange.DOLLAR_PER_GEM);

				gemtocoin.val(E.formatCoinString(currentcoin));
				gemtomoney.val(E.formatMoneyString(currentmoney));
				if (pWantAnimate === undefined || pWantAnimate)
				{
					E.animateValue(gemtocoin, previouscoin, currentcoin);
					E.animateValue(gemtomoney, previousmoney, currentmoney);
				}

				if (currentcoin === 0)
				{
					// Got here if value is too low be exchanged
					gemtocoin.val("0");
					gemtomoney.val("0");
				}
			});
			
			// Coin to user's gem
			E.getCoinFromGemInverse(gemtoamount, function(pCoin)
			{
				previouscoininverse = E.parseCoinString(gemtocoininverse.val());
				currentcoininverse = pCoin;
				gemtocoininverse.val(E.formatCoinString(currentcoininverse));

				if (pWantAnimate === undefined || pWantAnimate)
				{
					E.animateValue(gemtocoininverse, previouscoininverse, currentcoininverse);
				}
			});
		}
	},
	updateMoneyTo: function(pWantAnimate)
	{
		var previousgem = 0, currentgem = 0;
		var previouscoin = 0, currentcoin = 0;
		var moneyto = $("#trdExchange .trdMoneyTo");
		var moneytogem = $("#trdExchange .trdMoneyToGem");
		var moneytocoin = $("#trdExchange .trdMoneyToCoin");
		
		var moneytoamount = E.parseMoneyString(moneyto.val());
		var gems = moneytoamount * E.Exchange.GEM_PER_DOLLAR;
		if (moneytoamount === 0 || moneyto.val() === "")
		{
			moneytogem.val("");
			moneytocoin.val("");
		}
		else
		{
			E.getCoinFromGem(gems, function(pCoin)
			{
				previousgem = parseInt(moneytogem.val());
				previouscoin = E.parseCoinString(moneytocoin.val());
				currentgem = gems;
				currentcoin = pCoin;

				moneytogem.val(gems);
				moneytocoin.val(E.formatCoinString(currentcoin));
				if (pWantAnimate === undefined || pWantAnimate)
				{
					E.animateValue(moneytogem, previousgem, currentgem);
					E.animateValue(moneytocoin, previouscoin, currentcoin);
				}
				if (currentcoin === 0)
				{
					// Got here if value is too low be exchanged
					moneytogem.val("0");
					moneytocoin.val("0");
				}
			});
		}
	},
	updateNotifyCoinTo: function(pWantAnimate)
	{
		var previousgem = 0, currentgem = 0;
		var cointo = $("#trdExchange .trdNotifyCoinTo");
		var cointogem = $("#trdExchange .trdNotifyCoinToGem");
		
		var gemhighelm = $("#trdExchange .trdNotifyCoinToGemHigh");
		var gemhigh = E.parseGemString(gemhighelm.val());
		
		var cointoamount = E.parseCoinString(cointo.val());
		if (cointoamount === 0 || cointo.val() === "")
		{
			cointogem.val("");
		}
		else
		{
			// User's coin to gem
			E.getGemFromCoin(cointoamount, function(pGem)
			{
				previousgem = parseInt(cointogem.val());
				currentgem = pGem;

				cointogem.val(currentgem);
				if (pWantAnimate === undefined || pWantAnimate)
				{
					E.animateValue(cointogem, previousgem, currentgem);
				}
				
				if (currentgem === 0)
				{
					// Got here if value is too low be exchanged
					cointogem.val("0");
				}
				else if (currentgem >= gemhigh && gemhigh !== 0)
				{
					gemhighelm.addClass("trdMatched");
					var phrase = D.getPhraseTitle("buy gem high");
					D.speak(phrase);
					I.notify({
						aTitle: phrase,
						aIcon: "img/notification/gem.png"
					});
				}
				else
				{
					gemhighelm.removeClass("trdMatched");
				}
			});
		}
	},
	updateNotifyGemTo: function(pWantAnimate)
	{
		var previouscoin = 0, currentcoin = 0;
		var gemto = $("#trdExchange .trdNotifyGemTo");
		var gemtocoin = $("#trdExchange .trdNotifyGemToCoin");
		
		var coinhighelm = $("#trdExchange .trdNotifyGemToCoinHigh");
		var coinhigh = E.parseCoinString(coinhighelm.val());
		
		var gemtoamount = gemto.val();
		if (gemtoamount === 0 || gemto.val() === "")
		{
			gemtocoin.val("");
		}
		else
		{
			// User's gem to coin
			E.getCoinFromGem(gemtoamount, function(pCoin)
			{
				previouscoin = E.parseCoinString(gemtocoin.val());
				currentcoin = pCoin;

				gemtocoin.val(E.formatCoinString(currentcoin));
				if (pWantAnimate === undefined || pWantAnimate)
				{
					E.animateValue(gemtocoin, previouscoin, currentcoin);
				}
				
				if (currentcoin === 0)
				{
					// Got here if value is too low be exchanged
					gemtocoin.val("0");
				}
				else if (currentcoin >= coinhigh && coinhigh !== 0)
				{
					coinhighelm.addClass("trdMatched");
					var phrase = D.getPhraseTitle("buy coin high");
					D.speak(phrase);
					I.notify({
						aTitle: phrase,
						aIcon: "img/notification/coin.png"
					});
				}
				else
				{
					coinhighelm.removeClass("trdMatched");
				}
			});
		}
	},
	updateAllExchange: function()
	{
		E.updateCoinTo();
		E.updateGemTo();
		E.updateMoneyTo();
		
		E.updateNotifyCoinTo();
		E.updateNotifyGemTo();
	},
	
	/*
	 * Binds behavior of exchange input boxes.
	 */
	initializeExchange: function()
	{
		var cointo = $("#trdExchange .trdCoinTo");
		var gemto = $("#trdExchange .trdGemTo");
		var moneyto = $("#trdExchange .trdMoneyTo");
		var notifycointo = $("#trdExchange .trdNotifyCoinTo");
		var notifygemto = $("#trdExchange .trdNotifyGemTo");
		var notifycointogemhigh = $("#trdExchange .trdNotifyCoinToGemHigh");
		var notifygemtocoinhigh = $("#trdExchange .trdNotifyGemToCoinHigh");
		
		// Initial values as an example
		cointo.val("200..");
		gemto.val("4000");
		moneyto.val("50");
		
		var tip = function(pBoxName, pPhrase)
		{
			$("#trdExchange .trd" + pBoxName).attr("title", "<dfn>" + D.getPhraseTitle(pPhrase) + "</dfn>");
		};
		tip("CoinTo", "your coin");
		tip("GemTo", "your gem");
		tip("MoneyTo", "your dollar");
		tip("CoinToGem", "your coin to gem");
		tip("GemToCoin", "your gem to coin");
		tip("MoneyToGem", "your dollar to gem");
		tip("CoinToMoney", "your coin to dollar");
		tip("GemToMoney", "your gem to dollar");
		tip("MoneyToCoin", "your dollar to coin");
		tip("CoinToGemInverse", "gem to your coin");
		tip("GemToCoinInverse", "coin to your gem");
		tip("CoinToMoneyInverse", "dollar to your coin");
		
		tip("NotifyCoinTo", "your coin");
		tip("NotifyGemTo", "your gem");
		tip("NotifyCoinToGem", "your coin to current gem");
		tip("NotifyGemToCoin", "your gem to current coin");
		tip("NotifyCoinToGemHigh", "notify if current gem > this gem");
		tip("NotifyGemToCoinHigh", "notify if current coin > this coin");
		I.qTip.init($("#trdExchange input"));
		
		// Bind behavior
		I.bindInputSelect("#trdExchange input");
		
		cointo.on("input", $.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateCoinTo(false);
		})).onEnterKey($.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateCoinTo();
		}));
		
		gemto.on("input", $.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateGemTo(false);
		})).onEnterKey($.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateGemTo();
		}));
		
		moneyto.on("input", $.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateMoneyTo(false);
		})).onEnterKey($.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateMoneyTo();
		}));
		
		notifycointo.on("input", $.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateNotifyCoinTo(false);
		})).onEnterKey($.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateNotifyCoinTo();
		}));
		
		notifygemto.on("input", $.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateNotifyGemTo(false);
		})).onEnterKey($.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateNotifyGemTo();
		}));
		
		// Initialize storage behavior of inputs
		X.initializeTextlist(X.Textlists.ExchangeUnit,
			$([cointo, gemto, moneyto, notifycointo, notifygemto, notifycointogemhigh, notifygemtocoinhigh]), null, 16);
		
		// Finally, loop the refresh function
		$(".trdProgress").data("width", $(".trdProgress").width());
		E.isTradingCalculatorsInitialized = true;
		E.loopRefresh();
	},
	
	/*
	 * Cancels current loop refresh and progress bar.
	 */
	cancelLoopRefresh: function()
	{
		window.clearTimeout(E.ProgressTimeout);
		window.clearTimeout(E.RefreshTimeout);
		$(".trdProgress").width($(".trdProgress").data("width"));
	},
	
	/*
	 * Decreases the width of the progress line every second for the duration
	 * of the refresh wait time.
	 */
	animateProgress: function()
	{
		var progress = $(".trdProgress");
		if (E.ProgressTick < E.ProgressWait)
		{
			progress.width(progress.width() - (progress.data("width") / E.ProgressWait));
		}
		E.ProgressTick -= 1;
		
		E.ProgressTimeout = setTimeout(E.animateProgress, T.cMSECONDS_IN_SECOND);
	},
	
	/*
	 * Calls the refresh calculator function on regular interval.
	 */
	loopRefresh: function(pForce)
	{
		E.cancelLoopRefresh();
		
		if (pForce === true || O.Options.bol_refreshPrices)
		{
			E.updateAllTradingPrices();
			E.updateAllExchange();
			
			if (O.Options.bol_refreshPrices)
			{
				var wait = O.Options.int_secTradingRefresh * T.cMSECONDS_IN_SECOND;
				// Animate progress bar with same duration as refresh wait time
				E.ProgressTick = O.Options.int_secTradingRefresh;
				E.ProgressWait = O.Options.int_secTradingRefresh;
				E.animateProgress();
				// Repeat this function
				E.RefreshTimeout = setTimeout(E.loopRefresh, wait);
			}
		}
	},
	
	/*
	 * Binds behavior of the generic calculator.
	 */
	initializeCalculator: function()
	{
		// Calculation behavior
		$("#trdCalculation .trdCalculator").onEnterKey(function()
		{
			E.doCalculation($(this));
		}).click(function()
		{
			$(this).select();
		});
		// Assume expression input box is left sibling of the submit button
		$("#trdCalculation .trdCalcSubmit").click(function()
		{
			E.doCalculation($(this).prev());
		});
		
		// History behavior
		for (var i in E.CalculatorHistoryArray)
		{
			E.CalculatorHistoryArray[i] = "";
		}
		
		$("#trdCalculation .trdCalculator").onArrowUpKey(function()
		{
			if (E.CalcHistoryIndex === 0)
			{
				var expression = U.stripToCalculation($(this).val());
				if (E.CalculatorHistoryArray[0] !== $(this).val().toString())
				{
					E.CalculatorHistoryArray.pop();
					E.CalculatorHistoryArray.unshift(expression);
				}
			}
			if (E.CalcHistoryIndex + 1 < E.CalculatorHistoryArray.length)
			{
				E.CalcHistoryIndex++;
				$(this).val(E.CalculatorHistoryArray[E.CalcHistoryIndex]);
			}
		});
		$("#trdCalculation .trdCalculator").onArrowDownKey(function()
		{
			if (E.CalcHistoryIndex - 1 >= 0)
			{
				E.CalcHistoryIndex--;
				$(this).val(E.CalculatorHistoryArray[E.CalcHistoryIndex]);
			}
		});
	},
	
	/*
	 * Performs the expression on the arithmetic calculator.
	 * This function uses eval(), so must sanitize user input.
	 * @param jqobject pCalculator input box containing user's expression.
	 */
	doCalculation: function(pCalculator)
	{
		var expression = U.stripToCalculation(pCalculator.val());
		var result = "";
		try
		{
			result = eval(expression);
		}
		catch (e) {}
		
		pCalculator.val(parseFloat(result)).select();
		if (result.toString().length > 0)
		{
			E.CalculatorHistoryArray.pop();
			E.CalculatorHistoryArray.unshift(expression);
			E.CalcHistoryIndex = 0;
		}
	}
};
D = {
/* =============================================================================
 * @@Dictionary to translate readable/listenable strings
 * ========================================================================== */

	/*
	 * Words to be used alone or to form a phrase.
	 * HTML characters like "'" (single quote) must be escaped because these
	 * strings are used directly.
	 */
	Dictionary:
	{
		s_TEMPLATE: {de: "", es: "", fr: "",
			cs: "", it: "", pl: "", pt: "", ru: "", zh: ""},
		
		// Time
		s_y: {de: "j", es: "a", fr: "a", cs: "r", it: "a", pl: "r", pt: "a", ru: "г", zh: "年"},
		s_mo: {de: "mo", es: "me", fr: "mo", cs: "mě", it: "me", pl: "mi", pt: "mê", ru: "ме", zh: "月"},
		s_w: {de: "w", es: "s", fr: "s", cs: "t", it: "s", pl: "t", pt: "s", ru: "н", zh: "周"},
		s_d: {de: "t", es: "d", fr: "j", cs: "d", it: "g", pl: "d", pt: "d", ru: "д", zh: "日"},
		s_h: {de: "h", es: "h", fr: "h", cs: "h", it: "o", pl: "g", pt: "h", ru: "ч", zh: "时"},
		s_m: {de: "m", es: "m", fr: "m", cs: "m", it: "m", pl: "m", pt: "m", ru: "м", zh: "分"},
		s_s: {de: "s", es: "s", fr: "s", cs: "s", it: "s", pl: "s", pt: "s", ru: "с", zh: "秒"},
		s_hour: {de: "stunde", es: "hora", fr: "heure", cs: "hodina", it: "ora", pl: "godzinę", pt: "hora", ru: "час", zh: "时"},
		s_minute: {de: "minute", es: "minuto", fr: "minute", cs: "minuta", it: "minuto", pl: "minuta", pt: "minuto", ru: "минута", zh: "分"},
		s_second: {de: "sekunde", es: "segundo", fr: "seconde", cs: "sekunda", it: "secondo", pl: "sekund", pt: "segundo", ru: "секунду", zh: "秒"},
		s_hours: {de: "stunden", es: "horas", fr: "heures", cs: "hodin", it: "secondi", pl: "godzin", pt: "horas", ru: "часов", zh: "时"},
		s_minutes: {de: "minuten", es: "minutos", fr: "minutes", cs: "minut", it: "minuti", pl: "minut", pt: "minutos", ru: "минут", zh: "分"},
		s_seconds: {de: "sekunden", es: "segundos", fr: "secondes", cs: "sekund", it: "ore", pl: "sekund", pt: "segundos", ru: "секунд", zh: "秒"},
		s_half_an_hour: {de: "eine halbe stunde", es: "media hora", fr: "demi-heure",
			cs: "půl hodiny", it: "mezz&apos;ora", pl: "pół godziny", pt: "meia hora", ru: "полчаса", zh: "半小时"},
		s_cooldown: {de: "abkühl", es: "recuperación", fr: "recharge",
			cs: "dobíjení", it: "raffreddamento", pl: "ochładzania", pt: "resfriamento", ru: "перезарядка", zh: "冷却"},
		s_remaining: {de: "verbleibend", es: "restante", fr: "restant",
			cs: "zbývající", it: "rimanente", pl: "pozostały", pt: "restante", ru: "оставшиеся", zh: "剩余"},
		s_day: {de: "tag", es: "día", fr: "jour",
			cs: "den", it: "giorno", pl: "dzień", pt: "dia", ru: "день", zh: "白天"},
		s_night: {de: "nacht", es: "noche", fr: "nuit",
			cs: "noc", it: "notturne", pl: "nocna", pt: "noturno", ru: "ночь", zh: "夜间"},
		s_dawn: {de: "tagesanbruch", es: "amanecer", fr: "aube",
			cs: "svítání", it: "alba", pl: "świt", pt: "alvorecer", ru: "рассвет", zh: "黎明"},
		s_dusk: {de: "dämmerung", es: "crepúsculo", fr: "crépuscule",
			cs: "soumrak", it: "crepuscolo", pl: "zmierzch", pt: "crepúsculo", ru: "сумрак", zh: "黄昏"},
		s_approaching: {de: "nähert", es: "acerca", fr: "approchant",
			cs: "blíží", it: "avvicina", pl: "zbliża", pt: "aproximava", ru: "приближается", zh: "来临"},
		s_when: {de: "wann", es: "cuando", fr: "quand",
			cs: "když", it: "quando", pl: "gdy", pt: "quando", ru: "когда", zh: "什么时候"},
		s_now: {de: "jetzt", es: "ahora", fr: "présent",
			cs: "nyní", it: "adesso", pl: "teraz", pt: "agora", ru: "теперь", zh: "现在"},
		
		// Nouns
		s_directory: {de: "verzeichnis", es: "directorio", fr: "répertoire",
			cs: "adresář", it: "directory", pl: "katalog", pt: "diretório", ru: "каталог", zh: "目录"},
		s_dashboard: {de: "dashboard", es: "panel", fr: "tableau de bord",
			cs: "řídicí panel", it: "dashboard", pl: "pulpit nawigacyjny", pt: "painel", ru: "панель мониторинга", zh: "仪表板"},
		s_leaderboard: {de: "bestenliste", es: "marcador", fr: "classement",
			cs: "žebříček", it: "classifica", pl: "liderzy sprzedaży", pt: "placar de líderes", ru: "список лидеров", zh: "排行榜"},
		s_server: {de: "server", es: "servidor", fr: "serveur",
			cs: "server", it: "server", pl: "serwer", pt: "servidor", ru: "сервер", zh: "服务器"},
		s_account: {de: "account", es: "cuenta", fr: "compte",
			cs: "účet", it: "conto", pl: "konto", pt: "conta", ru: "счёт", zh: "帐户"},
		s_key: {de: "schlüssel", es: "tecla", fr: "clé",
			cs: "klávesa", it: "chiave", pl: "klawisz", pt: "chave", ru: "ключ", zh: "索引键"},
		s_history: {de: "verlauf", es: "historial", fr: "historique",
			cs: "historie", it: "cronologia", pl: "historii", pt: "histórico", ru: "истории", zh: "历史"},
		s_info: {de: "info", es: "información", fr: "info",
			cs: "informace", it: "info", pl: "informacje", pt: "informações", ru: "информация", zh: "资讯"},
		s_item: {de: "gegenstand", es: "objeto", fr: "objet",
			cs: "objekt", it: "oggetto", pl: "obiekt", pt: "objeto", ru: " объект", zh: "物品"},
		s_items: {de: "gegenstände", es: "objetos", fr: "objets",
			cs: "objektů", it: "oggetti", pl: "obiekty", pt: "objetos", ru: "объекты", zh: "物品"},
		s_collectible: {de: "sammlerstücke", es: "coleccionable", fr: "collectable",
			cs: "sběratelský", it: "collezione", pl: "kolekcjonerski", pt: "colecionável", ru: "коллекционирования", zh: "收藏"},
		s_tier: {de: "rang", es: "rango", fr: "niveau",
			cs: "pořadí", it: "rango", pl: "ranga", pt: "classe", ru: "ранг", zh: "级"},
		s_clock: {de: "uhr", es: "reloj", fr: "horloge",
			cs: "hodiny", it: "orologio", pl: "zegar", pt: "relógio", ru: "часы", zh: "时钟"},
		s_timers: {de: "zeitgeber", es: "temporizadores", fr: "minuteurs",
			cs: "časovače", it: "timer", pl: "czasomierzy", pt: "temporizadores", ru: "таймеров", zh: "计时器"},
		s_timeline: {de: "zeitachse", es: "escala de tiempo", fr: "chronologie",
			cs: "časová osa", it: "sequenza temporale", pl: "oś czasu", pt: "linha do tempo", ru: "временная шкала", zh: "时间线"},
		s_countdowns: {de: "countdown", es: "cuenta regresiva", fr: "compte à rebours",
			cs: "odpočítávání", it: "conto alla rovescia", pl: "odliczanie", pt: "contagem regressiva", ru: "обратный отсчет", zh: "倒计时"},
		s_announcements: {de: "ankündigungen", es: "anuncios", fr: "annonces",
			cs: "oznámení", it: "annunci", pl: "ogłoszenia", pt: "anúncios", ru: "объявления", zh: "公告"},
		s_console: {de: "konsole", es: "consola", fr: "console",
			cs: "konzola", it: "console", pl: "konsola", pt: "console", ru: "консоль", zh: "控制台"},
		s_panel: {de: "panel", es: "panel", fr: "panneau",
			cs: "panel", it: "pannello", pl: "panel", pt: "painel", ru: "панель", zh: "面板"},
		s_tools: {de: "extras", es: "herramientas", fr: "outils",
			cs: "nástroje", it: "strumenti", pl: "narzędzia", pt: "ferramentas", ru: "инструменты", zh: "工具"},
		s_guides: {de: "handbuch", es: "guías", fr: "guides",
			cs: "vodítka", it: "guide", pl: "prowadnice", pt: "guias", ru: "руководства", zh: "指南"},
		s_links: {de: "links", es: "vínculos", fr: "liens",
			cs: "odkazy", it: "collegamenti", pl: "linki", pt: "vínculos", ru: "ссылки", zh: "链接"},
		s_help: {de: "hilfe", es: "ayuda", fr: "assistance",
			cs: "pomoci", it: "guida", pl: "pomoc", pt: "ajuda", ru: "помощь", zh: "帮助"},
		s_options: {de: "optionen", es: "opciónes", fr: "options",
			cs: "možnosti", it: "opzioni", pl: "opcje", pt: "opções", ru: "параметры", zh: "选项"},
		s_arrival: {de: "ankunft", es: "llegada", fr: "arrivée",
			cs: "příjezd", it: "arrivo", pl: "przyjazd", pt: "chegada", ru: "прибытие", zh: "到来"},
		s_world: {de: "welt", es: "mundo", fr: "monde",
			cs: "svět", it: "mondo", pl: "świat", pt: "mundo", ru: "босс", zh: "世界"},
		s_boss: {de: "boss", es: "jefe", fr: "chef",
			cs: "boss", it: "boss", pl: "szef", pt: "chefe", ru: "босс", zh: "头目"},
		s_event: {de: "event", es: "evento", fr: "événement",
			cs: "událost", it: "evento", pl: "wydarzenie", pt: "evento", ru: "событие", zh: "事件"},
		s_events: {de: "ereignisse", es: "eventos", fr: "événements",
			cs: "dění", it: "eventi", pl: "wydarzenia", pt: "eventos", ru: "события", zh: "事件"},
		s_section: {de: "abschnitt", es: "sección", fr: "section",
			cs: "oddíl", it: "sezione", pl: "sekcja", pt: "seção", ru: "раздел", zh: "节"},
		s_map: {de: "karte", es: "mapa", fr: "carte",
			cs: "mapa", it: "mappa", pl: "mapa", pt: "mapa", ru: "ка́рта", zh: "地图"},
		s_terrain: {de: "terrain", es: "terreno", fr: "terrain",
			cs: "terén", it: "terreno", pl: "teren", pt: "terreno", ru: "местность", zh: "地形"},
		s_center: {de: "zentrum", es: "centro", fr: "centre",
			cs: "střed", it: "centro", pl: "środek", pt: "centro", ru: "центр", zh: "中心"},
		s_completion: {de: "abschluss", es: "finalización", fr: "progression",
			cs: "dokončení", it: "completamento", pl: "ukończenie", pt: "progressão", ru: "завершение", zh: "完成"},
		s_route: {de: "route", es: "ruta", fr: "route",
			cs: "trasa", it: "percorso", pl: "trasa", pt: "rota", ru: "маршрут", zh: "路线"},
		s_pins: {de: "stecknadel", es: "chincheta", fr: "repère",
			cs: "špendlík", it: "segnaposto", pl: "pinezka", pt: "marcador", ru: "маркер", zh: "大头针"},
		s_path: {de: "pfad", es: "trazado", fr: "tracé",
			cs: "cesta", it: "tracciato", pl: "ścieżka", pt: "demarcador", ru: "контур", zh: "路径"},
		s_range: {de: "reichweite", es: "alcance", fr: "portée",
			cs: "dosah", it: "portata", pl: "zasięg", pt: "alcance", ru: "дальность", zh: "范围"},
		s_color: {de: "farbe", es: "color", fr: "couleur",
			cs: "barva", it: "colore", pl: "kolor", pt: "cor", ru: "цвет", zh: "色"},
		s_opacity: {de: "deckkraft", es: "opacidad", fr: "opacité",
			cs: "neprůhlednost", it: "opacità", pl: "nieprzezroczystość", pt: "opacidade", ru: "прозрачность", zh: "不透明度"},
		s_comment: {de: "kommentar", es: "comentario", fr: "commentaire",
			cs: "komentář", it: "commento", pl: "komentarz", pt: "comentário", ru: "примечание", zh: "注释"},
		s_compass: {de: "zirkel", es: "compás", fr: "compas",
			cs: "kružítko", it: "compasso", pl: "cyrkiel", pt: "compasso", ru: "циркуль", zh: "指针"},
		s_slot: {de: "steckplatz", es: "ranura", fr: "emplacement",
			cs: "slot", it: "slot", pl: "gniazdo", pt: "slot", ru: "слот", zh: "插槽"},
		s_resource: {de: "ressourcen", es: "recursos", fr: "ressources",
			cs: "zdrojů", it: "risorse", pl: "zasobów", pt: "recursos", ru: "ресурсные", zh: "资源"},
		s_nodes: {de: "knoten", es: "nodos", fr: "zones",
			cs: "uzly", it: "nodi", pl: "węzły", pt: "nós", ru: "узлы", zh: "节点"},
		s_jumping: {de: "sprung", es: "salto", fr: "saut",
			cs: "skákání", it: "saltando", pl: "skoki", pt: "pulando", ru: "переход", zh: "跳跳"},
		s_puzzles: {de: "rätsel", es: "prueba", fr: "puzzle",
			cs: "hlavolam", it: "rompicapo", pl: "zagadki", pt: "desafio", ru: "пазлы", zh: "乐"},
		s_bookmarks: {de: "zeichen", es: "marcadores", fr: "signets",
			cs: "záložky", it: "segnalibri", pl: "zakładki", pt: "favoritos", ru: "закладки", zh: "书签"},
		s_lock: {de: "sperre", es: "bloqueo", fr: "verrou",
			cs: "zámek", it: "blocco", pl: "zablokuj", pt: "bloqueio", ru: "блокировка", zh: "锁定"},
		s_checklist: {de: "prüfliste", es: "lista de comprobación", fr: "liste de contrôle",
			cs: "kontrolní seznam", it: "elenco di controllo", pl: "lista kontrolna", pt: "lista de verificação", ru: "контрольный список", zh: "检查清单"},
		s_notepad: {de: "notizblock", es: "bloc de notas", fr: "blocnotes",
			cs: "poznámkový blok", it: "blocco note", pl: "notatnik", pt: "bloco de notas", ru: "блокнот", zh: "记事本"},
		s_subscription: {de: "abonnement", es: "suscripción", fr: "abonnement",
			cs: "předplatné", it: "sottoscrizione", pl: "abonament", pt: "assinatura", ru: "подписка", zh: "订阅"},
		s_alarm: {de: "alarm", es: "alarma", fr: "alarme",
			cs: "alarmu", it: "allarme", pl: "alarmu", pt: "alarme", ru: "будильника", zh: "闹钟"},
		s_mode: {de: "modus", es: "modo", fr: "mode",
			cs: "režim", it: "modalità", pl: "tryb", pt: "modo", ru: "режим", zh: "模式"},
		s_chatlink: {de: "chatlink", es: "vínculo chat", fr: "lien chat",
			cs: "chat odkaz", it: "collegamento chat", pl: "czat łącze", pt: "link bate-papo", ru: "чат связь", zh: "聊天链接"},
		s_stopwatch: {de: "stoppuhr", es: "cronómetro", fr: "chronomètre",
			cs: "stopky", it: "cronografo", pl: "stoper", pt: "cronômetro", ru: "секундомер", zh: "码表"},
		s_guild: {de: "gilden", es: "clan", fr: "guilde",
			cs: "cech", it: "clan", pl: "klan", pt: "clãs", ru: "гильдии", zh: "公会"},
		s_guilds: {de: "gilden", es: "clanes", fr: "guildes",
			cs: "cechy", it: "clan", pl: "klany", pt: "clãs", ru: "гильдий", zh: "公会"},
		s_missions: {de: "missionen", es: "misiónes", fr: "missions",
			cs: "mise", it: "missioni", pl: "misje", pt: "missões", ru: "миссии", zh: "任务"},
		s_pact: {de: "pakt", es: "pacto", fr: "pacte",
			cs: "pakt", it: "patto", pl: "pakt", pt: "pacto", ru: "пакт", zh: "契约团"},
		
		// Verbs
		s_is: {de: "ist", es: "es", fr: "est",
			cs: "je", it: "è", pl: "jest", pt: "é", ru: "является", zh: "是"},
		s_subscribe: {de: "abonnieren", es: "subscribir", fr: "abonner",
			cs: "předplatit si", it: "sottoscrivere", pl: "abonować", pt: "assinar", ru: "подписаться", zh: "订阅"},
		s_unsubscribe: {de: "abonnement kündigen", es: "cancelar suscripción", fr: "se désabonner",
			cs: "přestat odebírat", it: "annulla sottoscrizione", pl: "anulować subskrypcję", pt: "cancelar assinatura", ru: "отменить подписку", zh: "取消订阅"},
		s_pause: {de: "anhalten", es: "pausar", fr: "suspendre",
			cs: "pozastavit", it: "sospendere", pl: "wstrzymaj", pt: "pausar", ru: "приостановить", zh: "暂停"},
		s_resume: {de: "fortsetzen", es: "reanudar", fr: "reprendre",
			cs: "pokračovat", it: "riprendere", pl: "wznawiać", pt: "retomar", ru: "продолжить", zh: "继续"},
		s_will_start: {de: "wird starten", es: "se iniciará", fr: "débutera",
			cs: "začne", it: "inizierà", pl: "rozpocznie się", pt: "começará", ru: "начнется", zh: "开始"},
		s_click: {de: "klicken", es: "clic", fr: "cliquer",
			cs: "kliknout", it: "clic", pl: "klikać", pt: "clicar", ru: "щелкнуть", zh: "单击"},
		s_double: {de: "doppel", es: "doble", fr: "double",
			cs: "dvojité", it: "doppio", pl: "dwukrotnie", pt: "duplo", ru: "двойной", zh: "双"},
		s_drag: {de: "ziehen", es: "arrastrar", fr: "glisser",
			cs: "přetáhnout", it: "trascinare", pl: "przeciągnąć", pt: "arrastar", ru: "перетащить", zh: "拖动"},
		s_separate: {de: "trennen", es: "separar", fr: "séparer",
			cs: "oddělit", it: "separare", pl: "oddzielić", pt: "separar", ru: "разделять", zh: "分开"},
		s_view: {de: "anzeigen", es: "ver", fr: "afficher",
			cs: "zobrazit", it: "visualizzare", pl: "wyświetlać", pt: "exibir", ru: "представление", zh: "检视"},
		s_load: {de: "laden", es: "cargar", fr: "charger",
			cs: "načíst", it: "caricare", pl: "załaduj", pt: "carregar", ru: "загрузить", zh: "载入"},
		s_save: {de: "speichern", es: "guardar", fr: "enregistrer",
			cs: "uložit", it: "salvare", pl: "zapisać", pt: "salvar", ru: "сохранить", zh: "保存"},
		s_import: {de: "importieren", es: "importar", fr: "importer",
			cs: "importovat", it: "importować", pl: "", pt: "importar", ru: "импортировать", zh: "导入"},
		s_export: {de: "exportieren", es: "exportar", fr: "exporter",
			cs: "exportovat", it: "esportare", pl: "eksportować", pt: "exportar", ru: "экспортировать", zh: "导出"},
		s_select: {de: "markieren", es: "seleccionar", fr: "sélectionner",
			cs: "vybrat", it: "selezionare", pl: "zaznaczyć", pt: "selecionar", ru: "выделить", zh: "选择"},
		s_use: {de: "benutzen", es: "usar", fr: "utiliser",
			cs: "použít", it: "usare", pl: "używać", pt: "usar", ru: "использовать", zh: "用"},
		s_cancel: {de: "abbrechen", es: "cancelar", fr: "annuler",
			cs: "zrušit", it: "annullare", pl: "anulować", pt: "cancelar", ru: "отменить", zh: "取消"},
		s_add: {de: "hinzufügen", es: "añadir", fr: "ajouter",
			cs: "přidat", it: "aggiungere", pl: "dodać", pt: "adicionar", ru: "добавлять", zh: "加"},
		s_delete: {de: "löschen", es: "eliminar", fr: "supprimer",
			cs: "odstranit", it: "eliminare", pl: "usunąć", pt: "excluir", ru: "удалять", zh: "删除"},
		s_clear: {de: "löschen", es: "borrar", fr: "effacer",
			cs: "vymazat", it: "cancella", pl: "wyczyść", pt: "limpar", ru: "очистить", zh: "清除"},
		s_trim: {de: "trimmen", es: "recortar", fr: "découper",
			cs: "stříhat", it: "tagliare", pl: "odetnij", pt: "cortar", ru: "обрезать", zh: "剪裁"},
		s_toggle: {de: "umschalten", es: "alternar", fr: "basculer",
			cs: "přepnout", it: "alterna", pl: "przełączanie", pt: "alternar", ru: "переключить", zh: "切换"},
		s_condense: {de: "verkleinern", es: "condensar", fr: "condenser",
			cs: "zúžit", it: "riduci", pl: "zmniejsz", pt: "condensar", ru: "сжать", zh: "紧缩"},
		s_enable: {de: "aktivieren", es: "habilitar", fr: "activer",
			cs: "povolit", it: "abilitare", pl: "włączyć", pt: "habilitar", ru: "разрешить", zh: "启用"},
		s_disable: {de: "deaktivieren", es: "deshabilitar", fr: "désactiver",
			cs: "zakázat", it: "disabilitare", pl: "wyłączyć", pt: "desabilitar", ru: "отключить", zh: "禁用"},
		s_expand: {de: "erweiter", es: "expandir", fr: "développer",
			cs: "rozbalit", it: "espandere", pl: "rozwinąć", pt: "expandir", ru: "развернуть", zh: "展开"},
		s_collapse: {de: "verkleiner", es: "contraer", fr: "réduire",
			cs: "sbalit", it: "comprimere", pl: "zwinąć", pt: "recolher", ru: "свернуть", zh: "折叠"},
		s_show: {de: "anzeigen", es: "mostrar", fr: "afficher",
			cs: "zobrazit", it: "mostra", pl: "pokaż", pt: "mostrar", ru: "показать", zh: "显示"},
		s_hide: {de: "ausblenden", es: "ocultar", fr: "masquer",
			cs: "skrýt", it: "nascondi", pl: "ukryj", pt: "ocultar", ru: "скрыть", zh: "隐藏"},
		s_draw: {de: "zeichnen", es: "dibujar", fr: "dessiner",
			cs: "kreslit", it: "disegnare", pl: "rysować", pt: "desenhar", ru: "рисова́ть", zh: "画"},
		s_undo: {de: "rückgängig", es: "deshacer", fr: "annuler",
			cs: "zpět", it: "annullare", pl: "cofnąć", pt: "desfazer", ru: "отменить", zh: "撤销"},
		s_optimize: {de: "optimieren", es: "optimizar", fr: "optimiser",
			cs: "optimalizovat", it: "ottimizzare", pl: "optymalizować", pt: "otimizar", ru: "оптимизировать", zh: "最佳化路线"},
		s_search: {de: "suchen", es: "buscar", fr: "rechercher",
			cs: "vyhledat", it: "cerca", pl: "wyszukaj", pt: "pesquisar", ru: "поиск", zh: "搜寻"},
		s_get: {de: "erhalten", es: "conseguir", fr: "obtenir",
			cs: "dostat", it: "ottenere", pl: "dostawać", pt: "obter", ru: "достава́ть", zh: "获得"},
		s_update: {de: "aktualisieren", es: "actualizar", fr: "mettre à jour",
			cs: "aktualizovat", it: "aggiornare", pl: "aktualizować", pt: "atualizar", ru: "обновить", zh: "更新"},
		s_convert: {de: "konvertieren", es: "convertir", fr: "convertir",
			cs: "konvertovat", it: "convertire", pl: "converter", pt: "", ru: "конвертировать", zh: "兑换"},
		s_print: {de: "ausgeben", es: "imprimir", fr: "imprimer",
			cs: "tisk", it: "stampa", pl: "drukuj", pt: "imprimir", ru: "печать", zh: "打印"},
		
		// Adjectives, Adverbs, Participles
		s_yes: {de: "ja", es: "sí", fr: "oui",
			cs: "ano", it: "sì", pl: "tak", pt: "sim", ru: "да", zh: "是"},
		s_no: {de: "kein", es: "no", fr: "pas de",
			cs: "žádný", it: "non", pl: "żaden", pt: "nada de", ru: "нет", zh: "没有"},
		s_not: {de: "nicht", es: "no", fr: "ne",
			cs: "ne", it: "non", pl: "nie", pt: "não", ru: "не", zh: "不"},
		s_all: {de: "alle", es: "todos", fr: "tous",
			cs: "všechny", it: "tutti", pl: "wszystkie", pt: "todo", ru: "все", zh: "所有"},
		s_only: {de: "nur", es: "solamente", fr: "seulement",
			cs: "pouze", it: "solo", pl: "tylko", pt: "só", ru: "только", zh: "只要"},
		s_ago: {de: "vor", es: "hace", fr: "il ya",
			cs: "před", it: "fa", pl: "temu", pt: "há", ru: "назад", zh: "前"},
		s_also: {de: "auch", es: "también", fr: "aussi",
			cs: "také", it: "anche", pl: "też", pt: "também", ru: "то́же", zh: "也"},
		s_checked: {de: "abgehakt", es: "visto", fr: "coché",
			cs: "odškrtnout", it: "controllato", pl: "zakończony", pt: "marcado", ru: "включен", zh: "勾掉"},
		s_new: {de: "neu", es: "nuevo", fr: "nouveau",
			cs: "nový", it: "nuovo", pl: "nowy", pt: "novo", ru: "новый", zh: "新"},
		s_current: {de: "aktuelle", es: "actual", fr: "actuel",
			cs: "současný", it: "corrente", pl: "bieżący", pt: "corrente", ru: "текущий", zh: "活期"},
		s_expired: {de: "abgelaufen", es: "expirado", fr: "expiré",
			cs: "vypršel", it: "scaduto", pl: "wygasłe", pt: "expirado", ru: "просрочен", zh: "已过期"},
		s_daily: {de: "täglich", es: "diaria", fr: "quotidien",
			cs: "denní", it: "giornaliero", pl: "dzienny", pt: "diário", ru: "ежедневно", zh: "日常"},
		s_dailies: {de: "täglichen", es: "diarios", fr: "quotidiens",
			cs: "deníky", it: "quotidiani", pl: "dzienniki", pt: "diários", ru: "ежедневных", zh: "日常成就"},
		s_achievements: {de: "erfolge", es: "logros", fr: "succès",
			cs: "výsledky", it: "obiettivi", pl: "osiągnięcia", pt: "conquistas", ru: "достижения", zh: "成就"},
		s_personal: {de: "persönlicher", es: "personal", fr: "personnel",
			cs: "osobní", it: "personale", pl: "osobisty", pt: "pessoal", ru: "персональный", zh: "个人"},
		s_previous: {de: "vorhergehend", es: "previo", fr: "préalable",
			cs: "předchozí", it: "previo", pl: "poprzedni", pt: "prévio", ru: "предыдущий", zh: "以前的"},
		s_next: {de: "nächste", es: "siguiente", fr: "prochain",
			cs: "příští", it: "seguente", pl: "następny", pt: "próximo", ru: "следующий", zh: "下一"},
		s_off: {de: "aus", es: "desactivado", fr: "désactivé",
			cs: "vypnuto", it: "disattivato", pl: "wyłączany", pt: "desativado", ru: "выключено", zh: "关"},
		s_offline: {de: "offline", es: "sin conexión", fr: "hors connexion",
			cs: "offline", it: "offline", pl: "offline", pt: "", ru: "автономный", zh: "离线"},
		s_predicted: {de: "vorhergesagt", es: "previsto", fr: "prédit",
			cs: "předpovídal", it: "previsto", pl: "przewiduje", pt: "predito", ru: "предсказанный", zh: "预测"},
		s_subscribed: {de: "abonniert", es: "suscrito", fr: "souscrit",
			cs: "odebírané", it: "sottoscritti", pl: "subskrypcji", pt: "assinado", ru: "подписан", zh: "订阅"},
		s_then: {de: "dann", es: "luego", fr: "puis",
			cs: "pak", it: "poi", pl: "potem", pt: "então", ru: "затем", zh: "接着"},
		s_found: {de: "gefunden", es: "encontró", fr: "trouvé",
			cs: "zjištěno", it: "trovato", pl: "stwierdzono", pt: "encontrado", ru: "найден", zh: "发现了"},
		s_loading: {de: "laden", es: "cargando", fr: "chargement",
			cs: "načítání", it: "caricamento", pl: "ładowanie", pt: "carregando", ru: "загрузка", zh: "正在载入"},
		s_done: {de: "erledigt", es: "hecho", fr: "terminé",
			cs: "hotovo", it: "fatto", pl: "gotowe", pt: "concluído", ru: "сделанный", zh: "完成了"},
		s_automatic: {de: "automatisch", es: "automático", fr: "automatique",
			cs: "automatický", it: "automatico", pl: "automatyczny", pt: "automático", ru: "автоматический", zh: "自动的"},
		s_custom: {de: "benutzerdefinierte", es: "personalizado", fr: "personnalisée",
			cs: "vlastní", it: "personalizzata", pl: "niestandardowy", pt: "personalizado", ru: "настраиваемая", zh: "自定义"},
		
		// Prepositions and Conjunctions
		s_and: {de: "und", es: "y", fr: "et",
			cs: "a", it: "e", pl: "i", pt: "e", ru: "и", zh: "和"},
		s_if: {de: "wenn", es: "si", fr: "si",
			cs: "jestliže", it: "se", pl: "jeśli", pt: "se", ru: "если", zh: "如果"},
		s_at: {de: "um", es: "a", fr: "à",
			cs: "v", it: "a", pl: "o", pt: "a", ru: "в", zh: "在"},
		s_by: {de: "von", es: "por", fr: "de",
			cs: "od", it: "da", pl: "przez", pt: "por", ru: "", zh: "由"},
		s_in: {de: "in", es: "en", fr: "en",
			cs: "za", it: "in", pl: "w", pt: "em", ru: "в", zh: "在"},
		s_of: {de: "von", es: "de", fr: "de",
			cs: "z", it: "di", pl: "z", pt: "de", ru: "из", zh: "的"},
		s_for: {de: "für", es: "para", fr: "pour",
			cs: "pro", it: "per", pl: "dla", pt: "para", ru: "для", zh: "为了"},
		s_to: {de: "zu", es: "a", fr: "contre",
			cs: "ku", it: "a", pl: "na", pt: "a", ru: "до", zh: "至"},
		
		// Automatic
		s_Sector: {de: "Sektor", es: "Sector", fr: "Secteur", zh: "扇形"},
		s_Waypoint: {de: "Wegmarke", es: "Punto de ruta", fr: "Point de passage", zh: "传送点"},
		s_Point_of_Interest: {de: "Sehenswürdigkeit", es: "Punto de interés", fr: "Site remarquable", zh: "探索点"},
		s_Vista: {de: "Aussichtspunkt", es: "Vista", fr: "Panorama", zh: "观景点"},
		s_Mastery_Insight: {de: "Einsicht", es: "Reflexión de dominio", fr: "Source de connaissance de maîtrise", zh: "专精揭秘点"},
		s_Hero_Challenge: {de: "Heldenherausforderung", es: "Desafío de héroe", fr: "Défi de héros", zh: "英雄挑战"},
		s_Heart: {de: "Herzchen-Quest", es: "Corazón de prestigio", fr: "Cœur de renommé", zh: "爱心任务"},
		s_Scheduled_Bosses: {de: "Geplant", es: "Programado", fr: "Planifié",
			cs: "Plánované", it: "Pianificata", pl: "Zaplanowane", pt: "Agendado", ru: "Запланирован", zh: "世界BOSS"},
		s_Special_Bosses: {de: "Speziell", es: "Especial", fr: "Spécial",
			cs: "Speciální", it: "Speciale", pl: "Specjalny", pt: "Especial", ru: "Особый", zh: "特殊BOSS"},
		s_Dry_Top: {de: "Trockenkuppe", es: "Cima Seca", fr: "Cimesèche", zh: "干涸高地"},
		s_Legacy_Bosses: {de: "Legacy", es: "Heredado", fr: "Hérité",
			cs: "Starší", it: "Legacy", pl: "Starsze", pt: "Herdado", ru: "Устаревший", zh: "旧版BOSS"},
		s_Orr_Temples: {de: "Tempel", es: "Templos", fr: "Temples",
			cs: "Chrámy", it: "Templi", pl: "Świątynie", pt: "Templos", ru: "Храмы", zh: "欧尔神殿"},
		s_Full_Timetable: {de: "Zeitplan", es: "Horario", fr: "Horaire",
			cs: "Plán", it: "Programma", pl: "Harmonogram", pt: "Horário", ru: "Расписание", zh: "时间表"},
		s_promotions: {de: "aktionen", es: "promociones", fr: "promotions",
			cs: "propagace", it: "promozioni", pl: "promocje", pt: "promoções", ru: "продвижения", zh: "促销"},
		s_menu: {de: "menü", es: "menú", fr: "menu",
			cs: "nabídka", it: "menu", pl: "menu", pt: "menu", ru: "меню", zh: "功能表"},
		s_wvw: {de: "WvW", es: "McM", fr: "McM",
			cs: "SpS", it: "McM", pl: "SkS", pt: "McM", ru: "МпМ", zh: "世界战场"},
		s_pve: {de: "SgU", es: "JcE", fr: "JcE",
			cs: "HpP", it: "GcA", pl: "PvE", pt: "JcA", ru: "ИпО", zh: "玩家对抗环境"},
		s_pvp: {de: "PvP", es: "JcJ", fr: "JcJ",
			cs: "HpH", it: "GcG", pl: "PvP", pt: "JcJ", ru: "ИпИ", zh: "玩家对战"},
		s_display: {de: "anzeige", es: "presentación", fr: "affichage",
			cs: "zobrazení", it: "visualizzazione", pl: "wyświetlania", pt: "exibição", ru: "отображаемое", zh: "显示"},
		s_zone: {de: "gebiet", es: "zona", fr: "zone",
			cs: "zóna", it: "zona", pl: "zona", pt: "zona", ru: "зона", zh: "区域"},
		s_forum: {de: "forum", es: "foro", fr: "forum",
			cs: "fórum", it: "forum", pl: "forum", pt: "fórum", ru: "форум", zh: "论坛"},
		s_possessions: {de: "besitzungen", es: "posesiones", fr: "possessions",
			cs: "bohatství", it: "patrimonio", pl: "dobytek", pt: "posses", ru: "пожитки", zh: "财产"},
		s_catalog: {de: "katalog", es: "catálogo", fr: "catalogue",
			cs: "katalog", it: "catalogo", pl: "katalog", pt: "catálogo", ru: "каталог", zh: "目录"},
		s_audit: {de: "prüfung", es: "auditar", fr: "auditer",
			cs: "audit", it: "audit", pl: "audyt", pt: "auditar", ru: "аудит", zh: "审计"},
		s_cleanup: {de: "aufräumen", es: "limpia", fr: "nettoyer",
			cs: "úklid", it: "ripulire", pl: "oczyszczenie", pt: "limpeza", ru: "уборка", zh: "整理"},
		s_simple: {de: "einfach", es: "simple", fr: "simple",
			cs: "prostý", it: "semplice", pl: "prosty", pt: "simples", ru: "простой", zh: "简单"},
		s_mobile: {de: "mobil", es: "móvil", fr: "mobile",
			cs: "mobilní", it: "mobile", pl: "mobilna", pt: "móvel", ru: "мобильный", zh: "移动端"},
		s_tile: {de: "kacheln", es: "mosaico", fr: "mosaïque",
			cs: "dlaždice", it: "affianca", pl: "sąsiadująco", pt: "ladrilho", ru: "замостить", zh: "堆砌"},
		
		// Section names
		s_manager: {de: "manager", es: "administrador", fr: "gestionnaire",
			cs: "správce", it: "gestione", pl: "menedżer", pt: "gerenciador", ru: "диспетчер", zh: "管理员"},
		s_bank: {de: "bank", es: "banco", fr: "banque",
			cs: "banka", it: "banca", pl: "bank", pt: "banco", ru: "банк", zh: "银行"},
		s_vault: {de: "tresor", es: "arcón", fr: "coffre",
			cs: "trezor", it: "volta", pl: "kufer", pt: "tesouro", ru: "сундук", zh: "保险箱"},
		s_materials: {de: "materialien", es: "materiales", fr: "matériaux",
			cs: "materiály", it: "materiale", pl: "materiały", pt: "materiais", ru: "материалы", zh: "物料"},
		s_skins: {de: "skins", es: "diseños", fr: "apparences",
			cs: "vzhledy", it: "apparenze", pl: "karnacje", pt: "desenhos", ru: "конструкции", zh: "皮肤"},
		s_wardrobe: {de: "garderobenlager", es: "garderobe", fr: "garderobe",
			cs: "skříň", it: "armadio", pl: "szafa", pt: "roupeiro", ru: "гардероб", zh: "衣柜"},
		s_outfits: {de: "kleidungssets", es: "atuendos", fr: "tenues",
			cs: "oblečení", it: "abiti", pl: "strój", pt: "vestuário", ru: "костюмы", zh: "服装"},
		s_gliders: {de: "gleitschirm", es: "planeador", fr: "deltaplanes",
			cs: "kluzáky", it: "alianti", pl: "szybowce", pt: "planadores", ru: "планеры", zh: "滑翔翼"},
		s_dyes: {de: "farben", es: "tintes", fr: "teintures",
			cs: "barviva", it: "tinturi", pl: "barwniki", pt: "tinturas", ru: "красители", zh: "染料"},
		s_minis: {de: "miniaturen", es: "miniaturas", fr: "miniatures",
			cs: "miniatury", it: "miniature", pl: "miniatury", pt: "miniaturas", ru: "миниатюры", zh: "迷你宠物"},
		s_carriers: {de: "briefboten", es: "carteros", fr: "messagers",
			cs: "kurýři", it: "corrieri", pl: "kurierzy", pt: "correios", ru: "курьеры", zh: "快递"},
		s_champions: {de: "champion", es: "campeón", fr: "champion",
			cs: "mistr", it: "campione", pl: "mistrz", pt: "campeão", ru: "чемпион", zh: "迷雾首领"},
		s_finishers: {de: "todesstöße", es: "remates", fr: "coups de grâce",
			cs: "finišer", it: "finitore", pl: "apreter", pt: "arrematador", ru: "финишер", zh: "终结技"},
		s_cats: {de: "katzen", es: "gatos", fr: "chats",
			cs: "kočky", it: "gatti", pl: "koty", pt: "gatos", ru: "коты", zh: "猫"},
		s_characters: {de: "charaktere", es: "personajes", fr: "personnages",
			cs: "postavy", it: "personaggi", pl: "postacie", pt: "personagens", ru: "персонажей", zh: "人物"},
		s_hero: {de: "heldin", es: "héroe", fr: "héros",
			cs: "hrdina", it: "eroe", pl: "bohater", pt: "herói", ru: "геро́й", zh: "主角"},
		s_equipment: {de: "ausrüstung", es: "equipamiento", fr: "equipement",
			cs: "vybavení", it: "equipaggiamento", pl: "sprzęt", pt: "equipamento", ru: "обору́дование", zh: "装备"},
		s_inventory: {de: "inventar", es: "inventario", fr: "inventaire",
			cs: "inventář", it: "inventario", pl: "inwentarz", pt: "inventário", ru: "инвента́рь", zh: "背包"},
		s_ascended: {de: "aufgestiegen", es: "ascendido", fr: "élevé",
			cs: "vystoupal", it: "asceso", pl: "wstąpił", pt: "ascendeu", ru: "вознесся", zh: "升华"},
		s_recipes: {de: "rezepte", es: "recetas", fr: "recettes",
			cs: "recepty", it: "ricette", pl: "recepty", pt: "receitas", ru: "рецепты", zh: "配方"},
		s_crafting: {de: "handwerkskunst", es: "artesanía", fr: "artisanat",
			cs: "řemeslo", it: "mestiere", pl: "rzemiosło", pt: "ofício", ru: "ремесло", zh: "制作"},
		s_raids: {de: "schlachtzügen", es: "incursiones", fr: "raids",
			cs: "nájezd", it: "incursione", pl: "nalot", pt: "incursão", ru: "набег", zh: "大型地下城"},
		s_dungeons: {de: "verliesen", es: "mazmorras", fr: "donjons",
			cs: "dungeony", it: "dungeon", pl: "lochy", pt: "masmorras", ru: "подземелья", zh: "地下城"},
		s_masteries: {de: "beherrschungs", es: "dominios", fr: "maîtrises",
			cs: "nadvláda", it: "maestria", pl: "dominacji", pt: "mestrias", ru: "господства", zh: "专精"},
		s_museum: {de: "museum", es: "museo", fr: "musée",
			cs: "muzeum", it: "museo", pl: "muzeum", pt: "museu", ru: "музей", zh: "博物馆"},
		s_wishlist: {de: "wunschliste", es: "lista de deseos", fr: "liste d'envies",
			cs: "seznam přání", it: "lista desideri", pl: "lista życzeń", pt: "lista de desejos", ru: "список желаемого", zh: "愿望清单"},
		
		// Economy
		s_trading: {de: "handel", es: "comercio", fr: "commerciale",
			cs: "obchod", it: "commercio", pl: "handel", pt: "comércio", ru: "продажа", zh: "贸易"},
		s_tracker: {de: "tracker", es: "rastreador", fr: "suivi",
			cs: "tracker", it: "tracker", pl: "", pt: "rastreador", ru: "трекер", zh: "跟踪"},
		s_exchange: {de: "austauschen", es: "intercambiar", fr: "échanger",
			cs: "spoluužívat", it: "condividere", pl: "dzielić", pt: "compartilhar", ru: "предоставлять", zh: "货币兑换"},
		s_recent: {de: "aktuell", es: "reciente", fr: "récent",
			cs: "poslední", it: "recenti", pl: "ostatnie", pt: "recente", ru: "последние", zh: "最近"},
		s_buying: {de: "kaufen", es: "comprando", fr: "achat en cours",
			cs: "nákup", it: "comprando", pl: "kupuje", pt: "comprando", ru: "покупаю", zh: "目前买"},
		s_selling: {de: "verkaufen", es: "vendiendo", fr: "vente en cours",
			cs: "prodávat", it: "vendendo", pl: "sprzedaje", pt: "vendendo", ru: "продаю", zh: "目前卖"},
		s_bought: {de: "gekauft", es: "comprado", fr: "achats historique",
			cs: "koupil", it: "comprato", pl: "kupiłem", pt: "comprei", ru: "купил", zh: "买了"},
		s_sold: {de: "verkauft", es: "vendido", fr: "ventes historique",
			cs: "prodal", it: "venduto", pl: "sprzedał", pt: "vendi", ru: "продал", zh: "卖了"},
		s_this: {de: "dieses", es: "esto", fr: "ce",
			cs: "toto", it: "questo", pl: "to", pt: "isto", ru: "это", zh: "这"},
		s_my: {de: "mein", es: "mi", fr: "mon",
			cs: "můj", it: "mio", pl: "mój", pt: "meu", ru: "мой", zh: "我的"},
		s_your: {de: "dein", es: "tu", fr: "ton",
			cs: "tvůj", it: "tuo", pl: "twój", pt: "teu", ru: "твой", zh: "你的"},
		s_name: {de: "namen", es: "nombre", fr: "nom",
			cs: "název", it: "nome", pl: "nazwa", pt: "nome", ru: "имя", zh: "名"},
		s_ordered: {de: "bestellt", es: "pedidos", fr: "demandée",
			cs: "objednal", it: "ordinato", pl: "zamówiony", pt: "encomendado", ru: "заказал", zh: "订了"},
		s_available: {de: "verfügbar", es: "disponibles", fr: "disponible",
			cs: "dostupný", it: "disponibile", pl: "dostępny", pt: "disponível", ru: "досту́пный", zh: "可用"},
		s_supply: {de: "angebot", es: "oferta", fr: "stock",
			cs: "nabídka", it: "offerta", pl: "podaż", pt: "suprimento", ru: "предложение", zh: "供应"},
		s_demand: {de: "nachfrage", es: "demanda", fr: "demande",
			cs: "poptávka", it: "domanda", pl: "popyt", pt: "demanda", ru: "спрос", zh: "需求"},
		s_discount: {de: "rabatt", es: "rebaja", fr: "rabais",
			cs: "sleva", it: "sconto", pl: "rabat", pt: "desconto", ru: "rabat", zh: "折扣"},
		s_price: {de: "preis", es: "precio", fr: "prix",
			cs: "cena", it: "prezzo", pl: "cena", pt: "preço", ru: "цена", zh: "价格"},
		s_buy: {de: "kaufen", es: "comprar", fr: "acheter",
			cs: "koupit", it: "comprare", pl: "kupić", pt: "comprar", ru: "купить", zh: "买"},
		s_sell: {de: "verkaufen", es: "vender", fr: "vendre",
			cs: "prodat", it: "vendere", pl: "sprzedać", pt: "vender", ru: "продать", zh: "卖"},
		s_outbid: {de: "überbieten", es: "sobrepujar", fr: "surenchérir",
			cs: "přelicitovat", it: "prezzo più alto", pl: "przelicytować", pt: "ultrapassar", ru: "перекупать", zh: "出价高于"},
		s_quantity: {de: "anzahl", es: "cantidad", fr: "quantité",
			cs: "množství", it: "quantità", pl: "ilość", pt: "quantidade", ru: "количество", zh: "量"},
		s_profit: {de: "gewinn", es: "beneficio", fr: "profit",
			cs: "zisk", it: "profitto", pl: "zysk", pt: "lucro", ru: "прибыль", zh: "利润"},
		s_cost: {de: "kosten", es: "costo", fr: "coût",
			cs: "náklady", it: "costo", pl: "koszt", pt: "custo", ru: "стоимость", zh: "成本"},
		s_breakpoint: {de: "gewinnschwelle", es: "punto muerto", fr: "seuil de rentabilité",
			cs: "bod zvratu", it: "punto di pareggio", pl: "próg rentowności", pt: "ponto de equilíbrio", ru: "точка безубыточности", zh: "收支平衡点"},
		s_tax: {de: "steuer", es: "impuestos", fr: "impôt",
			cs: "daň", it: "fiscale", pl: "podatek", pt: "fiscal", ru: "налог", zh: "税"},
		s_revenue: {de: "einnahmen", es: "ingresos", fr: "revenus",
			cs: "příjmy", it: "entrate", pl: "dochody", pt: "receita", ru: "доходов", zh: "收入"},
		s_margin: {de: "gewinnspanne", es: "margen", fr: "marge",
			cs: "marže", it: "margine", pl: "marża", pt: "margem", ru: "валовая", zh: "边际"},
		s_low: {de: "niedrigen", es: "bajo", fr: "bas",
			cs: "nízký", it: "bassa", pl: "niski", pt: "baixa", ru: "низкая", zh: "低"},
		s_high: {de: "hohen", es: "alta", fr: "haut",
			cs: "vysoký", it: "alta", pl: "wysoki", pt: "alta", ru: "высокая", zh: "高"},
		s_notify: {de: "benachrichtigen", es: "notificar", fr: "notifier",
			cs: "oznámit", it: "notifica", pl: "powiadom", pt: "notificar", ru: "уведомить", zh: "通知"},
		s_overwrite: {de: "überschreiben", es: "sobrescribir", fr: "remplacer",
			cs: "přepsat", it: "sovrascrivi", pl: "zastąp", pt: "substituir", ru: "перезаписать", zh: "覆盖"},
		s_gem: {de: "edelsteine", es: "gema", fr: "gemme",
			cs: "klenot", it: "gemma", pl: "klejnot", pt: "gema", ru: "самоцвет", zh: "宝石"},
		s_coin: {de: "münze", es: "moneda", fr: "monnaie",
			cs: "mince", it: "moneta", pl: "moneta", pt: "moeda", ru: "монета", zh: "硬币"},
		s_dollar: {de: "dollar", es: "dólar", fr: "dollar",
			cs: "dolar", it: "dollaro", pl: "polar", pt: "dólar", ru: "доллар", zh: "元"}
	},
	
	// Strings from the game copied verbatim, for use mainly in tooltips
	Codex:
	{
		s_TEMPLATE: {en: "", de: "", es: "", fr: "", zh: ""},

		// Currency abbreviation
		s_CoinGold: {en: "g", de: "g", es: "o", fr: "o", cs: "z", it: "o", pl: "z", pt: "o", ru: "з", zh: "金"},
		s_CoinSilver: {en: "s", de: "s", es: "p", fr: "a", cs: "s", it: "a", pl: "s", pt: "p", ru: "с", zh: "银"},
		s_CoinCopper: {en: "c", de: "k", es: "c", fr: "c", cs: "m", it: "r", pl: "m", pt: "c", ru: "м", zh: "铜"},
		
		// Item Type
		s_Back: {en: "Back Item", de: "Rücken-Gegenstand", es: "Objeto para espalda", fr: "Objet de dos", zh: "背包"},
		s_Bag: {en: "Bag", de: "Tasche", es: "Saco", fr: "Sac", zh: "格包"},
		s_Boost: {en: "Boost", de: "Verstärker", es: "Potenciador", fr: "Augmentation", zh: "增幅剂"},
		s_Consumable: {en: "Consumable", de: "Verbrauchsgegenstand", es: "Consumible", fr: "Consommable", zh: "消耗"},
		s_Container: {en: "Container", de: "Behälter", es: "Contenedor", fr: "Conteneur", zh: "包"},
		s_CraftingMaterial: {en: "Crafting Material", de: "Handwerksmaterial", es: "Material de artesanía", fr: "Matériau d&apos;artisanat", zh: "制作材料"},
		s_Gathering: {en: "Gathering Tool", de: "Sammelwerkzeug", es: "Herramienta de recolección", fr: "Outil de récolte", zh: "采集工具"},
		s_Gizmo: {en: "Gizmo", de: "Dingsbums", es: "Aparato", fr: "Machin", zh: "小发明"},
		s_MiniPet: {en: "Miniature", de: "Miniatur", es: "Miniatura", fr: "Miniature", zh: "迷你宠物"},
		s_Nourishment: {en: "Nourishment", de: "Verbrauchsstoff", es: "Consumible", fr: "Produit consommable", zh: "食品"},
		s_Salvage: {en: "Salvage", de: "Wiederverwertungs", es: "Recicla", fr: "Recyclage", zh: "拆解"},
		s_Tool: {en: "Salvage Kit", de: "Wiederverwertungskit", es: "Kit de recicla", fr: "Nécessaire de recyclage", zh: "拆解工具包"},
		s_Trophy: {en: "Trophy", de: "Trophäe", es: "Trofeo", fr: "Trophée", zh: "战利品"},
		s_UpgradeComponent: {en: "Upgrade Component", de: "Aufwertung", es: "Componente de mejora", fr: "Composant d&apos;amélioration", zh: "升级组件"},
		// Item Rarity
		s_Junk: {en: "Junk", de: "Schrott", es: "Basura", fr: "Inutile", zh: "垃圾"},
		s_Basic: {en: "Basic", de: "Einfach", es: "Básico", fr: "Simple", zh: "基本"},
		s_Fine: {en: "Fine", de: "Edel", es: "Selecto", fr: "Raffiné", zh: "优质"},
		s_Masterwork: {en: "Masterwork", de: "Meisterwerk", es: "Obra de arte", fr: "Chef-d&apos;œuvre", zh: "精制"},
		s_Rare: {en: "Rare", de: "Selten", es: "Excepcional", fr: "Rare", zh: "稀有"},
		s_Exotic: {en: "Exotic", de: "Exotisch", es: "Exótico", fr: "Exotique", zh: "特异"},
		s_Ascended: {en: "Ascended", de: "Aufgestiegen", es: "Ascendido", fr: "Élevé", zh: "升华"},
		s_Legendary: {en: "Legendary", de: "Legendär", es: "Legendario", fr: "Légendaire", zh: "传奇"},
		// Item Weight
		s_Light: {en: "Light", de: "Leicht", es: "Ligero", fr: "Légèr", zh: "轻甲"},
		s_Medium: {en: "Medium", de: "Mittel", es: "Medio", fr: "Intermédiaire", zh: "中甲"},
		s_Heavy: {en: "Heavy", de: "Schwer", es: "Pesado", fr: "Lourd", zh: "重甲"},
		// Item Attributes
		s_Power: {en: "Power", de: "Kraft", es: "Potencia", fr: "Puissance", zh: "威力"},
		s_Toughness: {en: "Toughness", de: "Zähigkeit", es: "Dureza", fr: "Robustesse", zh: "坚韧"},
		s_Armor: {en: "Armor", de: "Rüstung", es: "Armadura", fr: "Armure", zh: "护甲"},
		s_Vitality: {en: "Vitality", de: "Vitalität", es: "Vitalidad", fr: "Vitalité", zh: "体力"},
		s_Health: {en: "Health", de: "Lebenspunkte", es: "Salud", fr: "Santé", zh: "生命值"},
		s_Precision: {en: "Precision", de: "Präzision", es: "Precisión", fr: "Précision", zh: "精准"},
		s_CriticalChance: {en: "Critical Chance", de: "Kritische Trefferchance", es: "Probabilidad de daño crítico", fr: "Chance de coup critique", zh: "暴击率"},
		s_Ferocity: {en: "Ferocity", de: "Wildheit", es: "Ferocidad", fr: "Férocité", zh: "暴击效果"},
		s_CriticalDamage: {en: "Critical Damage", de: "Kritischer Schaden", es: "Daño crítico", fr: "Dégâts critiques", zh: "暴击伤害"},
		s_ConditionDamage: {en: "Condition Damage", de: "Zustandsschaden", es: "Daño de condición", fr: "Dégâts par altération", zh: "症状伤害"},
		s_HealingPower: {en: "Healing Power", de: "Heilkraft", es: "Poder de curación", fr: "Guérison", zh: "治疗效果"},
		s_Expertise: {en: "Expertise", de: "Fachkenntnis", es: "Pericia", fr: "Expertise", zh: "症状效果"},
		s_ConditionDuration: {en: "Condition Duration", de: "Zustandsdauer", es: "Duración de condición", fr: "Durée d&apos;altération", zh: "症状持续时间"},
		s_Concentration: {en: "Concentration", de: "Konzentration", es: "Concentración", fr: "Concentration", zh: "增益效果"},
		s_BoonDuration: {en: "Boon Duration", de: "Segensdauer", es: "Duración de bendición", fr: "Durée d&apos;avantage", zh: "增益持续时间"},
		s_AgonyResistance: {en: "Agony Resistance", de: "Qual-Widerstand", es: "Resistencia a la agonía", fr: "Résistance à l&apos;agonie", zh: "痛苦抗性"},
		s_MagicFind: {en: "Magic Find", de: "Magisches Gespür", es: "Hallazgo mágico", fr: "Découverte de magie", zh: "宝物寻获率"},
		// Item Equipment
		s_Axe: {en: "Axe", de: "Axt", es: "Hacha", fr: "Haches", zh: "斧头"},
		s_Dagger: {en: "Dagger", de: "Dolch", es: "Daga", fr: "Dague", zh: "匕首"},
		s_Mace: {en: "Mace", de: "Streitkolben", es: "Maza", fr: "Masse", zh: "钉锤"},
		s_Pistol: {en: "Pistol", de: "Pistole", es: "Pistola", fr: "Pistolet", zh: "手枪"},
		s_Scepter: {en: "Scepter", de: "Zepter", es: "Cetro", fr: "Sceptre", zh: "节杖"},
		s_Sword: {en: "Sword", de: "Schwert", es: "Espada", fr: "Epée", zh: "单手剑"},
		s_Focus: {en: "Focus", de: "Fokus", es: "Foco", fr: "Focus", zh: "聚能器"},
		s_Shield: {en: "Shield", de: "Schild", es: "Escudo", fr: "Bouclier", zh: "盾牌"},
		s_Torch: {en: "Torch", de: "Fackel", es: "Antorcha", fr: "Torche", zh: "火炬"},
		s_Warhorn: {en: "Warhorn", de: "Kriegshorn", es: "Cuerno de guerra", fr: "Cor de guerre", zh: "号角"},
		s_Greatsword: {en: "Greatsword", de: "Großschwert", es: "Mandoble", fr: "Espadon", zh: "巨剑"},
		s_Hammer: {en: "Hammer", de: "Hammer", es: "Martillo", fr: "Marteau", zh: "巨锤"},
		s_LongBow: {en: "Longbow", de: "Langbogen", es: "Arco largo", fr: "Arc long", zh: "长弓"},
		s_Rifle: {en: "Rifle", de: "Gewehr", es: "Rifle", fr: "Fusil", zh: "步枪"},
		s_ShortBow: {en: "Shortbow", de: "Kurzbogen", es: "Arco corto", fr: "Arc court", zh: "短弓"},
		s_Staff: {en: "Staff", de: "Stab", es: "Báculo", fr: "Bâton", zh: "法杖"},
		s_Harpoon: {en: "Harpoon", de: "Speer", es: "Lanza", fr: "Lance", zh: "长矛"},
		s_Speargun: {en: "Speargun", de: "Harpunenschleuder", es: "Cañón de arpón", fr: "Fusil-harpon", zh: "鱼叉枪"},
		s_Trident: {en: "Trident", de: "Dreizack", es: "Tridente", fr: "Trident", zh: "三叉戟"},
		s_HelmAquatic: {en: "Head Armor", de: "Kopf-Rüstung", es: "Armadura de cabeza", fr: "Armure : Couvre-chef", zh: "呼吸器"},
		s_Helm: {en: "Head Armor", de: "Kopf-Rüstung", es: "Armadura de cabeza", fr: "Armure : Couvre-chef", zh: "头部护甲"},
		s_Shoulders: {en: "Shoulder Armor", de: "Schulter-Rüstung", es: "Armadura de hombros", fr: "Armure : Épaulières", zh: "肩部护甲"},
		s_Coat: {en: "Chest Armor", de: "Brust-Rüstung", es: "Armadura pectoral", fr: "Armure : Cuirasse", zh: "胸部护甲"},
		s_Gloves: {en: "Hand Armor", de: "Hand-Rüstung", es: "Armadura de mano", fr: "Armure : Gants", zh: "手部护甲"},
		s_Leggings: {en: "Leg Armor", de: "Bein-Rüstung", es: "Armadura de pierna", fr: "Armure : Jambières", zh: "腿部护甲"},
		s_Boots: {en: "Foot Armor", de: "Fuß-Rüstung", es: "Armadura de pie", fr: "Armure : Bottes", zh: "足部护甲"},
		s_Amulet: {en: "Amulet", de: "Amulett", es: "Amuleto", fr: "Amulette", zh: "项链"},
		s_Accessory: {en: "Accessory", de: "Accessoire", es: "Accesorio", fr: "Accessoire", zh: "饰品"},
		s_Ring: {en: "Ring", de: "Ring", es: "Anillo", fr: "Anneau", zh: "戒指"},
		// Item Tooltip
		s_Defense: {en: "Defense", de: "Verteidigung", es: "Defensa", fr: "Défense", zh: "防御"},
		s_WeaponStrength: {en: "Weapon Strength", de: "Waffenstärke", es: "Fuerza del arma", fr: "Puissance d&apos;arme", zh: "武器威力"},
		s_Healing: {en: "Healing", de: "Heilung", es: "Curación", fr: "Guérison", zh: "治疗"},
		s_RequiredLevel: {en: "Required Level", de: "Erforderliche Stufe", es: "Nivel necesario", fr: "Niveau requis", zh: "需要等级"},
		s_AccountBindOnUse: {en: "Account Bound on Use", de: "Accountgebunden bei Benutzung", es: "Vinculado a cuenta en uso", fr: "Lié au compte dès l&apos;utilisation", zh: "使用后账号绑定"},
		s_AccountBound: {en: "Account Bound", de: "Accountgebunden", es: "Vinculado a cuenta", fr: "Lié au compte", zh: "账号绑定"},
		s_SoulBindOnUse: {en: "Soulbound on Use", de: "Seelengebunden bei Benutzung", es: "Ligado en uso", fr: "Lié à l&apos;âme dès l&apos;utilisation", zh: "使用后灵魂绑定"},
		s_SoulbindOnAcquire: {en: "Soulbound", de: "Seelengebunden", es: "Ligado", fr: "Lié à l&apos;âme", zh: "拾取后灵魂绑定"},
		s_SoulboundToCharacter: {en: "Soulbound to another character", de: "An einen anderen Charakter seelengebunden", es: "Ligado a otro personaje", fr: "Lié à l&apos;âme d&apos;un autre personnage", zh: "与角色灵魂绑定"},
		s_Unique: {en: "Unique", de: "Einzigartig", es: "Equipamiento único", fr: "Unique", zh: "解除装备"},
		s_Transmuted: {en: "Transmuted", de: "Transmutiert", es: "Transmutado", fr: "Transmuté", zh: "幻化"},
		s_UnusedEnrichmentSlot: {en: "Unused Enrichment Slot", de: "Ungenutzter Anreicherungsplatz",
			es: "Casilla para enriquecimientos sin utilizar", fr: "Emplacement d'enrichissement inutilisé", zh: "未使用的富集灌注槽"},
		s_UnusedInfusionSlot: {en: "Unused Infusion Slot", de: "Freier Infusionsplatz",
			es: "Casilla de infusión sin utilizar", fr: "Emplacement d&apos;infusion inutilisé", zh: "未使用的灌注槽"},
		s_UnusedUpgradeSlot: {en: "Unused Upgrade Slot", de: "Freier Aufwertungsplatz",
			es: "Casilla para mejoras sin utilizar", fr: "Emplacement d&apos;amélioration inutilisé", zh: "未使用的升级槽"},
		s_DoubleClickToSelectStats: {en: "Double-click to select stats.", de: "Doppelklicken, um Werte auszuwählen.",
			es: "Haz doble clic para seleccionar estadísticas.", fr: "Double-cliquez pour sélectionner les statistiques.", zh: "双击选择属性"},
		s_DoubleClickToConsume: {en: "Double-click to consume.", de: "Zum Benutzen doppelklicken.",
			es: "Haz doble clic para consumir.", fr: "Double-cliquez pour utiliser.", zh: "双击使用"},
		s_ExcessiveAlcohol: {en: "Excessive alcohol consumption will result in intoxication.", de: "Übermäßiger Alkoholkonsum führt zu Rauschzuständen.",
			es: "El consumo excesivo de alcohol provoca embriaguez.", fr: "Consommer trop d&apos;alcool entraîne une ivresse manifeste.", zh: "过量饮酒容易醉"},
		s_GainBasedPercentage: {en: "Gain {1} Based on a Percentage of {0}", de: "Erhaltener prozentualer Anteil von {0} auf {1}:",
			es: "Ganas {1} según tu porcentaje de {0}", fr: "Vous bénéficiez d'une augmentation de {1} de {0}%.", zh: "获得等同于你{0}%的{1}"},
		// Guild
		s_GuildStash: {en: "Guild Stash", de: "Geheimvorrat", es: "Alijo del clan", fr: "Réserve de guilde"},
		s_TreasureTrove: {en: "Treasure Trove", de: "Schatzgrube", es: "Tesoro oculto", fr: "Trésor"},
		s_DeepCave: {en: "Deep Cave", de: "Tiefe Höhle", es: "Cueva profunda", fr: "Grotte profonde"}
	},
	
	/*
	 * Information about the user's selected language in determining content to present.
	 */
	isLanguageFullySupported: null,
	isLanguageDefault: null,
	isLanguageTraditional: null,
	isLanguageModifierFirst: null,
	isLanguageLogographic: null,
	langFullySupported: null, // The API supports zh but the wiki does not
	langPartiallySupported: null,
	initializeLanguage: function()
	{
		D.isLanguageFullySupported = (O.LanguageMeta.isFullySupported[O.Options.enu_Language]) ? true : false;
		D.isLanguageDefault = (O.Options.enu_Language === O.OptionEnum.Language.Default);
		D.isLanguageTraditional = (O.Options.enu_Language === O.OptionEnum.Language.ChineseTraditional);
		D.isLanguageModifierFirst = (O.LanguageMeta.isModifierFirst[O.Options.enu_Language]) ? true : false;
		D.isLanguageLogographic = (O.LanguageMeta.isLogographic[O.Options.enu_Language]) ? true : false;
		D.langFullySupported = (D.isLanguageFullySupported) ? O.Options.enu_Language : O.OptionEnum.Language.Default;
		D.langPartiallySupported = (O.Options.enu_Language === O.OptionEnum.Language.ChineseSimplified
			|| O.Options.enu_Language === O.OptionEnum.Language.ChineseTraditional)
			? O.OptionEnum.Language.ChineseSimplified : D.langFullySupported;
		
		D.initializeDictionary();
		U.initializeAPIURLs();
	},
	
	/*
	 * Gets a codex string based on the opted language.
	 * @param string pText text to translate without spaces.
	 * @returns string translated text.
	 */
	getString: function(pText)
	{
		var entry = D.Codex["s_" + pText];
		if (entry)
		{
			// Get the text based on user's language if available, otherwise use default
			var value = entry[O.Options.enu_Language];
			if (value)
			{
				return value;
			}
			return entry[O.OptionEnum.Language.Default];
		}
		// Language not found so use given instead
		return pText;
	},
	
	/*
	 * Gets translation string that was written within an element's data attribute.
	 * @param jqobject pElm
	 * @returns string
	 */
	getDataAttribute: function(pElm)
	{
		var elm = $(pElm);
		if (D.isLanguageDefault === false)
		{
			var str = pElm.attr("data-" + O.Options.enu_Language);
			if (str)
			{
				return str;
			}
			else if (D.isLanguageTraditional)
			{
				return $.s2t(pElm.attr("data-" + O.OptionEnum.Language.ChineseSimplified));
			}
		}
		return elm.text();
	},
	
	/*
	 * Settings for special languages.
	 */
	initializeDictionary: function()
	{
		// Use Simplified Chinese to create a Traditional Chinese dictionary
		if (D.isLanguageTraditional)
		{
			var entry, simp = O.OptionEnum.Language.ChineseSimplified, trad = O.OptionEnum.Language.ChineseTraditional;
			for (var i in D.Dictionary)
			{
				entry = (D.Dictionary[i])[simp];
				if (entry)
				{
					(D.Dictionary[i])[trad] = $.s2t(entry);
				}
			}
			for (var i in D.Codex)
			{
				entry = (D.Codex[i])[simp];
				if (entry)
				{
					(D.Codex[i])[trad] = $.s2t(entry);
				}
			}
		}
	},
	
	/*
	 * Adds new words to the dictionary from an object of the same structure.
	 * Note that the words have to be unique from the ones here.
	 * @param object pDictionary.
	 */
	addDictionary: function(pDictionary)
	{
		for (var i in pDictionary)
		{
			D.Dictionary[i] = pDictionary[i];
		}
		D.initializeDictionary();
	},
	
	/*
	 * Gets a dictionary entry translated based on the opted language.
	 * @param string pText text to translate.
	 * @returns string translated text.
	 */
	getTranslation: function(pText)
	{
		// If opted language is English then just return the given text
		if (D.isLanguageDefault)
		{
			return pText;
		}
		
		// Else look up the text in the dictionary
		var value;
		var text = pText;
		if (text.indexOf(" ") !== -1)
		{
			// Spaces become underscores
			text = text.replace(/ /g, "_");
		}
		
		var entry = D.Dictionary["s_" + text];
		if (entry)
		{
			// Get the text based on user's language
			value = entry[O.Options.enu_Language];
			if (value)
			{
				return value;
			}
		}
		// Language not found so use given instead
		return pText;
	},
	getWord: function(pText)
	{
		if (D.isLanguageDefault)
		{
			return pText;
		}
		// No error checking, assume entry exists
		return (D.Dictionary["s_" + pText])[O.Options.enu_Language];
	},
	getWordCase: function(pWord, pCase)
	{
		return U.toCase(D.getTranslation(pWord), pCase);
	},
	getWordCapital: function(pWord)
	{
		return U.toFirstUpperCase(D.getTranslation(pWord));
	},
	
	/*
	 * Translates multiple space separated words.
	 * @param string pString of words.
	 * @param enum pCase to change capitalization.
	 * @returns string translated.
	 */
	getPhrase: function(pString, pCase)
	{
		if (pCase === undefined)
		{
			pCase = U.CaseEnum.None;
		}
		
		var str = pString.split(" ");
		if (pCase === U.CaseEnum.Original)
		{
			for (var i in str)
			{
				str[i] = D.duplicateCase(str[i], D.getTranslation(str[i].toLowerCase()));
			}
		}
		else
		{
			for (var i in str)
			{
				str[i] = D.getTranslation(str[i]);
			}
		}
		
		var text = (D.isLanguageLogographic) ? str.join("") : str.join(" ");
		if (pCase === U.CaseEnum.None || pCase === U.CaseEnum.Original)
		{
			return text;
		}
		return U.toCase(text, pCase);
	},
	getPhraseTitle: function(pString)
	{
		return D.getPhrase(pString, U.CaseEnum.Every);
	},
	getPhraseOriginal: function(pString)
	{
		if (D.isLanguageDefault === false)
		{
			return D.getPhrase(pString, U.CaseEnum.Original);
		}
		return pString;
	},
	
	/*
	 * Gets a word and modifier string in language-dependent order in specified case.
	 * @param string pWord a noun for example.
	 * @param string pModifier an adjective for example.
	 * @param enum pCase to change the phrase's capitalization.
	 * @returns string modified word phrase.
	 */
	getModifiedWord: function(pWord, pModifier, pCase)
	{
		return D.getPhrase(D.orderModifier(pWord, pModifier), pCase);
	},
	orderModifier: function(pWord, pModifier)
	{
		return D.isLanguageModifierFirst ? (pModifier + " " + pWord) : (pWord + " " + pModifier);
	},
	getModifiedPhrase: function(pString, pCase)
	{
		var str = pString.split(" ");
		if (str.length === 1)
		{
			return D.getWordCase(str[0], pCase);
		}
		else if (str.length === 2)
		{
			return D.getModifiedWord(str[1], str[0], pCase); // Default language has modifier before the word
		}
		return D.getPhrase(pString, pCase);
	},
	
	/*
	 * Duplicates the case style of a source word to the translated word.
	 * @param string pSourceWord single and without whitespace.
	 * @param string pTranslatedWord to format with the same case.
	 */
	duplicateCase: function(pSourceWord, pTranslatedWord)
	{
		// If first letter is lowercase, assume the whole word is lowercase
		var firstletter = pSourceWord.charAt(0);
		if (firstletter === firstletter.toLowerCase())
		{
			return pTranslatedWord; // The dictionary is in lowercase by default, so no need to do it again
		}
		// If first two letters are capitalized, then assume all caps
		if (pSourceWord.length > 2 && pTranslatedWord.length > 2)
		{
			var secondletter = pSourceWord.charAt(1);
			if (firstletter === firstletter.toUpperCase() && secondletter === secondletter.toUpperCase())
			{
				return pTranslatedWord.toUpperCase();
			}
		}
		// For any other conditions, capitalize the first letter of the translated word
		return pTranslatedWord.charAt(0).toUpperCase() + pTranslatedWord.slice(1);
	},
	
	/*
	 * Finds element with the translation CSS class and translates them.
	 */
	translateElements: function()
	{
		if (D.isLanguageDefault === false)
		{
			// Translate each word individually for these elements
			$(".jsTranslate").each(function()
			{
				$(this).text(D.getPhraseOriginal($(this).text()))
					.removeClass("jsTranslate");
			});
			// Translate the entire text content as a compound word for these elements
			$(".jsTranslateCompound").each(function()
			{
				$(this).text(D.getTranslation($(this).text()))
					.removeClass("jsTranslateCompound");
			});
		}
	},
	
	/*
	 * Does translations for preloaded (not AJAX or generated) content, also
	 * re-initializes tooltips.
	 */
	translateAfter: function()
	{
		if (D.isLanguageDefault === false)
		{
			// Translate tooltips
			$(".hudSelect, .btnWindow").each(function()
			{
				var title = $(this).attr(I.cTooltipAttribute);
				if (title !== undefined)
				{
					var jqobj = $("<div>" + title + "</div>");
					var transtext = D.getPhraseOriginal(jqobj.find("dfn").text());
					jqobj.find("dfn").remove();
					$(this).attr("title", "<dfn>" + transtext + "</dfn>" + jqobj.html());
				}
				I.qTip.init($(this));
			});
			D.translateElements();
		}
	},
	
	/*
	 * Tells whether a substring is within a string, with provided multilingual substrings.
	 * @param string pString to search for the substring.
	 * @param object pSubstrings search strings keyed by language code. Example: {en: "day", de: "tag", ...}
	 * @returns boolean
	 */
	isWithin: function(pString, pSubstrings)
	{
		var findstr = pSubstrings[D.langPartiallySupported];
		if (pString.indexOf(findstr) !== -1)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Retrieves the name property of an object that was prefixed with a language code.
	 * Example: Object has first level properties: name_en: "Example Name", name_de: "Weise Name"
	 * @param object pObject to extract name.
	 * @returns name in user's language.
	 */
	getNameKey: function()
	{
		return "name_" + D.langFullySupported;
	},
	getURLKey: function()
	{
		return "url_" + D.langFullySupported;
	},
	getObjectTranslation: function(pObject) // No prefix, just the language code
	{
		if (pObject[O.Options.enu_Language] !== undefined)
		{
			return pObject[O.Options.enu_Language];
		}
		else if (O.Options.enu_Language === O.OptionEnum.Language.ChineseTraditional
			&& pObject[O.OptionEnum.Language.ChineseSimplified])
		{
			// Obtain Traditional Chinese from Simplified Chinese
			pObject[O.Options.enu_Language] = $.s2t(pObject[O.OptionEnum.Language.ChineseSimplified]);
			return pObject[O.Options.enu_Language];
		}
		return pObject[O.OptionEnum.Language.Default];
	},
	getObjectString: function(pObject, pPrefix)
	{
		var key = pPrefix + O.Options.enu_Language;
		if (pObject)
		{
			if (pObject[key])
			{
				return pObject[key];
			}
			else if (O.Options.enu_Language === O.OptionEnum.Language.ChineseTraditional)
			{
				// Obtain Traditional Chinese from Simplified Chinese
				var simp = pObject[pPrefix + O.OptionEnum.Language.ChineseSimplified];
				if (simp)
				{
					pObject[key] = $.s2t(simp);
					return pObject[key];
				}
			}
			return pObject[pPrefix + O.OptionEnum.Language.Default];
		}
		return null;
	},
	getObjectName: function(pObject)
	{
		return D.getObjectString(pObject, "name_");
	},
	getObjectNick: function(pObject)
	{
		return D.getObjectString(pObject, "nick_");
	},
	getObjectDesc: function(pObject)
	{
		return D.getObjectString(pObject, "desc_");
	},
	getObjectDefaultName: function(pObject)
	{
		return pObject["name_" + O.OptionEnum.Language.Default];
	},
	getObjectDefaultNick: function(pObject)
	{
		return pObject["nick_" + O.OptionEnum.Language.Default];
	},
	getObjectURL: function(pObject)
	{
		return pObject["url_" + D.langFullySupported];
	},
	
	/*
	 * Gets title of chain in opted language.
	 * @param int pIndex of chain.
	 * @returns string title.
	 */
	getChainTitle: function(pChain)
	{
		if (D.isLanguageDefault)
		{
			return pChain.title;
		}
		return D.getObjectName(pChain);
	},
	
	/*
	 * Gets short title of chain in opted language.
	 * @param int pIndex of chain.
	 * @returns string short title.
	 */
	getChainAlias: function(pChain)
	{
		if (D.isLanguageDefault)
		{
			return C.parseChainAlias(pChain.alias);
		}
		return D.getChainTitle(pChain);
	},
	
	/*
	 * Loads the client-side TTS exclusively for the overlay if haven't already.
	 * Should be called by any feature that uses TTS so the engine is ready to speak.
	 */
	verifyNativeTTS: function(pCallback)
	{
		if (I.isSpeechNativeEnabled === false
			&& I.isProgramEmbedded === false
			&& I.ModeCurrent === I.ModeEnum.Overlay
			&& I.BrowserCurrent !== I.BrowserEnum.IE)
		{
			I.isSpeechNativeEnabled = true;
			U.getScript(U.URL_API.TextToSpeechNative, function()
			{
				I.isSpeechNativeLoaded = true;
				meSpeak.loadConfig("bin/tts/mespeak_config.json");
				meSpeak.loadVoice("bin/tts/voices/" + O.Options.enu_Language + ".json");
				if (pCallback)
				{
					pCallback();
				}
			});
		}
		else if (pCallback)
		{
			pCallback();
		}
	},
	
	/*
	 * Plays an audio representation of provided string, using Chrome's TTS
	 * system if the user is running it. Otherwise loads a TTS sound file
	 * generated from a TTS web service into a hidden audio tag.
	 * @param string pString to convert to speech.
	 * @param float pDuration of the speech in seconds.
	 */
	speechWait: 0, // In milliseconds
	speak: function(pString, pDuration)
	{
		if (O.Options.bol_alertSpeech === false)
		{
			return;
		}
		
		var volume = (O.Options.int_setVolume / T.cPERCENT_100).toFixed(2);
		 /* 
		  * Chrome-only TTS service, Google Speech Synthesis API:
		  * https://developers.google.com/web/updates/2014/01/Web-apps-that-talk---Introduction-to-the-Speech-Synthesis-API?hl=en
			var msg = new SpeechSynthesisUtterance();
			var voices = window.speechSynthesis.getVoices();
			msg.voice = voices[10]; // Note: some voices don't support altering params
			msg.voiceURI = "native";
			msg.volume = 1; // 0 to 1
			msg.rate = 1; // 0.1 to 10
			msg.pitch = 2; //0 to 2
			msg.text = "Hello World";
			msg.lang = "en-US";
			speechSynthesis.speak(msg);
		 */
		try
		{
			if (I.isSpeechSynthesisEnabled)
			{
				var msg = new SpeechSynthesisUtterance(pString);
				/*
				 * Chrome bug https://code.google.com/p/chromium/issues/detail?id=582455
				 * Workaround is to manually set the voice. When the bug is fixed, can
				 * just set only the lang property and have the voice set automatically.
				 */
				//msg.lang = O.LanguageMeta.ISOCode[O.Options.enu_Language];
				msg.voice = window.speechSynthesis.getVoices().filter(function(iVoice)
				{
					return iVoice.name === O.LanguageMeta.VoiceCode[O.Options.enu_Language];
				})[0];
				msg.volume = volume;
				msg.rate = 0.8;
				window.speechSynthesis.speak(msg);
				return;
			}
		}
		catch (e)
		{
			I.isSpeechSynthesisEnabled = false;
		}
		
		// If using other TTS service then use custom queue system
		var doSpeak = function(pStringMacro)
		{
			D.verifyNativeTTS(function()
			{
				if (I.isSpeechNativeLoaded)
				{
					// API: http://www.masswerk.at/mespeak/
					meSpeak.speak(pStringMacro, {volume: volume, speed: 150, variant: "f5"});
				}
				else
				{
					// API: http://responsivevoice.org/api/
					var tts = document.getElementById("jsTTSAudio");
					tts.src = U.URL_API.TextToSpeech + "&vol=" + volume + "&t=" + pStringMacro;
					tts.volume = volume;
					tts.load();
					tts.play();
				}
			});
		};
		
		if (pDuration === undefined || pDuration === null)
		{
			// If no duration is given, then estimate speech length
			var charspersecond = (D.isLanguageLogographic) ? 4 : 12;
			pDuration = 1 + (Math.round(pString.length / charspersecond));
		}
		
		var durationms = pDuration * T.cMSECONDS_IN_SECOND;
		if (D.speechWait === 0)
		{
			// If no speech in queue then speak and add queue time, finally subtract after duration
			D.speechWait += durationms;
			doSpeak(pString);
			setTimeout(function()
			{
				D.speechWait -= durationms;
			}, durationms);
		}
		else
		{
			// If speech in queue then wait added queue time, finally speak and subtract after duration
			D.speechWait += durationms;
			setTimeout(function()
			{
				if (D.speechWait > 0)
				{
					doSpeak(pString);
					D.speechWait -= durationms;
				}
			}, D.speechWait - durationms);
		}
		
		// Prevent the speech queue to be too long, reset if it is
		var secmaxspeechduration = 30;
		D.resetSpeechQueue(secmaxspeechduration);
	},
	isSpeaking: function()
	{
		if (D.speechWait === 0)
		{
			return false;
		}
		return true;
	},
	stopSpeech: function()
	{
		if (I.isSpeechSynthesisEnabled)
		{
			window.speechSynthesis.cancel();
		}
		else if (I.isSpeechNativeLoaded)
		{
			meSpeak.stop();
		}
		else
		{
			document.getElementById("jsTTSAudio").src = "";
		}
	},
	
	/*
	 * Stops speech if the wait time is over the threshold.
	 * @param int pSeconds threshold.
	 */
	resetSpeechQueue: function(pSeconds)
	{
		if (pSeconds === undefined)
		{
			pSeconds = 0;
		}
		
		if (D.speechWait > (pSeconds * T.cMSECONDS_IN_SECOND))
		{
			D.speechWait = 0;
			D.stopSpeech();
		}
	},
	
	
	/*
	 * Gets translation for given text to be spoken.
	 * @param string pText to lookup.
	 * @param string pModifier optional adjective or adverb.
	 * @returns string translated text or given text.
	 */
	getSpeechWord: function(pText, pModifier)
	{
		if (pModifier)
		{
			return D.getModifiedWord(pText, pModifier);
		}
		return D.getPhrase(pText);
	},
		
	/*
	 * Adds spaces to a string so each letter is spoken separately.
	 * "SoS" returns "S O S" but "Mag" returns "Mag" (no change).
	 * @param string pString.
	 * @returns string of period separated initials.
	 */
	getSpeechInitials: function(pString, pWantTrim)
	{
		// If the last character of the string is lowercase, then don't do anything
		var finalchar = pString.charAt(pString.length - 1);
		if (finalchar === finalchar.toLowerCase())
		{
			return pString;
		}
		// Otherwise make initials
		if (pWantTrim)
		{
			pString = pString.replace(/ /g, "");
		}
		pString = pString.toUpperCase();
		var str = "";
		var char = "";
		for (var i = 0; i < pString.length; i++)
		{
			char = pString.charAt(i);
			str += (char === " ") ? char : (char + " ");
		}
		return str;
	},
	
	/*
	 * Gets a phrase such as " in 1 minute" or " in 15 minutes".
	 * @param int pTime amount of time units.
	 * @param string pUnit of time.
	 * @returns string phrase.
	 */
	getPluralTime: function(pTime, pUnit)
	{
		if (pTime > 1)
		{
			pUnit += "s";
		}
		return " " + D.getWord("in") + " " + pTime + " " + D.getWord(pUnit);
	},
	
	/*
	 * Gets pronunciation of chain in opted language.
	 * @param object pChain to get.
	 * @returns string pronunciation.
	 */
	getChainPronunciation: function(pChain)
	{
		if (D.isLanguageDefault
			|| I.BrowserCurrent !== I.BrowserEnum.Chrome)
		{
			return C.Chains[pChain.nexus].pronunciation;
		}
		return D.getChainTitle(pChain);
	}
};
C = {
/* =============================================================================
 * @@Chains of events
 * ========================================================================== */
	/*
	 * https://gw2timer.com/data/chains.js initially holds an array of scheduled
	 * meta event chain objects, which themselves contain an array of their events.
	 * This is referred to by the variable "C.Chains". It will be added with
	 * unscheduled chains when the user opens that section on the chains page.
	 */
	Chains: GW2T_CHAIN_DATA,
	ChainAssociation: {},
	UnscheduledChainsLength: GW2T_CHAIN_ADD_LENGTH,
	DryTop: {},
	// The word and variable "nexus" is simply a chain's index number in the Chains array
	cIndexSynonym: "nexus",
	ChainToday: null,
	ChainTomorrow: null,
	ChainDummy: {alias: "dummy"},
	CurrentChainSD: {}, NextChainSD1: {}, NextChainSD2: {}, NextChainSD3: {}, NextChainSD4: {},
	CurrentChainHC: {}, NextChainHC1: {}, NextChainHC2: {}, NextChainHC3: {}, NextChainHC4: {},
	NextChainLS1: {}, NextChainLS2: {},
	NextChainsMS1: [], NextChainsMS2: [],
	CurrentChains: [],
	CurrentChainsSD: [],
	PreviousChains1: [],
	PreviousChains2: [],
	NextChains1: [],
	cEventCharLimit: 44,
	cEventCharLimitLogographic: 20,
	cEventNameWidth: 320,
	TempleChains: [],
	LegacyChains: [],
	UnscheduledChains: [],
	ScheduledChains: [], // Any scheduled chain
	RegularChains: [], // Scheduled world bosses
	MiscellaneousChains: [],
	DryTopChains: [],
	LivingStoryChains: [],
	ChainSeriesEnum:
	{
		Temple: 0, // Unscheduled Orr temples
		Legacy: 1, // Unscheduled chains that still gives a rare
		ScheduledCutoff: 2,
		Standard: 2, // Scheduled non-hardcore chains
		Hardcore: 3, // Scheduled challenging chains with a separate schedule from non-hardcores
		Miscellaneous: 4, // Any scheduled chains not already defined here
		WorldBossCuttoff: 4,
		DryTop: 5, // Scheduled Dry Top chains
		LivingStory: 6 // Seasonal events
	},
	EventPrimacyEnum:
	{
		Optional: 0, // A failure or optional subevent; includes temple retake event which should be ignored
		Normal: 1, // A concurrent (multiple simultaneous) event that does not take the longest to complete
		Primary: 2, // An only event at the time or a concurrent event that takes the longest to complete
		Boss: 3 // The boss event, also considered a primary event
	},
	isUnscheduledChainsLoaded: false,
	isDryTopGenerated: false,
	isDryTopIconsShown: false,
	isTimetableGenerated: false,
	isTouringAuto: true, // False when the program starts touring by itself, to prevent multiple touring calls
	isTouringManual: false, // True when the user ever moves the map
	
	/*
	 * Gets a chain from its alias.
	 * @param string pAlias.
	 * @returns object chain.
	 * @pre ChainAssociation object has the requested chain.
	 */
	getChainByAlias: function(pAlias)
	{
		return C.Chains[C.ChainAssociation[pAlias.toLowerCase()]];
	},
	getChainRegion: function(pChain)
	{
		if (pChain && pChain.zone)
		{
			return M.getZoneRegion(pChain.zone);
		}
		return null;
	},
	
	/*
	 * Gets the coordinate of the final event in the chain.
	 * @param object pChain.
	 * @returns GW2 coordinates.
	 */
	viewChainFinale: function(pChain)
	{
		if (I.isMapEnabled)
		{
			M.goToView(pChain.finalCoord, M.ZoomEnum.Ground, M.Pin.Event);
			C.isTouringManual = false;
		}
	},
	
	/*
	 * Tells if specified chain is today's daily world boss.
	 * @param object pChain to compare.
	 * @returns true if daily.
	 */
	isChainToday: function(pChain)
	{
		if (C.ChainToday && pChain.nexus === C.ChainToday.nexus)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Shows or hides the daily icon for today's boss depending on availability.
	 * @pre Used variables has been reinitialized.
	 */
	refreshChainDailyIcon: function()
	{
		// Reimage the waypoint icon if boss on clock is daily
		for (var i = 0; i < T.cNUM_TIMEFRAMES_IN_HOUR; i++)
		{
			if (C.isChainToday(C.CurrentChainsSD[i]))
			{
				(K["WpChain" + i]).addClass("clkWaypointDaily");
			}
			else
			{
				(K["WpChain" + i]).removeClass("clkWaypointDaily");
			}
		}

		// Chain bar
		$(".chnDaily").hide();
		if (C.ChainToday)
		{
			$(".chnDaily_" + C.ChainToday.nexus).show();
		}
		// Restyle timetable
		C.updateTimetable();
	},
	
	/*
	 * Tells if a chain is timed by the schedule.
	 * @param object pChain to check.
	 * @returns boolean true if scheduled else false.
	 */
	isChainScheduled: function(pChain)
	{
		if (pChain.series >= C.ChainSeriesEnum.ScheduledCutoff)
		{
			return true;
		}
		return false;
	},
	isChainWorldBoss: function(pChain)
	{
		if (pChain.series <= C.ChainSeriesEnum.WorldBossCuttoff)
		{
			return true;
		}
		return false;
	},
	isChainRegular: function(pChain)
	{
		if (pChain.series === C.ChainSeriesEnum.Standard ||
			pChain.series === C.ChainSeriesEnum.Hardcore ||
			pChain.series === C.ChainSeriesEnum.Miscellaneous ||
			pChain.series === C.ChainSeriesEnum.LivingStory)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Returns the substring before the delimiter in a chain alias.
	 * Used for reusing chain icons of different chains.
	 * @param string pAlias of the chain.
	 * @returns string common alias of the chain.
	 */
	parseChainAlias: function(pAlias)
	{
		if (pAlias.indexOf("_") !== -1)
		{
			return pAlias.split("_")[0];
		}
		return pAlias;
	},
	
	/*
	 * Gets the integer part of an event number, for example: "10A2" returns "10".
	 * @param string pNumber of the event.
	 * @returns string integer of the event.
	 */
	getEventStepNumber: function(pNumber)
	{
		if (pNumber.length === 1)
		{
			return pNumber;
		}
		else
		{
			var i;
			var integer = "";
			for (i = 0; i < pNumber.length; i++)
			{
				if (isFinite(pNumber.charAt(i)))
				{
					integer += pNumber.charAt(i);
				}
				else
				{
					return integer;
				}
			}
			return integer;
		}
	},
	
	/*
	 * Gets URL to wiki of an event.
	 * @param string pName of event.
	 * @param boolean pWantDefault
	 * @returns string.
	 */
	getEventWiki: function(pName, pWantDefault)
	{
		if (pName.indexOf(".") === pName.length - 1)
		{
			pName = pName.slice(0, -1);
		}
		return (pWantDefault) ? U.getWikiLinkDefault(pName) : U.getWikiLinkLanguage(pName);
	},

	/*
	 * Initializes the chain HTML plate with chains and their individual events.
	 * Calculates time sums for chains and pushes to array for later accessing by the ticker.
	 * @param object pChain chain to initialize.
	 * @pre Event number can only go from 1-9.
	 */
	initializeChain: function(pChain)
	{
		var i, ii;
		var event;
		var chainextra = "";
		var chainextrastr = "";
		var chainname = U.escapeHTML(D.getObjectName(pChain));
		pChain.waypointText = pChain.waypoint + " " + chainname;
		pChain.iconSrc = "img/chain/" + C.parseChainAlias(pChain.alias).toLowerCase() + I.cPNG;
		
		/*
		 * Initialize step attribute (the first number in an event
		 * number, as in "2" in "2A1"), will be used to access events HTML.
		 */
		for (i in pChain.events)
		{
			// Minus 1 because the event numbers are 1 indexed
			pChain.events[i].step = parseInt(C.getEventStepNumber(pChain.events[i].num)) - 1;
		}
		pChain.isSorted = false;
		pChain.primaryEvents = [];
		pChain.scheduleKeys = [];
		
		if (pChain.waypoint)
		{
			chainextra = "<input id='chnWaypoint_" + pChain.nexus + "' class='chnWaypoint' type='text' value='"
					+ pChain.waypointText + "' title='In-game waypoint chatcode.' />"
				+ "<a" + U.convertExternalAnchor(U.getWikiSearchDefault(pChain.title)) + ">"
					+ "<ins class='s16 s16_wiki' title='Click for Wiki guide.'></ins></a> "
				+ " (" + pChain.level + ")"
					+ "<a" + U.convertExternalAnchor(U.getYouTubeLink(D.getObjectDefaultName(pChain))) + ">"
					+ "<ins class='s16 s16_youtube' title='Recommended level. Click for YouTube videos.'></ins></a> ";
		}
		if (pChain.reward)
		{
			for (i in pChain.reward)
			{
				if (i === "coin")
				{
					chainextra += E.formatCoinStringShort(pChain.reward[i]);
				}
				else
				{
					chainextra += pChain.reward[i] + "<ins class='s16 s16_" + i + "' title='" + i + "'></ins> ";
				}
			}
		}
		if (chainextra.length)
		{
			chainextrastr = "<div class='chnDetailsExtra'>"
				+ chainextra
				+ "<kbd id='chnDelete_" + pChain.nexus + "' class='chnDelete' "
					+ "title='Permanently hide this event chain (can undo in <img src=img/ui/menu/alarm.png /> menu above).'></kbd>"
			+ "</div>";
		}
		
		/*
		 * A chain bar (HTML) is a rectangle that contains the event chain icon,
		 * chain title, time, individual events listed, and other elements.
		 * Lots of CSS IDs and classes here, so update if the CSS changed.
		 */
		$(pChain.htmllist).append(
		"<div id='chnBar_" + pChain.nexus + "' class='chnBar'>"
			+ "<div class='chnTitle'>"
				+ "<img id='chnIcon_" + pChain.nexus + "' src='" + pChain.iconSrc + "' />"
				+ "<kbd id='chnCheck_" + pChain.nexus + "' class='chnCheck'></kbd>"
				+ "<h1 id='chnTitle_" + pChain.nexus + "'>" + chainname + "</h1>"
				+ "<time id='chnTime_" + pChain.nexus + "' class='chnTimeFutureFar'></time>"
				+ "<aside><img class='chnDaily chnDaily_" + pChain.nexus + "' src='img/ui/daily.png' /></aside>"
			+ "</div>"
			+ "<div id='chnDetails_" + pChain.nexus + "' class='chnDetails'>"
				+ "<ol id='chnEvents_" + pChain.nexus + "' class='chnEvents'></ol>"
				+ chainextrastr
			+ "</div>"
		+ "</div>");

		/*
		 * Inserts an event with icon and necessary indentation into the ol.
		 * @param object pChain to get chain info.
		 * @param object pEvent to extract information.
		 */
		var insertEventToBarHTML = function(pChain, pEvent)
		{
			var e = pEvent;
			var b = "&lt;br /&gt;";
			var w = function(pS)
			{
				return "&lt;dfn&gt;" + pS + "&lt;/dfn&gt;";
			};
			// Tooltip when user hovers over the tiny orange event icon
			var eventhtmltitle = "";
			if (pChain.series === C.ChainSeriesEnum.DryTop)
			{
				eventhtmltitle = w("Event Number: ") + e.num + b
					+ w("Start Time: ") + e.lim + b
					+ b + "&amp;quot;" + D.getObjectName(e).replace(/["']/g, "") + "&amp;quot;";
			}
			else
			{
				eventhtmltitle = w("Event Number: ") + e.num + b
					+ w("If Success Go To: ") + e.sGotoNum + b
					+ w("If Failure Go To: ") + e.fGotoNum + b
					+ w("If Success Wait: ") + e.sInterim + b
					+ w("If Failure Wait: ") + e.fInterim + b
					+ w("Time Limit: ") + e.lim + b
					+ w("Avg to Complete: ") + e.avg + b
					+ w("Min to Complete: ") + e.min + b
					+ w("Max to Complete: ") + e.max + b
					+ b + "&amp;quot;" + D.getObjectName(e).replace(/["']/g, "") + "&amp;quot;";
			}
			
			var classsubstep = "";
			var eventnamelimit = C.cEventCharLimit;
			var indentEvent = function()
			{
				classsubstep = "chnSubstep";
				eventnamelimit = C.cEventCharLimit - 4;
			};
			
			/*
			 * Indent concurrent events, except the first one in the step.
			 * For example: events numbered 1A1 1A2 1B1 1B2; 1A1 and 1B1 happens
			 * at the same time. For simplicity, indent all events starting with
			 * "1" except 1A1. Events numbered like 1A 1B are short for 1A1 1B1.
			 */
			// If the event number is an integer without concurrent letters
			var step = C.getEventStepNumber(e.num);
			if (step.length !== e.num.length)
			{
				var subnum = e.num.slice(step.length);
				if (e.num.indexOf(".") !== -1) // Always indent failure events
				{
					indentEvent();
				}
				else if (e.num.length === 2)
				{
					if (subnum.indexOf("A") === -1 && subnum.indexOf("a") === -1)
					{
						indentEvent();
					}
				}
				else if (subnum.indexOf("A1") === -1 && subnum.indexOf("a1") === -1)
				{
					indentEvent();
				}
			}
			$("#chnEvents_" + pChain.nexus).append(
			"<li id='chnEvent_" + pChain.nexus + "_" + e.num + "' class='chnStep_" + pChain.nexus + "_" + e.step + " " + classsubstep + "'>"
				+ "<ins class='evt_" + e.icon + "' title='" + eventhtmltitle + "'></ins>"
				+ "<span>" + U.truncateString(D.getObjectName(e), eventnamelimit, "..") + "</span>"
			+ "</li>");
		};

		/*
		 * Initialize the chain by summing its events' min/avg/max times.
		 * The primary event array holds events temporally significant to the chain.
		 * For example: the "1A destroy chaotic materials" and "1B escort Rooba"
		 * events happen at the same time so they share the same first event
		 * number (the "step" number), but "escort Rooba" is considered primary
		 * because it takes the longest. Each event gets the three new time
		 * variables equalling how far into the chain they are.
		 */
		for (i in pChain.events)
		{
			event = pChain.events[i];
			if (event.primacy === C.EventPrimacyEnum.Primary)
			{
				pChain.primaryEvents.push(event);
			}
			else if (event.primacy === C.EventPrimacyEnum.Boss)
			{
				pChain.primaryEvents.push(event);
				// 0 because the first primary event does not have precedents
				pChain.primaryEvents[0].minSum = 0;
				pChain.primaryEvents[0].avgSum = 0;
				pChain.primaryEvents[0].minavgSum = 0;
				break;
			}
		}
		for (i = 1; i < pChain.primaryEvents.length; i++)
		{
			/*
			 * iterated event's xxxSum = the previous primary event's xxx time
			 *		+ the previous primary event's success interim
			 *		+ the previous primary event's xxxSum;
			 */
			var previoussuccessinterim = T.parseEventTime(pChain.primaryEvents[i-1].sInterim[0]);

			pChain.primaryEvents[i].minSum = T.parseEventTime(pChain.primaryEvents[i-1].min)
				+ previoussuccessinterim + pChain.primaryEvents[i-1].minSum;
			pChain.primaryEvents[i].avgSum = T.parseEventTime(pChain.primaryEvents[i-1].avg)
				+ previoussuccessinterim + pChain.primaryEvents[i-1].avgSum;
			// minavgSum = minSum + (avgSum - minSum)/2;
			pChain.primaryEvents[i].minavgSum = pChain.primaryEvents[i].minSum
				+ Math.floor(Math.abs(pChain.primaryEvents[i].avgSum - pChain.primaryEvents[i].minSum) / 2);
		}
		/*
		 * min time for the entire chain to finish is the final primary event's
		 * minSum plus the final primary event's min.
		 * Note that i was post-incremented in the for loop after exiting.
		 */
		i--;
		pChain.minFinish = pChain.primaryEvents[i].minSum
			+ T.parseEventTime(pChain.primaryEvents[i].min);
		pChain.avgFinish = pChain.primaryEvents[i].avgSum
			+ T.parseEventTime(pChain.primaryEvents[i].avg);
		pChain.minavgFinish = pChain.minFinish + Math.floor(Math.abs(pChain.avgFinish - pChain.minFinish)/2);
		
		/*
		 * Now with an array of primary events created, link the non-primary
		 * events and create HTML elements so they can be displayed in totality.
		 */
		ii = 0;
		// Unscheduled events don't need queued accessing
		if ( ! C.isChainScheduled(pChain))
		{
			for (i in pChain.events)
			{
				insertEventToBarHTML(pChain, pChain.events[i]);
			}
		}
		else // Scheduled events need to remember concurrent events
		{
			for (i in pChain.events)
			{
				// Ignore failure events and optional defense events
				if (pChain.events[i].primacy !== C.EventPrimacyEnum.Optional)
				{
					// Compare the first character of their event number
					if (C.getEventStepNumber(pChain.events[i].num)
						!== C.getEventStepNumber(pChain.primaryEvents[ii].num))
					{
						ii++;
					}
					/*
					 * Each primary event has references to their concurrent
					 * events, which will later be used to highlight them.
					 */ 
					insertEventToBarHTML(pChain, pChain.events[i]);
				}
				// If reached the boss event (which has been added), then stop looping
				if (pChain.events[i].primacy === C.EventPrimacyEnum.Boss)
				{
					break;
				}
			}
		}
		
		// Toggles the chain details when clicked on the chain title
		if (I.ModeCurrent !== I.ModeEnum.Tile)
		{
			$("#chnTitle_" + pChain.nexus).click(function(pEvent)
			{
				if (pEvent.which === I.ClickEnum.Left)
				{
					$(this).parent().next().slideToggle(100, function()
					{
						I.updateScrollbar($(this));
					});
				}
			});
			$("#chnDetails_" + pChain.nexus).hide();
		}
		// Clipboard behavior
		$("#chnDetails_" + pChain.nexus + " .chnWaypoint").each(function()
		{
			I.bindClipboard($(this), $(this).val());
		}).click(function()
		{
			$(this).select();
		});
		
		// Initialize tooltips
		I.qTip.init($("#chnDetails_" + pChain.nexus + " ins"));
		I.qTip.init($("#chnDetails_" + pChain.nexus + " kbd"));
		
		// Finally intialize its checklist state
		X.initializeChainChecklist(pChain);
		
	}, // End of initializeChain()

	/*
	 * Categorizes and initializes scheduled chains, which are already in the
	 * main chains array.
	 */
	initializeScheduledChains: function()
	{
		var chain;
		var length = C.Chains.length;
		for (var i = 0; i < length; i++)
		{
			// Unschedule chains will be initialized when their headers are clicked on
			chain = C.Chains[i];
			chain.nexus = i;
			C.ChainAssociation[(chain.alias.toLowerCase())] = chain.nexus;

			switch (chain.series)
			{
				case C.ChainSeriesEnum.Standard:
				{
					chain.htmllist = "#sectionChains_Scheduled";
					C.RegularChains.push(chain);
					C.ScheduledChains.push(chain);
				} break;
				case C.ChainSeriesEnum.Hardcore:
				{
					chain.htmllist = "#sectionChains_Scheduled";
					C.RegularChains.push(chain);
					C.ScheduledChains.push(chain);
				} break;
				case C.ChainSeriesEnum.DryTop:
				{
					chain.htmllist = "#sectionChains_Drytop";
					C.DryTopChains.push(chain);
					C.ScheduledChains.push(chain);
				} break;
				case C.ChainSeriesEnum.Miscellaneous:
				{
					if (chain.flags.isSpecial)
					{
						chain.htmllist = "#sectionChains_Special";
					}
					else
					{
						chain.htmllist = "#sectionChains_Scheduled";
					}
					C.MiscellaneousChains.push(chain);
					C.RegularChains.push(chain);
					C.ScheduledChains.push(chain);
				} break;
				case C.ChainSeriesEnum.LivingStory:
				{
					if (H.isStoryEnabled)
					{
						// Show Living Story events on the chains panel if the dashboard is not visible
						if (H.isStoryDashboard)
						{
							chain.htmllist = "#dsbStory";
						}
						else
						{
							chain.htmllist = "#sectionChains_Scheduled";
						}
						C.LivingStoryChains.push(chain);
						C.RegularChains.push(chain);
						C.ScheduledChains.push(chain);
					}
					else
					{
						continue;
					}
				} break;
			}
			C.initializeChain(chain);
		}
	},
	
	/*
	 * Loads the unscheduled chains data then categorizes and initializes them.
	 */
	initializeUnscheduledChains: function()
	{
		if (C.isUnscheduledChainsLoaded === false)
		{
			U.getScript(U.URL_DATA.Unscheduled, function()
			{
				if (C.isUnscheduledChainsLoaded)
				{
					return;
				}
				
				// Add them to the main chains array
				var unscheduledchains = GW2T_CHAIN_UNSCHEDULED;
				var oldlength = C.Chains.length;
				for (var i = 0; i < unscheduledchains.length; i++)
				{
					C.Chains.push(unscheduledchains[i]);
				}
				
				// Initialize them
				var chain;
				var newlength = C.Chains.length;
				for (var i = oldlength; i < newlength; i++)
				{
					chain = C.Chains[i];
					chain.nexus = i;

					switch (chain.series)
					{
						case C.ChainSeriesEnum.Temple:
						{
							chain.htmllist = "#sectionChains_Temple";
							C.TempleChains.push(chain);
							C.UnscheduledChains.push(chain);
						} break;
						case C.ChainSeriesEnum.Legacy:
						{
							chain.htmllist = "#sectionChains_Legacy";
							C.LegacyChains.push(chain);
							C.UnscheduledChains.push(chain);
						} break;
					}
					C.initializeChain(chain);
					P.drawChainPaths(chain);
				}
				C.isUnscheduledChainsLoaded = true;
			});
		}
	},
	
	/*
	 * Tells if a chain is active on the chain bars list.
	 * @param object pChain to verify.
	 * @returns boolean current or not.
	 */
	isChainCurrent: function(pChain)
	{
		for (var i in C.CurrentChains)
		{
			if (pChain.nexus === C.CurrentChains[i].nexus)
			{
				return true;
			}
		}
		return false;
	},
	
	/*
	 * Tells if a chain check state is intact (not checked off or deleted).
	 * @param object pChain to get state.
	 * @returns boolean unchecked or not.
	 */
	isChainUnchecked: function(pChain)
	{
		if (X.getChainChecklistState(pChain) === X.ChecklistEnum.Unchecked)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Tells if a chain bar is expanded by reading the details child element.
	 * @param object pChain to get the bar.
	 * @returns boolean shown or not.
	 */
	isChainSubscribed: function(pChain)
	{
		if (X.getChecklistItem(X.Checklists.ChainSubscription, pChain.nexus) ===
			X.ChecklistEnum.Checked)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Updates the time in the chain bars for all chains.
	 * @pre scheduleKeys array is sorted and first element is the soonest.
	 */
	updateChainsTimeHTML: function()
	{
		var i;
		var ithchain;
		var countdownstr, timestr;
		var delayseconds;
		
		var subscribetext = "<dfn>" + D.getPhraseTitle("click to <br/> subscribe") + "</dfn><br />";
		
		for (i in C.ScheduledChains)
		{
			ithchain = C.ScheduledChains[i];
			// Chains that don't start at the quarters of an hour can have the displayed time adjusted
			delayseconds = (ithchain.flags.minuteDelay) ? ithchain.flags.minuteDelay * T.cSECONDS_IN_MINUTE : 0;
			// Update the title tootlip with that chain's schedule
			var minischedulestring = "";
			var spacer;
			if (ithchain.series !== C.ChainSeriesEnum.DryTop)
			{
				for (var ii in ithchain.scheduleKeys)
				{
					spacer = (parseInt(ii) === 0) ? subscribetext : " <br /> ";
					minischedulestring = minischedulestring + spacer
						+ T.getTimeFormatted(
						{
							aWantSeconds: false,
							aCustomTimeInSeconds: T.convertScheduleKeyToLocalSeconds(
								ithchain.scheduleKeys[ii]) + delayseconds
						});
				}
				$("#chnTime_" + ithchain.nexus).prop("title", minischedulestring);
			}

			// Update inactive chains' displayed time
			if (C.isChainCurrent(ithchain) === false)
			{
				var symbol = "";
				var wantneg = (ithchain.flags.minuteDelay < 0) ? true : false;
				countdownstr = T.getTimeFormatted(
				{
					aWantLetters: true,
					aWantSeconds: false,
					aWantNegative: wantneg,
					aCustomTimeInSeconds: T.getSecondsUntilChainStarts(ithchain) + delayseconds
				});
				if (wantneg && countdownstr.indexOf(I.Symbol.Negative) !== -1)
				{
					symbol = I.Symbol.StateActive + " ";
				}
				timestr = T.getTimeFormatted(
				{
					aWantLetters: false,
					aWantSeconds: false,
					aCustomTimeInSeconds: T.convertScheduleKeyToLocalSeconds(ithchain.scheduleKeys[0]) + delayseconds
				});

				$("#chnTime_" + ithchain.nexus).html(
					symbol + countdownstr + "<br />" + "<sup>" + timestr + "</sup>"
				);
			}
		}
		
		// Rebind tooltips for the time elements because they were updated
		I.qTip.init(".chnTitle time");
	},
	
	/*
	 * Updates the current chain bar's time as a countdown until the chain is
	 * predicted to finish, or until the next chain starts if finished.
	 * To be called every 1 second.
	 */
	updateCurrentChainTimeHTML: function(pChain)
	{
		var elapsed = T.getCurrentTimeframeElapsedTime();
		var remaining = pChain.countdownToFinish - elapsed;
		var delayminutes = pChain.flags.minuteDelay;
		var delayremaining;
		var elm = $("#chnTime_" + pChain.nexus);
		var time = remaining;
		var timestr;
		var signstr = I.Symbol.StateActive + " ";
		
		if (pChain.series === C.ChainSeriesEnum.DryTop && C.isDryTopGenerated)
		{
			// Dry Top events
			var currentframe = T.getDryTopMinute();
			var nextframe = T.getDryTopMinute(1);
			timestr = T.getTimeFormatted(
			{
				aReference: T.ReferenceEnum.UTC,
				aWant24: true,
				aWantHours: false
			});
			
			var zerostr = (currentframe < T.cBASE_10) ? "0" : "";
			elm.html(":" + currentframe + " (:" + zerostr + timestr + ")");
			if (C.isDryTopIconsShown)
			{
				var colorprefix0 = "<var style='color:" + T.getCurrentDryTopColor() + "'>";
				var colorprefix1 = "<var style='color:" + T.getCurrentDryTopColor(1) + "'>";
				$("#mapDryTopTimer").html(
					colorprefix0 + ":" + currentframe + " (:" + zerostr + timestr + ") </var>" + colorprefix1 + ":" + nextframe + "</var><br />"
					+ colorprefix0 + D.getWord("now") + " →</var> " + colorprefix1 + D.getWord("next") + "</var>");
			}
		}
		else
		{
			// Other scheduled chains
			if (delayminutes)
			{
				delayremaining = (delayminutes * T.cSECONDS_IN_MINUTE) - elapsed;
				if (delayremaining > 0)
				{
					time = delayremaining;
					signstr = I.Symbol.StateWaiting + " ";
				}
			}
			if (remaining <= 0)
			{
				time = T.cSECONDS_IN_TIMEFRAME - elapsed;
				signstr = I.Symbol.StateInactive + " " + I.Symbol.Negative;
			}
			timestr = T.getTimeFormatted(
			{
				aWantLetters: true,
				aCustomTimeInSeconds: time
			});
			elm.html(signstr + timestr);
		}
	},
	
	/*
	 * Creates a list similar to the schedule chains HTML list but with bare
	 * chain titles and static schedule time.
	 */
	initializeTimetableHTML: function()
	{
		if (C.isTimetableGenerated === false)
		{
			return;
		}
		
		$("#sectionChains_Timetable").empty(); // This makes the function reuseable
		var i, ii;
		var chains;
		var ithchain;
		var timestring;
		for (i in T.Schedule)
		{
			chains = T.getScheduleSlotChainsByKey(i);
			for (ii in chains)
			{
				ithchain = chains[ii];
				// Only generate chain bars for these types
				if ((ithchain.series !== C.ChainSeriesEnum.Standard
					&& ithchain.series !== C.ChainSeriesEnum.Hardcore
					&& ithchain.series !== C.ChainSeriesEnum.Miscellaneous)
					|| ithchain.flags.isSpecial)
				{
					break;
				}
				
				timestring = T.getTimeFormatted(
				{
					aWantSeconds: false,
					aCustomTimeInSeconds: T.convertScheduleKeyToLocalSeconds(i)
				});

				$("#sectionChains_Timetable").append(
				"<div class='chnSlot chnSlotTime_" + i + " chnSlot_" + ithchain.nexus + "' data-" + C.cIndexSynonym + "='" + ithchain.nexus + "' data-timeframe='" + i + "'>"
					+ "<div class='chnTitle'>"
						+ "<img src='" + ithchain.iconSrc + "' />"
						+ "<kbd class='chnCheck'></kbd>"
						+ "<h1>" + D.getObjectName(ithchain) + "</h1>"
						+ "<time>" + timestring + "</time>"
						+ "<aside><img class='chnDaily chnDaily_" + ithchain.nexus + "' src='img/ui/daily.png' /></aside>"
					+ "</div>"
				+ "</div>");
			}
		}
		// Set slot visual state as stored in checklist
		for (var i in C.RegularChains)
		{
			ithchain = C.RegularChains[i];
			var slots = $(".chnSlot_" + ithchain.nexus);
			var checks = slots.find(".chnCheck");
			var times = slots.find("time");
			X.reapplyChainBarState(ithchain.nexus, slots, checks, times);
		}
		// Hover on chain slot highlight same bosses
		$(".chnTitle h1").hover(
			function() { $(".chnSlot_" + $(this).parent().parent().data(C.cIndexSynonym)).addClass("chnBarHover"); },
			function() { $(".chnSlot").removeClass("chnBarHover"); }
		);
		// Mimic check off function
		$(".chnSlot .chnCheck").click(function()
		{
			$("#chnCheck_" + C.Chains[$(this).parent().parent().data(C.cIndexSynonym)].nexus).trigger("click");
		});
		// Mimic subscription function
		$(".chnSlot time").click(function()
		{
			$("#chnTime_" + C.Chains[$(this).parent().parent().data(C.cIndexSynonym)].nexus).trigger("click");
		});
		// Special color of the reset time slot
		$(".chnSlotTime_0").addClass("chnBarReset");
		C.refreshChainDailyIcon();
	},
	
	/*
	 * Puts the past chains behind the current chain slots.
	 */
	updateTimetable: function()
	{
		if (C.isTimetableGenerated === false)
		{
			return;
		}
		
		var previousframe = T.getTimeframeKey(-1);
		var currentframe = T.getTimeframeKey();
		var nextframe = T.getTimeframeKey(1);
		// Also highlight timetable chain bar
		$(".chnSlotTime_" + previousframe)
			.removeClass("chnBarCurrent");
		$(".chnSlotTime_" + currentframe)
			.addClass("chnBarCurrent");
		// Current chain title
		$(".chnSlotTime_" + previousframe + " .chnTitle h1")
			.removeClass("chnTitleCurrent");
		$(".chnSlotTime_" + currentframe + " .chnTitle h1")
			.removeClass("chnTitleFuture").addClass("chnTitleCurrent");
		// Future chain title
		$(".chnSlotTime_" + nextframe + " .chnTitle h1")
			.addClass("chnTitleFuture");
		
		// Move the past time slots to the bottom, so the current slot(s) is always the top
		var currenttimeframe = T.getCurrentTimeframe();
		$(".chnSlot").each(function()
		{
			if (T.convertScheduleKeyToUTCMinutes($(this).data("timeframe")) < currenttimeframe)
			{
				$(this).appendTo("#sectionChains_Timetable");
			}
			else
			{
				// Break out of this each loop since the arranging is done
				return false;
			}
		});
		
		// Hide daily world boss beyond today's reset
		if (C.ChainToday)
		{
			$("#sectionChains_Timetable .chnDaily_" + C.ChainToday.nexus).each(function()
			{
				if (T.convertScheduleKeyToUTCMinutes($(this).closest(".chnSlot").data("timeframe")) < currenttimeframe)
				{
					$(this).hide();
				}
			});
		}
	},

	/*
	 * Sorts the scheduled chains list in the chains plate. This is
	 * called by the ticker every timeframe.
	 */
	sortChainsListHTML: function()
	{
		var numchainssorted = 0;
		var numchainstosort = C.ScheduledChains.length;
		var i = 0;
		var ii = 0;
		var chains;
		var ithchain;
		var workcounter = 0;
		var workmax = 999;
		/*
		 * Look at the schedule and start with the current active chain; move
		 * that chain's HTML to the bottom of the HTML chains list, then look at
		 * the next (and so on), if it is not already sorted then also move it
		 * to the bottom. This loop stops when all scheduled events have been
		 * sorted as soonest at the top and latest at the bottom.
		 * Note that there will be timeframe gaps in the list because only the
		 * soonest chain will be sorted and later repeats of the chain are ignored.
		 */
		while (numchainssorted < numchainstosort)
		{
			workcounter++;
			if (workcounter > workmax)
			{
				I.urge("Chains sort overflow. Check chains file for order and timing logic.");
				break;
			}
			chains = T.getTimeframeChains(i);
			for (ii in chains)
			{
				if (numchainssorted >= numchainstosort)
				{
					break;
				}
				
				ithchain = chains[ii];
				if (ithchain.isSorted === false)
				{
					$("#chnBar_" + ithchain.nexus).appendTo(ithchain.htmllist);
					
					ithchain.isSorted = true;
					ithchain.scheduleKeyImmediate = T.getTimeframeKey(i);
					numchainssorted++;
				}
			}
			i++;
		}
		
		for (i in C.ScheduledChains)
		{
			ithchain = C.ScheduledChains[i];
			// Reset the sorted boolean (important, else infinite loop)
			ithchain.isSorted = false;
			
			/*
			 * scheduleKeys is an array of keys to the schedule for when that
			 * chain starts. Circularly shift the array so that the soonest
			 * index is first--by concatenating the two slices of the array
			 * using that found index.
			 */
			for (ii in ithchain.scheduleKeys)
			{
				if (ithchain.scheduleKeys[ii] === ithchain.scheduleKeyImmediate)
				{
					ithchain.scheduleKeys = 
						(ithchain.scheduleKeys.slice(ii, ithchain.scheduleKeys.length))
							.concat(ithchain.scheduleKeys.slice(0, ii));
					break;
				}
			}
		}
		// Update chain time HTML
		C.updateChainsTimeHTML();
		
		/*
		 * Now that the chains are sorted, do cosmetic updates.
		 */
		var currentchainids = {};
		for (i in C.CurrentChains)
		{
			ithchain = C.CurrentChains[i];
			currentchainids[ithchain.nexus] = ithchain.nexus;
			// Highlight
			$("#chnBar_" + ithchain.nexus).addClass("chnBarCurrent");
			// Show the events (details)
			if (C.isChainUnchecked(ithchain))
			{
				if (O.Options.bol_expandWB && (I.ModeCurrent !== I.ModeEnum.Tile))
				{
					$("#chnDetails_" + ithchain.nexus).show("fast", function()
					{
						I.updateScrollbar();
					});
				}
			}
			
			// Style the title and time
			$("#chnBar_" + ithchain.nexus + " h1").first()
				.removeClass("chnTitleFuture chnTitleFutureFar").addClass("chnTitleCurrent");
			$("#chnBar_" + ithchain.nexus + " time").first()
				.removeClass("chnTimeFuture chnTimeFutureFar").addClass("chnTimeCurrent");
		}

		for (i in C.PreviousChains1)
		{
			ithchain = C.PreviousChains1[i];
			if (currentchainids[ithchain.nexus] === ithchain.nexus)
			{
				continue;
			}
			// Still highlight the previous chain bar but collapse it
			$("#chnBar_" + ithchain.nexus)
				.removeClass("chnBarCurrent").addClass("chnBarPrevious");
			// Hide previous chains if opted to automatically expand before
			if (O.Options.bol_collapseChains && (I.ModeCurrent !== I.ModeEnum.Tile))
			{
				$("#chnDetails_" + ithchain.nexus).hide();
			}
			
			// Style the title and time
			$("#chnBar_" + ithchain.nexus + " h1").first()
				.removeClass("chnTitleCurrent").addClass("chnTitleFutureFar");
			$("#chnBar_" + ithchain.nexus + " time").first()
				.removeClass("chnTimeCurrent").addClass("chnTimeFutureFar");
		}
		
		for (i in C.PreviousChains2)
		{
			ithchain = C.PreviousChains2[i];
			if (currentchainids[ithchain.nexus] === ithchain.nexus)
			{
				continue;
			}
			// Stop highlighting the previous previous chain bar
			$("#chnBar_" + ithchain.nexus).removeClass("chnBarPrevious");
		}
		
		for (i in C.NextChains1)
		{
			ithchain = C.NextChains1[i];
			if (currentchainids[ithchain.nexus] === ithchain.nexus)
			{
				continue;
			}
			// Style the title and time
			$("#chnBar_" + ithchain.nexus + " h1").first()
				.removeClass("chnTitleFutureFar").addClass("chnTitleFuture");
			$("#chnBar_" + ithchain.nexus + " time").first()
				.removeClass("chnTimeFutureFar").addClass("chnTimeFuture");
		}
	},
	
	/*
	 * minSum avgSum and minavgSum are the seconds since a chain began that
	 * an event of it starts. Because the time a chain starts is known, these
	 * statistical times can be used to predict when events happen and end.
	 * @param object pChainOuter to queue.
	 * @pre The sum statistics have been computed. Chains list has been sorted.
	 */
	queueEventsHighlight: function(pChainOuter)
	{
		var i;
		var chain = pChainOuter;
		var elapsed = T.getCurrentTimeframeElapsedTime();
		var wait;
		var hasfoundcurrentprimaryindex = false;
		
		/*
		 * If the user just loaded in instead of transitioning at a timeframe.
		 */
		if (elapsed > 0)
		{
			// Find the current active event and highlight it
			for (i in chain.primaryEvents)
			{
				/*
				 * For an event to be active, its start time (xxxSum) should be 
				 * <= the elapsed time, and the next event's start time
				 * should be > the elapsed time.
				 */
				wait = C.getSumBasedOnOptions(chain, i);
				if (wait >= elapsed)
				{
					if (i > 0) // Disregard the first event in the chain
					{
						C.highlightEvents(chain, parseInt(i-1));
						hasfoundcurrentprimaryindex = true;
						break;
					}
				}
			}
			/*
			 * Finished scanning the array but couldn't find active event in it,
			 * now compare with the final event's finish time.
			 */
			if (hasfoundcurrentprimaryindex === false)
			{
				wait = C.getSumBasedOnOptions(chain, -1);
				if (wait >= elapsed)
				{
					C.highlightEvents(chain, i); // Final event in progress
				}
				else
				{
					C.highlightEvents(chain, -1); // Final event finished
				}
			}
		}
		
		/*
		 * Queue the highlighting of events using setTimeout. Events that had
		 * already happened (elapsed time is greater than their start time)
		 * are ignored, and the future events are offsetted by the elapsed.
		 */
		for (i in chain.primaryEvents)
		{
			wait = C.getSumBasedOnOptions(chain, i);
			if (wait >= elapsed)
			{
				wait = wait - elapsed;
				setTimeout((function(iChain, iPrimaryEventIndex)
				{
					// Have to use this clunky nesting else the timeout gets the last iterator
					return function()
					{
						C.highlightEvents(iChain, iPrimaryEventIndex);
					};
				})(chain, parseInt(i)), wait * T.cMSECONDS_IN_SECOND);
			}
		}
		
		// Queued all the events' start, now queue when the chain finishes
		wait = C.getSumBasedOnOptions(chain, -1);
		if (wait >= elapsed)
		{
			wait = wait - elapsed;
			setTimeout((function(iChain)
			{
				return function()
				{
					C.highlightEvents(iChain, -1);
				};
			})(chain), wait * T.cMSECONDS_IN_SECOND);
		}
	},
	
	/*
	 * Does cosmestic effects to event names as they transition and view the
	 * event on the map. Also shows/hides Dry Top event icons.
	 * Also plays the alarm if it is the final event finishing.
	 * @param object pChain to read from.
	 * @param int pPrimaryEventIndex of the current active event.
	 * @pre Events HTML is generated and map is loaded.
	 */
	highlightEvents: function(pChain, pPrimaryEventIndex)
	{
		var i;
		var animationspeed = 500;
		var eventnamewidth = C.cEventNameWidth;
		var finalstep = pChain.primaryEvents.length - 1;
		var event;
		var isregularchain = C.isChainRegular(pChain);
		
		// Hide past events' markers
		if (pChain.series === C.ChainSeriesEnum.DryTop && C.isDryTopGenerated)
		{
			P.LayerArray.DryTopActive = null;
			P.LayerArray.DryTopActive = [];
			if (C.isDryTopIconsShown)
			{
				for (i in pChain.events)
				{
					event = pChain.events[i];
					M.toggleLayer(event.eventicon, false);
					M.toggleLayer(event.eventring, false);
				}
			}
		}
		
		// Do event highlights, -1 means the final event's finish time
		if (pPrimaryEventIndex > -1)
		{
			pChain.CurrentPrimaryEvent = pChain.primaryEvents[pPrimaryEventIndex];
			
			// Recolor past events
			for (i = 0; i < pPrimaryEventIndex; i++)
			{
				$(".chnStep_" + pChain.nexus + "_" + i)
					.removeClass("chnEventCurrent");
			}
			$(".chnStep_" + pChain.nexus + "_" + (pPrimaryEventIndex - 1))
				.css({opacity: 1}).animate({opacity: 0.5}, animationspeed,
				function()
				{
					if (pChain.series === C.ChainSeriesEnum.DryTop)
					{
						// Also hide the past events after fading if it is Dry Top events
						$(this).hide();
					}
				});
			
			// Recolor current events and animate transition
			$(".chnStep_" + pChain.nexus + "_" + pPrimaryEventIndex).each(function()
			{
				$(this).removeClass("chnEventFuture").addClass("chnEventCurrent").show()
					.css({width: 0, opacity: 0.5}).animate({width: eventnamewidth, opacity: 1}, animationspeed)
					.css({width: "auto"});
				// Also show current events' markers
				if (pChain.series === C.ChainSeriesEnum.DryTop && C.isDryTopGenerated)
				{
					event = pChain.events[$(this).attr("data-eventindex")];
					if (I.isMapEnabled)
					{
						// Add active events to iterable array
						P.LayerArray.DryTopActive.push(event.eventicon);
						P.LayerArray.DryTopActive.push(event.eventring);
						// Show active Dry Top events
						if (C.isDryTopIconsShown)
						{
							M.toggleLayerArray(P.LayerArray.DryTopActive, true);
						}
						P.rebindMarkerTooltips();
					}
				}
			});
		
			// Recolor future events
			if (pPrimaryEventIndex < pChain.primaryEvents.length)
			{
				for (i = (pPrimaryEventIndex + 1); i < pChain.primaryEvents.length; i++)
				{
					$(".chnStep_" + pChain.nexus + "_" + i).show()
						.removeClass("chnEventCurrent").addClass("chnEventFuture");
				}
			}
			
			// Tour to the event on the map if opted
			if (P.wantTourPrediction() && M.isMapAJAXDone
				&& C.isChainUnchecked(pChain) && isregularchain && !pChain.flags.isSpecial)
			{
				if (C.isTouringAuto && C.isTouringManual === false)
				{
					C.isTouringAuto = false;
					$("#chnEvent_" + pChain.nexus + "_" + pChain.CurrentPrimaryEvent.num).trigger("click");
					// Prevent simultaneous touring, which would waste bandwidth from downloading unseen map tiles
					setTimeout(function()
					{
						C.isTouringAuto = true;
					}, 1000);
				}
			}
			
			// If the final event is just starting, alert if opted
			if (pPrimaryEventIndex === finalstep && O.Options.bol_alertArrival && isregularchain)
			{
				if ((O.Options.int_setAlarm === O.IntEnum.Alarm.Checklist
						&& C.isChainUnchecked(pChain) && !pChain.flags.isSpecial)
					|| (O.Options.int_setAlarm === O.IntEnum.Alarm.Subscription
						&& C.isChainSubscribed(pChain) && C.isChainUnchecked(pChain)))
				{
					var arrivalstr = D.getPhraseOriginal("Arrival predicted");
					D.speak(D.getChainPronunciation(pChain) + " " + arrivalstr);
					I.notify({
						aTitle: D.getObjectName(pChain),
						aBody: arrivalstr,
						aIcon: pChain.iconSrc
					});
				}
			}
		}
		else // Finish time
		{
			pChain.CurrentPrimaryEvent = pChain.primaryEvents[finalstep];
			
			// Recolor all events
			$("#chnEvents_" + pChain.nexus + " li").show()
				.removeClass("chnEventCurrent");
			// Recolor current (final) events as past
			$(".chnStep_" + pChain.nexus + "_" + finalstep)
				.css({opacity: 1}).animate({opacity: 0.5}, animationspeed);
			
			/*
			 * Announce the next world boss and the time until it, only if it's
			 * not past the timeframe, and the subscription option is off.
			 */
			if (O.Options.int_setAlarm === O.IntEnum.Alarm.Checklist
				&& O.Options.bol_alertAtEnd && I.isProgramLoaded
				&& pChain.nexus === C.CurrentChainSD.nexus
				&& isregularchain)
			{
				var checked = ", " + D.getSpeechWord("checked");
				var checkedsd = "";
				var checkedhc = "";
				var wantsd = U.objToBool(C.NextChainSD1);
				var wanthc = U.objToBool(C.NextChainHC1);
				var speech = D.getSpeechWord("next " + D.orderModifier("boss", "world") + " is") + " ";
				var timephrase = "";
				
				if (C.NextChainSD1 && ( ! C.isChainUnchecked(C.NextChainSD1)))
				{
					checkedsd = checked;
				}
				if (C.NextChainHC1 && ( ! C.isChainUnchecked(C.NextChainHC1)))
				{
					checkedhc = checked;
				}
				// Don't alert if next boss is checked off and user opted not to hear
				if (O.Options.bol_alertChecked === false)
				{
					if (checkedsd.length > 0) { wantsd = false; }
					if (checkedhc.length > 0) { wanthc = false; }
				}
				
				// Voice
				if (wantsd && wanthc)
				{
					D.speak(speech + D.getChainPronunciation(C.NextChainSD1) + checkedsd, 5);
					D.speak(D.getSpeechWord("also") + ", " + D.getChainPronunciation(C.NextChainHC1) + checkedhc, 3);
				}
				else if (wantsd)
				{
					D.speak(speech + D.getChainPronunciation(C.NextChainSD1) + checkedsd, 5);
				}
				else if (wanthc)
				{
					D.speak(speech + D.getChainPronunciation(C.NextChainHC1) + checkedhc, 5);
				}
				
				if (wantsd || wanthc)
				{
					timephrase = T.getTimeTillChainFormatted(C.NextChainSD1, "speech");
					D.speak(timephrase, 3);
				}
				// Popup
				if (wantsd)
				{
					I.notify({
						aTitle: D.getObjectName(C.NextChainSD1),
						aBody: timephrase,
						aIcon: C.NextChainSD1.iconSrc
					});
				}
				if (wanthc)
				{
					I.notify({
						aTitle: D.getObjectName(C.NextChainHC1),
						aBody: timephrase,
						aIcon: C.NextChainHC1.iconSrc
					});
				}
			}
			
			// Also unsubscribe from world boss chains if opted
			if (O.Options.int_setAlarm === O.IntEnum.Alarm.Subscription && O.Options.bol_alertUnsubscribe && I.isProgramLoaded
				&& C.isChainWorldBoss(pChain) && C.isChainSubscribed(pChain))
			{
				$("#chnTime_" + pChain.nexus).trigger("click");
			}
		}
	},
	
	/*
	 * Gets the time an event start or a chain finishes based on user option.
	 * @param object pChain to read from.
	 * @param int pIndex of a primary event. -1 if want finish.
	 * @returns int sum statistics for that event/step.
	 */
	getSumBasedOnOptions: function(pChain, pIndex)
	{
		// Daily chain will always use min time because more players will do these
		if (C.isChainToday(pChain))
		{
			if (pIndex > -1)
			{
				return pChain.primaryEvents[pIndex].minSum;
			}
			else
			{
				pChain.countdownToFinish = pChain.minFinish;
				return pChain.minFinish;
			}
		}
		
		// Else for non daily chains use chosen statistical time
		var hour = T.getTimeSinceMidnight(T.ReferenceEnum.Local, T.UnitEnum.Hours);
		
		if (pIndex > -1)
		{
			switch (O.Options.int_setPredictor)
			{
				case O.IntEnum.Predictor.Auto:
				{
					if (hour >= 12 && hour < 18)
					{
						return pChain.primaryEvents[pIndex].minSum;
					}
					if (hour >= 18)
					{
						return pChain.primaryEvents[pIndex].minavgSum;
					}
					if (hour >= 0 && hour < 6)
					{
						return pChain.primaryEvents[pIndex].avgSum;
					}
					if (hour >= 6 && hour < 12)
					{
						return pChain.primaryEvents[pIndex].minavgSum;
					}
				} break;
				case O.IntEnum.Predictor.Min:
				{
					return pChain.primaryEvents[pIndex].minSum;
				} break;
				case O.IntEnum.Predictor.MinAvg:
				{
					return pChain.primaryEvents[pIndex].minavgSum;
				} break;
				case O.IntEnum.Predictor.Avg:
				{
					return pChain.primaryEvents[pIndex].avgSum;
				} break;
			}
			// Failsafe
			return pChain.primaryEvents[pIndex].minavgSum;
		}
		else
		{
			switch (O.Options.int_setPredictor)
			{
				case O.IntEnum.Predictor.Auto:
				{
					if (hour >= 12 && hour < 18)
					{
						pChain.countdownToFinish = pChain.minFinish;
						return pChain.minFinish;
					}
					if (hour >= 18)
					{
						pChain.countdownToFinish = pChain.minavgFinish;
						return pChain.minavgFinish;
					}
					if (hour >= 0 && hour < 6)
					{
						pChain.countdownToFinish = pChain.avgFinish;
						return pChain.avgFinish;
					}
					if (hour >= 6 && hour < 12)
					{
						pChain.countdownToFinish = pChain.minavgFinish;
						return pChain.minavgFinish;
					}
				} break;
				case O.IntEnum.Predictor.Min:
				{
					pChain.countdownToFinish = pChain.minFinish;
					return pChain.minFinish;
				} break;
				case O.IntEnum.Predictor.MinAvg:
				{
					pChain.countdownToFinish = pChain.minavgFinish;
					return pChain.minavgFinish;
				} break;
				case O.IntEnum.Predictor.Avg:
				{
					pChain.countdownToFinish = pChain.avgFinish;
					return pChain.avgFinish;
				} break;
			}
			// Failsafe
			pChain.countdownToFinish = pChain.minavgFinish;
			return pChain.minavgFinish;
		}
	}
};
M = {
/* =============================================================================
 * @@Map and map control template object
 * ========================================================================== */

	/*
	 * https://gw2timer.com/data/general.js contains zone (e.g. Queensdale, LA)
	 * objects with their rectangular coordinates.
	 * This is referred to by the variable "Zones".
	 * Each zone will be assigned with LayerGroup of world completion markers,
	 * they can be accessed by the format: zonevariable.Layers.LandmarkType
	 * where LandmarkType may be Waypoint, Vista, or others.
	 */
	MapEnum: "map", // Type of map this map is
	OptionSuffix: "", // Tyria map has unsuffixed option variable names
	Continent: GW2T_CONTINENT_DATA["map"],
	Zones: GW2T_ZONE_DATA,
	ZoneAssociation: GW2T_ZONE_ASSOCIATION, // This contains API zone IDs that associates with regular world zones
	Subzones: {},
	Regions: GW2T_REGION_DATA,
	Submaps: GW2T_SUBMAP_DATA,
	Compasses: GW2T_COMPASS_DATA,
	cInitialZone: "lion",
	Map: {},
	FloorCurrent: {},
	ZoneCurrent: {},
	numPins: 0,
	numPinsSlots: 32,
	numCompassesSlots: 32,
	cICON_SIZE_STANDARD: 32,
	cRING_SIZE_MAX: 256,
	isMapInitialized: false,
	isTouchEnabled: false,
	isMouseOnHUD: false,
	isMenuOnHUD: false,
	isUserDragging: false,
	isZoneLocked: false,
	isFloorShown: true,
	isMapAJAXDone: false,
	isAPIRetrieved_MAPFLOOR: false,
	isItineraryRetrieved: false,
	isMappingIconsGenerated: false,
	isEventIconsGenerated: false,
	ContextLatLng: null, // Coordinates to store when user right clicks on the map
	cMAP_MOUSEMOVE_RATE: 100,
	cInertiaThreshold: 100, // Milliseconds between drag and release to flick pan
	cZoomFactor: 2,
	ZoomEnum:
	{
		Adaptive: -2,
		Same: -1,
		Min: 0,
		Overview: 3,
		Default: 3,
		Space: 3,
		Sky: 5,
		Bird: 6,
		Ground: 7,
		Max: 7
	},
	cZIndexRaise: 999999,
	cZIndexBury: -999999,
	
	// MumbleLink data assigned by overlay program
	GPSPreviousZoneID: "",
	GPSPreviousCoord: [],
	GPSPreviousAngleCharacter: 0,
	GPSPreviousAngleCamera: 0,
	GPSisInstance: false,
	
	/*
	 * All objects in the map are called "markers". Some markers are grouped into iterable "layers".
	 * Markers in layers are destroyed and recreated into the map using the toggleLayer function.
	 * This is to reduce CPU usage when these markers are not displayed.
	 * To iterate layers: LAYER.eachLayer(function(MARKER) { MARKER.dostuff });
	 * To assign marker properties: MARKER.options.PROPERTY
	 */
	Layer: {
		Overview: new L.layerGroup(), // Stats of zone's number of world completion icons
		Pin: new L.layerGroup(), // Utility pin markers, looks like GW2 personal waypoints
		PersonalPin: new L.layerGroup(),
		PersonalPath: new L.layerGroup(), // Path drawn from connecting player-laid pins
		CompassIcon: new L.layerGroup(), // A compass icon with its radius circle
		CompassCircle: new L.layerGroup()
	},
	Pin: {
		Program: {},
		Event: {},
		Over: {},
		Character: {},
		Camera: {}
	},
	MappingEnum:
	{
		Sector: 0,
		Waypoint: 1,
		Landmark: 2,
		Vista: 3,
		Challenge: 4,
		Heart: 5,
		EventIcon: 6,
		EventCircle: 7,
		EventLabel: 8
	},
	APIPOIEnum:
	{
		Sector: "sectors",
		Waypoint: "waypoint",
		Landmark: "landmark",
		Vista: "vista",
		Challenge: "skill_challenges",
		Heart: "tasks"
	},
	
	/*
	 * Initializes the Leaflet map, adds markers, and binds events.
	 */
	initializeMap: function()
	{
		var that = this;
		var htmlidprefix = "#" + this.MapEnum;
		var initialzoom = O.Options["int_setInitialZoom" + P.MapSwitchSuffix];
		
		// ?.Map is the actual Leaflet map object, initialize it
		this.Map = L.map(this.MapEnum + "Pane", {
			minZoom: this.ZoomEnum.Min,
			maxZoom: this.ZoomEnum.Max,
			inertiaThreshold: this.cInertiaThreshold,
			doubleClickZoom: false,
			touchZoom: false, // Disable pinch to zoom
			zoomControl: false, // Hide the zoom UI
			attributionControl: false, // Hide the Leaflet link UI
			crs: L.CRS.Simple
		}).setView(this.Continent.CenterInitial, initialzoom); // Out of map boundary so browser doesn't download tiles yet
		this.initializeTouch();
		
		// Initialize LayerGroup in zones to later hold world completion and dynamic event icons
		var zone;
		for (var i in this.Zones)
		{
			zone = this.Zones[i];
			zone.center = this.computeZoneCenter(zone);
			zone.nick = i;
			zone.Layers = {
				Path: new L.layerGroup(),
				Waypoint: new L.layerGroup(),
				Landmark: new L.layerGroup(),
				Vista: new L.layerGroup(),
				Mastery: new L.layerGroup(),
				Challenge: new L.layerGroup(),
				Heart: new L.layerGroup(),
				Sector: new L.layerGroup(),
				HeartArea: new L.layerGroup(),
				SectorArea: new L.layerGroup(),
				EventIcon: new L.layerGroup(),
				EventCircle: new L.layerGroup(),
				EventArea: new L.layerGroup(),
				EventLabel: new L.layerGroup()
			};
			if (that.MapEnum === P.MapEnum.Tyria)
			{
				P.LayerArray.ChainPath.push(zone.Layers.Path);
			}
		}
		this.ZoneCurrent = this.Zones[this.cInitialZone];
		
		// Do other initialization functions
		switch (this.MapEnum)
		{
			case P.MapEnum.Tyria: {
				this.createStandardPins();
				P.populateMap(M);
				P.drawZoneBorders();
				P.drawZoneGateways();
				C.ScheduledChains.forEach(P.drawChainPaths);
				H.getUrgent(H.Announcement.UrgentPVE);
			} break;
			
			case P.MapEnum.Mists: {
				this.createStandardPins();
				P.populateMap(W);
				H.getUrgent(H.Announcement.UrgentWVW);
			} break;
		}
		
		// Bind map click functions devices
		this.bindMapClicks();
		
		/*
		 * Go to the coordinates in the bar when user presses enter.
		 */
		$(htmlidprefix + "CoordinatesCopy").onEnterKey(function()
		{
			var val = $(this).val();
			Z.interpretCommand(val, that, that.ZoomEnum.Ground, that.Pin.Program);
		});
		
		/*
		 * Bind map HUD buttons functions.
		 */
		$(htmlidprefix + "GPSButton").click(function()
		{
			// Go to character if cliked on GPS button
			P.updateCharacter(1);
		}).dblclick(function()
		{
			if (that.Map.getZoom() !== that.ZoomEnum.Ground)
			{
				that.Map.setZoom(that.ZoomEnum.Ground);
			}
			else
			{
				that.Map.setZoom(that.ZoomEnum.Default);
			}
		});
		// Translate and bind map zones list
		$(htmlidprefix + "ZoneButton").one("mouseenter", that.bindZoneList(that))
		.dblclick(function()
		{
			that.goToDefault();
		}).contextmenu(function(pEvent)
		{
			pEvent.preventDefault();
			that.Map.setZoom(that.Map.getZoom() - 1); // Zoom out one level
		});
		
		// Finally
		this.isMapInitialized = true;
	},
	
	/*
	 * Create pin markers that can be moved by user or program.
	 */
	createStandardPins: function()
	{
		if ( ! I.isMapEnabled)
		{
			return;
		}
		var that = this;
		this.Pin.Program = this.createPin("img/map/pin_blue.png");
		this.Pin.Event = this.createPin("img/map/pin_green.png");
		this.Pin.Over = this.createPin("img/map/pin_over.png", [128,128]);
		this.Pin.Character = this.createPin("img/map/pin_character.png", [40,40]);
		this.Pin.Camera = this.createPin("img/map/pin_camera.png", [256,256], {clickable: false});
		
		// Bind pin click event to get coordinates in the coordinates bar
		this.Layer.Pin.eachLayer(function(iMarker)
		{
			that.bindMarkerCoordBehavior(iMarker, "click");
			that.bindMarkerZoomBehavior(iMarker, "contextmenu");
			iMarker.on("dblclick", function()
			{
				that.movePin(this);
			});
		});
		// Double clicking on the character pin hides it
		this.Pin.Character.on("dblclick", function()
		{
			that.movePin(this);
			that.movePin(that.Pin.Camera);
		});
		// Hide the pins, they will be shown when they are moved
		this.toggleLayer(this.Layer.Pin, false);
	},
	
	/*
	 * Initializes touch features and disable some features if the user actually
	 * touches the screen.
	 */
	initializeTouch: function()
	{
		var that = this;
		if (I.ModeCurrent === I.ModeEnum.Overlay || O.Options.bol_ignoreTouch || (that.isTouchEnabled && I.isTouchEnabled))
		{
			return;
		}
		if ("ontouchstart" in window)
		{
			that.isTouchEnabled = true;
			I.isTouchEnabled = true;
			
			// Because the map will interfere with scrolling the website on touch devices
			if (that.Map.touchZoom)
			{
				that.Map.touchZoom.disable();
			}
			if (that.Map.tap)
			{
				that.Map.tap.disable();
			}
			
			// Create map zoom menu with big buttons
			var htmlidprefix = "#" + that.MapEnum;
			var menu = $("<div class='tchMenu'></div>").prependTo(htmlidprefix + "Pane");
			I.preventMapPropagation(menu);
			$("<kbd class='tchTogglePanel tchButton'></kbd>").appendTo(menu).click(function()
			{
				$("#opt_bol_showPanel").trigger("click");
			});
			$("<kbd class='tchZoomIn tchButton'></kbd>").appendTo(menu).click(function()
			{
				that.Map.zoomIn();
			});
			$("<kbd class='tchZoomOut tchButton'></kbd>").appendTo(menu).click(function()
			{
				that.Map.zoomOut();
			});

			menu.css({top: "calc(50% - " + menu.height() + "px)"});
		};
	},
	
	/*
	 * Bind mouse button functions for the map. Also binds the map custom context menu.
	 * @param enum pMapEnum.
	 */
	bindMapClicks: function()
	{
		var that = this;
		var htmlidprefix = "#" + that.MapEnum;
		
		/*
		 * Emulate the click behavior of OS window menus to the HUD buttons.
		 */
		var peripheral = $(htmlidprefix + "Peripheral");
		var peripheralselects = peripheral.find(".hudSelect");
		var peripheralitems = peripheral.find(".hudItem");
		var hudpericlass = "hudPeripheralActive";
		var huditemclass = "hudItemActive";
		peripheralselects.click(function()
		{
			peripheralitems.removeClass(huditemclass);
			if (that.isMenuOnHUD)
			{
				peripheral.removeClass(hudpericlass);
			}
			else
			{
				peripheral.addClass(hudpericlass);
				$(this).parent().addClass(huditemclass);
			}
			that.isMenuOnHUD = !that.isMenuOnHUD;
		}).mouseenter(function()
		{
			if (that.isMenuOnHUD)
			{
				peripheralitems.removeClass(huditemclass);
				$(this).parent().addClass(huditemclass);
			}
		});
		peripheral.mouseleave(function()
		{
			peripheral.removeClass(hudpericlass);
			if (that.isMenuOnHUD)
			{
				peripheralitems.removeClass(huditemclass);
				that.isMenuOnHUD = false;
			}
		});
		
		/*
		 * Shows or hides coordinates bar.
		 */
		I.preventMapPropagation(htmlidprefix + "CoordinatesBar");
		this.toggleCoordinatesBar(); // Apply initial appearance
		$(htmlidprefix + "CoordinatesToggle").click(function()
		{
			$("#opt_bol_showCoordinatesBar").trigger("click");
		});
		
		/*
		 * Clicking an empty place on the map highlight its coordinate.
		 */
		this.Map.on("click", function(pEvent)
		{
			if (that.isMouseOnHUD || that.isTouchEnabled) { return; }
			var coord = that.convertLCtoGC(pEvent.latlng);
			that.outputCoordinatesCopy(P.formatCoord(coord));
		});

		/*
		 * Create a personal pin marker to where the user double clicks.
		 */
		this.Map.on("dblclick", function(pEvent)
		{
			if (that.isMouseOnHUD) { return; }
			that.saveBackupPins();
			that.createPersonalPin(pEvent.latlng, true);
		});

		/*
		 * Right clicking the map shows a custom context menu.
		 */
		this.Map.on("contextmenu", function(pEvent)
		{
			that.ContextLatLng = pEvent.latlng;
			I.showContextMenu(htmlidprefix + "Context");
		});
		
		/*
		 * Bind context menu functions.
		 */
		$(htmlidprefix + "Context").click(function()
		{
			$(this).hide();
		});
		$(htmlidprefix + "ContextCenter").click(function()
		{
			that.goToDefault();
		});
		$(htmlidprefix + "ContextToggleHUD").click(function()
		{
			$("#opt_bol_showHUD" + that.OptionSuffix).trigger("click");
		});
		$(htmlidprefix + "ContextCompass").one("mouseenter", function()
		{
			U.getScript(U.URL_DATA.Resource, function()
			{
				that.initializeCompassPlacer(that);
			});
		});
		$(htmlidprefix + "ContextPins").one("mouseenter", function()
		{
			that.initializePinsPlacer(that);
		});
		$(htmlidprefix + "ContextToggleFloor").click(function()
		{
			that.toggleFloor();
		});
		$(htmlidprefix + "ContextToggleLock").click(function()
		{
			that.toggleZoneLock();
		});
		$(htmlidprefix + "ContextToggleCompletion").click(function()
		{
			$("#opt_bol_showWorldCompletion" + that.OptionSuffix).trigger("click");
		});
		
		// Map exclusive functions
		switch (that.MapEnum)
		{
			case P.MapEnum.Tyria:
			{
				$(htmlidprefix + "ContextDrawCompletion").click(function()
				{
					P.drawCompletionRoute();
				});
				$(htmlidprefix + "ContextDrawResource").click(function()
				{
					G.drawResourceRoute();
				});
			} break;
			case P.MapEnum.Mists:
			{
				
			} break;
		}
	},
	
	/*
	 * Toggles both the Tyria and Mists map's coordinates bars.
	 */
	toggleCoordinatesBar: function()
	{
		var bool = O.Options.bol_showCoordinatesBar;
		$(".mapCoordinatesBar input").toggle(bool);
		if (I.ModeCurrent === I.ModeEnum.Overlay)
		{
			$(".mapTime").toggle(bool);
		}
	},
	
	/*
	 * Sets the value provided to the coordinates bar.
	 * @param string pText to output.
	 */
	outputCoordinatesCopy: function(pText)
	{
		var htmlidprefix = "#" + this.MapEnum;
		$(htmlidprefix + "CoordinatesCopy").val(pText).select();
	},
	outputCoordinatesName: function(pText)
	{
		var htmlidprefix = "#" + this.MapEnum;
		$(htmlidprefix + "CoordinatesName").val(pText);
	},
	
	/*
	 * Bindings for map events that need to be done after AJAX has loaded the
	 * API-generated markers.
	 */
	bindMapVisualChanges: function()
	{
		var that = this;
		var htmlidprefix = "#" + that.MapEnum;
		/*
		 * Booleans to stop some map functions from activating.
		 */
		$(htmlidprefix + "HUDPane").hover(
			function() { that.isMouseOnHUD = true; },
			function() { that.isMouseOnHUD = false; }
		);
		$(htmlidprefix + "Context").hover(
			function() { that.isMouseOnHUD = true; },
			function() { that.isMouseOnHUD = false; }
		);
		this.Map.on("dragstart", function()
		{
			that.isUserDragging = true;
			C.isTouringManual = true;
		});
		this.Map.on("dragend", function()
		{
			that.isUserDragging = false;
		});
		
		/*
		 * Bind the mousemove event to update the map coordinate bar.
		 * Note that the throttle function is from a separate script. It permits
		 * the event handler to only run once every so specified milliseconds.
		 */
		this.Map.on("mousemove", $.throttle(that.cMAP_MOUSEMOVE_RATE, function(pEvent)
		{
			if (that.isMouseOnHUD || that.isUserDragging) { return; }
			that.showCurrentZone(that.convertLCtoGC(pEvent.latlng));
		}));

		/*
		 * At the end of a zoom animation, resize the map icons depending on
		 * zoom level. Hide if zoomed too far.
		 */
		this.Map.on("zoomend", function(pEvent)
		{
			that.adjustZoomMapping();
			if (that.MapEnum === P.MapEnum.Tyria)
			{
				P.adjustZoomDryTop();
			}
		});
	},
	
	/*
	 * Changes the floor tile layer.
	 * @param int pFloor number.
	 * If "true" or undefined then will reset to default floor, if "false" then will hide the map tiles.
	 */
	changeFloor: function(pFloor)
	{
		this.Map.removeLayer(this.FloorCurrent);
		if (pFloor === undefined || pFloor === true)
		{
			pFloor = O.Options["int_setFloor" + this.OptionSuffix];
		}
		if (pFloor !== false)
		{
			this.FloorCurrent = L.tileLayer("https://tiles.guildwars2.com/" + this.Continent.id + "/" + pFloor + "/{z}/{x}/{y}.jpg",
			{
				continuousWorld: true
			});
			this.FloorCurrent.addTo(this.Map);
		}
	},
	
	/*
	 * Shows or hides the map tiles and map background.
	 */
	toggleFloor: function(pBoolean)
	{
		var that = this;
		var htmlidprefix = "#" + that.MapEnum;
		var mappane = $(htmlidprefix + "Pane");
		that.isFloorShown = (pBoolean === undefined) ? !that.isFloorShown : pBoolean;
		
		mappane.toggleClass("mapPaneOff", !that.isFloorShown);
		if (that.isFloorShown)
		{
			that.changeFloor();
		}
		else if (I.ModeCurrent === I.ModeEnum.Overlay)
		{
			that.changeFloor(false);
		}
	},
	
	/*
	 * Prevents the zone change function, which shows zone specific icons, from triggering.
	 */
	toggleZoneLock: function()
	{
		this.isZoneLocked = !this.isZoneLocked;
		if (this.isZoneLocked)
		{
			I.write("Map locked to zone: " + D.getObjectName(this.ZoneCurrent));
		}
		else
		{
			I.write("Map zoning unlocked.");
		}
	},
	
	/*
	 * Informs Leaflet that the map pane was resized so it can load tiles properly.
	 */
	refreshMap: function()
	{
		if (this.isMapInitialized)
		{
			this.Map.invalidateSize();
			this.refreshView();
		}
	},
	
	/*
	 * Tells if the specified zone exists within the listing.
	 * @param string pZoneID to look up.
	 * @returns true if exists.
	 */
	isZoneValid: function(pZoneID)
	{
		if (this.ZoneAssociation[pZoneID] === undefined)
		{
			return false;
		}
		return true;
	},
	isSubzoneValid: function(pZoneID)
	{
		if (this.Subzones[pZoneID] === undefined || this.Subzones[pZoneID].map_rect === undefined)
		{
			return false;
		}
		return true;
	},
	
	/*
	 * Gets a GW2T zone object from an API zone ID.
	 * @param string pZoneID to look up.
	 * @returns object zone.
	 */
	getZoneFromID: function(pZoneID)
	{
		var zonenick = this.ZoneAssociation[pZoneID];
		if (zonenick)
		{
			return this.Zones[zonenick];
		}
		return null;
	},
	getZoneFromString: function(pString)
	{
		// Returns zone if string contains a zone's nick
		var nick = pString.toLowerCase();
		for (var i in this.Zones)
		{
			if (nick.indexOf(i) !== -1)
			{
				return this.Zones[i];
			}
		}
		return null;
	},
	
	/*
	 * Gets a zone's translated name if available.
	 * @param string pNick name of the zone to retrieve, or a zone object itself.
	 * @returns string zone name.
	 */
	getZoneName: function(pNick)
	{
		// If pNick is an alias of a zone
		var zone;
		if (typeof pNick === "string" && this.Zones[pNick])
		{
			zone = this.Zones[pNick];
		}
		// If pNick is a zone that has the property
		else if (typeof pNick === "object")
		{
			zone = pNick;
		}
		else
		{
			return "nozonename";
		}
		
		// Now get the name
		return D.getObjectName(zone);
	},
	getZoneNick: function(pZone)
	{
		return this.ZoneAssociation[pZone.id];
	},
	
	/*
	 * Gets the region nick of a zone.
	 * @param string pNick of the zone.
	 * @returns string region nick.
	 */
	getZoneRegion: function(pNick)
	{
		var zone = this.Zones[(pNick.toLowerCase())];
		if (zone)
		{
			return zone.region;
		}
		return null;
	},
	
	/*
	 * Tells if the provided coordinates is within the provided zone.
	 * @param object pZone for getting bounds.
	 * @param 2D array pCoord GW2 coordinates.
	 * @returns boolean
	 */
	isWithinZone: function(pZone, pCoord)
	{
		var rect = pZone.continent_rect;
		if (pCoord[0] >= rect[0][0]
			&& pCoord[1] >= rect[0][1]
			&& pCoord[0] <= rect[1][0]
			&& pCoord[1] <= rect[1][1])
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Gets the zone a coordinates reside in.
	 * @param array pCoord.
	 * @returns object zone if found else null.
	 */
	getZoneFromCoord: function(pCoord)
	{
		for (var i in this.Zones) // i is the index and nickname of the zone
		{
			if (this.isWithinZone(this.Zones[i], pCoord))
			{
				return this.Zones[i];
			}
		}
		return null;
	},
	
	/*
	 * Finds what zone the specified point is in by comparing it to the top left
	 * and bottom right coordinates of the zones, then show the zone's visuals.
	 * @param array pCoord containing x and y coordinates.
	 * @pre Zone perimeters do not intersect.
	 */
	showCurrentZone: function(pCoord)
	{
		var that = this;
		var htmlidprefix = that.MapEnum;
		
		document.getElementById(htmlidprefix + "CoordinatesMouse")
			.value = pCoord[0] + ", " + pCoord[1];
	
		// Don't continue if mouse is still in the same zone
		if (pCoord[0] >= this.ZoneCurrent.continent_rect[0][0] // x1
			&& pCoord[1] >= this.ZoneCurrent.continent_rect[0][1] // y1
			&& pCoord[0] <= this.ZoneCurrent.continent_rect[1][0] // x2
			&& pCoord[1] <= this.ZoneCurrent.continent_rect[1][1] // y2
			|| this.isZoneLocked === true)
		{
			return;
		}
		
		// Else search for new moused zone
		var zonename = "";
		var previouszone;
		var testzone = this.getZoneFromCoord(pCoord); // Search for the zone
		
		if (testzone !== null)
		{
			// Hide the icons of the previously moused zone
			previouszone = this.Zones[this.ZoneCurrent.nick];
			for (var i in previouszone.Layers)
			{
				this.Map.removeLayer(previouszone.Layers[i]);
			}
			// Update current zone object
			this.ZoneCurrent = testzone;
			zonename = this.getZoneName(this.ZoneCurrent);
			document.getElementById(htmlidprefix + "CoordinatesName").value = zonename;

			// Reveal moused zone's icons
			switch (that.MapEnum)
			{
				case P.MapEnum.Tyria:
				{
					if (P.isChainPathsAllowed()) { this.ZoneCurrent.Layers.Path.addTo(this.Map); }
					if (O.Options.bol_displayWaypoints) { this.ZoneCurrent.Layers.Waypoint.addTo(this.Map); }
					if (O.Options.bol_displayPOIs) { this.ZoneCurrent.Layers.Landmark.addTo(this.Map); }
					if (O.Options.bol_displayVistas) { this.ZoneCurrent.Layers.Vista.addTo(this.Map); }
					if (O.Options.bol_displayMasteries) { this.ZoneCurrent.Layers.Mastery.addTo(this.Map); }
					if (O.Options.bol_displayChallenges) { this.ZoneCurrent.Layers.Challenge.addTo(this.Map); }
					if (O.Options.bol_displayHearts) { this.ZoneCurrent.Layers.Heart.addTo(this.Map); }
					if (O.Options.bol_displaySectors) { this.ZoneCurrent.Layers.Sector.addTo(this.Map); }
					if (O.Options.bol_displayHeartsArea) { this.ZoneCurrent.Layers.HeartArea.addTo(this.Map); }
					if (O.Options.bol_displaySectorsArea) { this.ZoneCurrent.Layers.SectorArea.addTo(this.Map); }
					if (O.Options.bol_displayEvents) {
						this.ZoneCurrent.Layers.EventIcon.addTo(this.Map);
						this.ZoneCurrent.Layers.EventCircle.addTo(this.Map);
						this.ZoneCurrent.Layers.EventArea.addTo(this.Map);
						this.ZoneCurrent.Layers.EventLabel.addTo(this.Map);
					}
				} break;
				case P.MapEnum.Mists:
				{
					if (O.Options.bol_displayWaypointsWvW) { this.ZoneCurrent.Layers.Waypoint.addTo(this.Map); }
					if (O.Options.bol_displayPOIsWvW) { this.ZoneCurrent.Layers.Landmark.addTo(this.Map); }
					if (O.Options.bol_displayVistasWvW) { this.ZoneCurrent.Layers.Vista.addTo(this.Map); }
					if (O.Options.bol_displayChallengesWvW) { this.ZoneCurrent.Layers.Challenge.addTo(this.Map); }
					if (O.Options.bol_displaySectorsWvW) { this.ZoneCurrent.Layers.Sector.addTo(this.Map); }
					if (O.Options.bol_displaySectorsAreaWvW) { this.ZoneCurrent.Layers.SectorArea.addTo(this.Map); }
				} break;
			}

			// Re-tooltip
			P.rebindMarkerTooltips();
			// Rescale current moused mapping markers
			this.adjustZoomMapping();
			
			// Temporary submaps for new zones if needed
			/*if (testzone.id === "1178" && P.TempSubmap.iscreated !== true)
			{
				P.TempSubmap.iscreated = true;
				this.createSubmap(P.TempSubmap, true);
			}*/
		}
	},
	
	/*
	 * Simulates the action of moving the mouse outside the current zone to
	 * another and back again, so as to trigger the icon adjustment functions.
	 */
	refreshCurrentZone: function()
	{
		var currentcoord = this.ZoneCurrent.center;
		switch (this.MapEnum)
		{
			case P.MapEnum.Tyria:
			{
				// These specimen zone are chosen because they are the top of the array
				this.showCurrentZone(this.getZoneCenter("verdant"));
				this.showCurrentZone(this.getZoneCenter("auric"));
			} break;
			case P.MapEnum.Mists:
			{
				this.showCurrentZone(this.getZoneCenter("edge"));
				this.showCurrentZone(this.getZoneCenter("eternal"));
			} break;
		}
		this.showCurrentZone(currentcoord);
	},
	
	/*
	 * Gets the center coordinates of a zone.
	 * @param object pZone
	 * @returns array of x and y coordinates.
	 */
	computeZoneCenter: function(pZone)
	{
		var rect = pZone.continent_rect;
		// x = OffsetX + (WidthOfZone/2), y = OffsetY + (HeightOfZone/2)
		var x = rect[0][0] + Math.floor((rect[1][0] - rect[0][0]) / 2);
		var y = rect[0][1] + Math.floor((rect[1][1] - rect[0][1]) / 2);
		return [x, y];
	},
	getZoneCenter: function(pNick)
	{
		if (this.Zones[pNick])
		{
			return this.Zones[pNick].center;
		}
		return [0,0];
	},
	
	/*
	 * Gets the center coordinates of an event.
	 * @param object pEvent an event from event_details.json
	 * @returns array of x and y coordinates.
	 * @pre map_floor.json was extracted to the this.Zones object.
	 */
	getEventCenter: function(pEvent)
	{
		var zone = this.getZoneFromID(pEvent.map_id);
		var p = pEvent.location.center; // 2D float array

		return this.convertEventCoord(p, zone);
	},
	
	/*
	 * Gets the dimension (of say a marker) adjusted to the specified zoom level.
	 * For example, a submap must be resized so that it is the same scale as
	 * the map's tileset. It is known that every zoom down doubles the size of
	 * the map, and vice versa. The formula below is:
	 * maxdimension / (2 ^ (maxzoomlevel - currentzoomlevel))
	 * Each zoom down increases the dimension toward the maxdimension, so when
	 * it's at maxzoomlevel, the returned dimension equals maxdimension.
	 * @param int pMaxDimension to rescale.
	 * @param int or enum pZoomLevel for adjustment.
	 */
	scaleDimension: function(pMaxDimension, pZoomLevel)
	{
		pZoomLevel = pZoomLevel || this.Map.getZoom();
		return parseInt(pMaxDimension / (Math.pow(this.cZoomFactor, (this.ZoomEnum.Max) - pZoomLevel)));
	},
	
	/*
	 * Converts a zoom level where 0 is ground level to proper level.
	 * @param int zoom level inverted.
	 * @returns int zoom level proper.
	 */
	invertZoomLevel: function(pZoomLevel)
	{
		return this.ZoomEnum.Max - pZoomLevel;
	},
	
	/*
	 * Resizes mapping markers so they scale with the current zoom level.
	 */
	adjustZoomMapping: function()
	{
		var that = this;
		var currentzoom = this.Map.getZoom();
		var zoomindex = this.invertZoomLevel(currentzoom);
		
		var ZoomValues = {
			// The first index is the max zoom-in level
			waypoint: [40, 32, 26, 20, 16, 12, 0, 0],
			landmark: [32, 24, 16, 12, 0, 0, 0, 0],
			eventicon: [32, 24, 16, 12, 0, 0, 0, 0],
			eventlabelfont: [14, 0, 0, 0, 0, 0, 0, 0],
			sectorfont: [28, 20, 16, 0, 0, 0, 0, 0],
			sectoropacity: [0.9, 0.6, 0.3, 0, 0, 0, 0, 0],
			objicon: [38, 38, 38, 38, 32, 24, 16, 0],
			objtimerfont: [18, 17, 16, 15, 14, 13, 12, 0],
			objinfofont: [14, 13, 12, 11, 10, 9, 0, 0],
			objumbrella: [96, 96, 96, 96, 64, 32, 24, 0],
			spawnfont: [28, 24, 20, 16, 12, 8, 0, 0],
			spawnopacity: [0.9, 0.9, 0.8, 0.7, 0.6, 0.5, 0, 0],
			wallweight: [10, 8, 6, 4, 2, 0, 0, 0]
		};
		var getZoomValue = function(pKey)
		{
			return (ZoomValues[pKey])[zoomindex];
		};
		var waypointsize = getZoomValue("waypoint");
		var landmarksize = getZoomValue("landmark");
		var eventiconsize = getZoomValue("eventicon");
		var eventlabelfont = getZoomValue("eventlabelfont");
		var sectorfont = getZoomValue("sectorfont");
		var sectoropacity = getZoomValue("sectoropacity");
		var objiconsize = getZoomValue("objicon");
		var objtimerfont = getZoomValue("objtimerfont");
		var objinfofont = getZoomValue("objinfofont");
		var objumbrella = getZoomValue("objumbrella");
		var spawnfont = getZoomValue("spawnfont");
		var spawnopacity = getZoomValue("spawnopacity");
		var wallweight = getZoomValue("wallweight");
		
		var completionboolean;
		var overviewboolean;
		var sectorboolean;
		
		switch (this.MapEnum)
		{
			case P.MapEnum.Tyria:
			{
				if (O.Options.bol_displayEvents)
				{
					// Event Icon
					this.ZoneCurrent.Layers.EventIcon.eachLayer(function(iLayer)
					{
						that.resizeMarkerIcon(iLayer, eventiconsize);
						if (iLayer._icon)
						{
							iLayer._icon.style.zIndex = M.cZIndexRaise;
						}
					});
					
					// Event Circle
					this.ZoneCurrent.Layers.EventCircle.eachLayer(function(iLayer)
					{
						iLayer.setRadius(that.getZoomedDistance(iLayer.options.trueradius));
					});
					
					// Event Label
					this.ZoneCurrent.Layers.EventLabel.eachLayer(function(iLayer)
					{
						if (iLayer._icon)
						{
							iLayer._icon.style.fontSize = eventlabelfont + "px";
							iLayer._icon.style.zIndex = that.cZIndexBury + 1; // Don't cover other icons
							iLayer._icon.style.display = "table"; // For middle vertical alignment
						}
					});
				}
				overviewboolean = O.Options.bol_showZoneOverview;
				completionboolean = O.Options.bol_showWorldCompletion;
				sectorboolean = O.Options.bol_displaySectors;
			} break;
			case P.MapEnum.Mists:
			{
				// Objective
				$(".objIcon").css({width: objiconsize, height: objiconsize});
				$(".objProgressBar").css({width: objiconsize});
				$(".objTimer").css({fontSize: objtimerfont});
				$(".objInfo").css({fontSize: objinfofont});
				$(".objUmbrella").css({width: objumbrella, height: objumbrella});
				// World Completion
				overviewboolean = O.Options.bol_showZoneOverviewWvW;
				completionboolean = O.Options.bol_showWorldCompletionWvW;
				sectorboolean = O.Options.bol_displaySectorsWvW;
				// Server spawn area labels
				this.Layer.SpawnLabel.eachLayer(function(iLayer)
				{
					iLayer._icon.style.fontSize = spawnfont + "px";
					iLayer._icon.style.opacity = spawnopacity;
					iLayer._icon.style.zIndex = that.cZIndexBury + 1;
					iLayer._icon.style.display = "table";
				});
				// Secondary objectives
				this.Layer.Secondaries.eachLayer(function(iLayer)
				{
					that.resizeMarkerIcon(iLayer, landmarksize);
				});
				// Destructible walls and gates paths
				this.Layer.Destructible.eachLayer(function(iLayer)
				{
					iLayer.setStyle({weight: wallweight});
				});
			} break;
		}
		
		// Adjust compass circles
		this.Layer.CompassCircle.eachLayer(function(iLayer)
		{
			iLayer.setRadius(that.getZoomedDistance(iLayer.options.trueradius));
		});
		
		// Overview on the zones
		if (completionboolean && overviewboolean)
		{
			if (currentzoom === this.ZoomEnum.Overview)
			{
				this.toggleLayer(this.Layer.Overview, true);
				this.Layer.Overview.eachLayer(function(iLayer)
				{
					iLayer._icon.style.display = "table";
				});
			}
			else
			{
				this.toggleLayer(this.Layer.Overview, false);
			}
		}
		else
		{
			this.toggleLayer(this.Layer.Overview, false);
		}

		// Waypoints
		this.ZoneCurrent.Layers.Waypoint.eachLayer(function(iLayer)
		{
			that.resizeMarkerIcon(iLayer, waypointsize);
		});
		
		// Landmarks
		this.ZoneCurrent.Layers.Landmark.eachLayer(function(iLayer)
		{
			that.resizeMarkerIcon(iLayer, landmarksize);
			if (iLayer._icon)
			{
				iLayer._icon.style.opacity = (currentzoom < that.ZoomEnum.Max) ? 0.6 : 0.8;
			}
		});
		
		// Vista
		this.ZoneCurrent.Layers.Vista.eachLayer(function(iLayer)
		{
			that.resizeMarkerIcon(iLayer, landmarksize);
		});
		
		// Mastery
		this.ZoneCurrent.Layers.Mastery.eachLayer(function(iLayer)
		{
			that.resizeMarkerIcon(iLayer, landmarksize);
		});
		
		// Challenge
		this.ZoneCurrent.Layers.Challenge.eachLayer(function(iLayer)
		{
			that.resizeMarkerIcon(iLayer, landmarksize);
		});
		
		// Heart
		this.ZoneCurrent.Layers.Heart.eachLayer(function(iLayer)
		{
			that.resizeMarkerIcon(iLayer, landmarksize);
		});
		
		// Sector
		this.ZoneCurrent.Layers.Sector.eachLayer(function(iLayer)
		{
			if (iLayer._icon)
			{
				iLayer._icon.style.fontSize = sectorfont + "px";
				iLayer._icon.style.opacity = sectoropacity;
				iLayer._icon.style.zIndex = that.cZIndexBury + 1; // Don't cover other icons
				if (sectorboolean)
				{
					iLayer._icon.style.display = "table"; // For middle vertical alignment
				}
			}
		});
		
		// Character pin and camera FOV
		P.updateCharacter(-1);
	},
	
	/*
	 * Calculates a new distance from an inherent distance based on current map zoom level.
	 */
	getZoomedDistance: function(pDistance)
	{
		return pDistance / Math.pow(2, this.ZoomEnum.Max - this.Map.getZoom());
	},
	
	/*
	 * Returns a common sized Leafet icon.
	 * @param string pIconURL of the icon image.
	 * @returns object Leaflet icon.
	 */
	createStandardIcon: function(pIconURL)
	{
		return L.icon({
			iconUrl: pIconURL,
			iconSize: [32, 32],
			iconAnchor: [16, 16]
		});
	},
	
	/*
	 * Creates a pin in the map to be assigned to a reference object.
	 * @param string pIconURL image of the marker.
	 * @param 2D array pDimension width and height of pin.
	 * @param object pOptions additional marker options.
	 * @returns object Leaflet marker.
	 */
	createPin: function(pIconURL, pDimension, pOptions)
	{
		if (pDimension === undefined)
		{
			pDimension = [32, 32];
		}
		// Default pin options
		var options = {
			icon: L.icon(
			{
				iconUrl: pIconURL,
				iconSize: pDimension,
				iconAnchor: [(pDimension[0])/2, (pDimension[1])/2]
			}),
			draggable: true
		};
		// If additional options was provided then override the default
		if (pOptions !== undefined)
		{
			for (var i in pOptions)
			{
				options[i] = pOptions[i];
			}
		}
		var marker = L.marker(this.convertGCtoLC([0,0]), options);
		this.Layer.Pin.addLayer(marker);
		return marker;
	},
	
	/*
	 * Generates a save/load list in the map context menu.
	 * @param string pName of the list.
	 * @param int pNumSlots to generate.
	 * @param object pMapObject
	 * @param function pSaveFunction
	 * @param function pLoadFunction
	 */
	initializeContextSlots: function(pName, pNumSlots, pMapObject, pSaveFunction, pLoadFunction)
	{
		var that = pMapObject;
		var htmlidprefix = "#" + that.MapEnum;
		var wordload = D.getWordCapital("load");
		var wordsave = D.getWordCapital("save");
		var wordslot = D.getWordCapital("slot");
		var listload = $(htmlidprefix + "ContextLoad" + pName);
		var listsave = $(htmlidprefix + "ContextSave" + pName);
		var htmlsuffix;
		for (var i = 0; i < pNumSlots; i++)
		{
			htmlsuffix = " " + wordslot + ": <input class='cssInputText mapContextSlot' type='text' value='" + "#" + (i+1) + "' /></li>";
			listload.append("<li data-index='" + i + "' class='mapContextLine'>" + wordload + htmlsuffix);
			listsave.append("<li data-index='" + i + "' class='mapContextLine'>" + wordsave + htmlsuffix);
		}
		X.initializeTextlist(X.Textlists["Slot" + pName + that.OptionSuffix], listload.find(".mapContextSlot"), null, 64);
		X.initializeTextlist(X.Textlists["Slot" + pName + that.OptionSuffix], listsave.find(".mapContextSlot"), null, 64);
		$([listload, listsave]).each(function()
		{
			$(this).find(".mapContextSlot").click(function(pEvent)
			{
				pEvent.stopPropagation();
				$(this).select();
			});
		});
		// Bind behavior for the created list items
		$(htmlidprefix + "ContextSave" + pName + " li").click(function()
		{
			// Click list item to save
			pSaveFunction($(this).attr("data-index"));
		}).find(".mapContextSlot").onEnterKey(function()
		{
			// Pressing Enter on the list item's name input box triggers the save
			$(this).parent().trigger("click");
		});
		$(htmlidprefix + "ContextLoad" + pName + " li").click(function()
		{
			pLoadFunction($(this).attr("data-index"));
		}).find(".mapContextSlot").onEnterKey(function()
		{
			$(this).parent().trigger("click");
		});;
		// Create server bar
		I.createFilterBar($("<div class='mapContextSearch'></div>").prependTo(listload), listload.find(".mapContextSlot"), ".mapContextLine");
		I.createFilterBar($("<div class='mapContextSearch'></div>").prependTo(listsave), listsave.find(".mapContextSlot"), ".mapContextLine");
		I.bindScrollbar(listload);
		I.bindScrollbar(listsave);
	},
	
	/*
	 * Initializes the personal pin storage system.
	 */
	initializePinStorage: function(pMapObject)
	{
		var that = pMapObject;
		var initializeStoredPins = function(pQuantity)
		{
			var obj = O.Utilities["StoredPins" + that.OptionSuffix];
			// First make a new array with desired length
			obj.value = new Array(pQuantity);
			var key = obj.key;
			// Try to overwrite it with the stored arrays, if this fails then the value property is unchanged (a blank array)
			try
			{
				obj.value = JSON.parse(localStorage[key]);
			}
			catch (e) {}
		};
		var saveStoredPins = function(pIndex)
		{
			var obj = O.Utilities["StoredPins" + that.OptionSuffix];
			var coords = that.getPersonalCoords();
			if (coords.length > 0)
			{
				obj.value[pIndex] = coords;
				localStorage[obj.key] = JSON.stringify(obj.value);
				I.write(coords.length + " pins saved.");
			}
			else
			{
				that.isPersonalPinsLaid(true);
			}
		};
		var loadStoredPins = function(pIndex)
		{
			var obj = O.Utilities["StoredPins" + that.OptionSuffix];
			that.redrawPersonalPath(obj.value[pIndex]);
		};
		
		// Generate the load/save items when user opens the Pins context menu for the first time
		var numslots = that.numPinsSlots;
		initializeStoredPins(numslots);
		that.initializeContextSlots("Pins", numslots, that, saveStoredPins, loadStoredPins);
	},
	
	/*
	 * Saves the current personal pins as backup. This is to be called before the
	 * user manually adds and inserts a pin.
	 */
	saveBackupPins: function()
	{
		var obj = O.Utilities["BackupPins" + this.OptionSuffix];
		localStorage[obj.key] = JSON.stringify(this.getPersonalCoords());
	},
	loadBackupPins: function()
	{
		var obj = O.Utilities["BackupPins" + this.OptionSuffix];
		try
		{
			obj.value = JSON.parse(localStorage[obj.key]);
		}
		catch (e) {}
		this.redrawPersonalPath(obj.value, null);
	},
	
	/*
	 * Prints help message for using pins.
	 */
	printPinHelp: function()
	{
		var str = "<h2>Path Pins Interactions</h2>"
			+ "<ul>"
			+ "<li><b>Create a pin:</b> double click an empty area on the map (multiple pins creates a path).</li>"
			+ "<li><b>Insert a pin between a path:</b> double click a part of the path.</li>"
			+ "<li><b>Delete a pin:</b> double click that pin.</li>"
			+ "<li><b>Delete all pins:</b> choose Clear from the Path context menu.</li>"
			+ "<li><b>Move a pin:</b> hold click and drag that pin.</li>"
			+ "<li><b>Move a pin to center:</b> right click that pin.</li>"
			+ "<li><b>Zoom to a pin:</b> right click that pin when not in max zoom.</li>"
			+ "</ul>"
			+ "<br />"
			+ "<h2>Path Pins Features</h2>"
			+ "<ul>"
			+ "<li><b>Check off a pin:</b> single click that pin.</li>"
			+ "<li><b>Get coordinates of a pin:</b> single click that pin.</li>"
			+ "<li><b>Get coordinates of a path:</b> single click on the path.</li>"
			+ "<li><b>Generate a path:</b> paste the path coordinates into the coordinates bar and press Enter.</li>"
			+ "<li><b>Optimize a path:</b> middle click that pin, it will become the starting pin.</li>"
			+ "<li><b>Save/Load pins:</b> the save slots can be named, which can be filtered by the search bar.</li>"
			+ "</ul>";
		I.help(str);
	},
	printCompassHelp: function()
	{
		var str = "<h2>Compass Pins Interactions</h2>"
			+ "<ul>"
			+ "<li><b>Create a pin:</b> select an icon from the context menu gallery.</li>"
			+ "<li><b>Create a custom pin:</b> checkmark the checkbox by the custom input boxes then enter your own range, color, and comment.</li>"
			+ "<li><b>Delete a pin:</b> double click that pin.</li>"
			+ "<li><b>Delete all pins:</b> choose Clear from the Compass context menu.</li>"
			+ "<li><b>Move a pin:</b> hold click and drag that pin.</li>"
			+ "<li><b>Move a pin to center:</b> right click that pin.</li>"
			+ "<li><b>Zoom to a pin:</b> right click that pin when not in max zoom.</li>"
			+ "</ul>"
			+ "<br />"
			+ "<h2>Compass Pins Features</h2>"
			+ "<ul>"
			+ "<li><b>Get coordinates of a pin:</b> single click that pin.</li>"
			+ "<li><b>Draw a path connecting all compasses of a type:</b> middle click that pin.</li>"
			+ "<li><b>Export pins for sharing:</b> use the compass export function and copy and output text.</li>"
			+ "<li><b>Import pins from text:</b> use the compass import function, then paste the compass data text into the adjacent input box.</li>"
			+ "<li><b>Import pins from file:</b> use the Choose File button and select a .json or .xml file.</li>"
			+ "<li><b>Save/Load pins:</b> the save slots can be named, which can be filtered by the search bar.</li>"
			+ "</ul>";
		I.help(str);
	},
	
	/*
	 * Creates a personal pin.
	 * @param object pLatLng coordinates.
	 * @param boolean pWantDraw to redraw the paths (shouldn't redraw when
	 * looping this function because that's inefficient).
	 */
	createPersonalPin: function(pLatLng, pWantDraw)
	{
		var that = this;
		var index = this.numPins;
		var coord = this.convertLCtoGC(pLatLng);
		var angle = (this.coordPreviousPin) ? this.convertDirectionAngle(this.coordPreviousPin, coord) : 0;
		this.coordPreviousPin = coord;
		
		// Create a pin at double click location
		var url = (this.numPins === 0) ? "img/map/pin_red.png" : "img/map/pin_directed.png";
		var marker = L.marker(pLatLng,
		{
			icon: L.icon(
			{
				iconUrl: url,
				iconSize: [32, 32],
				iconAnchor: [16, 16]
			}),
			draggable: true,
			opacity: 0.9,
			rotationAngle: angle
		});
		this.toggleLayer(marker, true);
		this.Layer.PersonalPin.addLayer(marker);
		this.numPins++;
		if (pWantDraw)
		{
			this.drawPersonalPath();
		}
		
		// Single click pin: get its coordinates and toggle its opacity
		this.bindMarkerCoordBehavior(marker, "click");
		marker.on("mousedown", function(pEvent)
		{
			switch (pEvent.originalEvent.which)
			{
				case I.ClickEnum.Left:
				{
					if (this.options.isMarked === undefined || this.options.isMarked === false)
					{
						this.options.isMarked = true;
						this.setOpacity(0.3);
					}
					else
					{
						this.options.isMarked = false;
						this.setOpacity(1);
					}
				} break;
				case I.ClickEnum.Middle:
				{
					// If middle click then set as starting pin
					that.optimizePersonalPath(index);
				} break;
			}
		});
		// Double click pin: remove itself from map
		marker.on("dblclick", function()
		{
			that.removePersonalPin(this);
		});
		// Right click pin: centers the pin on GPS character
		marker.on("contextmenu", function(pEvent)
		{
			if (that.Map.getZoom() === that.ZoomEnum.Max)
			{
				if (that.GPSPreviousCoord.length > 0)
				{
					that.movePin(this, that.GPSPreviousCoord);
				}
				else
				{
					that.movePin(this, that.Map.getCenter());
				}
				that.drawPersonalPath();
			}
			else
			{
				that.Map.setView(pEvent.latlng, that.ZoomEnum.Max);
			}
			
		});
		// Drag pin: redraw the personal path
		marker.on("dragend", function()
		{
			that.drawPersonalPath();
		});
	},
	
	/*
	 * Removes a personal pin from the map.
	 * @param object pPin
	 */
	removePersonalPin: function(pPin)
	{
		this.toggleLayer(pPin, false);
		this.Layer.PersonalPin.removeLayer(pPin);
		this.drawPersonalPath();
		this.numPins--;
	},
	
	/*
	 * Inserts a personal pin between a group of pins.
	 * @param int pPrecede index of the preceding pin.
	 * @param object pLatLng of the inserted pin.
	 */
	insertPersonalPin: function(pPrecede, pLatLng)
	{
		var latlngs = [];
		var i = 0;
		// Recompile pin coordinates for recreation
		this.Layer.PersonalPin.eachLayer(function(iPin)
		{
			latlngs.push(iPin.getLatLng());
			if (i === pPrecede)
			{
				// When at the index to insert, push the provided coordinates of the new pin
				latlngs.push(pLatLng);
			}
			i++;
		});
		// Redraw the entire series of pins
		this.clearPersonalPins();
		for (i in latlngs)
		{
			this.createPersonalPin(latlngs[i]);
		}
		this.drawPersonalPath();
	},
	
	/*
	 * Removes all personal pins from the map.
	 */
	clearPersonalPins: function()
	{
		var that = this;
		this.Layer.PersonalPin.eachLayer(function(iPin)
		{
			that.toggleLayer(iPin, false);
		});
		this.Layer.PersonalPin.clearLayers();
		this.drawPersonalPath();
		this.numPins = 0;
		this.coordPreviousPin = null;
	},
	
	/*
	 * Draws a path from the group of personal pins the user laid.
	 */
	drawPersonalPath: function()
	{
		var that = this;
		var path;
		var latlngs = [];
		var pinids = [];
		var length = 0;
		this.Layer.PersonalPin.eachLayer(function(iPin)
		{
			latlngs.push(iPin.getLatLng());
			pinids.push(P.getLayerId(iPin));
			length++;
		});
		
		var pathcolor = P.getUserPathColor();
		var pathopacity = P.getUserPathOpacity();
		if (length > 1)
		{
			this.Layer.PersonalPath.clearLayers();
			for (var i = 0; i < length - 1; i++)
			{
				// Create a single line connecting next two pins
				path = L.polyline([latlngs[i], latlngs[i+1]], {
					color: pathcolor,
					opacity: pathopacity,
					precede: i // Store the index of the preceding pin that connects the path
				});
				// Single click path: get the coordinates of all pins
				path.on("click", function()
				{
					that.outputCoordinatesCopy(that.getPersonalString());
					that.outputPinsDistance();
				});
				// Double click path: insert a pin between the two pins that connect the path
				path.on("dblclick", function(pEvent)
				{
					that.saveBackupPins();
					that.insertPersonalPin(this.options.precede, pEvent.latlng);
				});
				this.Layer.PersonalPath.addLayer(path);
			}
			this.toggleLayer(this.Layer.PersonalPath, true);
			that.outputPinsDistance();
		}
		else
		{
			this.toggleLayer(this.Layer.PersonalPath, false);
			this.Layer.PersonalPath.clearLayers();
		}
	},
	
	/*
	 * Parses a personal path string then draw it if valid.
	 * @param string pString of coordinates.
	 * @returns boolean true if valid.
	 */
	parsePersonalPath: function(pString)
	{
		var coords = this.parseCoordinatesMulti(pString);
		if (coords !== null)
		{
			this.redrawPersonalPath(coords);
			return true;
		}
		return false;
	},
	
	/*
	 * Draws a path from a given set of coordinates.
	 * @param 2D array pCoords of x y coordinates.
	 * @param string pZoomArgs for map view.
	 */
	redrawPersonalPath: function(pCoords, pZoomArgs)
	{
		var coords = (pCoords !== undefined) ? pCoords : this.getPersonalCoords();
		if (coords !== undefined && coords !== null && coords.length > 0)
		{
			this.clearPersonalPins();
			for (var i in coords)
			{
				this.createPersonalPin(this.convertGCtoLC(coords[i]));
			}
			this.drawPersonalPath();
			// View the first point in the generated path
			if (pZoomArgs !== null)
			{
				if (pZoomArgs === undefined)
				{
					this.goToArguments(coords[0]);
				}
				else
				{
					this.goToArguments(pZoomArgs);
				}
			}
		}
		else
		{
			I.write(D.getPhraseOriginal("Path not available for this") + ".");
		}
	},
	
	/*
	 * Outputs the total game "unit" distance for the pins.
	 */
	outputPinsDistance: function()
	{
		var distance = 0;
		var markers = this.Layer.PersonalPin.getLayers();
		var length = markers.length - 1;
		
		for (var i = 0; i < length; i++)
		{
			distance += P.getDistanceBetweenCoords(
				this.convertLCtoGC(markers[i].getLatLng()),
				this.convertLCtoGC(markers[i+1].getLatLng())
			);
		}
		var units = Math.floor(distance * T.cPOINTS_TO_UNITS);
		var time = T.formatTimeLetter(Math.ceil(units / T.cUNITS_PER_SECOND), true);
		this.outputCoordinatesName(units + " " + D.getWord("range") + " (" + time + ")");
	},
	
	/*
	 * Tells if there is at least one personal pin laid on the map.
	 * @returns boolean.
	 */
	isPersonalPinsLaid: function(pWantMessage)
	{
		if (this.numPins === 0)
		{
			if (pWantMessage)
			{
				I.write("No path pins to work with. Double click on the map to lay pins.");
			}
			return false;
		}
		return true;
	},
	
	/*
	 * Redraws the path with a shorter distance, only the starting point is not changed.
	 */
	optimizePersonalPath: function(pStart)
	{
		this.redrawPersonalPath(P.getGreedyPath(this.getPersonalCoords(), pStart));
	},
	
	/*
	 * Draw pins in random coordinates.
	 * @param pQuantity pins to draw.
	 */
	drawRandom: function(pQuantity)
	{
		var qty = parseInt(pQuantity);
		if (qty === 0 || qty > 1000 || this.numPins > 1000 || qty === undefined)
		{
			return;
		}
		
		var x, y;
		for (var i = 0; i < qty; i++)
		{
			x = T.getRandomIntRange(0, this.Continent.Dimensions[0]);
			y = T.getRandomIntRange(0, this.Continent.Dimensions[1]);
			this.createPersonalPin(this.convertGCtoLC([x, y]));
		}
		this.drawPersonalPath();
	},
	
	/*
	 * Gets the personal pins' coordinates.
	 * @returns string of the 2D array.
	 */
	getPersonalCoords: function()
	{
		var that = this;
		var coords = [];
		this.Layer.PersonalPin.eachLayer(function(iPin)
		{
			coords.push(that.convertLCtoGC(iPin.getLatLng()));
		});
		return coords;
	},
	getPersonalString: function()
	{
		return JSON.stringify(this.getPersonalCoords());
	},
	
	/*
	 * Gets the closest marker to the specified coordinates.
	 * @param array pCoord.
	 * @param object pLayerGroup markers to scan.
	 * @param boolean wantCoord to return coordinate instead of the marker object.
	 * @returns object Leaflet marker.
	 * @pre Coordinates must be inside a zone.
	 */
	getClosestLocation: function(pCoord, pLayerGroup)
	{
		var that = this;
		var distance;
		var mindistance = Number.POSITIVE_INFINITY;
		var minmarker = null;
		
		pLayerGroup.eachLayer(function(iLayer)
		{
			distance = P.getDistanceBetweenCoords(pCoord, that.convertLCtoGC(iLayer.getLatLng()));
			if (distance < mindistance)
			{
				mindistance = distance;
				minmarker = iLayer;
			}
		});
		return minmarker;
	},
	
	initializePinsPlacer: function(pMapObject)
	{
		var that = pMapObject;
		var htmlidprefix = "#" + that.MapEnum;
		
		$(htmlidprefix + "ContextClearPins").click(function()
		{
			that.clearPersonalPins();
		});
		that.initializePinStorage(that);
		$(htmlidprefix + "ContextOptimizePins").click(function()
		{
			if (that.isPersonalPinsLaid(true))
			{
				that.optimizePersonalPath();
			}
		});
		$(htmlidprefix + "ContextChatlinkPins").click(function()
		{
			if (that.isPersonalPinsLaid(true))
			{
				P.printClosestWaypoints();
			}
		});
		var urlpins = $(htmlidprefix + "ContextURLPins");
		if (urlpins.length)
		{
			I.bindClipboard(urlpins);
			urlpins.mouseenter(function()
			{
				if (that.isPersonalPinsLaid())
				{
					var urlmod = (P.MapSwitchWebsite === P.MapEnum.Mists) ? "wvw/" : "";
					I.updateClipboard($(this), I.cSiteURL + urlmod + that.getPersonalString());
				}
			});
		}
		var urlcoord = $(htmlidprefix + "ContextURLCoord");
		if (urlcoord.length)
		{
			I.bindClipboard(urlcoord);
			urlcoord.mouseenter(function()
			{
				if (that.ContextLatLng)
				{
					var urlmod = (P.MapSwitchWebsite === P.MapEnum.Mists) ? "wvw/" : "";
					I.updateClipboard($(this), I.cSiteURL + urlmod + that.convertLCtoGC(that.ContextLatLng));
				}
			});
		}
		$(htmlidprefix + "ContextZoneInfo").click(function()
		{
			if (that.ZoneCurrent)
			{
				for (var i in that.ZoneCurrent)
				{
					var data = that.ZoneCurrent[i];
					I.print(i + ": " + (Array.isArray(data) ? JSON.stringify(data) : data));
				}
			}
			else
			{
				I.write("Invalid zone.");
			}
		});
		$(htmlidprefix + "ContextHelpPins").click(function()
		{
			that.printPinHelp();
		});
		$(htmlidprefix + "ContextUndoPins").click(function()
		{
			that.loadBackupPins();
		});
	},
	
	/*
	 * Writes context menu elements for placing compasses with compass circles on the map.
	 */
	initializeCompassPlacer: function(pMapObject)
	{
		var that = pMapObject;
		var htmlidprefix = "#" + that.MapEnum;
		var iconsperline = 8;
		var nodeiconsperline = 4;
		var rangemaxvalue = 1000000;
		var colormaxlength = 32;
		var commentmaxlength = 256;
		var importmaxlength = 65536;
		
		var compasscontext = $(htmlidprefix + "ContextCompass");
		var compassgallery = $(htmlidprefix + "ContextCompassList");
		I.preventMapPropagation(compassgallery);
		var counter = 0;
		var nodecounter = 0;
		var nodetypeprev = null;
		var compassprev = null;
		
		// Entry: Lay another of the previously laid compass
		var addbutton = $(htmlidprefix + "ContextAddCompass");
		addbutton.click(function()
		{
			if (compassprev)
			{
				that.saveBackupCompasses();
				that.createCompass(compassprev, that.ContextLatLng);
			}
			else
			{
				I.write("Please select a compass pin first.");
			}
		});
		
		// Inputs: Custom compass properties
		var customcheck = $("<input type='checkbox' />");
		var customchecklabel = $("<label title='" + D.getPhraseOriginal("Enable custom range and comment") + ".'></label>").append(customcheck);
		var customrange = $("<input type='number' value='1200' min='0' max='" + rangemaxvalue
			+ "' step='100' style='width:48px' title='" + D.getWordCapital("range") + "' />");
		var customcolor = $("<input type='text' value='#ffffff' maxlength='" + colormaxlength
			+ "' style='width:48px' class='cssInputText' title='" + D.getWordCapital("color") + "' />");
		var customcomment = $("<input type='text' value='" + D.getWordCapital("comment") + "...' maxlength='" + commentmaxlength
				+ "' style='width:" + ((I.ModeCurrent === I.ModeEnum.Overlay) ? 64 : 128)
				+ "px; margin-left:4px;' class='cssInputText' title='" + D.getWordCapital("comment") + "' />");
		
		// Add resource node compasses if is this map
		if (that.MapEnum === P.MapEnum.Tyria)
		{
			var nodes = GW2T_RESOURCE_DATA;
			for (var i in nodes)
			{
				var nodename = i.toLowerCase();
				that.Compasses["node_" + nodename] = {
					nodetype: nodes[i].type,
					icon: "img/node/" + nodename + I.cPNG
				};
			}
		}
		// Add compass buttons into the gallery
		for (var i in that.Compasses)
		{
			var compass = that.Compasses[i];
			compass.id = i;
			if (compass.isPlaceable === false)
			{
				continue;
			}
			counter++;
			
			// Icon
			compass.icon = compass.icon || "img/compass/" + compass.id + I.cPNG;
			var compassbutton = $("<img src='" + compass.icon + "' />");
			// Button tooltip
			var title = (compass.tooltip !== undefined) ? compass.tooltip : ((compass.range) ? D.getWordCapital("range") + " " + compass.range : "");
			if (title.length)
			{
				compassbutton.attr("title", title);
			}
			
			if (compass.nodetype)
			{
				// Add resource node compass button to its specific menu
				if (nodetypeprev !== compass.nodetype)
				{
					nodetypeprev = compass.nodetype;
					nodecounter = 0;
				}
				nodecounter++;
				var nodecompassgallery = $("#mapContextNodeList_" + compass.nodetype);
				nodecompassgallery.append(compassbutton);
				if (nodecounter % nodeiconsperline === 0)
				{
					nodecompassgallery.append("<br />");
				}
			}
			else
			{
				// Add standard compass button to regular menu
				compassgallery.append(compassbutton);
				if (counter % iconsperline === 0)
				{
					compassgallery.append("<br />");
				}
			}
			(function(iCompass)
			{
				compassbutton.click(function()
				{
					var outputcompass = (customcheck.is(":checked")) ? $.extend({}, iCompass, {
						range: parseInt(customrange.val()),
						color: U.stripToColorString(customcolor.val()),
						comment: U.escapeHTML(customcomment.val())
					}) : iCompass;
					compassprev = outputcompass;
					that.saveBackupCompasses();
					that.createCompass(outputcompass, that.ContextLatLng);
				});
			})(compass);
		}
		
		// Insert the custom inputs at the bottom of the gallery
		$("<span id='" + that.MapEnum + "CompassCustom' style='display:block;' class='mapCompassCustom'></span>")
			.prependTo(compassgallery).append([customchecklabel, customrange, customcolor, customcomment]).find("input").onEnterKey(function()
		{
			addbutton.trigger("click");
		});
		
		// Entry: Clear all compasses
		$(htmlidprefix + "ContextClearCompasses").click(function()
		{
			that.clearCompasses();
		});
		
		// Entry: Import compass data
		var importbutton = $(htmlidprefix + "ContextImportCompasses");
		importbutton.click(function()
		{
			var str = $(htmlidprefix + "CompassImportText").val();
			that.parseCompasses(str);
		});
		var importfile = $("<input type='file' style='width:128px' />").insertBefore(importbutton);
		Z.bindFileInput(importfile, function(pString, file)
		{
			that.parseCompasses(pString, file);
		});
		// Input: Import input box
		$("<input id='" + that.MapEnum + "CompassImportText' type='text' value='' maxlength='"
			+ importmaxlength + "' style='width:96px; margin-left:4px;' class='cssInputText' title='"
			+ "<dfn>Export</dfn> to get the textual copy of laid compasses.<br />"
			+ "Paste that text in this box and <dfn>Import</dfn> to reconstruct the compasses.' />")
		.onEnterKey(function()
		{
			importbutton.trigger("click");
		}).appendTo(importbutton);
		// Entry: Export current compasses
		$(htmlidprefix + "ContextExportCompasses").click(function()
		{
			if (that.isCompassesLaid())
			{
				var outputstr = JSON.stringify(that.serializeCompasses());
				I.print("Saveable File:");
				Z.createFile(outputstr, "gw2t_compasses.json");
				I.print("<br />Copyable Text:");
				I.paste(outputstr);
			}
		});
		
		// Entry: Draw standard siege placement for WvW
		$("#wvwContextDrawCompasses").click(function()
		{
			W.redrawDefaultCompasses();
		});
		
		// Entry: Help message
		$(htmlidprefix + "ContextHelpCompasses").click(function()
		{
			that.printCompassHelp();
		});
		
		// Entry: Undo by loading backup
		$(htmlidprefix + "ContextUndoCompasses").click(function()
		{
			that.loadBackupCompasses();
		});
		
		// Allow interaction with the inputs within the context menu
		compasscontext.find("input").click(function(pEvent)
		{
			pEvent.stopPropagation();
			$(this).select();
		}).trigger("mouseenter"); // Trigger the context menu positioning function after generating the menu
		customchecklabel.click(function(pEvent)
		{
			pEvent.stopPropagation();
		});
		
		// Finally
		I.qTip.init(compasscontext.find("label, input, img"));
		X.rewrapCheckboxes();
		that.initializeCompassStorage();
	},
	
	/*
	 * Initializes the compass storage system.
	 */
	initializeCompassStorage: function()
	{
		var that = this;
		var initializeStoredCompasses = function(pQuantity)
		{
			var obj = O.Utilities["StoredCompasses" + that.OptionSuffix];
			// First make a new array with desired length
			obj.value = new Array(pQuantity);
			// Try to overwrite it with the stored arrays, if this fails then the value property is unchanged (a blank array)
			obj.value = O.loadCompressedObject(obj.key) || new Array(pQuantity);
		};
		var saveStoredCompasses = function(pIndex)
		{
			var obj = O.Utilities["StoredCompasses" + that.OptionSuffix];
			var compasses = that.serializeCompasses();
			if (compasses.length > 0)
			{
				obj.value[pIndex] = compasses;
				O.saveCompressedObject(obj.key, obj.value);
				I.write(compasses.length + " compasses saved.");
			}
			else
			{
				that.isCompassesLaid();
			}
		};
		var loadStoredCompasses = function(pIndex)
		{
			var obj = O.Utilities["StoredCompasses" + that.OptionSuffix];
			that.redrawCompasses(obj.value[pIndex]);
		};
		
		var numslots = that.numCompassesSlots;
		initializeStoredCompasses(numslots);
		that.initializeContextSlots("Compasses", numslots, that, saveStoredCompasses, loadStoredCompasses);
	},
	
	/*
	 * Saves the current compass pins as backup. This is to be called before the
	 * user manually adds a compass.
	 */
	saveBackupCompasses: function()
	{
		var obj = O.Utilities["BackupCompasses" + this.OptionSuffix];
		localStorage[obj.key] = JSON.stringify(this.serializeCompasses());
	},
	loadBackupCompasses: function()
	{
		var obj = O.Utilities["BackupCompasses" + this.OptionSuffix];
		try
		{
			obj.value = JSON.parse(localStorage[obj.key]);
		}
		catch (e) {}
		this.redrawCompasses(obj.value);
	},
	
	/*
	 * Gets an array of objects with properties needed to reconstruct the compasses on the map.
	 * @returns array of objects.
	 */
	serializeCompasses: function()
	{
		var that = this;
		var company = [];
		that.Layer.CompassCircle.eachLayer(function(iLayer)
		{
			var opt = iLayer.options;
			// Store only the compass ID and location
			var compass = {
				id: opt.compassid,
				coord: that.convertLCtoGC(iLayer.getLatLng())
			};
			// If compass has custom properties then save them too
			if (opt.color)
			{
				compass.color = (opt.color).toLowerCase();
			}
			if (opt.compassrange)
			{
				compass.range = parseInt(opt.compassrange);
			}
			if (opt.compasscomment)
			{
				compass.comment = opt.compasscomment;
			}
			company.push(compass);
		});
		U.sortObjects(company, {aKeyName: "id"});
		return company;
	},
	
	/*
	 * Draws a path between a specific type of compass pins.
	 * @param object pCompass to get its type.
	 */
	pathCompasses: function(pCompass)
	{
		var that = this;
		var type = pCompass.options.compassid;
		var coords = [];
		that.Layer.CompassCircle.eachLayer(function(iLayer)
		{
			var opt = iLayer.options;
			if (opt.compassid === type)
			{
				coords.push(that.convertLCtoGC(iLayer.getLatLng()));
			}
		});
		that.redrawPersonalPath(coords);
	},
	
	/*
	 * Reconstructs a placement of compasses on the map.
	 * @param array pCompany of compasses and their location.
	 * @param array pOffset x and y coordinates offset, optional.
	 * @pre Compasses' placement was stored as game coordinates, not LatLng.
	 */
	redrawCompasses: function(pCompany, pOffset)
	{
		if (pCompany !== undefined && pCompany !== null && pCompany.length > 0)
		{
			this.clearCompasses();
			var counter = 0;
			var coords = [];
			for (var i in pCompany)
			{
				var compass = pCompany[i];
				var coord = (pOffset !== undefined) ? [compass.coord[0] + pOffset[0], compass.coord[1] + pOffset[1]] : compass.coord;
				// If it is not a custom compass, then use the default properties via that compass ID
				var compasstomake = null;
				if (this.Compasses[compass.id])
				{
					compasstomake = $.extend({}, this.Compasses[compass.id], compass);
				}
				else if (compass.coord && coord)
				{
					// For unrecognized compasses (deprecated compass IDs, but still have a valid properties)
					compasstomake = {
						id: "custom",
						icon: "img/compass/custom.png",
						range: compass.range,
						color: compass.color,
						comment: compass.comment
					};
				}
				
				// Only draw if it is a valid compass object
				if (compasstomake !== null)
				{
					counter++;
					coords.push(coord);
					this.createCompass(compasstomake, this.convertGCtoLC(coord));
				}
				else
				{
					I.write("Failed parsing a compass: " + compass.id);
				}
			}
			// After success
			if (counter > 0)
			{
				this.goToView(U.getRandomElement(coords));
				I.write(counter + " compasses reconstructed.");
			}
		}
		else
		{
			I.write(D.getPhraseOriginal("Compass not available for this" + "."));
		}
	},
	
	/**
	 * Parses a standard company of compasses array, or a third party format.
	 * @param string pString formatted data.
	 * @param object pFile if imported from file, optional.
	 */
	parseCompasses: function(pString, pFile)
	{
		var that = this;
		var parseTaco = function()
		{
			var types = {};
			var counter = 0;
			var replacements = ["squad_arrow", "squad_circle", "squad_heart", "squad_rectangle", "squad_spiral", "squad_star", "squad_triangle", "squad_x"];
			var xml = $($.parseXML(pString));
			var poi, type, zoneid, zone, unrecognizedzones = {}, coord, coords = [], company = [];
			// Reconstruct each POI with reassigned icons for each type
			xml.find("POI").each(function()
			{
				poi = $(this);
				type = poi.attr("type");
				if (types[type] === undefined)
				{
					types[type] = {
						id: replacements[counter]
					};
					counter = (counter < replacements.length - 1) ? counter + 1 : 0;
				}
				zoneid = poi.attr("MapID");
				zone = that.getZoneFromID(zoneid);
				if (zone)
				{
					coord = that.convertGPSCoord([poi.attr("xpos"), poi.attr("ypos"), poi.attr("zpos")], zone);
					coords.push(coord);
					company.push({
						id: types[type].id,
						coord: coord
					});
				}
				else if (unrecognizedzones[zoneid] === undefined)
				{
					unrecognizedzones[zoneid] = true;
					I.print("Unrecognized zone ID: " + zoneid);
				}
			});
			that.redrawCompasses(company);
			that.redrawPersonalPath(coords);
			
			// Print metadata
			var metadata = "";
			var category = xml.find("MarkerCategory").first();
			while (category.length)
			{
				metadata += (category.attr("DisplayName") || category.attr("name")) + " ";
				category = category.find("MarkerCategory").first();
			}
			I.print(metadata.length ? ("&quot;" + U.escapeHTML(metadata.trim()) + "&quot;") : "Untitled Markers");
		};
		
		var parseAug = function(pData)
		{
			var commentoffsetY = 10; // In game units
			var coords = [], company = [];
			var coord, comment;
			var nodes = pData["Nodes"];
			var detachednodes = pData["DetachedNodes"];
			var zoneid = (pFile.name.split("."))[0];
			var zone = that.getZoneFromID(zoneid);
			if (zone)
			{
				nodes.forEach(function(iNode)
				{
					coords.push(that.convertGPSCoord([iNode["X"], iNode["Y"], iNode["Z"]], zone));
					comment = iNode["Comment"];
					if (comment)
					{
						detachednodes.push(iNode);
					}
				});
				detachednodes.forEach(function(iNode)
				{
					coord = that.convertGPSCoord([iNode["X"], iNode["Y"], iNode["Z"]], zone);
					coord[1] = coord[1] + commentoffsetY;
					company.push({
						id: "comment",
						coord: coord,
						comment: iNode["Comment"]
					});
				});
				that.redrawCompasses(company);
				that.redrawPersonalPath(coords);
			}
			else
			{
				I.print("Unrecognized zone ID: " + zoneid);
			}
		};
		
		if (pString.indexOf("<OverlayData>") !== -1)
		{
			try
			{
				parseTaco(pString);
			}
			catch (e)
			{
				I.write("Invalid marker file for importing Compasses.");
			};
		}
		else
		{
//			try
//			{
				var company = JSON.parse(pString);
				if (Array.isArray(company))
				{
					this.redrawCompasses(company);
				}
				else if (company["Nodes"] && pFile)
				{
					parseAug(company);
				}
//			}
//			catch (e)
//			{
//				I.write("Invalid data string for importing Compasses.");
//			};
		}
	},
	
	/*
	 * Draws the standard siege placement for the current zone.
	 */
	redrawDefaultCompasses: function()
	{
		var placementname = W.Metadata.PlacementAssociation[W.ZoneCurrent.nick];
		var placement = W.Placement[placementname];
		var offset = W.Metadata.Offsets[W.ZoneCurrent.nick];
		if (offset !== undefined && placement)
		{
			var arsenal = placement.Company;
			W.redrawCompasses(arsenal, offset);
		}
	},
	
	/*
	 * Tells if there is at least one personal pin laid on the map.
	 * @returns boolean.
	 */
	isCompassesLaid: function()
	{
		if (this.Layer.CompassIcon.getLayers().length === 0)
		{
			I.write("No compass pins to work with. Lay compasses from the map's &quot;Compass&quot; context menu.");
			return false;
		}
		return true;
	},
	
	/*
	 * Places a range marker icon and circle circumference on the map.
	 * @param object pCompass.
	 * @param object pLatLng location of the compass.
	 * @pre LatLng variable was assigned when the user right clicked on the map.
	 */
	createCompass: function(pCompass, pLatLng)
	{
		var that = this;
		// The circle indicating the range
		var trueradius = pCompass.range * T.cUNITS_TO_POINTS;
		var radius = this.getZoomedDistance(trueradius);
		var circle = L.circleMarker(pLatLng, {
			clickable: false,
			compassid: pCompass.id,
			compassrange: pCompass.range,
			compasscomment: pCompass.comment,
			trueradius: trueradius,
			radius: radius,
			color: pCompass.color,
			weight: 2,
			opacity: pCompass.opacity || 0.8,
			fillOpacity: pCompass.fillOpacity || 0.1
		});
		this.Layer.CompassCircle.addLayer(circle);
		this.toggleLayer(circle);
		
		// The interactive icon allowing the user to relocate the circle
		var width = (pCompass.range) ? 24 : 32;
		var height = (pCompass.range) ? 24 : 32;
		var compass = L.marker(pLatLng,
		{
			circle: circle,
			icon: L.icon(
			{
				className: "mapCompass",
				iconUrl: pCompass.icon,
				iconSize: [width, height],
				iconAnchor: [width / 2, height / 2]
			}),
			title: pCompass.comment,
			draggable: true,
			opacity: 0.9
		});
		that.bindMarkerCoordBehavior(compass, "click");
		
		// Bind placed marker behavior
		compass.on("drag", function()
		{
			this.options.circle.setLatLng(this.getLatLng());
		});
		compass.on("dblclick", function()
		{
			that.removeCompass(this);
			I.qTip.hide();
		});
		compass.on("contextmenu", function()
		{
			if (that.Map.getZoom() !== that.ZoomEnum.Ground)
			{
				that.Map.setView(this.getLatLng(), that.ZoomEnum.Ground);
			}
			else
			{
				if (that.GPSPreviousCoord.length > 0)
				{
					that.movePin(this, that.GPSPreviousCoord);
				}
				else
				{
					that.movePin(this, that.Map.getCenter());
				}
				this.options.circle.setLatLng(this.getLatLng());
			}
		});
		compass.on("mousedown", function(pEvent)
		{
			if (pEvent.originalEvent.which === I.ClickEnum.Middle)
			{
				that.pathCompasses(this.options.circle);
			}
		});
		this.Layer.CompassIcon.addLayer(compass);
		this.toggleLayer(compass);
		
		// Bind tooltip if compass is commented
		if (pCompass.comment)
		{
			I.qTip.init(".mapCompass");
		}
	},
	
	/*
	 * Removes a placed compass from the map and associated container objects.
	 * @param object pMarker.
	 */
	removeCompass: function(pMarker)
	{
		// Remove its range circle before removing the compass
		this.toggleLayer(pMarker.options.circle, false);
		this.Layer.CompassCircle.removeLayer(pMarker.options.circle);
		// Remove the compass itself
		this.toggleLayer(pMarker, false);
		this.Layer.CompassIcon.removeLayer(pMarker);
	},
	
	/*
	 * Removes all compasses from the map.
	 */
	clearCompasses: function()
	{
		var that = this;
		this.Layer.CompassIcon.eachLayer(function(iLayer)
		{
			that.removeCompass(iLayer);
		});
		this.Layer.CompassCircle.clearLayers();
		this.Layer.CompassIcon.clearLayers();
	},
	
	/*
	 * Changes the marker icon's image and size (Leaflet does not have this method).
	 * @param object pMarker Leaflet marker.
	 * @param string pIconURL of the icon image.
	 * @param int pSize of icon.
	 */
	resizeMarkerIcon: function(pMarker, pSize)
	{
		if (pSize === undefined)
		{
			pSize = this.cICON_SIZE_STANDARD;
		}
		
		pMarker.setIcon(new L.icon(
		{
			iconUrl: pMarker.options.icon.options.iconUrl,
			iconSize: [pSize, pSize],
			iconAnchor: [pSize/2, pSize/2]
		}));
	},
	
	/*
	 * Toggles recreation/destruction of layers (a group of markers).
	 * @param object pLayer of markers.
	 * @param boolean pBoolean to show or hide.
	 */
	toggleLayer: function(pLayer, pBoolean)
	{
		if ( ! pLayer)
		{
			return;
		}
		// No boolean provided so assumes toggle
		if (pBoolean === undefined)
		{
			pBoolean = !(this.Map.hasLayer(pLayer));
		}
		
		// Show if true, hide if false
		if (pBoolean)
		{
			pLayer.addTo(this.Map);
		}
		else
		{
			this.Map.removeLayer(pLayer);
		}
	},
	toggleLayerArray: function(pLayerArray, pBoolean)
	{
		for (var i in pLayerArray)
		{
			this.toggleLayer(pLayerArray[i], pBoolean);
		}
	},
	
	/*
	 * Initializes or toggle a submap, which is a Leaflet ImageOverlay over the map.
	 * Look at general.js for submap declarations.
	 * @param string pName of the submap.
	 * @param boolean pBoolean to show or hide.
	 */
	toggleSubmap: function(pName, pBoolean)
	{
		var submap = this.Submaps[pName];
		if (submap.ImageOverlay === undefined)
		{
			submap.ImageOverlay = this.createSubmap(submap);
			this.toggleSubmap(pName, pBoolean);
		}
		else
		{
			// No boolean provided so assumes toggle
			if (pBoolean === undefined)
			{
				pBoolean = !(this.Map.hasLayer(submap.ImageOverlay));
			}

			// Show if true, hide if false
			if (pBoolean)
			{
				submap.ImageOverlay.addTo(this.Map).bringToBack();
			}
			else
			{
				this.Map.removeLayer(submap.ImageOverlay);
			}
		}
	},
	toggleSubmapArray: function(pNames, pBoolean)
	{
		for (var i in pNames)
		{
			this.toggleSubmap(pNames[i], pBoolean);
		}
	},
	createSubmap: function(pSubmapData, pWantShow)
	{
		var submap = L.imageOverlay(pSubmapData.img, this.convertGCtoLCMulti(pSubmapData.bounds));
		if (pWantShow)
		{
			submap.addTo(this.Map).bringToBack();
		}
		return submap;
	},
	
	/*
	 * Moves a pin to a map coordinate.
	 * @param object pPin to move.
	 * @param 2D array or Leaflet latlng object pCoord coordinates.
	 */
	movePin: function(pPin, pCoord)
	{
		if (pCoord === undefined)
		{
			// No coordinates given means hide the pin
			this.toggleLayer(pPin, false);
		}
		else
		{
			this.toggleLayer(pPin, true);
			if (Array.isArray(pCoord))
			{
				pPin.setLatLng(this.convertGCtoLC(pCoord));
			}
			else
			{
				pPin.setLatLng(pCoord);
			}
			pPin._icon.style.zIndex = this.cZIndexRaise;
		}
	},
	
	/*
	 * Views the map at the specifications.
	 * @param 2D array pCoord coordinates.
	 * @param object pPin which to move to coordinate.
	 * @param enum pZoom level or object with integer "offset" key.
	 */
	goToView: function(pCoord, pZoom, pPin)
	{
		if (pPin !== undefined)
		{
			this.movePin(pPin, pCoord);
		}
		
		if (pZoom === undefined)
		{
			pZoom = this.ZoomEnum.Ground;
		}
		else if (pZoom === this.ZoomEnum.Same)
		{
			pZoom = this.Map.getZoom();
		}
		else if (pZoom === this.ZoomEnum.Adaptive)
		{
			pZoom = this.getAdaptiveZoom();
		}
		else if (typeof pZoom === "object" && pZoom.offset !== undefined)
		{
			pZoom = this.getAdaptiveZoom(pZoom.offset);
		}
		this.Map.setView(this.convertGCtoLC(pCoord), pZoom);
		this.showCurrentZone(pCoord);
	},
	
	/*
	 * Views the map outside of bounds then instantly back at original view,
	 * to workaround the unresponsive map bug when the map was previously hidden.
	 */
	refreshView: function(pCoord)
	{
		var latlng = (pCoord) ? this.convertGCtoLC(pCoord) : this.Map.getCenter();
		this.Map.setView(M.Continent.CenterInitial, this.Map.getZoom());
		this.Map.setView(latlng, this.Map.getZoom());
	},
	
	/*
	 * Views the map at the zone.
	 * @param string pNick of the zone.
	 * @param enum pZoom level.
	 */
	goToZone: function(pNick, pZoom)
	{
		var coord = this.getZoneCenter(pNick);
		this.showCurrentZone(coord);
		this.goToView(coord, pZoom);
	},
	
	/*
	 * Gets a zoom level that depends on the user's screen width.
	 * @param int pOffset from the returned zoom.
	 * @returns int zoom level.
	 */
	getAdaptiveZoom: function(pOffset)
	{
		if (pOffset === undefined)
		{
			pOffset = 0;
		}
		var zoom;
		var winwidth = $(window).width();
		
		if (winwidth >= I.ScreenWidth.Huge)
		{
			zoom = this.ZoomEnum.Default + 1;
		}
		else if (winwidth >= I.ScreenWidth.Large)
		{
			zoom = this.ZoomEnum.Default;
		}
		else if (winwidth >= I.ScreenWidth.Medium)
		{
			zoom = this.ZoomEnum.Default - 1;
		}
		else
		{
			zoom = this.ZoomEnum.Default - 2;
		}
		return zoom + pOffset;
	},
	
	/*
	 * Views the default map view.
	 */
	goToDefault: function(pZoom)
	{
		if (pZoom === undefined)
		{
			pZoom = this.getAdaptiveZoom();
		}
		this.Map.setView(this.convertGCtoLC(this.Continent.Center), pZoom);
	},
	
	/*
	 * Views the map at the given URL coordinates if exist.
	 * URL should be in the form of https://gw2timer.com/?go=4874,16436,1
	 * @param string pArguments of location to view.
	 * @param enum pZoom level, optional.
	 * @param object pPin pin, optional.
	 * coords[0] = x coordinate.
	 * coords[1] = y coordinate.
	 * coords[2] = z coordinate (zoom level, lower value equals greater zoom-in).
	 */
	goToArguments: function(pArguments, pZoom, pPin)
	{
		var i;
		var coords = [];
		var zone;
		if (pArguments)
		{
			coords = this.parseCoordinates(pArguments);
			if (coords.length === 2)
			{
				if (isFinite(coords[0]) && isFinite(coords[1]))
				{
					this.goToView(coords, pZoom, pPin);
				}
			}
			else if (coords.length >= 3)
			{
				if (isFinite(coords[0]) && isFinite(coords[1]) && isFinite(coords[2]))
				{
					// Zoom level 0 is ground level (opposite the enum)
					var zoomlevel = this.invertZoomLevel(coords[2]);
					this.goToView([coords[0], coords[1]], zoomlevel, pPin);
				}
			}
			else
			{
				// Else assume the argument is a short name for the zone
				zone = pArguments.toLowerCase();
				if (zone === "default")
				{
					this.goToDefault();
				}
				else
				{
					for (i in this.Zones)
					{
						if (zone.indexOf(i) !== -1)
						{
							this.goToView(this.getZoneCenter(i), this.ZoomEnum.Sky);
							break;
						}
					}
				}
			}
		}
	},
	
	/*
	 * Executes map commands in URL query string if available. Also starts GPS.
	 */
	executeURLCommands: function()
	{
		var qsgo = U.Args[U.KeyEnum.Go];
		var qsdraw = U.Args[U.KeyEnum.Draw];
		var arr;
		var goPage = function()
		{
			// Go to map page if go or draw commanded is provided and page is not
			if (U.Args[U.KeyEnum.Page] === undefined)
			{
				$("#plateMenu_Map").trigger("click");
			}
		};
		try { arr = JSON.parse(qsgo); } catch (e) {}
		if (arr && Array.isArray(arr) && arr.length && Array.isArray(arr[0]))
		{
			// If is draw command, array of coordinates
			this.parsePersonalPath(qsgo);
			U.Args[U.KeyEnum.Go] = null;
			goPage();
		}
		else if (qsgo)
		{
			// If is go command, just a coordinates
			this.goToArguments(qsgo, this.ZoomEnum.Ground, this.Pin.Program);
			U.Args[U.KeyEnum.Go] = null;
			goPage();
		}
		if (qsdraw)
		{
			var drawzone = this.getZoneFromString(qsdraw);
			if (drawzone)
			{
				P.drawCompletionRoute(drawzone);
			}
			else
			{
				this.parsePersonalPath(qsdraw);
			}
			U.Args[U.KeyEnum.Draw] = null;
			goPage();
		}
		
		// Start GPS if on overlay
		if (I.ModeCurrent === I.ModeEnum.Overlay && I.isProgramEmbedded === false)
		{
			P.tickGPS();
		}
	},
	
	/*
	 * Converts GW2's coordinates XXXXX,XXXXX to Leaflet LatLng coordinates XXX,XXX.
	 * @param array pCoord array of two numbers.
	 * @returns LatLng Leaflet object.
	 */
	convertGCtoLC: function(pCoord)
	{
		return this.Map.unproject(pCoord, this.Map.getMaxZoom());
	},
	
	/*
	 * Converts multiple GW2 coordinates to multiple LatLng.
	 * @param array of arrays pCoordArrays to convert.
	 * @param int pIndexStart starting index.
	 * @returns array of LatLng.
	 */
	convertGCtoLCMulti: function(pCoordArray, pIndexStart)
	{
		pIndexStart = pIndexStart || 0;
		var i;
		var latlngs = [];
		for (i = pIndexStart; i < pCoordArray.length; i++)
		{
			latlngs.push(this.convertGCtoLC(pCoordArray[i]));
		}
		return latlngs;
	},
	
	/*
	 * Converts two coordinates [[X1, Y2], [X2, Y2]] to two LatLng's.
	 * @param 2D array pSegmentArray.
	 * @returns array.
	 */
	convertGCtoLCDual: function(pSegmentArray)
	{
		return [this.convertGCtoLC(pSegmentArray[0]), this.convertGCtoLC(pSegmentArray[1])];
	},
	
	/*
	 * Converts Leaflet LatLng to GW2's 2 unit array coordinates.
	 * @param object pLatLng from Leaflet.
	 * @returns array of x and y coordinates.
	 */
	convertLCtoGC: function(pLatLng)
	{
		var coord = this.Map.project(pLatLng, this.ZoomEnum.Max);
		return [Math.round(coord.x), Math.round(coord.y)];
	},
	convertLCtoGCMulti: function(pCoordArray)
	{
		var coords = [];
		for (var i = 0; i < pCoordArray.length; i++)
		{
			coords.push(this.convertLCtoGC(pCoordArray[i]));
		}
		return coords;
	},
	
	/*
	 * Converts a map_floor.json event coordinates to the map coordinates system.
	 * @param 2D float array pPos event center. Only uses [0] and [1] values.
	 * @param object pZone to translate coordinates.
	 * @returns 2D int array map coordinates.
	 * @pre pZone was initialized (this is asynchronous).
	 */
	convertEventCoord: function(pPos, pZone)
	{
		var cr = pZone.continent_rect_actual || pZone.continent_rect; // 2D float array
		var mr = pZone.map_rect; // 2D float array
		
		// Code from http://gw2.chillerlan.net/examples/gw2maps-jquery.html
		return [
			Math.floor(cr[0][0]+(cr[1][0]-cr[0][0])*(pPos[0]-mr[0][0])/(mr[1][0]-mr[0][0])),
			Math.floor(cr[0][1]+(cr[1][1]-cr[0][1])*(1-(pPos[1]-mr[0][1])/(mr[1][1]-mr[0][1])))
		];
	},
	convertEventCoordMulti: function(pPosArray, pZone)
	{
		var coords = [];
		for (var i = 0; i < pPosArray.length; i++)
		{
			coords.push(this.convertEventCoord(pPosArray[i], pZone));
		}
		return coords;
	},
	
	/*
	 * Converts a MumbleLink player coordinates to the map coordinates system.
	 * @param 2D float array pPos [latitude altitude longitude] player position.
	 * @param object pZone the player is in.
	 * @returns 2D int array map coordinates.
	 */
	convertGPSCoord: function(pPos, pZone)
	{
		var coord = new Array(3);
		coord[0] = pPos[0] * T.cMETERS_TO_UNITS; // x coordinate
		coord[1] = pPos[2] * T.cMETERS_TO_UNITS; // y coordinate
		coord[2] = pPos[1] * T.cMETERS_TO_UNITS; // z coordinate
		return this.convertEventCoord(coord, pZone);
	},
	
	/*
	 * Converts a MumbleLink 3D vector values to degrees of 2D rotation.
	 * @param 2D array pVector [x, z, y].
	 * @returns float degrees.
	 */
	convertGPSAngle: function(pVector)
	{
		return Math.atan2(pVector[2], pVector[0]) * T.cRADIAN_TO_DEGREE;
	},
	
	/*
	 * Gets the angle between two map coordinates.
	 * @param array pCoordA game coordinates.
	 * @param array pCoordB game coordinates.
	 * @returns float degree.
	 */
	convertDirectionAngle: function(pCoordA, pCoordB)
	{
		return Math.atan2(pCoordB[1] - pCoordA[1], pCoordB[0] - pCoordA[0]) * T.cRADIAN_TO_DEGREE;
	},
	
	/*
	 * Converts a coordinate string to array coordinates.
	 * @param string pString coordinates in the form of "[X, Y]" GW2 coords.
	 * @returns array of numbers.
	 */
	parseCoordinates: function(pString)
	{
		// The regex strips all characters except digits, commas, periods, and minus sign
		var coord = pString.toString().replace(/[^\d,-.]/g, "");
		return coord.split(",");
	},
	
	/*
	 * Converts a string of coordinates to a 2D array.
	 * @param string pString array in the form of "[[X1,Y1],[X2,Y2]]" GW2 coords.
	 * @returns 2D array of coordinates. null if unable to parse.
	 */
	parseCoordinatesMulti: function(pString)
	{
		var arraylengthlimit = 13;
		var s = pString.replace(/\s/g, "");
		var sarray = [];
		var narray = [];
		var coord;
		
		if (s.length >= arraylengthlimit &&
			(s.charAt(0) === "["
			&& s.charAt(1) === "["
			&& s.charAt(s.length - 1) === "]"
			&& s.charAt(s.length - 2) === "]"))
		{
			s = s.substring(2, s.length-2); // Trim the [[ and ]]
			sarray = s.split("],["); // Create array from assumed "separator"
			for (var i in sarray)
			{
				coord = sarray[i].split(",");
				if (coord.length === 2)
				{
					coord[0] = Math.round(coord[0]);
					coord[1] = Math.round(coord[1]);
					narray.push(coord);
				}
			}
			return narray;
		}
		return null;
	},
	
	/*
	 * Converts and prints an array of LatLngs to GW2 coordinates.
	 * @param 2D array pArray.
	 * @returns 2D array.
	 */
	convertLatLngs: function(pArray)
	{
		if (Array.isArray(pArray))
		{
			var coords = this.convertLCtoGCMulti(pArray);
			P.printCoordinates(coords);
		}
	},
	
	/*
	 * Gets the coordinates from the data attribute of an HTML element.
	 * @param jqobject pElement to extract from.
	 * @returns array of GW2 coordinates.
	 */
	getElementCoordinates: function(pElement)
	{
		var coordstring = pElement.attr("data-coord");
		if (this.Zones[coordstring])
		{
			return this.getZoneCenter(coordstring);
		}
		return this.parseCoordinates(coordstring);
	},
	
	/*
	 * Binds map view event handlers to all map links (dfn tag reserved) in the
	 * specified container.
	 * @param string pContainer element ID.
	 * @param enum pZoom level.
	 */
	bindMapLinks: function(pContainer, pZoom)
	{
		if (I.isMapEnabled === false) { return; }
		var that = this;
		$(pContainer + " dfn").each(function()
		{
			$(this).text("[" + $(this).text() + "]");
			that.bindMapLinkBehavior($(this), pZoom, that.Pin.Program);
		});
	},
	
	/*
	 * Binds specified link to move a pinpoint to the location when hovered, and
	 * to view the map location when clicked.
	 * @param jqobject pLink to bind.
	 * @param object pPin marker to move.
	 * @param enum pZoom level when viewed location.
	 */
	bindMapLinkBehavior: function(pLink, pZoom, pPin)
	{
		if (I.isMapEnabled === false || pLink === undefined || pLink === null) { return; }
		var that = this;
		pLink.click(function()
		{
			var command = $(this).attr("data-coord");
			Z.interpretCommand(command, that, pZoom, pPin);
			C.isTouringManual = false;
		});
		
		pLink.dblclick(function()
		{
			var thiscoord = that.getElementCoordinates($(this));
			if (thiscoord.length > 1)
			{
				if (that.Map.getZoom() === that.ZoomEnum.Max)
				{
					that.goToView(thiscoord, that.ZoomEnum.Default, pPin);
				}
				else
				{
					that.Map.zoomIn();
				}
			}
		});
		
		pLink.contextmenu(function(pEvent)
		{
			pEvent.preventDefault();
			var thislatlng = that.convertGCtoLC(that.getElementCoordinates($(this)));
			if (that.Map.getZoom() === that.ZoomEnum.Max)
			{
				var center = that.Map.getCenter();
				if (Math.floor(center.lat) === Math.floor(thislatlng.lat)
					&& Math.floor(center.lng) === Math.floor(thislatlng.lng))
				{
					// If maxed zoom and centered on the marker, then zoom out
					that.Map.setZoom(that.ZoomEnum.Default);
				}
				else
				{
					// If maxed zoom and not centered on the marker, then center on the marker
					that.Map.setView(thislatlng, that.Map.getZoom());
				}
			}
			else
			{
				// All other cases zoom and center on the marker
				that.Map.setView(thislatlng, that.ZoomEnum.Max);
			}
		});
		
		// Move a point pin to that location as a preview
		pLink.mouseover(function()
		{
			var thiscoord = that.getElementCoordinates($(this));
			if (thiscoord.length > 1)
			{
				that.movePin(that.Pin.Over, thiscoord);
			}
		});
		pLink.mouseout(function()
		{
			that.movePin(that.Pin.Over);
		});
	},
	
	/*
	 * Binds standard behavior when user do something to an icon on the map.
	 * @param object pMarker to bind.
	 * @param string pEventType like "click" or "dblclick".
	 */
	bindOverviewBehavior: function(pMarker, pEventType)
	{
		var that = this;
		pMarker.on(pEventType, function(pEvent)
		{
			that.goToZone(pMarker.options.mappingzone, that.ZoomEnum.Sky);
		});
	},
	bindMarkerZoomBehavior: function(pMarker, pEventType, pZoomOut)
	{
		if (I.isTouchEnabled)
		{
			return;
		}
		var that = this;
		if (pZoomOut === undefined)
		{
			pZoomOut = that.ZoomEnum.Default;
		}
		
		pMarker.on(pEventType, function(pEvent)
		{
			if (that.Map.getZoom() === that.ZoomEnum.Max)
			{
				var center = that.Map.getCenter();
				if (Math.floor(center.lat) === Math.floor(pEvent.latlng.lat)
					&& Math.floor(center.lng) === Math.floor(pEvent.latlng.lng))
				{
					// If maxed zoom and centered on the marker, then zoom out
					that.Map.setZoom(pZoomOut);
				}
				else
				{
					// If maxed zoom and not centered on the marker, then center on the marker
					that.Map.setView(pEvent.latlng, that.Map.getZoom());
				}
			}
			else
			{
				// All other cases zoom and center on the marker
				that.Map.setView(pEvent.latlng, that.ZoomEnum.Max);
			}
		});
	},
	bindMarkerCoordBehavior: function(pMarker, pEventType)
	{
		if (I.isTouchEnabled)
		{
			return;
		}
		var that = this;
		pMarker.on(pEventType, function()
		{
			var coord = that.convertLCtoGC(this.getLatLng());
			that.outputCoordinatesCopy(P.formatCoord(coord));
		});
	},
	bindMarkerWikiBehavior: function(pMarker, pEventType, pWantDefault)
	{
		if (I.isTouchEnabled)
		{
			return;
		}
		pMarker.on(pEventType, function(pEvent)
		{
			U.openExternalURL(C.getEventWiki(this.options.wiki, pWantDefault));
		});
	},
	
	/*
	 * Translates the zones list in the Map page and bind click zoom behavior.
	 * @pre The translated names from the API was retrieved.
	 */
	bindZoneList: function(pMapObject)
	{
		var that = pMapObject;
		var htmlidprefix = "#" + that.MapEnum;
		$(htmlidprefix + "ZoneList li").each(function()
		{
			var zonenick = $(this).attr("data-zone");
			$(this).text(that.getZoneName(zonenick));
			$(this).attr("data-coord", that.getZoneCenter(zonenick).toString());
			that.bindMapLinkBehavior($(this), {offset: 1});
		});
		$(htmlidprefix + "ZoneList h2").each(function()
		{
			var regionnick = $(this).attr("data-region");
			$(this).text(D.getObjectName(that.Regions[regionnick]));
		});
	}	
};
P = {
/* =============================================================================
 * @@Populate GPS shared and independent map properties and functions
 * ========================================================================== */

	MapSwitchObject: M, // Reference to the map superobject
	MapSwitchSuffix: "", // Map options with suffix to differentiate for which map
	MapSwitchWebsite: "map", // The map currently displayed on the website
	MapSwitchGPS: null, // The map which the player resides in game
	MapEnum:
	{
		Tyria: "map",
		Mists: "wvw"
	},
	TempSubmap: {
		submap: {},
		img: "https://i.imgur.com/cTSJUvZ.jpg", 
		bounds: [[20736, 6656], [23808, 8192]]
	},
	
	Layer: {
		ZoneBorder: new L.layerGroup(), // Rectangles colored specific to the zones' region
		ZoneGateway: new L.layerGroup(), // Interzone and intergate connections
		ZonePowerup: new L.layerGroup(), // Pick up mobility skills
		ZoneLaunchpad: new L.layerGroup(), // One direction transports
		DryTopNicks: new L.layerGroup(), // Dry Top event names and timestamps
		Chest: new L.layerGroup()
	},
	NodeArray: { // An ordered array of markers and associated path
		JP: []
	},
	LayerArray: {
		ChainPath: [],
		Resource: [],
		JP: [],
		Guild_Bounty: [],
		Guild_Trek: [],
		Guild_Challenge: [],
		Guild_Rush: [],
		Guild_Puzzle: [],
		DryTopIcons: [],
		DryTopRings: [],
		DryTopActive: []
	},
	LocationsDatabase: [], // A searchable array of API markers like POIs, hearts, events
	
	Events: {},
	DryTopTimer: {},
	Resources: {},
	JPs: {},
	Chests: {},
	Collectibles: {},
	Guild: {},
	GPSTimeout: {},
	isGPSPrinting: false,
	
	/*
	 * Initializes the map only if the boolean set by specific modes is on.
	 */
	initializeMap: function()
	{
		if (I.isMapEnabled)
		{
			M.initializeMap();
		}
	},
	rebindMarkerTooltips: function()
	{
		I.qTip.init(".leaflet-marker-icon");
	},
	
	/*
	 * Adds an API map location to the searchable database array.
	 * @param array pCoord of the location.
	 * @param string pName of the location.
	 * @param string pIcon URL of the type of location.
	 * @param string pKeywords additional words for the search string.
	 */
	addMapLocation: function(pCoord, pName, pIcon, pKeywords)
	{
		var object = {
			name: pName,
			icon: pIcon,
			coord: pCoord,
			keywords: (pName + " " + pKeywords).toLowerCase()
		};
		P.LocationsDatabase.push(object);
	},
		
	/*
	 * Generates map waypoints and other markers from the GW2 server API files.
	 */
	populateMap: function(pMapObject)
	{
		if (I.isMapEnabled === false)
		{
			return;
		}
		var that = pMapObject;
		var url;
		var completionboolean = O.Options["bol_showWorldCompletion" + that.OptionSuffix];
		switch (that.MapEnum)
		{
			case P.MapEnum.Tyria: {
				url = U.getLangURL(U.URL_API.MapFloorTyria);
			} break;
			
			case P.MapEnum.Mists: {
				url = U.getLangURL(U.URL_API.MapFloorMists);
				// Exit this entire function if using the Mists map but have completion option off
				if (completionboolean === false)
				{
					return;
				}
			} break;
		}
		
		// Switches and functions to execute after population
		var finalizePopulate = function(pIsSuccess)
		{
			if (pIsSuccess)
			{
				that.isAPIRetrieved_MAPFLOOR = true;
			}
			/*
			 * AJAX takes a while so can use this to advantage to delay graphics
			 * that seem out of place without a map loaded.
			 */
			if (that.MapEnum === P.MapEnum.Tyria && O.Options.bol_displayEvents === false)
			{
				P.donePopulation();
			}
			
			switch (that.MapEnum)
			{
				case P.MapEnum.Tyria: {
					if (O.Options.bol_displayEvents === true)
					{
						P.populateEvents();
					}
					else
					{
						P.finishPopulation();
					}
				} break;

				case P.MapEnum.Mists: {
					W.finishPopulation();
				} break;
			}
		};
		
		/*
		 * map_floor.json sample structure of desired data
		 * Code based on API documentation.
		{
			"regions":
			{
				"1":
				{
					"name": "Shiverpeak Mountains"
					"maps":
					{
						"26":
						{
							"name": "Dredgehaunt Cliffs",
							"continent_rect": [[19456, 14976], [21760, 18176]],
							"points_of_interest":
							[{
								"poi_id": 602,
								"name": "Grey Road Waypoint",
								"type": "waypoint",
								"coord": [20684.6, 17105.3]
							},
							...
							]
						}
					}
				}
			}
		}*/	
		var doPopulate = function(pData)
		{
			var i;
			var numofpois;
			var regionid, region, zoneid, apizone, poi, zoneobj;
			var marker, icon, area, cssclass, tooltip;
			var translationsector = D.getTranslation("Sector");
			var translationpoi = D.getTranslation("Point of Interest");
			var translationvista = D.getTranslation("Vista");
			var translationmastery = D.getTranslation("Mastery Insight");
			var translationchallenge = D.getTranslation("Hero Challenge");
			var translationheart = D.getTranslation("Heart");

			for (regionid in pData.regions)
			{
				region = pData.regions[regionid];

				for (zoneid in region.maps)
				{
					// Don't bother parsing if not a regular world zone
					zoneobj = that.getZoneFromID(zoneid);
					if ( ! zoneobj || zoneobj.ispopulated)
					{
						continue;
					}
					
					zoneobj.ispopulated = true; // Mark as populated to avoid duplicate zones
					apizone = region.maps[zoneid];
					var zonename = D.getObjectName(zoneobj);
					var poiname;
					var numheart = 0;
					var numwaypoint = 0;
					var numlandmark = 0;
					var numvista = 0;
					var nummastery = 0;
					var numchallenge = 0;
					
					/* 
					 * For waypoints, points of interest, and vistas.
					 */
					numofpois = apizone.points_of_interest.length;
					for (i = 0; i < numofpois; i++)
					{
						poi = apizone.points_of_interest[i];

						// Properties assignment based on location's type
						switch (poi.type)
						{
							case that.APIPOIEnum.Waypoint:
							{
								// Waypoints are always created for Tyria, others are optional
								numwaypoint++;
								icon = U.URL_IMG.Waypoint;
								cssclass = "mapWp";
								tooltip = poi.name;
								P.addMapLocation(poi.coord, poi.name, icon, zonename);
							} break;
							
							case that.APIPOIEnum.Landmark:
							{
								if (completionboolean === false)
								{
									continue;
								}
								numlandmark++;
								icon = U.URL_IMG.Landmark;
								cssclass = "mapPoi";
								tooltip = poi.name;
								P.addMapLocation(poi.coord, poi.name, icon, zonename + " " + translationpoi);
							} break;
							
							case that.APIPOIEnum.Vista:
							{
								if (completionboolean === false)
								{
									continue;
								}
								numvista++;
								icon = U.URL_IMG.Vista;
								cssclass = "mapPoi";
								poiname = poi.name ? (poi.name + " " + translationvista) : translationvista;
								tooltip = poiname;
								P.addMapLocation(poi.coord, zonename + " " + poiname + " " + poi.poi_id, icon, zonename + " " + translationvista);
							} break;
							
							default: continue; // Don't create marker if not desired type
						}

						marker = L.marker(that.convertGCtoLC(poi.coord),
						{
							title: "<span class='" + cssclass + "'>" + tooltip + "</span>",
							markername: poi.name,
							icon: L.icon(
							{
								iconUrl: icon,
								iconSize: [16, 16], // Initial size corresponding to default zoom level
								iconAnchor: [8, 8]
							}),
							id: poi.poi_id
						});
						
						// Bind behavior
						switch (poi.type)
						{
							case that.APIPOIEnum.Waypoint:
							{
								marker.on("mouseout", function()
								{
									// Workaround a null pointer exception when changing zones
									try { this._icon.src = U.URL_IMG.Waypoint; } catch (e) {}
								});
								marker.on("mouseover", function()
								{
									this._icon.src = U.URL_IMG.WaypointOver;
								});
								zoneobj.Layers.Waypoint.addLayer(marker);
							} break;
							case that.APIPOIEnum.Landmark:
							{
								marker.on("mouseout", function()
								{
									try { this._icon.src = U.URL_IMG.Landmark; } catch (e) {}
								});
								marker.on("mouseover", function()
								{
									this._icon.src = U.URL_IMG.LandmarkOver;
								});
								zoneobj.Layers.Landmark.addLayer(marker);
							} break;
							case that.APIPOIEnum.Vista:
							{
								zoneobj.Layers.Vista.addLayer(marker);
							} break;
						}
						// Clicking on waypoints or POIs gives a chatlink
						if (I.isTouchEnabled === false)
						{
							if (poi.type === that.APIPOIEnum.Waypoint || poi.type === that.APIPOIEnum.Landmark)
							{
								marker.on("click", function()
								{
									that.outputCoordinatesCopy(U.getChatlinkFromPoiID(this.options.id));
									that.outputCoordinatesName(this.options.markername);
								});
								marker.on("dblclick", function()
								{
									if (D.isLanguageDefault)
									{
										U.openExternalURL(U.getWikiLinkLanguage(this.options.markername));
									}
									else
									{
										U.openExternalURL(U.getWikiLinkCode(this.options.id, this.options.markername));
									}
								});
								that.bindMarkerZoomBehavior(marker, "contextmenu", that.ZoomEnum.Sky);
							}
							else
							{
								that.bindMarkerZoomBehavior(marker, "click", that.ZoomEnum.Sky);
								that.bindMarkerZoomBehavior(marker, "contextmenu", that.ZoomEnum.Sky);
							}
						}
					}
					
					/*
					 * For API arrays separate from pois.
					 */
					if (completionboolean)
					{
						// Mastery Insights
						if (apizone.training_points)
						{
							numofpois = apizone.training_points.length;
							nummastery = numofpois;
							icon = U.URL_IMG.Mastery;
							for (i = 0; i < numofpois; i++)
							{
								poi = apizone.training_points[i];
								marker = L.marker(that.convertGCtoLC(poi.coord),
								{
									title: "<span class='" + "mapPoi" + "'>" + translationmastery + "</span>",
									icon: L.icon(
									{
										iconUrl: icon,
										iconSize: [16, 16],
										iconAnchor: [8, 8]
									})
								});
								that.bindMarkerZoomBehavior(marker, "click", that.ZoomEnum.Sky);
								that.bindMarkerZoomBehavior(marker, "contextmenu", that.ZoomEnum.Sky);
								zoneobj.Layers.Mastery.addLayer(marker);
								P.addMapLocation(poi.coord, zonename + " " + translationmastery + " " + poi.id, icon, zonename + " " + translationmastery);
							}
						}
						
						// Hero Challenges
						if (apizone.skill_challenges)
						{
							numofpois = apizone.skill_challenges.length;
							numchallenge = numofpois;
							icon = U.URL_IMG.Challenge;
							for (i = 0; i < numofpois; i++)
							{
								poi = apizone.skill_challenges[i];
								marker = L.marker(that.convertGCtoLC(poi.coord),
								{
									title: "<span class='" + "mapPoi" + "'>" + translationchallenge + "</span>",
									icon: L.icon(
									{
										iconUrl: icon,
										iconSize: [16, 16],
										iconAnchor: [8, 8]
									})
								});
								that.bindMarkerZoomBehavior(marker, "click", that.ZoomEnum.Sky);
								that.bindMarkerZoomBehavior(marker, "contextmenu", that.ZoomEnum.Sky);
								zoneobj.Layers.Challenge.addLayer(marker);
								P.addMapLocation(poi.coord, zonename + " " + translationchallenge + " " + poi.idx, icon, zonename + " " + translationchallenge);
							}
						}
						
						// Renown Hearts
						if (apizone.tasks)
						{
							numofpois = apizone.tasks.length;
							numheart = numofpois;
							icon = U.URL_IMG.Heart;
							for (i = 0; i < numofpois; i++)
							{
								poi = apizone.tasks[i];
								marker = L.marker(that.convertGCtoLC(poi.coord),
								{
									title: "<span class='" + "mapPoi" + "'>" + poi.objective + " (" + poi.level + ")" + "</span>",
									wiki: poi.objective,
									icon: L.icon(
									{
										iconUrl: icon,
										iconSize: [16, 16],
										iconAnchor: [8, 8]
									})
								});
								M.bindMarkerWikiBehavior(marker, "click");
								M.bindMarkerZoomBehavior(marker, "contextmenu", that.ZoomEnum.Sky);
								zoneobj.Layers.Heart.addLayer(marker);
								P.addMapLocation(poi.coord, poi.objective, icon, zonename + " " + translationheart);

								// Heart Area
								area = L.polygon(that.convertGCtoLCMulti(poi.bounds), {
									clickable: false,
									color: "#ffc321",
									weight: 2,
									opacity: 0.8,
									fillOpacity: 0.1
								});
								zoneobj.Layers.HeartArea.addLayer(area);
								
								// Highlight the heart's area when hovered over its icon
								(function(iArea)
								{
									marker.on("mouseover", function() { iArea.setStyle({ color: "lime" }); })
										.on("mouseout", function() { iArea.setStyle({ color: "#ffc321" }); });
								})(area);
							}
						}
						
						// Sector Names
						if (apizone.sectors)
						{
							numofpois = apizone.sectors.length;
							icon = U.URL_IMG.Sector;
							for (i = 0; i < numofpois; i++)
							{
								poi = apizone.sectors[i];
								marker = L.marker(that.convertGCtoLC(poi.coord),
								{
									clickable: false,
									icon: L.divIcon(
									{
										className: "mapSec",
										html: "<span class='mapSecIn'>" + poi.name + "</span>",
										iconSize: [512, 64],
										iconAnchor: [256, 32]
									})
								});
								zoneobj.Layers.Sector.addLayer(marker);
								P.addMapLocation(poi.coord, poi.name, icon, zonename + " " + translationsector);

								// Sector Area
								area = L.polyline(that.convertGCtoLCMulti(poi.bounds), {
									clickable: false,
									color: "white",
									weight: 2,
									opacity: 0.8
								});
								zoneobj.Layers.SectorArea.addLayer(area);
							}
						}
						
						that.isMappingIconsGenerated = true;
					}
					
					// Generate locations overview for this zone
					if (completionboolean)
					{
						marker = L.marker(that.convertGCtoLC(zoneobj.center),
						{
							mappingzone: zoneobj.nick,
							riseOnHover: true,
							icon: L.divIcon(
							{
								className: "mapOverview",
								html: "<span class='mapOverviewIn'>"
									+ "<var class='mapOverviewName'>" + D.getObjectName(zoneobj) + "</var>"
									+ ((apizone.min_level > 0) ? ("<var class='mapOverviewLevel'>"
										+ ((apizone.min_level === 80) ? (apizone.max_level) : (apizone.min_level + " - " + apizone.max_level))
									+ "</var>") : "")
									+ ((numheart > 0) ? ("<img src='img/map/heart.png' />" + numheart + " ") : "")
									+ ((numwaypoint > 0) ? ("<img src='img/map/waypoint.png' />" + numwaypoint + " ") : "")
									+ ((numlandmark > 0) ? ("<img src='img/map/landmark.png' />" + numlandmark + " ") : "")
									+ ((numchallenge > 0) ? ("<img src='img/map/challenge.png' />" + numchallenge + " ") : "")
									+ ((numvista > 0) ? ("<img src='img/map/vista.png' />" + numvista) : "")
									+ ((nummastery > 0) ? ("<img src='img/map/mastery.png' />" + nummastery + " ") : "")
								+ "</span>",
								iconSize: [256, 64],
								iconAnchor: [128, 32]
							})
						});
						that.bindOverviewBehavior(marker, "click");
						that.bindOverviewBehavior(marker, "contextmenu");
						that.Layer.Overview.addLayer(marker);
						that.toggleLayer(that.Layer.Overview, true);
					}
				}
			}
		};
		
		// Temporary use of cache until PoF zones are added back by Anet
		$.getJSON(U.URL_DATA.Maps, function(pBackup)
		{
			doPopulate(pBackup);
			finalizePopulate(true);
		});
		return;
		/*
		 * Retrieve map data from API.
		 */
		$.getJSON(url, function(pData)
		{
			doPopulate(pData);
			finalizePopulate(true);
		}).fail(function()
		{
			I.isAPIEnabled = false;
			// If failed to get from API then use backup cache
			if (that.MapEnum === P.MapEnum.Tyria)
			{
				if (I.ModeCurrent === I.ModeEnum.Website)
				{
					I.urge(
						"ArenaNet API server is unreachable. <a" + U.convertExternalAnchor(U.URL_API.Support + "?source=map") + ">Check status</a>.<br />"
						+ "Map will use backup cache and features will be limited.<br />");
				}
				
				$.getJSON(U.URL_DATA.Maps, function(pBackup)
				{
					doPopulate(pBackup);
					finalizePopulate(true);
				});
			}
			else
			{
				finalizePopulate(false);
			}
		});
	},
	
	/*
	 * Generates icons and rings for all dynamic events.
	 */
	populateEvents: function()
	{
		// Function to filter out unwanted events
		var isEventUnwanted = function(pName)
		{
			var blacklist = [
				"scarlet", "molten all", "overdue emi", "aetherblade", "queen's cha", "mordrem inv", "offshoot", "vigil eng", "haunted", // Obsolete events
				"stabilize the rift", // Rift events
				"guild", // Guild missions
				"subdue", // Guild bounty
				"bounty", // Path of Fire bounties
				"hero cha" // Hero challenges
			];
			for (var i = 0; i < blacklist.length; i++)
			{
				if (pName.indexOf(blacklist[i]) !== -1)
				{
					return true;
				}
			}
			return false;
		};
		
		// Function to guess an event's icon (not provided by the API) based on its name
		var determineEventIcon = function(pName)
		{
			if (pName.indexOf("free") !== -1) return "release";
			if (pName.indexOf("rescue") !== -1) return "release";
			if (pName.indexOf("capture") !== -1) return "flag";
			if (pName.indexOf("retake") !== -1) return "flag";
			if (pName.indexOf("reclaim") !== -1) return "flag";
			if (pName.indexOf("liberate") !== -1) return "flag";
			if (pName.indexOf("protect") !== -1) return "shield";
			if (pName.indexOf("defend") !== -1) return "shield";
			if (pName.indexOf("escort") !== -1) return "shield";
			if (pName.indexOf("kill") !== -1) return "boss";
			if (pName.indexOf("slay") !== -1) return "boss";
			if (pName.indexOf("defeat") !== -1) return "boss";
			if (pName.indexOf("collect") !== -1) return "collect";
			if (pName.indexOf("help") !== -1) return "star";
			if (pName.indexOf("destroy") !== -1) return "cog";
			if (pName.indexOf("gather") !== -1) return "collect";
			if (pName.indexOf("bring") !== -1) return "collect";
			if (pName.indexOf("recover") !== -1) return "collect";
			if (pName.indexOf("return") !== -1) return "collect";
			if (pName.indexOf("retrieve") !== -1) return "collect";
			if (pName.indexOf("salvage") !== -1) return "collect";
			if (pName.indexOf("treasure") !== -1) return "fist";
			return "swords";
		};
		var iconURL = {
			release: "img/event/release.png",
			flag: "https://render.guildwars2.com/file/A4F01E7A5E90382F0ACFA71348E4241900529EB5/102321.png",
			shield: "https://render.guildwars2.com/file/4D52C9605D6F19D3B6FB00D39E95EC45C3FCB62C/102387.png",
			boss: "https://render.guildwars2.com/file/9C97043218F4EF1205B6FB5503CFCCA038D607E1/102392.png",
			collect: "https://render.guildwars2.com/file/7695C3055956ACCC4D7F273F59B2120B0CB123B0/102330.png",
			star: "https://render.guildwars2.com/file/F6B0F9F82D1D3A000D1827E3EA59A7D734141004/102388.png",
			cog: "https://render.guildwars2.com/file/92BC536037C0AA531E9019D7AB3A23C71805FB99/102393.png",
			fist: "https://render.guildwars2.com/file/9005555700262173FB6506A12204776AAEC6A40F/102391.png",
			swords: "https://render.guildwars2.com/file/98EB189CADF825549B187C57B551CE1AA29CA694/102320.png"
		};
		
		// Function to store event names for filtering
		var initializeEvents = function(pEventData)
		{
			var id;
			for (id in pEventData.events)
			{
				P.Events[id] = {};
				P.Events[id].name = pEventData.events[id].name;
			}
		};
		
		// Function to filter events and generate event markers
		var generateEvents = function(pData)
		{
			// Retrieve the event details in the default language for filtering events
			$.getJSON(U.URL_API.EventDetails, function(pDataInner)
			{
				var i;
				var event;
				var searchname;
				var newname;
				var marker, label, area, icon;
				var coord, coordmarker, areacoords, radius, trueradius;
				var instructionstr = D.getPhraseOriginal("Drag to separate") + ". " + D.getPhraseOriginal("Double click for wiki") + ".";

				var zoneobj, zonename;
				initializeEvents(pData || pDataInner);

				for (i in pDataInner.events)
				{
					event = pDataInner.events[i];
					searchname = event.name.toLowerCase();
					newname = (P.Events[i] !== undefined) ? P.Events[i].name : event.name;
					zoneobj = M.getZoneFromID(event.map_id);
					zonename = D.getObjectName(zoneobj);
					// Skip iterated event if...
					if ( ! zoneobj // Event is not in a world map zone
						|| isEventUnwanted(searchname) // Event is obsolete
						|| event.map_id === 50) // LA
					{
						continue;
					}
					
					coord = M.getEventCenter(event);
					coordmarker = M.convertGCtoLC(coord);

					// Create event's area if coordinates are available, otherwise create a circle
					if (event.location.points)
					{
						areacoords = M.convertEventCoordMulti(event.location.points, zoneobj);
						area = L.polygon(M.convertGCtoLCMulti(areacoords), {
							clickable: false,
							color: "#ff8844",
							weight: 2,
							opacity: 0.8,
							fillOpacity: 0.1
						});
						zoneobj.Layers.EventArea.addLayer(area);
					}
					else
					{
						trueradius = (event.location.radius || 1) * T.cUNITS_TO_POINTS;
						radius = M.getZoomedDistance(trueradius);
						area = L.circleMarker(coordmarker, {
							trueradius: trueradius,
							radius: radius,
							clickable: false,
							color: "#ff8844",
							weight: 2,
							opacity: 0.8,
							fillOpacity: 0.1
						});
						zoneobj.Layers.EventCircle.addLayer(area);
					}
					
					// Create event's label
					label = L.marker(coordmarker,
					{
						clickable: false,
						icon: L.divIcon(
						{
							className: "mapSec",
							html: "<span class='mapSecIn'>" + newname + "</span>",
							iconSize: [128, 128],
							iconAnchor: [64, 64]
						})
					});
					zoneobj.Layers.EventLabel.addLayer(label);

					// Use API's icon type if available, otherwise guess
					if (event.icon)
					{
						icon = U.getAPIImage(event.icon.signature + "/" + event.icon.file_id);
					}
					else
					{
						icon = iconURL[determineEventIcon(searchname)];
					}
					marker = L.marker(coordmarker,
					{
						title: "<span class='mapPoi'><dfn>" + newname + "</dfn> (" + event.level + ")<br /><cite>" + instructionstr + "</cite></span>",
						wiki: event.name,
						coord: coord,
						eventid: i,
						icon: L.icon(
						{
							iconUrl: icon,
							iconSize: [48, 48],
							iconAnchor: [24, 24]
						}),
						draggable: true
					});
					
					// Highlight the event's area when hovered over its icon
					(function(iLabel, iArea)
					{
						marker.on("mouseover", function() { iArea.setStyle({ color: "red" }); })
							.on("mouseout", function() { iArea.setStyle({ color: "#ff8844" }); })
							.on("drag", function()
						{
							iLabel.setLatLng(this.getLatLng());
						});
					})(label, area);
					
					// Bind standard behaviors
					M.bindMarkerCoordBehavior(marker, "click", true);
					M.bindMarkerWikiBehavior(marker, "dblclick", true);
					M.bindMarkerZoomBehavior(marker, "contextmenu");
					zoneobj.Layers.EventIcon.addLayer(marker);
					P.addMapLocation(coord, event.name, icon, zonename + " " + event.name);
				}
				M.isEventIconsGenerated = true;

			}).done(function()
			{
				P.donePopulation();
			}).always(function()
			{
				P.finishPopulation();
			});
		};
		
		/*
		 * Before generating the events, all event names must be collected first
		 * so obsolete events can be filtered. Non-default languages has to download
		 * the event data twice because the filter keywords are in the default language.
		 */
		if (D.isLanguageDefault)
		{
			generateEvents();
		}
		else
		{
			// Store the event names in user's language
			$.getJSON(U.getLangURL(U.URL_API.EventDetails), function(pData)
			{
				generateEvents(pData);
			}).fail(function()
			{
				P.finishPopulation();
			});
		}
	},
	
	/*
	 * Does final touches to the map after the icons have been generated.
	 */
	donePopulation: function()
	{
		M.refreshCurrentZone();
	},
	finishPopulation: function()
	{
		// Do visual changes
		M.isMapAJAXDone = true;
		M.bindMapVisualChanges();
		M.adjustZoomMapping();
		P.adjustZoomDryTop();
		P.initializeMapSearch();
		
		// Execute query string commands if available
		if (I.PageInitial !== "wvw")
		{
			M.executeURLCommands();
		}
	},
	
	/*
	 * Compiles a searchable database of API map locations like hearts and events.
	 * @pre Locations were completely downloaded.
	 */
	initializeMapSearch: function()
	{
		$("#mapZoneButton").one("mouseenter", function()
		{
			I.preventMapPropagation("#mapSearch");
			Q.bindItemSearch("#mapSearch", {
				aDatabase: P.LocationsDatabase,
				aResultsClass: "mapSearchResults",
				aResultsLimit: 200,
				aCallback: function(pLocation)
				{
					M.goToView(pLocation.coord, M.ZoomEnum.Same, M.Pin.Program);
				}
			});
		});
	},
	
	/*
	 * Conditions needed to do the initial zoom to event on pageload.
	 * @returns true if qualify.
	 */
	wantTourPrediction: function()
	{
		if (I.isMapEnabled
			&& O.Options.bol_tourPrediction && I.ModeCurrent !== I.ModeEnum.Overlay
			&& (I.PageCurrent === I.PlateEnum.Chains || I.PageCurrent === I.PlateEnum.Directory)
			&& C.isDryTopIconsShown === false
			&& !(U.Args[U.KeyEnum.Go]))
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Initializes an array of nodes, which is an indexed marker with an associated path.
	 * @param array pNodeArray reference to initialize.
	 * @param int length for the array.
	 * @returns array of empty nodes.
	 */
	createNodeArray: function(pLength)
	{
		var nodearray = new Array(pLength);
		for (var i = 0; i < pLength; i++)
		{
			nodearray[i] = {
				oMarker: null,
				oPath: null
			};
		}
		return nodearray;
	},
	
	/*
	 * Toggles visibility of map objects of a node.
	 * @param array pNodeArray.
	 * @param int pIndex to find node.
	 * @param boolean pBoolean to show.
	 */
	toggleNode: function(pNodeArray, pIndex, pBoolean)
	{
		if (pNodeArray[pIndex])
		{
			M.toggleLayer(pNodeArray[pIndex].oMarker, pBoolean);
			M.toggleLayer(pNodeArray[pIndex].oPath, pBoolean);
		}
	},
	toggleNodeArray: function(pNodeArray, pBoolean)
	{
		for (var i = 0; i < pNodeArray.length; i++)
		{
			M.toggleLayer(pNodeArray[i].oMarker, pBoolean);
			M.toggleLayer(pNodeArray[i].oPath, pBoolean);
		}
	},
	
	/*
	 * Gets ID of a Leaflet layer.
	 * @param object pLayer.
	 * @returns string ID number.
	 */
	getLayerId: function(pLayer)
	{
		return pLayer["_leaflet_id"];
	},
	
	/*
	 * Gets the object containing the layers.
	 * @param object pLayerGroup
	 * @returns object iterable.
	 */
	getLayerGroup: function(pLayerGroup)
	{
		return pLayerGroup["_layers"];
	},
	
	/*
	 * Sorts an array of GW2 coordinates.
	 * @param 2D array pArray to sort.
	 */
	sortCoordinates: function(pCoords, pIsNumbered)
	{
		var coord;
		// Convert to integer
		for (var i in pCoords)
		{
			coord = pCoords[i];
			coord[0] = Math.round(coord[0]);
			coord[1] = Math.round(coord[1]);
		}
		// Sort the array
		pCoords.sort(function (a, b)
		{
			if (a[0] > b[0])
			{
				return 1;
			}
			if (a[0] < b[0])
			{
				return -1;
			}
			return 0;
		});
		// Print the result formatted
		if (pIsNumbered)
		{
			for (var i in pCoords)
			{
				this.printNumberedCoordinates(pCoords[i], i);
			}
		}
		else
		{
			return pCoords;
		}
	},
	roundCoordinates: function(pCoords, pIsPair)
	{
		var coord;
		// Convert to integer
		for (var i in pCoords)
		{
			coord = pCoords[i];
			coord[0] = Math.round(coord[0]);
			coord[1] = Math.round(coord[1]);
		}
		// Print the result formatted
		this.printCoordinates(pCoords, pIsPair);
	},
	printNeedles: function(pNeedles)
	{
		for (var i in pNeedles)
		{
			this.printNumberedCoordinates((pNeedles[i]).c, i);
		}
	},
	printNodes: function(pCoords, pIsNumbered)
	{
		for (var i = 0; i < pCoords.length; i++)
		{
			var numprefix = (pIsNumbered) ? ("n: " + (i+1) + ", ") : "";
			I.print("{" + numprefix + "c: [" + (pCoords[i])[0] + ", " + (pCoords[i])[1] + "]},");
		}
	},
	printNumberedCoordinates: function(pCoord, i)
	{
		I.print("{n: " + (parseInt(i)+1) + ", c: [" + pCoord[0] + ", " + pCoord[1] + "]},");
	},
	formatCoord: function(pCoord)
	{
		return "[" + pCoord[0] + ", " + pCoord[1] + "]";
	},
	compileCoordinates: function(pCoords, pIsPair)
	{
		var output = "";
		var spacing = (pIsPair) ? " " : "";
		var sepstr;
		for (var i = 0; i < pCoords.length; i++)
		{
			sepstr = (i < pCoords.length - 1) ? ((pIsPair && ((i+1) % 2 === 0)) ? ("]],<br />") : ((pIsPair && (i % 2 === 0)) ? "], " : "],")) : "]";
			output += (pCoords[i] === null) ? "null," : "[" + ((pIsPair && (i % 2 === 0)) ? "[" : "") + (pCoords[i])[0] + "," + spacing + (pCoords[i])[1] + sepstr;
		}
		return (pIsPair ? "[<br />" : "[") + output + (pIsPair ? "]<br />]" : "]");
	},
	printCoordinates: function(pCoords, pIsPair)
	{
		I.print(this.compileCoordinates(pCoords, pIsPair));
	},
	
	/*
	 * Prints a series of text inputs for the user to copy waypoint chatlinks
	 * that are closest to each personal pins.
	 * @returns int number of waypoints to be used.
	 */
	printClosestWaypoints: function()
	{
		var CHATLINKS_PER_MESSAGE = 12; // Maximum to fit chat message limit
		var DISTANCE_MINIMUM = 500; // The distance between two coordinates must be greater than this to include a new waypoint
		var html = "";
		var chatlink;
		var chatlinks = [""]; // First element is a dummy for comparison
		var coordpin;
		var coordprev = [0, 0];
		var distancetoprevious = 0;
		var zone, waypoint;
		
		M.Layer.PersonalPin.eachLayer(function(iLayer)
		{
			coordpin = M.convertLCtoGC(iLayer.getLatLng());
			zone = M.getZoneFromCoord(coordpin);
			if (zone !== null)
			{
				waypoint = M.getClosestLocation(coordpin, zone.Layers.Waypoint);
				chatlink = "";
				if (waypoint !== null)
				{
					chatlink = U.getChatlinkFromPoiID(waypoint.options.id);
					distancetoprevious = P.getDistanceBetweenCoords(coordpin, coordprev);
					// Don't append consecutively duplicate waypoints or if distance between is too short
					if (chatlinks[chatlinks.length - 1] !== chatlink && distancetoprevious > DISTANCE_MINIMUM)
					{
						chatlinks.push(chatlink);
					}
					coordprev = coordpin;
				}
			}
		});
		chatlinks.shift(); // Remove the first dummy element
		
		if (chatlinks.length > 0)
		{
			// A message contains a limited quantity of chatlinks/waypoints
			var nummessages = Math.ceil(chatlinks.length / CHATLINKS_PER_MESSAGE);
			var numwaypoints = 0;
			var html = "<div id='jsWaypointLinks'>Copy the codes below and<br />paste them in game chat to <br />follow the route:<br />";
			for (var i = 0; i < nummessages; i++)
			{
				// Each message gets its own input box
				html += "<input type='text'  class='cssInputText' value='";
				for (var ii = CHATLINKS_PER_MESSAGE * i;
						ii < (CHATLINKS_PER_MESSAGE * (i+1));
						ii++)
				{
					if (numwaypoints >= chatlinks.length)
					{
						// If reached the end of the array
						break;
					}
					html += " " + (ii+1) + "-&gt;" + chatlinks[ii]; // Chatlinks divider
					numwaypoints++;
				}
				html += "' /> Message " + (i+1) + "<br />";
			}
			html += "</div>";
			
			// Output the input boxes containing the chatlinks
			I.print(html, true);
			I.bindInputSelect("#jsWaypointLinks .cssInputText");
			I.bindConsoleInput();
		}
		else
		{
			I.write("Pins must first be placed and be inside zones in order to create chatlinks.");
		}
		// Return the number of waypoints
		return numwaypoints;
	},
	
	/*
	 * Gets the distance between two points.
	 * @param array pCoordA.
	 * @param array pCoordB.
	 * @returns float distance.
	 */
	getDistanceBetweenCoords: function(pCoordA, pCoordB)
	{
		return Math.sqrt(Math.pow(pCoordA[0] - pCoordB[0], 2) + Math.pow(pCoordA[1] - pCoordB[1], 2));
	},
	getUnitsBetweenCoords: function(pCoordA, pCoordB)
	{
		return Math.floor(P.getDistanceBetweenCoords(pCoordA, pCoordB) * T.cPOINTS_TO_UNITS);
	},
	
	/*
	 * Gets a nearest neighbor path from an array of coordinates.
	 * @param 2D array pCoords of GW2 coordinates.
	 * @param int pStart index of the optional starting coordinate.
	 * @returns 2D array path.
	 */
	getGreedyPath: function(pCoords, pStart)
	{
		var array = pCoords;
		if (pStart !== undefined)
		{
			// Do initial swapping for selected starting coordinates
			var temp = array[0];
			array[0] = array[pStart];
			array[pStart] = temp;
		}
		
		var currentcoord = array[0];
		var indexofclosest = 0;
		var length = array.length;
		
		for (var i = 0; i < length; i++)
		{
			var prevmindistance = Number.POSITIVE_INFINITY;
			// Scan through coordinates and find the closest to the current point
			for (var ii = i; ii < length; ii++)
			{
				var ithdistance = P.getDistanceBetweenCoords(currentcoord, array[ii]);
				if (ithdistance <= prevmindistance)
				{
					indexofclosest = ii;
					prevmindistance = ithdistance;
				}
			}
			/*
			 * Rewrite the array with the closest adjacent points, example:
			 * [A, B, C, D, E] where B was found to be closest to A, and C was
			 * found closest to B in the order they were scanned.
			 */
			currentcoord = array[indexofclosest];
			array[indexofclosest] = array[i];
			array[i] = currentcoord;
		}
		
		return array;
	},
	
	/*
	 * Gets the user opted color for drawing generic paths.
	 */
	getUserPathColor: function()
	{
		return U.stripToColorString(O.Options.str_colorPersonalPath);
	},
	getUserPathOpacity: function()
	{
		return O.Options.int_opacityPersonalPath / 100;
	},
	refreshPersonalPath: function()
	{
		if (M.isMapInitialized)
		{
			M.drawPersonalPath();
		}
		if (W.isMapInitialized)
		{
			W.drawPersonalPath();
		}
	},
	
	/*
	 * Draws a path with each link of increasing or decreasing thickness, to
	 * simulate a worm crawling in a direction.
	 * @param array pCoords GW2 coordinates.
	 * @param boolean pIsObverse or reversed.
	 * @returns LayerGroup path.
	 * @pre Path has enough links to distinguish themselves.
	 */
	drawDirectedPath: function(pCoords, pIsObverse, pColor)
	{
		if (pIsObverse === undefined)
		{
			pIsObverse = true;
		}
		var latlngs = M.convertGCtoLCMulti(pCoords);
		var layergroup = new L.layerGroup();
		var numofsegments = 8;
		var ithickness = (pIsObverse) ? 0 : numofsegments-1;
		pColor = pColor || "lime";
		
		for (var i = 0; i < latlngs.length - 1; i++)
		{
			layergroup.addLayer(L.polyline([latlngs[i], latlngs[i+1]], {color: pColor, weight: (ithickness+2)*2}));
			ithickness = (pIsObverse) ? (ithickness+1) : (ithickness-1);
			if (pIsObverse && ithickness >= numofsegments)
			{
				ithickness = 0;
			}
			else if ( ! pIsObverse && ithickness < 0)
			{
				ithickness = numofsegments-1;
			}
		}
		return layergroup;
	},
	
	/*
	 * Draws spots representing an interactable item in the game world.
	 * @param array pCoords GW2 coordinates.
	 * @param object pOptions Leaflet marker options.
	 * @returns LayerGroup circles.
	 */
	drawSpots: function(pCoords, pOptions)
	{
		var latlngs = M.convertGCtoLCMulti(pCoords);
		var layergroup = new L.layerGroup();
		var marker;
		var Options = {radius: 10, color: "lime", weight: 4};
		if (pOptions !== undefined)
		{
			for (var i in pOptions)
			{
				Options[i] = pOptions[i];
			}
		}
		
		for (var i in latlngs)
		{
			marker = L.circleMarker(latlngs[i], Options);
			M.bindMarkerZoomBehavior(marker, "click");
			layergroup.addLayer(marker);
		}
		return layergroup;
	},
	
	/*
	 * Draws a map completion route for the current moused zone, using the
	 * personal pins system.
	 * @param object pZone
	 */
	drawCompletionRoute: function(pZone)
	{
		if (M.isItineraryRetrieved)
		{
			var path = (pZone) ? pZone.path : M.ZoneCurrent.path;
			M.redrawPersonalPath(path);
		}
		else
		{
			// If route data is not loaded, load it and execute this function again
			U.getScript(U.URL_DATA.Itinerary, function()
			{
				for (var i in GW2T_COMPLETION_DATA)
				{
					M.Zones[i].path = GW2T_COMPLETION_DATA[i].path;
				}
				M.isItineraryRetrieved = true;
				P.drawCompletionRoute(pZone);
			});
		}
	},
	
	/*
	 * Prints the current zone's event names and coordinates.
	 */
	printZoneEvents: function()
	{
		if (M.isEventIconsGenerated)
		{
			// Sort the zone events by X coordinates
			var arr = [];
			M.ZoneCurrent.Layers.EventIcon.eachLayer(function(iLayer)
			{
				iLayer.oSortableCoord = iLayer.options.coord[0];
				arr.push(iLayer);
			});
			U.sortObjects(arr, {aKeyName: "oSortableCoord"});
			// Print the coordinates and event names
			var console = I.getConsole();
			arr.forEach(function(iLayer)
			{
				var obj = iLayer.options;
				$("<div class='mapEventListEntry'><input type='text' class='cssInputText' value='" + obj.eventid + "' /> "
					+ "<input type='text' class='cssInputText' value='[" + obj.coord + "]' /> "
					+ "<a" + U.convertExternalAnchor(C.getEventWiki(obj.wiki)) + ">[W]</a> "
					+ "<dfn class='cssGameTitle' data-coord='" + obj.coord + "'>" + obj.wiki + "</dfn></div>")
				.appendTo(console).data("keywords", obj.wiki.toLowerCase());
			});
			I.print("");
			M.bindMapLinks("#itemConsole");
			I.bindConsoleInput();
			// Create search bar
			var search = $("<div class='cntSearchContainer'></div>").prependTo(console);
			I.createFilterBar(search, ".mapEventListEntry");
		}
		else
		{
			I.write("Event icons have not been generated.");
		}
	},
	
	/*
	 * Generates border rectangles on initial call. Otherwise toggle visibility.
	 */
	drawZoneBorders: function()
	{
		if (O.Options.bol_showZoneBorders
			&& P.Layer.ZoneBorder.getLayers().length === 0)
		{
			for (var i in M.Zones)
			{
				var zoneobj = M.Zones[i];
				// Cover the zone with a colored border signifying its region
				P.Layer.ZoneBorder.addLayer(L.rectangle(
					M.convertGCtoLCMulti(zoneobj.continent_rect), {
						fill: false,
						color: M.Regions[zoneobj.region].color,
						weight: 2,
						clickable: false
					}
				));
			}
		}
		M.toggleLayer(P.Layer.ZoneBorder, O.Options.bol_showZoneBorders);
	},
	
	/*
	 * Generates gateway icons on initial call. Otherwise toggle visibility.
	 */
	drawZoneGateways: function()
	{
		if (O.Options.bol_showZoneGateways
			&& P.Layer.ZoneGateway.getLayers().length === 0)
		{
			var marker, path;
			var connection = GW2T_GATEWAY_CONNECTION;
			var launchpads = connection.launchpads;
			
			// pCoord may be a single coordinate, or two coordinates 2D array
			var createGate = function(pCoord, pImage, pOpacity, pTitle)
			{
				var coordA = pCoord;
				var coordB;
				if (Array.isArray(pCoord[0]))
				{
					coordA = pCoord[0];
					coordB = pCoord[1];
				}
				var options = {
					icon: L.icon(
					{
						iconUrl: pImage,
						iconSize: [32, 32], // Initial size corresponding to default zoom level
						iconAnchor: [16, 16]
					}),
					opacity: pOpacity || 0.6,
					title: pTitle
				};
				if (coordB)
				{
					options.rotationAngle = M.convertDirectionAngle(coordA, coordB) + T.cCIRCLE_RIGHT_DEGREE;
				}
				var marker = L.marker(M.convertGCtoLC(coordA), options);
				M.bindMarkerZoomBehavior(marker, "click");
				M.bindMarkerZoomBehavior(marker, "contextmenu");
				return marker;
			};
			
			var drawGates = function(pGates, pName, pPathColor, pIsAngled)
			{
				var icon = "img/map/gateway_" + pName + I.cPNG;
				for (var i in pGates)
				{
					// Draw the two gates
					if (pIsAngled)
					{
						marker = createGate(pGates[i], icon);
						P.Layer.ZoneGateway.addLayer(marker);
						marker = createGate(pGates[i].reverse(), icon);
						P.Layer.ZoneGateway.addLayer(marker);
					}
					else
					{
						for (var ii in pGates[i])
						{
							marker = createGate((pGates[i])[ii], icon);
							P.Layer.ZoneGateway.addLayer(marker);
						}
					}
					// Draw the line connecting the gates
					if (pPathColor)
					{
						path = L.polyline(M.convertGCtoLCDual(pGates[i]),
						{
							color: pPathColor,
							opacity: 0.2
						});
						P.Layer.ZoneGateway.addLayer(path);
					}
				}
			};
			
			var drawPowerups = function(pPowerups, pName)
			{
				for (var i in pPowerups)
				{
					marker = L.marker(M.convertGCtoLC(pPowerups[i].c), {
						icon: L.icon(
						{
							iconUrl: "img/map/" + pName + I.cPNG,
							iconSize: [32, 32], // Initial size corresponding to default zoom level
							iconAnchor: [16, 16]
						})
					});
					M.bindMarkerZoomBehavior(marker, "click");
					M.bindMarkerZoomBehavior(marker, "contextmenu");
					P.Layer.ZonePowerup.addLayer(marker);
					P.Layer.ZoneGateway.addLayer(marker);
				}
			};
			
			drawGates(connection.interborders, "interborders");
			drawGates(connection.interzones, "interzones", "purple");
			drawGates(connection.intrazones, "intrazones", "white", true);
			drawPowerups(connection.powerups, "powerup");
			// One-way "gate" special case
			launchpads.forEach(function(iLaunchpad)
			{
				var tooltip = (iLaunchpad.i) ? "<div class='mapLoc'><img src='" + iLaunchpad.i + "' /></div>" : null;
				// Draw the launchpad (first inner coordinates)
				marker = createGate(iLaunchpad.c, "img/map/launchpad.png", 1, tooltip);
				P.Layer.ZoneLaunchpad.addLayer(marker);
				P.Layer.ZoneGateway.addLayer(marker);
				// Draw the line trajectory
				path = L.polyline(M.convertGCtoLCDual(iLaunchpad.c),
				{
					color: "gold",
					opacity: 0.2
				});
				P.Layer.ZoneGateway.addLayer(path);
			});
			P.rebindMarkerTooltips();
		}
		M.toggleLayer(P.Layer.ZoneGateway, O.Options.bol_showZoneGateways);
		M.adjustZoomMapping();
	},
	
	/*
	 * Creates polylines for the map based on event's path data, then add event
	 * coordinates to the event names HTML so the map views the location when
	 * user clicks on it.
	 */
	drawChainPaths: function(pChain)
	{
		if (I.isMapEnabled === false) { return; }
		var i;
		var event, primaryevent;
		var color;
		var coords;
		var pathline;
		
		if (pChain.series !== C.ChainSeriesEnum.DryTop)
		{
			for (i = 0; i < pChain.primaryEvents.length; i++)
			{
				primaryevent = pChain.primaryEvents[i];

				switch (i)
				{
					case 0: color = "red"; break;
					case 1: color = "orange"; break;
					case 2: color = "yellow"; break;
					case 3: color = "lime"; break;
					case 4: color = "cyan"; break;
					case 5: color = "blue"; break;
					case 6: color = "violet"; break;
					case 7: color = "purple"; break;
					default: color = "white";
				}

				/*
				 * An event's path in the Chains object is an array of coordinates
				 * (which are themselves array of two numbers x and y). For primary
				 * events: the first entry is the event's location, the rest is
				 * the visual path of the step. Nonprimary events contain
				 * only a single entry, that is, their location.
				 */
				if ((primaryevent.path[0])[0] < 0) // If the first entry has negative coordinates, then the paths are meant to be points rather than connected lines
				{
					for (var ii = 1; ii < primaryevent.path.length; ii++)
					{
						pathline = L.circleMarker(M.convertGCtoLC(primaryevent.path[ii]), {
							clickable: false,
							radius: 8,
							color: "red",
							weight: 2,
							opacity: 0.8,
							fillOpacity: 0.1
						});
						M.Zones[(pChain.zone)].Layers.Path.addLayer(pathline);
					}
				}
				else // Draw a connected path
				{
					coords = M.convertGCtoLCMulti(primaryevent.path, 1);
					pathline = L.polyline(coords, {color: color});
					M.Zones[(pChain.zone)].Layers.Path.addLayer(pathline);
				}
			}
		}
		// Remember final event coordinate
		// Remember primary event coordinate
		var prim = pChain.primaryEvents;
		pChain.finalCoord = prim[(prim.length - 1)].path[0];

		/*
		 * Go to the event location when clicked on event name.
		 */
		var eventnum;
		for (i in pChain.events)
		{
			event = pChain.events[i];
			eventnum = event.num;
			if (eventnum.indexOf(".") !== -1)
			{
				// jQuery thinks the period is a class, escape it
				eventnum = eventnum.replace(".", "\\.");
			}
			$("#chnEvent_" + pChain.nexus + "_" + eventnum).each(function()
			{
				// Assign a data attribute to the event name
				var firstcoord = event.path[0];
				var coord = firstcoord;
				if (firstcoord[0] < 0)
				{
					coord = [Math.abs(firstcoord[0]), Math.abs(firstcoord[1])];
				}
				$(this).attr("data-coord", coord[0] + "," + coord[1]);
				$(this).attr("data-eventindex", i);
				// Read the attribute and use the coordinate when clicked for touring
				if (I.ModeCurrent !== I.ModeEnum.Mobile)
				{
					M.bindMapLinkBehavior($(this), M.ZoomEnum.Ground, M.Pin.Event);
				}
			});
		}
	},
	isChainPathsAllowed: function()
	{
		return (O.Options.bol_showChainPaths && I.PageCurrent !== I.PlateEnum.Map && I.ModeCurrent !== I.ModeEnum.Overlay);
	},
	
	/*
	 * Creates event icons for Dry Top chains, they will be resized by the zoomend function
	 */
	generateDryTop: function()
	{
		U.getScript(U.URL_DATA.DryTop, function()
		{
			C.DryTop = GW2T_DRYTOP_EVENTS;
			var i, ii;
			var chain, event, marker;
			
			if (I.isMapEnabled)
			{
				// Event nicks are independent of the events themselves and are always shown on the map
				for (i in C.DryTop)
				{
					event = C.DryTop[i];
					marker = L.marker(M.convertGCtoLC(event.coord),
					{
						clickable: false,
						icon: L.divIcon(
						{
							className: "mapNick",
							html: "<span class='mapNickIn'>" + D.getObjectName(event)
								+ "<br /><var class='mapDryTopTimestamp' style='color:" + event.color + "'>" + event.time + "</var></span>",
							iconSize: [512, 64],
							iconAnchor: [256, 32]
						})
					});
					P.Layer.DryTopNicks.addLayer(marker);
				}
				M.toggleLayer(P.Layer.DryTopNicks, true);

				// Timer integrated on the map
				P.DryTopTimer = L.marker(M.convertGCtoLC(M.getZoneCenter("dry")),
				{
					clickable: false,
					icon: L.divIcon(
					{
						className: "mapNick",
						html: "<div class='mapNickIn' id='mapDryTopInfo'><span id='mapDryTopTimer'></span><br />"
							+ "<input id='mapDryTopClip0' type='text' /> "
							+ "<input id='mapDryTopClip1' type='text' /></div>",
						iconSize: [512, 64],
						iconAnchor: [256, 32]
					})
				});
				M.toggleLayer(P.DryTopTimer, true);

				// Create icons
				for (i in C.DryTopChains)
				{
					chain = C.DryTopChains[i];
					for (ii in chain.events)
					{
						event = chain.events[ii];

						event.eventring = L.marker(M.convertGCtoLC(event.path[0]),
						{
							zIndexOffset: M.cZIndexBury,
							clickable: false,
							icon: L.icon(
							{
								iconUrl: "img/event/ring/" + event.ring + I.cPNG,
								iconSize: [32, 32],
								iconAnchor: [16, 16]
							})
						});
						event.eventicon = L.marker(M.convertGCtoLC(event.path[0]),
						{
							title: "<span class='mapEvent'><dfn>" + D.getObjectName(event) + "</dfn></span>",
							wiki: D.getObjectName(event),
							icon: L.icon(
							{
								iconUrl: "img/event/" + event.icon + I.cPNG,
								iconSize: [16, 16],
								iconAnchor: [8, 8]
							})
						});
						M.bindMarkerWikiBehavior(event.eventicon, "click");
						M.bindMarkerZoomBehavior(event.eventicon, "contextmenu");
						// Show only current event icons, the highlight event function will continue this
						if ($("#chnEvent_" + chain.nexus + "_" + event.num).hasClass("chnEventCurrent"))
						{
							P.LayerArray.DryTopActive.push(event.eventicon);
							P.LayerArray.DryTopActive.push(event.eventring);
							M.toggleLayer(event.eventring, true);
							M.toggleLayer(event.eventicon, true);
						}

						P.LayerArray.DryTopRings.push(event.eventring);
						P.LayerArray.DryTopIcons.push(event.eventicon);
					}
				}
				P.rebindMarkerTooltips();
			}
			I.loadImg($("#sectionChains_Drytop"));
			
			// Clipboard
			for (var i = 0; i < 2; i++)
			{
				I.bindClipboard("#chnDryTopWaypoint" + i);
				I.bindClipboard("#mapDryTopClip" + i);
			}
			
			// Finally
			C.isDryTopGenerated = true;
			T.initializeDryTopStrings();
			P.toggleDryTopIcons(true);
		});
	},
	
	/*
	 * Shows or hides Dry Top associated map markers.
	 * @param boolean pBoolean.
	 */
	toggleDryTopIcons: function(pBoolean)
	{
		if (C.isDryTopGenerated && I.isMapEnabled)
		{
			C.isDryTopIconsShown = pBoolean;
			M.toggleLayer(P.Layer.DryTopNicks, pBoolean);
			M.toggleLayer(P.DryTopTimer, pBoolean);
			if (pBoolean)
			{
				M.toggleLayerArray(P.LayerArray.DryTopActive, pBoolean);
				P.adjustZoomDryTop();
				I.qTip.init($("#mapDryTopClip0, #mapDryTopClip1").click(function()
				{
					$(this).select();
				}).hover(
					function() { M.isMouseOnHUD = true; },
					function() { M.isMouseOnHUD = false; }
				));
			}
			else
			{
				M.toggleLayerArray(P.LayerArray.DryTopIcons, pBoolean);
				M.toggleLayerArray(P.LayerArray.DryTopRings, pBoolean);
			}
		}
		K.updateDryTopClipboard();
	},
	
	/*
	 * Resizes Dry Top markers so they scale with the current zoom level.
	 */
	adjustZoomDryTop: function()
	{
		if (C.isDryTopIconsShown)
		{
			var i;
			var currentzoom = M.Map.getZoom();
			var icon, iconsize, ringsize;
			var nickfontsize, nickopacity;

			switch (currentzoom)
			{
				case 7: iconsize = 32; nickfontsize = 20; nickopacity = 0.9; break;
				case 6: iconsize = 28; nickfontsize = 16; nickopacity = 0.8; break;
				case 5: iconsize = 24; nickfontsize = 12; nickopacity = 0.8; break;
				case 4: iconsize = 20; nickfontsize = 0; nickopacity = 0; break;
				case 3: iconsize = 16; nickfontsize = 0; nickopacity = 0; break;
				default:
				{
					iconsize = 0; nickfontsize = 0; nickopacity = 0;
				}
			}
			
			// Event icons are same size as waypoints, but their rings are bigger
			ringsize = M.scaleDimension(M.cRING_SIZE_MAX);

			for (i in P.LayerArray.DryTopIcons)
			{
				// Icons
				icon = P.LayerArray.DryTopIcons[i];
				M.resizeMarkerIcon(icon, iconsize);
				// Rings
				icon = P.LayerArray.DryTopRings[i];
				M.resizeMarkerIcon(icon, ringsize);
			}
			
			P.Layer.DryTopNicks.eachLayer(function(iLayer)
			{
				if (iLayer._icon)
				{
					iLayer._icon.style.fontSize = nickfontsize + "px";
					iLayer._icon.style.opacity = nickopacity;
					iLayer._icon.style.zIndex = M.cZIndexBury + 1; // Don't cover other icons
					iLayer._icon.style.display = "table"; // For middle vertical alignment
				}
			});
			P.DryTopTimer._icon.style.fontSize = Math.ceil(nickfontsize * 1.5) + "px";
			P.DryTopTimer._icon.style.opacity = nickopacity;
			P.DryTopTimer._icon.style.zIndex = M.cZIndexRaise + 1;
			P.DryTopTimer._icon.style.display = "table";
		}
	},
	
	/*
	 * Loads a new zone (ingame map instance) if haven't already.
	 * @param int pID
	 * @param object pMapObject
	 */
	loadSubzone: function(pID, pMapObject)
	{
		var that = pMapObject;
		var subzones = that.Subzones;
		if (subzones[pID] !== undefined)
		{
			return;
		}
		subzones[pID] = {};
		$.getJSON(U.getAPIMap(pID), function(pData)
		{
			// Initialize the added zone
			subzones[pID] = {
				map_rect: pData.map_rect,
				continent_rect: pData.continent_rect,
				floors: pData.floors,
				center: that.computeZoneCenter(pData)
			};
			var namekey = "name_" + D.langPartiallySupported;
			(subzones[pID])[namekey] = pData.name;
		}).fail(function()
		{
			I.warn("zone ID: " + pID);
		});
	},
	
	/*
	 * Checks whether the player is in a Tyria or a Mists associated zone then
	 * switch the map automatically if it is not already displayed.
	 */
	switchMapCheck: function()
	{
		if (GPSIdentityJSON === undefined || GPSIdentityJSON === null)
		{
			return;
		}
		
		var previousmap = P.MapSwitchGPS;
		var currentnick = GPSIdentityJSON["map_id"];
		var htmlidprefix = "#" + P.MapSwitchWebsite;
		
		// Get the map the player is in
		if (M.ZoneAssociation[currentnick] !== undefined)
		{
			P.MapSwitchGPS = P.MapEnum.Tyria;
		}
		else if (W.ZoneAssociation[currentnick] !== undefined)
		{
			P.MapSwitchGPS = P.MapEnum.Mists;
		}
		
		// If the player has changed the map in game and the website's map is different from it, then switch the website's map
		if (O.Options.bol_switchMap && P.MapSwitchGPS !== previousmap && P.MapSwitchGPS !== P.MapSwitchWebsite)
		{
			$(htmlidprefix + "SwitchButton").trigger("click");
		}
	},
	
	/*
	 * Imitates the character pin as in the game minimap, as informed by the overlay.
	 * This function is shared by the Tyria and Mists maps.
	 * @param int pForceCode 1 to force update position, -1 angle, 0 both, undefined neither.
	 */
	updateCharacter: function(pForceCode)
	{
		var that;
		var followenum = O.Options["int_setFollow" + P.MapSwitchSuffix];
		var displayboolean = O.Options["bol_displayCharacter" + P.MapSwitchSuffix];
		switch (P.MapSwitchWebsite)
		{
			case P.MapEnum.Tyria: { that = M; } break;
			case P.MapEnum.Mists: { that = W; if (W.isWvWLoaded === false) { return; } } break;
		}
		
		/*
		 * Validate the GPS data before allowing updates. Sample structure:
		 * GPSPositionArray or fAvatarPosition or "character coordinates": [-81.31199, 22.930353, 305.7106]
		 * GPSDirectionArray or fAvatarFront or "character angle": [-0.08111322, 0, 0.9967049]
		 * GPSPerspectiveArray or fCameraPosition or "camera coordinates": [-90.5499, 28.430332, 294.4064]
		 * GPSCameraArray or fCameraFront or "camera angle": [0.60616076, -0.28702924, 0.74174345]
		 * GPSIdentityJSON or identity:
		 * {"name": "Character Name","profession": 1,"race": 2,"map_id": 38,"world_id": 1234567890,"team_color_id": 9,"commander": false,"fov": 0.873}
		 */
		if (GPSPositionArray === undefined || GPSPositionArray === null || GPSPositionArray.length !== 3 || that.isUserDragging)
		{
			return;
		}
		if (GPSIdentityJSON === undefined || GPSIdentityJSON === null)
		{
			return;
		}
		if (P.MapSwitchGPS !== P.MapSwitchWebsite)
		{
			return;
		}
		var zone;
		var zoneid = GPSIdentityJSON["map_id"];
		if (that.isZoneValid(zoneid))
		{
			zone = that.getZoneFromID(zoneid);
			if (that.GPSisInstance)
			{
				that.GPSisInstance = false;
				if (that.isFloorShown)
				{
					that.changeFloor();
				}
			}
		}
		else if (that.isSubzoneValid(zoneid))
		{
			zone = that.Subzones[zoneid];
			that.GPSisInstance = true;
		}
		else
		{
			P.loadSubzone(zoneid, that);
			that.movePin(that.Pin.Character);
			that.movePin(that.Pin.Camera);
			return;
		}
		var coord = that.convertGPSCoord(GPSPositionArray, zone);
		
		var iscoordchanged = false;
		var iszonechanged = false;
		// Character has moved
		if (that.GPSPreviousCoord[0] !== coord[0] || that.GPSPreviousCoord[1] !== coord[1])
		{
			iscoordchanged = true;
			that.GPSPreviousCoord = coord;
			document.getElementById(P.MapSwitchWebsite + "CoordinatesMouse").value = coord[0] + ", " + coord[1];
		}
		// Zone has changed
		if (that.GPSPreviousZoneID !== zoneid)
		{
			iszonechanged = true;
			that.GPSPreviousZoneID = zoneid;
			if (that.GPSisInstance)
			{
				if (that.isFloorShown)
				{
					that.changeFloor(zone.floors[0]);
				}
			}
		}
		
		// Follow character if detected change
		if ((followenum === O.IntEnum.Follow.Character && iscoordchanged) || pForceCode >= 0)
		{
			that.Map.setView(that.convertGCtoLC(coord), that.Map.getZoom());
			that.showCurrentZone(coord);
			pForceCode = -1; // Also update pin position
		}
		if (followenum === O.IntEnum.Follow.Zone && iszonechanged && that.ZoneAssociation[zoneid])
		{
			that.refreshView(zone.center);
			that.showCurrentZone(zone.center);
			pForceCode = -1; // Also update pin position
		}
		
		// Pin character if opted and angle has changed (character turned)
		if (displayboolean)
		{
			var anglecharacter = -(that.convertGPSAngle(GPSDirectionArray));
			var anglecamera = -(that.convertGPSAngle(GPSCameraArray));
			if (that.GPSPreviousAngleCharacter !== anglecharacter
				|| that.GPSPreviousAngleCamera !== anglecamera
				|| pForceCode <= 0)
			{
				if (P.isGPSPrinting)
				{
					I.clear();
					I.print("Coord: " + P.formatCoord(coord) + "<br />"
						+ "Position: " + U.formatJSON(GPSPositionArray) + "<br />"
						+ "Direction: " + U.formatJSON(GPSDirectionArray) + "<br />"
						+ "Perspective: " + U.formatJSON(GPSPerspectiveArray) + "<br />"
						+ "Camera: " + U.formatJSON(GPSCameraArray)
					);
					I.prettyJSON(GPSIdentityJSON);
					if (J.isProjectionInitialized)
					{
						J.Camera.lookAt(new THREE.Vector3(GPSCameraArray[0], GPSCameraArray[1], GPSCameraArray[2]));
					}
				}
				that.movePin(that.Pin.Character, coord);
				that.movePin(that.Pin.Camera, coord);
				that.Pin.Camera._icon.style.zIndex = that.cZIndexBury;
				that.Pin.Camera._icon.style.pointerEvents = "none"; // Don't let this marker overlap pin
				that.Pin.Character.setRotationAngle(anglecharacter);
				that.Pin.Camera.setRotationAngle(anglecamera);
				that.GPSPreviousAngleCharacter = anglecharacter;
				that.GPSPreviousAngleCamera = anglecamera;
			}
		}
	},
	
	/*
	 * Executes GPS functions every specified milliseconds.
	 */
	tickGPS: function()
	{
		if (O.Options["int_setFollow" + P.MapSwitchSuffix]
			|| O.Options["bol_displayCharacter" + P.MapSwitchSuffix])
		{
			P.updateCharacter();
			window.clearTimeout(P.GPSTimeout);
			P.GPSTimeout = setTimeout(function()
			{
				P.tickGPS();
			}, O.Options.int_msecGPSRefresh);
		}
	}
};
G = {
/* =============================================================================
 * @@Generate content for the sections on Map page
 * ========================================================================== */

	/*
	 * Initializes or regenerates the daily achievements box.
	 */
	generateAndInitializeDailies: function()
	{
		var calendar = $("#dlyCalendar");
		var now = new Date();
		
		// Regenerate the whole section
		$("#dlyHeader, #dlyCalendar, #dlyActivity").empty();
		I.removeThrobber("#dlyContainer");
		$("#dlyHeader").html(T.formatWeektime(now));
	
		// Daily countdown
		T.isChecklistCountdownsStarted = true;
		
		// Generate daily achievement boxes
		G.fillDailyCalendar(calendar, now);
	},
	fillDailyCalendar: function(pContainer, pDate, pIsVertical)
	{
		var calendar = $(pContainer);
		var finalizeDailies = function()
		{
			calendar.find(".dlyBox:first").addClass("dlyCurrent").next().addClass("dlyNext");
			calendar.find(".dlyZoom").each(function()
			{
				M.bindMapLinkBehavior($(this), M.ZoomEnum.Sky, M.Pin.Program);
			});
			I.bindPseudoCheckbox(calendar.find("ins"));
			I.qTip.init(calendar.find("ins"));
			I.removeThrobber(calendar.parent());
			
			// Create achievement tooltips
			Q.bindAchievement(".dly");
		};
		
		G.createDailyBookmarks(calendar);
		calendar.after(I.cThrobber);
		T.getDaily().done(function()
		{
			G.insertDailyDay(calendar, T.DailyToday, pDate, pIsVertical); // Today's dailies
			T.getDaily({aWantGetTomorrow: true}).done(function() // Tomorrow's dailies
			{
				G.insertDailyDay(calendar, T.DailyTomorrow, T.addDaysToDate(pDate, 1), pIsVertical);
				finalizeDailies(calendar);
			});
		}).fail(function()
		{
			I.warn("daily achievements");
			I.removeThrobber(calendar.parent());
		});
	},
	createDailyBookmarks: function(pContainer)
	{
		if (I.isMapEnabled === false)
		{
			return;
		}
		
		I.createSearchBar(pContainer, {
			aIsSelect: true,
			aBarClass: "dlyBookmarks",
			aDatabase: T.Daily.Bookmark,
			aFillerText: D.getModifiedWord("bookmarks", "map", U.CaseEnum.Every),
			aCallback: function(pObj)
			{
				M.redrawPersonalPath(pObj.path);
			},
			aCancel: function()
			{
				M.clearPersonalPins();
			}
		});
	},
	
	/*
	 * Inserts a "day" box with all its achievements into a container.
	 * @param object pDaily daily object from general.js
	 * @param object pDate of the day.
	 */
	insertDailyDay: function(pContainer, pDailyObj, pDate, pIsVertical)
	{
		var calendar = $(pContainer);
		// Daily category rows (game modes)
		var pve = pDailyObj["pve"];
		var pvp = pDailyObj["pvp"];
		var wvw = pDailyObj["wvw"];
		var fractals = pDailyObj["fractals"];
		var dayclass = "";
		var activityhtml = "";
		var dailynicks, d0, d1, d2, d3, d4;
		
		// PVE daily nicknames may be suffixed by a region, or prefixed by its daily type
		var parsePVE = function(pDaily)
		{
			dailynicks = pDaily.split(" ");
			d0 = dailynicks[0];
			d1 = dailynicks[1].toLowerCase();
			d2 = (dailynicks.length > 2) ? dailynicks[2].toLowerCase() : "";
			d3 = (dailynicks.length > 3) ? dailynicks[3].toLowerCase() : "";
			d4 = (dailynicks.length > 4) ? dailynicks[4].toLowerCase() : "";
			
			if (d1 === "misc")
			{
				return "<ins class='dly dly_pve_" + d2 + " dlyZoom curZoom' data-ach='" + d0 + "' data-coord='" + d3 + "'></ins>";
			}
			else if (d1 === "jp" || d1 === "adventure" || d1 === "bounty")
			{
				return "<ins class='dlyRegion dly_region_" + d3 + "'>"
					+ "<ins class='dly dly_pve_" + d1 + " dlyZoom curZoom' data-ach='" + d0 + "' data-coord='" + d4 + "'></ins>"
				+ "</ins>";
			}
			else if (d1 === "vista" || d1 === "miner" || d1 === "lumberer" || d1 === "forager")
			{
				return "<ins class='dlyRegion dly_region_" + d2 + "'>"
					+ "<ins class='dly dly_pve_" + d1 + " dlyZoom curZoom' data-ach='" + d0 + "' data-coord='" + d3 + "'></ins>"
				+ "</ins>";
			}
			else if (d1 === "dungeon")
			{
				return "<ins class='dlyRegion dly_region_" + d3 + "'>"
					+ "<ins class='dly dly_pve_dungeon_" + d2 + " dlyZoom curZoom' data-ach='" + d0 + "' data-coord='" + d4 + "'></ins>"
				+ "</ins>";
			}
			else if (d1 === "boss")
			{
				var bosschain = C.getChainByAlias(d2);
				return "<ins class='dlyRegion dly_region_" + C.getChainRegion(bosschain) + "'>"
					+ "<ins class='dly dly_pve_boss dlyZoom curZoom' data-ach='" + d0 + "' data-coord='" + bosschain.finalCoord + "'></ins>"
				+ "</ins>";
			}
			else if (d1 === "event")
			{
				return "<ins class='dlyRegion dly_region_" + M.getZoneRegion(d2) + "'>"
					+ "<ins class='dly dly_pve_event dlyZoom curZoom' data-ach='" + d0 + "' data-coord='" + d2 + "'></ins>"
				+ "</ins>";
			}
			return "";
		};
		
		// PVP daily nicknames may be 1 word long, or 2 words containing the daily professions
		var parsePVP = function(pDaily)
		{
			dailynicks = pDaily.split(" ");
			d0 = dailynicks[0];
			d1 = dailynicks[1].toLowerCase();
			if (dailynicks.length === 2)
			{
				return "<ins class='dly dly_pvp_" + d1 + "' data-ach='" + d0 + "'></ins>";
			}
			
			var dspec = dailynicks[2].toLowerCase();
			return "<ins class='dly dly_pvp_profession_" + d1 + "_0' data-ach='" + d0 + "'><ins class='dly dly_pvp_profession_" + dspec + "_1'></ins></ins>";
		};
		
		// WvW daily nicknames are always 1 word long
		var parseWVW = function(pDaily)
		{
			dailynicks = pDaily.split(" ");
			d0 = dailynicks[0];
			d1 = dailynicks[1].toLowerCase();
			return "<ins class='dly dly_wvw_" + d1 + "' data-ach='" + d0 + "'></ins>";
		};
		
		// Generate the daily icons for each game mode
		var pvestr = "";
		var pvpstr = "";
		var wvwstr = "";
		pve.forEach(function(iDaily)
		{
			pvestr += parsePVE(iDaily);
		});
		pvp.forEach(function(iDaily)
		{
			pvpstr += parsePVP(iDaily);
		});
		wvw.forEach(function(iDaily)
		{
			wvwstr += parseWVW(iDaily);
		});

		// Write the daily box containing the icons
		switch (pDate.getUTCDay())
		{
			case T.DayEnum.Sunday: dayclass = "dlySunday"; break;
			case T.DayEnum.Saturday: dayclass = "dlySaturday"; break;
		}
		var dsbclass = (pIsVertical || pIsVertical === undefined) ? "" : "dlyBoxDashboard";
		// Get daily activity
		var activity = T.Daily.Activity;
		var activityalias = activity.Schedule[pDate.getUTCDay()];
		var activityname = D.getObjectName(activity.Activities[activityalias]);
		// Generate HTML
		activityhtml = "<em class='dlyActivityIconContainer dlyMonthday' title='" + activityname + "'><img class='dlyActivityIcon' src='img/daily/activities/" + activityalias + I.cPNG + "' /></em>";
		var dailybox = $("<div class='dlyBox " + dsbclass + "'>"
			+ "<aside class='dlyMonthdayBackground dlyMonthday'></aside>" + activityhtml + "<a class='dlyMonthdayNumber dlyMonthday " + dayclass + "'"
				+ U.convertExternalAnchor(U.getWikiLinkLanguage(activityname)) + "title='" + activityname + "'>" + pDate.getUTCDate() + "</a>"
			+ "<span class='dlyMode'><ins class='dly dly_daily_pve'></ins>" + pvestr + "</span>"
			+ "<span class='dlyMode'><ins class='dly dly_daily_pvp'></ins>" + pvpstr + "</span>"
			+ "<span class='dlyMode'><ins class='dly dly_daily_wvw'></ins>" + wvwstr + "</span>"
		+ "</div>").appendTo(calendar);
		I.qTip.init(".dlyMonthdayNumber");

		// Insert fractal row
		var fractalmeta = T.Daily.Fractal;
		var insertFractal = function(pType, pIslands, pIDs, pScaleNumbers, pScaleNames)
		{
			dailybox.append("<span class='dlyMode dlyModeFractal'>"
				+ "<ins class='dly dly_daily_fractal" + (pType ? "scale" : "island")  + "'></ins>"
				+ "<ins class='dly chl_fractal chl_" + pIslands[0].toLowerCase() + "' title='" + pIslands[0] + "' " + ((pIDs) ? ("data-ach='" + pIDs[0] + "'") : "") + "></ins>"
				+ "<ins class='dly chl_fractal chl_" + pIslands[1].toLowerCase() + "' title='" + pIslands[1] + "' " + ((pIDs) ? ("data-ach='" + pIDs[1] + "'") : "") + "></ins>"
				+ "<ins class='dly chl_fractal chl_" + pIslands[2].toLowerCase() + "' title='" + pIslands[2] + "' " + ((pIDs) ? ("data-ach='" + pIDs[2] + "'") : "") + "></ins>"
				+ "<a class='dlyFractalScales' title='<dfn>" + pScaleNames + "</dfn>'" + U.convertExternalAnchor(D.getObjectURL(fractalmeta)) + ">" + pScaleNumbers + "</a>"
			+ "</span>");
			I.qTip.init(dailybox.find("ins"));
			I.qTip.init(".dlyFractalScales");
		};
		
		// Gets the highest scale number from an island name
		var getMaxScale = function(pIsland)
		{
			for (var i = fractalmeta.Scale.length - 1; i > 0; i--)
			{
				if (fractalmeta.Scale[i] === pIsland)
				{
					return i + 1; // Zero indexed
				}
			}
			return 1;
		};
		var getIslandFromScale = function(pScale)
		{
			return fractalmeta.Scale[pScale - 1];
		};
		
		// Daily fractal scales
		var scaleids = [fractals[0], fractals[1], fractals[2]]; // The daily scales are located in these API array indexes
		var scaleA = parseInt(T.DailyAssociation[(scaleids[0])]);
		var scaleB = parseInt(T.DailyAssociation[(scaleids[1])]);
		var scaleC = parseInt(T.DailyAssociation[(scaleids[2])]);
		if (scaleA && scaleB && scaleC)
		{
			insertFractal(true,
				[getIslandFromScale(scaleA), getIslandFromScale(scaleB), getIslandFromScale(scaleC)],
				scaleids,
				scaleA + " " + scaleB + " " + scaleC,
				fractalmeta.Scale[scaleA - 1] + " | " + fractalmeta.Scale[scaleB - 1] + " | " + fractalmeta.Scale[scaleC - 1]
			);
		}

		// Daily fractal islands
		var islandids = [fractals[5], fractals[9], fractals[13]]; // The daily islands of the highest scale are located in these API array indexes
		var islandA = T.DailyAssociation[islandids[0]];
		var islandB = T.DailyAssociation[islandids[1]];
		var islandC = T.DailyAssociation[islandids[2]];
		if (islandA && islandB && islandC)
		{
			insertFractal(false,
				[islandA, islandB, islandC],
				islandids,
				getMaxScale(islandA) + " " + getMaxScale(islandB) + " " + getMaxScale(islandC),
				islandA + " | " + islandB + " | " + islandC
			);
		}
		Q.bindAchievement(".chl_fractal");
	},
	
	/*
	 * Populates the map with resource node markers and create HTML checkboxes
	 * to toggle their display on the map.
	 */
	generateAndInitializeResources: function()
	{
		var priceids = [];
		var metadata;
		var opacityclicked = 0.3;
		var pathcolor = P.getUserPathColor();
		var pathopacity = P.getUserPathOpacity();
		var inputwaypoint = I.bindInputSelect("#nod_int_coinWaypointAverage");
		var inputvisit = I.bindInputSelect("#nod_int_secNodeVisitAverage");
		var getNodeState = function(pMarker)
		{
			return X.getChecklistItem(X.Checklists["Resource" + pMarker.options.grade], pMarker.options.index);
		};
		var setNodeState = function(pMarker, pState)
		{
			X.setChecklistItem(X.Checklists["Resource" + pMarker.options.grade], pMarker.options.index, pState);
		};
		var reapplyNodesState = function()
		{
			// Fade the node if state is so in checklist
			for (var i in P.LayerArray.Resource)
			{
				P.LayerArray.Resource[i].eachLayer(function(iLayer)
				{
					if (iLayer instanceof L.Marker && getNodeState(iLayer) === X.ChecklistEnum.Checked)
					{
						iLayer.setOpacity(opacityclicked);
					}
				});
			}
		};
		var bindNodeBehavior = function(pMarker)
		{
			M.bindMarkerZoomBehavior(pMarker, "contextmenu");
			M.bindMarkerCoordBehavior(pMarker, "click");
			pMarker.on("mousedown", function(pEvent)
			{
				switch (pEvent.originalEvent.which)
				{
					case I.ClickEnum.Left:
					{
						if (getNodeState(pMarker) === X.ChecklistEnum.Checked)
						{
							setNodeState(pMarker, X.ChecklistEnum.Unchecked);
							this.setOpacity(1);
						}
						else
						{
							setNodeState(pMarker, X.ChecklistEnum.Checked);
							this.setOpacity(opacityclicked);
						}
					} break;
					case I.ClickEnum.Middle:
					{
						M.createPersonalPin(this.getLatLng(), true);
					} break;
				}
			});
		};
		var refreshResourcePrices = function()
		{
			E.getPrices(priceids, function(pPriceDB)
			{
				for (var i in P.Resources)
				{
					var resource = P.Resources[i];
					var itemid = resource.item;
					if (itemid && pPriceDB[itemid])
					{
						var priceobj = pPriceDB[itemid];
						$("#nodPrice_" + i).html(E.formatCoinStringColored(priceobj.oPriceSell));
						P.Resources[i].price = priceobj.oPriceSellTaxed;
					}
					else
					{
						$("#nodPrice_" + i).html(D.getObjectName(resource));
					}
				}
			}, false);
		};
		var getNodeQuantity = function(pResource, pGrade)
		{
			return (metadata.Yield[pResource.type])[pGrade];
		};
		var initializeNodes = function(pGrade)
		{
			var i, ii;
			var counter = 0;
			var grade = pGrade;
			var resource; // A type of resource, like copper ore
			var layer, marker, path;
			var iconsize = (pGrade === "Rich") ? [32, 32] : [24, 24];
			var iconanchor = (pGrade === "Rich") ? [16, 16] : [12, 12];

			for (i in P.Resources)
			{
				resource = P.Resources[i];
				if (P.Resources[i].price === undefined)
				{
					P.Resources[i].price = 0; // Also initialize price property
				}
				var name = i.toLowerCase();
				var resourcegrade = resource[grade];

				// Permanent Rich/Farm nodes
				if (resourcegrade !== undefined && resourcegrade.length > 0)
				{
					layer = new L.layerGroup();
					for (ii in resourcegrade)
					{
						marker = L.marker(M.convertGCtoLC(resourcegrade[ii].c),
						{
							grade: grade,
							name: i,
							quantity: getNodeQuantity(resource, grade),
							index: counter,
							coord: resourcegrade[ii].c,
							icon: L.divIcon(
							{
								className: "nod" + grade,
								html: "<img src='" + "img/node/" + name + I.cPNG + "' />",
								iconSize: iconsize,
								iconAnchor: iconanchor
							}),
							isNode: true
						});
						bindNodeBehavior(marker);
						// Add to array
						layer.addLayer(marker);
						// Draw path if this node has it
						if (resourcegrade[ii].p !== undefined)
						{
							path = L.polyline(M.convertGCtoLCMulti(resourcegrade[ii].p),
							{
								color: pathcolor,
								dashArray: "5,10",
								opacity: pathopacity
							});
							layer.addLayer(path);
						}
						counter++;
					}
					M.toggleLayer(layer);
					P.Layer["Resource_" + grade + "_" + i] = layer;
					P.LayerArray.Resource.push(layer);
				}
			}
			
			// Initialize checklist for saving nodes clicked state
			X.initializeChecklist(X.Checklists["Resource" + grade], counter);
			reapplyNodesState();
		};
		var displayNodes = function(pCheckbox, pIsExclusive)
		{
			if (pIsExclusive)
			{
				// If want exclusive then hide all other node types before showing only this one
				for (var i in P.Resources)
				{
					$("#nod_" + i).prop("checked", false).trigger("change");
				}
				pCheckbox.prop("checked", true);
			}
			var thisresource = U.getSubstringFromHTMLID(pCheckbox);
			var wantshow = pCheckbox.prop("checked");
			var wantregular = $("#nodShowRegular").prop("checked");
			var wanthotspot = $("#nodShowHotspot").prop("checked");
			M.toggleLayer(P.Layer["Resource_Rich_" + thisresource], wantshow);
			M.toggleLayer(P.Layer["Resource_Permanent_" + thisresource], wantshow);
			M.toggleLayer(P.Layer["Resource_Regular_" + thisresource], (wantshow && wantregular));
			M.toggleLayer(P.Layer["Resource_Hotspot_" + thisresource], (wantshow && wanthotspot));
		};
		var drawResourceRoute = function(pZone)
		{
			var i = 0;
			var coords = [];
			var coord;
			var eastmostcoord = Number.POSITIVE_INFINITY;
			var indexofeastmostcoord;

			var WAYPOINT_COPPER_AVERAGE = inputwaypoint.val();
			var TIME_SECOND_AVERAGE = inputvisit.val();
			var waypointcost = 0;
			var timecost = 0;
			var sumprice = 0;

			// Gather the coordinates of valid resource node markers
			M.Map.eachLayer(function(iLayer)
			{
				if (iLayer instanceof L.Marker && iLayer.options.isNode
					&& getNodeState(iLayer) === X.ChecklistEnum.Unchecked)
				{
					if (pZone && M.isWithinZone(M.ZoneCurrent, iLayer.options.coord) === false)
					{
						return;
					}
					/*
					 * Sum the price with the node's single resource price times the output of the node.
					 * The price was initialized the TP refresh function.
					 * The quantity was initialized by the marker initialization function.
					 */
					sumprice += P.Resources[(iLayer.options.name)].price * iLayer.options.quantity;

					// Find eastmost coordinate to use it as the starting point
					coords.push(iLayer.options.coord);
					coord = (coords[i])[0];
					if (coord < eastmostcoord)
					{
						eastmostcoord = coord;
						indexofeastmostcoord = i;
					}
					i++;
				}
			});
			var numnodes = coords.length;

			if (numnodes > 0)
			{
				// The eastmost coordinates will be the starting point of the optimized path
				M.redrawPersonalPath(P.getGreedyPath(coords, indexofeastmostcoord));
				waypointcost = P.printClosestWaypoints() * WAYPOINT_COPPER_AVERAGE;
				timecost = numnodes * TIME_SECOND_AVERAGE;
				var summary = "Gather Profit: <span class='cssRight'>" + E.formatCoinStringColored(sumprice) + "</span><br />"
					+ "Waypoint Cost: <span class='cssRight'>" + E.formatCoinStringColored(waypointcost) + "</span><br />"
					+ "</br >"
					+ "Net Profit: <span class='cssRight'>" + E.formatCoinStringColored(sumprice - waypointcost) + "</span><br />"
					+ "<br />"
					+ "Nodes to Visit: <span class='cssRight'>" + numnodes + "</span><br />"
					+ "Estimated Time: <span class='cssRight'>" + T.getTimeFormatted({aCustomTimeInSeconds: timecost, aWantLetters: true}) + "</span>";
				I.print(summary);
			}
		};
		
		U.getScript(U.URL_DATA.Resource, function()
		{
			var i;
			var resource;
			P.Resources = GW2T_RESOURCE_DATA;
			metadata = GW2T_RESOURCE_METADATA;
			initializeNodes("Rich"); // Only create rich and permanent node markers initially
			initializeNodes("Permanent");
			
			// Create checkboxes
			for (i in P.Resources)
			{
				resource = P.Resources[i];
				$("#nodResource_" + resource.type).append(
					"<label><input id='nod_" + i + "' type='checkbox' checked='checked' /> <img src='img/node/"
					+ i.toLowerCase() + I.cPNG + "' /> <abbr>" + D.getObjectName(resource) + "</abbr><var id='nodPrice_" + i + "'></var></label>");
				if (resource.item)
				{
					priceids.push(resource.item);
				}
			}
			// Bind checkboxes
			for (i in P.Resources)
			{
				(function(iCheckbox)
				{
					iCheckbox.change(function()
					{
						displayNodes(iCheckbox);
					});
					X.getCheckboxLabel(iCheckbox).dblclick(function()
					{
						displayNodes(iCheckbox, true);
					});
				})($("#nod_" + i));
					
			}
			
			// Bind button to toggle all checkboxes
			$("#mapToggle_Resource").data("checked", true).click(function()
			{
				var bool = I.toggleButtonState($(this));
				for (i in P.Resources)
				{
					$("#nod_" + i).prop("checked", bool).trigger("change");
				}
			});
			
			// Bind button to draw a route from the currently visible and unchecked permanent nodes
			$("#nodRoute").click(function()
			{
				// Clears any pins on the map if already laid, otherwise draw the route
				if (M.isPersonalPinsLaid())
				{
					M.clearPersonalPins();
					return;
				}
				drawResourceRoute();
			}).contextmenu(function(pEvent)
			{
				pEvent.preventDefault();
				drawResourceRoute(M.ZoneCurrent);
			});
			
			// Bind buttons to toggle all checkboxes of that resource category
			$("#nodToggle_ResourceOre").click(function()
			{
				$("#nodResource_Ore input").trigger("click");
			});
			$("#nodToggle_ResourcePlant").click(function()
			{
				$("#nodResource_Plant input").trigger("click");
			});
			$("#nodToggle_ResourceWood").click(function()
			{
				$("#nodResource_Wood input").trigger("click");
			});
			
			// Bind the checkbox to show regular nodes
			$("#nodShowRegular").one("click", function()
			{
				// Only create the non-rich nodes when the user has chosen to show
				initializeNodes("Regular");
			});
			$("#nodShowHotspot").one("click", function()
			{
				initializeNodes("Hotspot");
			});
			$("#nodShowRegular").change(function()
			{
				var wantregular = $(this).prop("checked");
				for (var i in P.Resources)
				{
					var wantshow = $("#nod_" + i).prop("checked");
					M.toggleLayer(P.Layer["Resource_Regular_" + i], (wantshow && wantregular));
				}
			}).trigger("change");
			$("#nodShowHotspot").change(function()
			{
				var wanthotspot = $(this).prop("checked");
				for (var i in P.Resources)
				{
					var wantshow = $("#nod_" + i).prop("checked");
					M.toggleLayer(P.Layer["Resource_Hotspot_" + i], (wantshow && wanthotspot));
				}
			}).trigger("change");
			
			// Bind button to show the clicked map nodes again
			$("#nodUncheck").click(function()
			{
				for (var i in P.LayerArray.Resource)
				{
					P.LayerArray.Resource[i].eachLayer(function(iLayer)
					{
						if (iLayer instanceof L.Marker)
						{
							iLayer.setOpacity(1);
						}
					});
				}
				X.clearChecklist(X.Checklists.ResourceRich);
				X.clearChecklist(X.Checklists.ResourcePermanent);
				X.clearChecklist(X.Checklists.ResourceRegular);
				X.clearChecklist(X.Checklists.ResourceHotspot);
			});
			X.rewrapCheckboxes();
			
			// Bind button to refresh TP prices
			$("#nodRefresh").click(function()
			{
				refreshResourcePrices();
				I.write("Prices refreshed.");
			});
			refreshResourcePrices();
			
			// Map bookmarks
			G.createDailyBookmarks("#nodBookmarks");
			// Pre-show specific grades of nodes if requested
			U.verifyArticle("All", function()
			{
				$("#nodShowRegular, #nodShowHotspot").trigger("click");
			});
			U.verifyArticle("Regular", function()
			{
				$("#nodShowRegular").trigger("click");
			});
			U.verifyArticle("Hotspot", function()
			{
				$("#nodShowHotspot").trigger("click");
			});
		});
	},
	drawResourceRoute: function()
	{
		if ($("#nodMenu").is(":visible") === false)
		{
			I.write("Please view the <a data-page='Resource'>Resource Nodes</a> section first.");
			I.bindConsoleLink();
		}
		$("#nodRoute").trigger("contextmenu");
	},
	
	/*
	 * Populates the map with JP location markers with different color depending
	 * on the difficulty.
	 */
	generateAndInitializeJPs: function()
	{
		var jptype;
		var styleJPNode = function(pNode, pIsChecked)
		{
			var marker = pNode.oMarker;
			var difficulty = marker.options.difficulty;
			var cssclass = (pIsChecked) ? "jpzDifficulty0" : "jpzDifficulty" + difficulty;
			marker.setIcon(new L.icon(
			{
				className: cssclass,
				iconUrl: "img/map/" + (jptype[difficulty]).name + I.cPNG,
				iconSize: [32, 32],
				iconAnchor: [16, 16]
			}));
		};
		
		U.getScript(U.URL_DATA.JP, function()
		{
			jptype = GW2T_JP_DATA.Type;
			P.JPs = GW2T_JP_DATA.JP;
			X.Checklists.JP.length = U.getObjectLength(P.JPs);
			P.NodeArray.JP = P.createNodeArray(X.Checklists.JP.length);
			var jp, jplink, marker, path, translatedname, keywords;
			var pathcolor = P.getUserPathColor();
			var pathopacity = P.getUserPathOpacity();
			
			// Translate headers
			$(".jpzHeader").each(function()
			{
				$(this).text(D.getObjectName(jptype[$(this).attr("data-difficulty")]));
			});
		
			for (var i in P.JPs)
			{
				jp = P.JPs[i];
				translatedname = D.getObjectName(jp);
				/*
				 * Create JP markers.
				 */
				marker = L.marker(M.convertGCtoLC(jp.coord),
				{
					id: jp.id,
					difficulty: jp.difficulty,
					title: "<div class='mapLoc'><dfn>" + D.getObjectName(jptype[jp.difficulty]) + ":</dfn> " + translatedname
						+ "<img src='" + jp.img + "' /></div>"
				});
				P.NodeArray.JP[jp.id].oMarker = marker;
				styleJPNode(P.NodeArray.JP[jp.id]);
				/*
				 * Create JP path, if available.
				 */
				if (jp.path)
				{
					path = L.polyline(M.convertGCtoLCMulti(jp.path),
					{
						color: pathcolor,
						dashArray: "5,10",
						opacity: pathopacity
					});
					P.NodeArray.JP[jp.id].oPath = path;
				}
				
				/*
				 * Create JP HTML entries.
				 */
				keywords = (translatedname + " " + M.getZoneName(jp.zone)).toLowerCase();
				$("<aside class='jpzItem'><dt id='jpz_" + jp.id + "' data-coord='" + jp.coord + "'>" + translatedname + "</dt>"
					+ "<label><input type='checkbox' id='jpzCheck_" + jp.id + "' /></label>"
					+ "&nbsp;<cite><a href='"
					+ U.getYouTubeLink(translatedname) + "'>[Y]</a> <a href='"
					+ U.getWikiLinkObject(jp) + "'>[W]</a></cite>"
					+ "<dd>" + jp.description + "</dd></aside>").data("keywords", keywords)
					.appendTo("#jpzList_" + jp.difficulty);
				jplink = $("#jpz_" + jp.id);
				jplink.attr("title", "<div class='mapLoc'><img src='" + jp.img + "' /></div>");
				M.bindMapLinkBehavior(jplink, M.ZoomEnum.Same);
			}
			P.toggleNodeArray(P.NodeArray.JP, true);
			M.bindMapLinks(".jpzList");
			U.convertExternalLink(".jpzList a");
			I.createFilterBar("#jpzSearch", ".jpzItem");
			I.qTip.init(".jpzList dt");
			X.rewrapCheckboxes();

			// Button to toggle JP markers only
			$("#jpzToggleJP").change(function()
			{
				var state = $(this).prop("checked");
				P.toggleNodeArray(P.NodeArray.JP, state);
				if (state)
				{
					for (var i = 0; i < P.NodeArray.JP.length; i++)
					{
						var node = P.NodeArray.JP[i];
						var state = X.getChecklistItem(X.Checklists.JP, i);
						if (state === X.ChecklistEnum.Unchecked)
						{
							styleJPNode(node);
						}
						else
						{
							// Difficulty 0 is reserved for checked off JPs
							styleJPNode(node, true);
						}
					}
				}
			});
			
			// Button to toggle markers display
			$("#mapToggle_JP").data("checked", true).click(function()
			{
				var bool = I.toggleButtonState($(this));
				$("#jpzToggleJP").prop("checked", bool).trigger("change");
				// Chests are not shown by default
				if ($("#jpzToggleChest").prop("checked"))
				{
					$("#jpzToggleChest").prop("checked", bool).trigger("change");
				}
			});

			P.rebindMarkerTooltips();
			
			/*
			 * Initialize checklist and bind marker and checkboxes together.
			 */
			X.initializeChecklist(X.Checklists.JP, X.Checklists.JP.length);

			// Count completed JPs function
			var updateJPCount = function()
			{
				var completed = X.countChecklist(X.Checklists.JP, X.ChecklistEnum.Checked);
				var total = X.Checklists.JP.length;
				$("#jpzCounter").text(completed + "/" + total);
			};

			// Bind behavior
			for (var i = 0; i < X.Checklists.JP.length; i++)
			{
				$("#jpzCheck_" + i).each(function()
				{
					/*
					 * Read and enact the state of the JP checklist.
					 */
					// Convert the digit at ith position in the checklist string to boolean
					var stateinstring = X.getChecklistItem(X.Checklists.JP, i, U.TypeEnum.isBoolean);
					$(this).prop("checked", stateinstring);
					if (stateinstring === false)
					{
						X.getCheckboxLabel($(this)).prev().removeClass("jpzListNameChecked");
					}
					else
					{
						X.getCheckboxLabel($(this)).prev().addClass("jpzListNameChecked");
						styleJPNode(P.NodeArray.JP[i], true);
					}

				}).change(function()
				{
					// Get the checkbox ID that associates itself with that JP
					var checkboxstate = X.getCheckboxEnumState($(this));
					var checkboxindex = U.getSubintegerFromHTMLID($(this));
					if (checkboxstate === X.ChecklistEnum.Unchecked)
					{
						X.getCheckboxLabel($(this)).prev().removeClass("jpzListNameChecked");
						styleJPNode(P.NodeArray.JP[checkboxindex]);
					}
					else
					{
						X.getCheckboxLabel($(this)).prev().addClass("jpzListNameChecked");
						styleJPNode(P.NodeArray.JP[checkboxindex], true);
					}

					// Rewrite the checklist string by updating the digit at the ID/index
					X.setChecklistItem(X.Checklists.JP, checkboxindex, checkboxstate);
					updateJPCount();

				}).parent().hover(
					// Highlight JP name when hovered over checkbox's label
					function()
					{
						$(this).prev().css({"text-decoration": "underline"}).trigger("mouseenter");
					},
					function()
					{
						$(this).prev().css({"text-decoration": "none"}).trigger("mouseleave");
					}
				);

				/*
				 * Duplicate the behavior of JP checklist and zoom by mirroring the
				 * action of clicking on the JP icon with the associated HTML element.
				 */
				(function(iIndex)
				{
					// Click associated checkbox when clicked
					var marker = P.NodeArray.JP[iIndex].oMarker;
					marker.on("click", function()
					{
						$("#jpzCheck_" + iIndex).trigger("click");
						I.scrollToElement("#jpz_" + this.options.id, {aContainer: "#plateMap"});
					});
					M.bindMarkerZoomBehavior(marker, "contextmenu");
				})(i);
			}

			// The button to clear all JP checkboxes
			$("#jpzUncheckJP").click(function()
			{
				for (i = 0; i < X.Checklists.JP.length; i++)
				{
					$("#jpzCheck_" + i).prop("checked", false)
						.parent().prev().removeClass("jpzListNameChecked");
					styleJPNode(P.NodeArray.JP[i]);
				}
				X.clearChecklist(X.Checklists.JP);

				updateJPCount();
			});
			
			updateJPCount();
			G.generateAndInitializeChests();
		});
	},
	
	/*
	 * Populates the map with chest icons. These are found in the open world and
	 * unrelated to chests found within JPs. Should be run after the JP function.
	 */
	generateAndInitializeChests: function()
	{
		P.Chests = GW2T_JP_DATA.Chest;
		var numofchests = P.Chests.Basic.length + P.Chests.Splendid.length;
		X.initializeChecklist(X.Checklists.Chest, numofchests);
		
		var i, ii;
		var counter = 0;
		var opacityclicked = 0.3;
		var getNodeState = function(pMarker)
		{
			return X.getChecklistItem(X.Checklists.Chest, pMarker.options.index);
		};
		var setNodeState = function(pMarker, pState)
		{
			X.setChecklistItem(X.Checklists.Chest, pMarker.options.index, pState);
		};
		var refreshNodeState = function()
		{
			P.Layer.Chest.eachLayer(function(iMarker)
			{
				if (getNodeState(iMarker) === X.ChecklistEnum.Checked)
				{
					iMarker.setOpacity(opacityclicked);
				}
				else
				{
					iMarker.setOpacity(1);
				}
			});
		};
		var createChestMarker = function(pObject, pType, pID)
		{
			var newtitle = null;
			if (pObject.t)
			{
				newtitle = pObject.t;
			}
			var marker = L.marker(M.convertGCtoLC(pObject.c),
			{
				index: pID,
				icon: L.divIcon(
				{
					className: "mapChest" + pType,
					html: "<img src='" + "img/map/chest.png" + "' />",
					iconSize: [32, 32],
					iconAnchor: [16, 16]
				}),
				title: newtitle
			});
			marker.on("click", function()
			{
				if (getNodeState(this) === X.ChecklistEnum.Checked)
				{
					setNodeState(this, X.ChecklistEnum.Unchecked);
					this.setOpacity(1);
				}
				else
				{
					setNodeState(this, X.ChecklistEnum.Checked);
					this.setOpacity(opacityclicked);
				}
			});
			M.bindMarkerZoomBehavior(marker, "contextmenu");
			P.Layer.Chest.addLayer(marker);
		};
		
		// Create the chests
		for (i in P.Chests)
		{
			for (ii in P.Chests[i])
			{
				createChestMarker((P.Chests[i])[ii], i, counter);
				counter++;
			}
		}

		// Checkbox to toggle chest markers
		$("#jpzToggleChest").change(function()
		{
			M.toggleLayer(P.Layer.Chest, $(this).prop("checked"));
			refreshNodeState();
		});
		
		// The button to "uncheck" all chests
		$("#jpzUncheckChest").click(function()
		{
			X.clearChecklist(X.Checklists.Chest);
			refreshNodeState();
		});
	},
	
	/*
	 * Create list of collectibles and checkbox to toggle their display. The
	 * first checkbox click generates the icon.
	 */
	generateCollectiblesUI: function()
	{
		U.getScript(U.URL_DATA.Collectible, function()
		{
			P.Collectibles = GW2T_COLLECTIBLE_DATA;
			var metadata = GW2T_COLLECTIBLE_METADATA;
			var i;
			var collectible;
			var translatedname, defaultname, samplelink;
			var categories = {};
			
			for (i in P.Collectibles)
			{
				// Create checkboxes
				collectible = P.Collectibles[i];
				categories[collectible.category] = true;
				translatedname = D.getObjectName(collectible);
				defaultname = D.getObjectDefaultName(collectible);
				samplelink = I.cSiteLink + "<dfn>" + X.Collectibles[i].urlkey + "</dfn>";
				$("<div class='cltBox cltBox_" + collectible.category + "'>"
					+ "<label style='color:" + collectible.color + "'>"
						+ "<img id='cltPins_" + i + "' class='cltIcon' src='img/collectible/" + i.toLowerCase() + ".png' /><input id='ned_" + i + "' type='checkbox' /> " + translatedname
					+ "</label>"
					+ "<span class='cltLinks' title='" + samplelink + "' ><cite>"
						+ "<a href='" + U.getYouTubeLink(defaultname) + "'>[Y]</a>&nbsp;"//
						+ "<a href='" + collectible.wiki + "'>[W]</a>&nbsp;"
						+ "<a href='" + collectible.credit + "'>[C]</a>&nbsp;"
						+ "&nbsp;-&nbsp;&nbsp;</cite>"
						+ "<a id='nedUncheck_" + i + "'>Reset</a>"
					+ "</span>"
				+ "</div>").appendTo("#cltList").data("keywords", translatedname.toLowerCase());

				// Clicking a checkbox generates the markers for that collectible type
				$("#ned_" + i).one("click", function()
				{
					var type = U.getSubstringFromHTMLID($(this));
					G.generateCollectibles(type);
					M.goToArguments(P.Collectibles[type].view);
				});
				
				// If article URL query string exists, show collectible of specified index
				U.verifyArticle(X.Collectibles[i].urlkey, function()
				{
					var elm = $("#ned_" + i).trigger("click");
					setTimeout(function()
					{
						I.scrollToElement(elm, {aOffset: -64, aSpeed: "fast"});
					}, 2000);
				});
			}
			U.convertExternalLink("#cltList cite a");
			I.qTip.init(".cltLinks");
			I.createFilterBar("#cltSearch", ".cltBox");
			X.rewrapCheckboxes();
			
			// Create category filter
			for (var i in metadata.Categories)
			{
				(function(iCategory)
				{
					var catimg = metadata.Categories[iCategory];
					$("<button class='cltFilterButton btnTab curToggle' title='Filter: <dfn>" + iCategory + "</dfn>'><img src='" + catimg + "' /></button>")
						.appendTo("#cltFilter").click(function()
					{
						if ($(this).hasClass("btnActive"))
						{
							$(".cltFilterButton").removeClass("btnActive");
							$(".cltBox").show();
						}
						else
						{
							$(".cltFilterButton").removeClass("btnActive");
							$(this).addClass("btnActive");
							$(".cltBox").hide();
							$(".cltBox_" + iCategory).show();
						}
					});
				})(i);
			}
			I.qTip.init(".cltFilterButton");

			// Toggle button will only hide icons, by unchecking the checked boxes
			$("#mapToggle_Collectible").data("checked", false).data("hideonly", true).click(function()
			{
				for (i in P.Collectibles)
				{
					if ($("#ned_" + i).prop("checked"))
					{
						$("#ned_" + i).trigger("click");
					}
				}
			});
			// Scroll to the section now that the list is generated
			I.scrollToElement("#headerMap_Collectible", {aContainer: "#plateMap"});
		});
	},
	
	/*
	 * Generates the markers for a collectible type.
	 * @param string pType of the collectible.
	 */
	generateCollectibles: function(pType)
	{
		var i, ii, number, extreme;
		var pingsimport = U.Args[X.Collectibles[pType].urlkey];
		var collectible = P.Collectibles[pType];
		var ithneedle, markeroptions;
		var unlocktoindex, indextounlock;
		var stateinstring;
		var pathline, pathstyle;
		var markertitle;
		var translatedname = D.getObjectName(collectible);
		var directory = "img/collectible/" + pType.toLowerCase() + "/";
		/*
		 * If the collectible's indexes are associated with special unlock IDs,
		 * then use those IDs instead of the needle's index number.
		 */
		if (collectible.needles[0].u)
		{
			unlocktoindex = {};
			indextounlock = {};
			for (i = 0; i < collectible.needles.length; i++)
			{
				ithneedle = collectible.needles[i];
				unlocktoindex[ithneedle.u] = i + 1;
				indextounlock[i] = ithneedle.u;
			}
		}
		
		var styleCollectibleMarker = function(pMarker, pState)
		{
			if (collectible.iconsize)
			{
				var size = collectible.ringsize || 16;
				pMarker.setIcon(new L.divIcon(
				{
					className: "mapNeedle" + pState,
					html: "<span class='mapNeedleIcon' style='color:" + collectible.color + ";"
						+ "background-image: url(" + pMarker.options.needleLabel + ");"
						+ "background-size: " + collectible.iconsize + "px'></span>",
					iconSize: [size, size],
					iconAnchor: [size/2, size/2]
				}));
			}
			else
			{
				pMarker.setIcon(new L.divIcon(
				{
					className: "mapNeedle" + pState + " mapNeedleExtreme" + pMarker.options.needleExtreme,
					html: "<span style='color:" + collectible.color + "'>"
						+ pMarker.options.needleLabel + "</span>",
					iconSize: [16, 16],
					iconAnchor: [8, 8]
				}));
			}
			// Fade the icon if user marked it as found (clicked it enough times)
			if (pState === X.ChecklistEnum.Found)
			{
				pMarker.setOpacity(0.2);
			}
			else
			{
				pMarker.setOpacity(1);
			}
		};
		var createMarker = function(pCoord, pMarkerOptions)
		{
			var marker = L.marker(M.convertGCtoLC(pCoord), pMarkerOptions);
			styleCollectibleMarker(marker, stateinstring);

			// Bind marker behavior
			marker.on("click", function(pEvent)
			{
				var newstate = X.trackChecklistItem(X.Collectibles[this.options.needleType], this.options.needleIndex);
				var thismarker = this;
				if (collectible.iscushion)
				{
					// For needle sets, clicking one marker will also change all markers of the same set (index)
					P.LayerArray[this.options.needleType].forEach(function(iLayer)
					{
						if (iLayer.options.needleIndex === thismarker.options.needleIndex)
						{
							styleCollectibleMarker(iLayer, newstate);
						}
					});
				}
				else
				{
					styleCollectibleMarker(this, newstate);
				}

				// Update URL bar with list of numbers of checked markers
				var pingsexport = X.getCheckedIndexes(X.Collectibles[this.options.needleType], indextounlock);
				if (pingsexport.length)
				{
					U.updateAddressBar("?" + this.options.needleKey + "=" + pingsexport);
				}
				else
				{
					U.updateQueryString();
				}
			});
			M.bindMarkerCoordBehavior(marker, "click");
			M.bindMarkerZoomBehavior(marker, "contextmenu");

			// Add to array
			P.LayerArray[pType].push(marker);
		};
		
		// Initialize checklist
		X.Collectibles[pType].length = P.Collectibles[pType].needles.length;
		X.initializeChecklist(X.Collectibles[pType], X.Collectibles[pType].length, pingsimport, null, unlocktoindex);
		
		P.LayerArray[pType] = []; // Holds markers (needles)
		P.Layer[pType] = new L.layerGroup(); // Holds path connecting the markers
		
		for (i = 0; i < collectible.needles.length; i++)
		{
			// Read and enact the state of the ith collectible checklist
			number = i + 1;
			ithneedle = collectible.needles[i];
			stateinstring = X.getChecklistItem(X.Collectibles[pType], i);
			if (ithneedle.u && ithneedle.l === undefined)
			{
				ithneedle.l = ithneedle.u.toString();
			}

			markertitle = "<div class='mapLoc'><dfn>" + translatedname + ":</dfn> " + (ithneedle.l ? (ithneedle.l + " (#" + number + ")") : "#" + number)
				+ ((collectible.iscushion) ? "<br />" + D.getObjectName(ithneedle) : "");
			if (ithneedle.s)
			{
				markertitle += "<img src='" + ithneedle.s + "' />";
			}
			if (ithneedle.t)
			{
				markertitle += "<div class='mapTip'>" + ithneedle.t + "</div>";
			}
			markertitle += "</div>";

			// The "extreme" enum indicates the needle is an extremity or sub-extremity of the path
			if ((i === 0 || i === collectible.needles.length - 1))
			{
				extreme = 0;
			}
			else
			{
				extreme = ((ithneedle.e === undefined) ? "" : ithneedle.e);
			}
			// Define marker options before sending it to the create method
			markeroptions = {
				needleExtreme: extreme,
				needleIndex: i,
				needleType: pType,
				needleKey: X.Collectibles[pType].urlkey,
				needleLabel: (collectible.iconsize) ? (directory + ithneedle.i + I.cPNG)
					: ((ithneedle.l === undefined) ? number : ithneedle.l),
				title: markertitle
			};

			if (collectible.iscushion) // Special set of markers without tracing
			{
				for (ii = 0; ii < ithneedle.c.length; ii++)
				{
					createMarker(ithneedle.c[ii], markeroptions);
				}
			}
			else // Regular set of markers with tracing
			{
				createMarker(ithneedle.c, markeroptions);
				// Draw a segment from the current and next needle's coordinates
				if (i < collectible.needles.length - 1 && collectible.wantpath !== false)
				{
					pathstyle = (ithneedle.e === 2) ? "5,15" : "1";
					pathline = L.polyline(M.convertGCtoLCDual([ithneedle.c, (collectible.needles[i+1]).c]),
					{
						color: "lime",
						dashArray: pathstyle,
						opacity: 0.5
					});
					P.Layer[pType].addLayer(pathline);
				}
				// Draw path for the node itself, if provided
				if (ithneedle.p)
				{
					for (ii = 0; ii < ithneedle.p.length - 1; ii++)
					{
						pathline = L.polyline(M.convertGCtoLCDual([ithneedle.p[ii], ithneedle.p[ii+1]]),
						{
							color: "magenta",
							dashArray: "5,15",
							opacity: 0.5
						});
						P.Layer[pType].addLayer(pathline);
					}
				}
			}
		}
		
		// Draw paths from markers numbered low to high
		M.toggleLayerArray(P.LayerArray[pType], true);
		M.toggleLayer(P.Layer[pType], true);
		
		// Bind checkboxes after the markers and paths have been generated for this collectible
		$("#ned_" + pType).change(function()
		{
			var state = $(this).prop("checked");
			var type = U.getSubstringFromHTMLID($(this));
			M.toggleLayerArray(P.LayerArray[type], state);
			M.toggleLayer(P.Layer[type], state);
			// Also views the map location of the collectible if box is checked
			if (state)
			{
				M.goToArguments(P.Collectibles[type].view);
				// Rebind tooltip
				P.rebindMarkerTooltips();
				X.getCheckboxLabel($(this)).addClass("cltCheckedLabel");
			}
			else
			{
				X.getCheckboxLabel($(this)).removeClass("cltCheckedLabel");
			}
			// Special case for ranger pets
			if (pType === "RangerPets")
			{
				G.generatePetsList(collectible.needles, state);
			}
		});
		$("#nedUncheck_" + pType).click(function()
		{
			var type = U.getSubstringFromHTMLID($(this));
			var markers = P.LayerArray[type];
			for (var i in markers)
			{
				styleCollectibleMarker(markers[i], X.ChecklistEnum.Unfound);
			}
			X.clearChecklist(X.Collectibles[type]);
			U.updateQueryString();
		});
		// Clicking on the list icon will draw pins from the collectible path
		$("#cltPins_" + pType).click(function()
		{
			if (M.isPersonalPinsLaid())
			{
				M.clearPersonalPins();
				return;
			}
			var coords = [];
			var testcoord = collectible.needles[0].c;
			if (isNaN(testcoord[0]) === false) // Allow 1D arrays only
			{
				for (var i in collectible.needles)
				{
					coords.push(collectible.needles[i].c);
				}
				M.redrawPersonalPath(coords);
			}
		});
	},
	
	/*
	 * Gets a pings URL containing collectible unlock indexes.
	 * @param object pCollectible checklist.
	 * @param object pUnlockAssoc derived from API.
	 * @returns string URL
	 */
	getCollectibleURL: function(pCollectible, pUnlockAssoc)
	{
		var ids = U.convertAssocToArray(pUnlockAssoc).join(",");
		ids = (ids.length) ? ids : "null";
		return I.cSiteURL + "?" + pCollectible.urlkey + "=" + ids + "&bol_showPanel=false";
	},
	
	/*
	 * Generates a list of pets and their pet skills, on the console.
	 * @param objarray pNeedles from Collectibles object.
	 * @param boolean pState to show or hide.
	 */
	generatePetsList: function(pNeedles, pState)
	{
		var type = "RangerPets";
		var container = $("#cltSublist" + type);
		var list = container.find(".cltSublistContainer");
		container.toggle(pState);
		$(".cltPetIcon").removeClass("cltPetIconFocused");
		// Don't regenerate the list if already did
		if (list.is(":empty") === false)
		{
			I.scrollToElement(container, {aContainer: "#plateMap"});
			return;
		}
		
		var ithneedle, fact, factline;
		var name, wiki, marker, factstr, durationstr, peticon;
		var secstr = D.getWord("s");
		for (var i = 0; i < pNeedles.length; i++)
		{
			ithneedle = pNeedles[i];
			name = D.getObjectName(ithneedle);
			wiki = U.getWikiLinkDefault("Juvenile " + D.getObjectDefaultName(ithneedle));
			peticon = "img/collectible/rangerpets/" + ithneedle.i + I.cPNG;
			var str = "<div class='cltPetBox'><span class='cltPetIcon curToggle' title='" + name + "' style='background-image:url(" + peticon + ")'>" 
				+ "<var class='cltPetIconBackground'>" + I.Symbol.Filler + "</var></span><aside class='cltPetFacts'>";
			for (var ii in ithneedle.a)
			{
				fact = ithneedle.a[ii];
				if (Array.isArray(fact))
				{
					// If a fact is an array containing the buff/condition's: [stackNumber, duration]
					durationstr = "(" + fact[1] + secstr + ")"; // Include stack number if there's more than 1
					factstr = (fact[0] > 1) ? ("<var class='cltPetStack'>" + fact[0] + "</var>" + durationstr) : durationstr;
				}
				else
				{
					factstr = fact;
				}
				str += "<span class='cltPetFact'><img class='cltPetFactIcon' src='img/fact/"
					+ ii + I.cPNG + "' /><var class='cltPetFactText'>" + factstr + "</var></span>";
			}
			str += "</aside></div>";
			factline = $(str).appendTo(list).data("keywords", name.toLowerCase());
			(function(iIndex, iWiki)
			{
				factline.find(".cltPetIcon").click(function()
				{
					// Clicking on the pet icon from the list shows that pet species only
					var ischecked = $(this).hasClass("cltPetIconFocused");
					$(".cltPetIcon").removeClass("cltPetIconFocused");
					if (ischecked)
					{
						// Show all species
						M.toggleLayerArray(P.LayerArray[type], true);
					}
					else
					{
						for (var ii = 0; ii < P.LayerArray[type].length; ii++)
						{
							// Show the clicked species while hiding all others
							marker = (P.LayerArray[type])[ii];
							if (marker.options.needleIndex === iIndex)
							{
								M.toggleLayer(marker, true);
							}
							else
							{
								M.toggleLayer(marker, false);
							}
						}
						$(this).addClass("cltPetIconFocused");
					}
				}).dblclick(function()
				{
					// Double clicking on the pet icon opens the wiki
					U.openExternalURL(iWiki);
				});
			})(i, wiki);
		}
		I.qTip.init(list.find(".cltPetIcon"));
		// Create search bar
		var search = $("<div class='cntSearchContainer'></div>").insertBefore(list);
		I.createFilterBar(search, $(".cltPetBox"));
		// Scroll to the list
		setTimeout(function()
		{
			I.scrollToElement(container, {aContainer: "#plateMap"});
		}, 200);
	},
	
	/*
	 * Create list of guild mission types, and mission checkboxes for each type.
	 * First checkbox click generates the mission's data into the map.
	 */
	generateGuildUI: function()
	{
		var insertMission = function(pBookName, pMission, pIndex)
		{
			var missiontype = D.getObjectName(P.Guild[pBookName]);
			var name = D.getObjectDefaultName(pMission);
			var translatedname = D.getObjectName(pMission);
			var limitstr = (pMission.limit) ? (" - " + pMission.limit) : "";
			var elmid = "gld" + pBookName + "_" + pIndex;
			$("<div class='gld" + pBookName + "'><img class='cssWaypoint' " + I.cClipboardAttribute
				+ "='" + pMission.wp + " " + missiontype + ": " + translatedname + "' src='" + U.URL_IMG.Placeholder + "' /> "
				+ "<dfn id='" + elmid + "' data-coord='[" + pMission.coord[0] + "," + pMission.coord[1] + "]'>" + translatedname + limitstr + "</dfn> "
				+ "<a href='" + U.getYouTubeLink(name) + "'>[Y]</a> "
				+ "<a href='" + U.getWikiLinkLanguage(translatedname) + "'>[W]</a>"
			+ "</div>").appendTo("#gldBook_" + pBookName).data("keywords", translatedname.toLowerCase());
			// Return for binding mission type specific map behavior
			return $("#" + elmid);
		};
				
		var finalizeGuildBook = function(pBookName)
		{
			var bookid = "#gldBook_" + pBookName;
			U.convertExternalLink(bookid + " a");
			I.qTip.init(bookid + " dfn");
			// Initialize clipboard for each waypoint
			$(bookid + " .cssWaypoint").each(function()
			{
				I.bindClipboard($(this));
			});
			// Search bar
			var search = $("<div class='cntSearchContainer'><div>").prependTo(bookid);
			I.createFilterBar(search, ".gld" + pBookName);
		};
		
		var hideGuildMapDrawings = function(pBook)
		{
			M.toggleLayerArray(P.LayerArray["Guild_" + pBook], false);
			$("#gldBook_" + pBook + " dfn").each(function()
			{
				I.toggleHighlight($(this), false);
			});
			if (P.Guild[pBook].usedSubmaps !== undefined)
			{
				M.toggleSubmapArray(P.Guild[pBook].usedSubmaps, false);
			}
		};
		
		U.getScript(U.URL_DATA.Guild, function()
		{
			P.Guild = GW2T_GUILD_DATA;
			var i;
			// Create buttons for each mission type, which generates content when first clicked
			for (i in P.Guild)
			{
				var missiontype = P.Guild[i];
				var translatedname = D.getObjectName(missiontype);
				$("#gldButtons").append("<div class='gldButtonContainer'>"
					+ "<button class='gldButton curToggle btnTab' id='gldButton_" + i
						+ "' style='background-size:cover; background-image:url(img/guild/" + i.toLowerCase() + I.cPNG + ")' "
						+ "title='<dfn>" + translatedname + "</dfn><br />" + I.cSiteLink + "<dfn>guild/" + i.toLowerCase() + "</dfn>'></button>"
					+ "<a class='gldLink cssButton' href='" + U.getYouTubeLink(translatedname) + "'>Y</a>&nbsp;"
					+ "<a class='gldLink cssButton' href='" + D.getObjectURL(missiontype) + "'>W</a>"
					+ "</div>");
				$("#gldBooks").append("<div class='gldBook' id='gldBook_" + i + "'></div>");
			}
			$(".gldBook").hide();
			I.qTip.init("#gldButtons button");
			U.convertExternalLink("#gldButtons a");
			
			// Bind button to show the guild mission type
			$(".gldButton").click(function()
			{
				$(".gldButton").removeClass("btnActive");
				var missiontype = U.getSubstringFromHTMLID($(this));
				var wantshow = true;
				// If current mission type is already showing
				if ($("#gldBook_" + missiontype).is(":visible"))
				{
					hideGuildMapDrawings(missiontype);
					wantshow = false;
				}
				$(".gldBook").hide();
				if (wantshow)
				{
					$(this).addClass("btnActive");
					$("#gldBook_" + missiontype).show();
				}
				I.updateScrollbar();
			});
			
			// Bind button to hide all guild map drawings
			$("#mapToggle_Guild").data("hideonly", true).click(function()
			{
				$(".gldButton").removeClass("btnActive").each(function()
				{
					hideGuildMapDrawings(U.getSubstringFromHTMLID($(this)));
					$(".gldBook").hide();
					I.updateScrollbar();
				});
				M.movePin(M.Pin.Program);
			});
			
			/*
			 * Bounty generation.
			 */
			$("#gldButton_Bounty").one("click", function()
			{
				U.sortObjects(P.Guild.Bounty.data);
				for (var i in P.Guild.Bounty.data)
				{
					var mission = P.Guild.Bounty.data[i];
					var elm = insertMission("Bounty", mission, i);
					
					var layergroup = new L.layerGroup();
					if (mission.paths !== undefined)
					{
						for (var ii in mission.paths)
						{
							layergroup.addLayer(P.drawDirectedPath(mission.paths[ii]));
						}
					}
					if (mission.spawn !== undefined)
					{
						layergroup.addLayer(P.drawSpots(mission.spawn));
					}
					P.LayerArray.Guild_Bounty.push(layergroup);
					
					// Bind this mission's behavior
					elm.attr("title", "<div class='mapLoc'><img src='" + mission.img + "' /></div>")
						.click(function()
					{
						I.toggleHighlight($(this));
						M.toggleLayer(P.LayerArray.Guild_Bounty[U.getSubintegerFromHTMLID($(this))]);
					});
					M.bindMapLinkBehavior(elm, M.invertZoomLevel(mission.coord[2]));
				}
				finalizeGuildBook("Bounty");
			});
			
			/*
			 * Trek generation.
			 */
			$("#gldButton_Trek").one("click", function()
			{
				U.sortObjects(P.Guild.Trek.data);
				for (var i in P.Guild.Trek.data)
				{
					var mission = P.Guild.Trek.data[i];
					var elm = insertMission("Trek", mission, i);
					
					var layergroup = new L.layerGroup();
					layergroup.addLayer(L.polyline(M.convertGCtoLCMulti(mission.path), {color: "gold"}));
					P.LayerArray.Guild_Trek.push(layergroup);
					
					// Bind this mission's behavior
					elm.attr("title", "<div class='mapLoc'><img src='" + mission.img + "' /></div>")
						.click(function()
					{
						I.toggleHighlight($(this));
						M.toggleLayer(P.LayerArray.Guild_Trek[U.getSubintegerFromHTMLID($(this))]);
					});
					M.bindMapLinkBehavior(elm, M.ZoomEnum.Ground, M.Pin.Program);
				}
				finalizeGuildBook("Trek");
			});
			
			/*
			 * Challenge generation.
			 */
			$("#gldButton_Challenge").one("click", function()
			{
				P.Guild.Challenge.usedSubmaps = [];
				U.sortObjects(P.Guild.Challenge.data);
				for (var i in P.Guild.Challenge.data)
				{
					var mission = P.Guild.Challenge.data[i];
					var elm = insertMission("Challenge", mission, i);
			
					// Submap image of interior map
					if (mission.submap !== undefined)
					{
						M.toggleSubmap(mission.submap, false);
						P.Guild.Challenge.usedSubmaps.push(mission.submap);
					}
					
					var layergroup = new L.layerGroup();
					layergroup.addLayer(L.polyline(M.convertGCtoLCMulti(mission.path), {color: "gold"}));
					layergroup.addLayer(P.drawSpots(mission.spawn, {color: "gold"}));
					P.LayerArray.Guild_Challenge.push(layergroup);
					
					// Bind this mission's behavior
					elm.click(function()
					{
						var index = U.getSubintegerFromHTMLID($(this));
						var submap = P.Guild.Challenge.data[index].submap;
						var state = I.toggleHighlight($(this));
						if (submap !== undefined)
						{
							M.toggleSubmap(submap, state);
						}
						M.toggleLayer(P.LayerArray.Guild_Challenge[index]);
					});
					M.bindMapLinkBehavior(elm, M.ZoomEnum.Ground, M.Pin.Program);
				}
				finalizeGuildBook("Challenge");
			});
			
			/*
			 * Rush generation.
			 */
			$("#gldButton_Rush").one("click", function()
			{
				P.Guild.Rush.usedSubmaps = [];
				U.sortObjects(P.Guild.Rush.data);
				for (var i in P.Guild.Rush.data)
				{
					var mission = P.Guild.Rush.data[i];
					var elm = insertMission("Rush", mission, i);
					
					// Submap image of interior map
					if (mission.submap !== undefined)
					{
						M.toggleSubmap(mission.submap, false);
						P.Guild.Rush.usedSubmaps.push(mission.submap);
					}
					
					var layergroup = new L.layerGroup();
					// Path from waypoint to start
					layergroup.addLayer(L.polyline(M.convertGCtoLCMulti(mission.path), {color: "gold"}));
					// Path from start to finish
					layergroup.addLayer(L.polyline(M.convertGCtoLCMulti(mission.track), {color: "lime", dashArray: "5,10"}));
					// Markers for finish chest
					layergroup.addLayer(L.marker(M.convertGCtoLC(mission.finish), {icon: M.createStandardIcon("img/map/chest.png")}));
					// Circles for small traps
					if (mission.traps0 !== undefined)
					{
						layergroup.addLayer(P.drawSpots(mission.traps0, {radius: 5, color: "red", weight: 1, opacity: 1}));
					}
					// Circles for big traps
					if (mission.traps1 !== undefined)
					{
						layergroup.addLayer(P.drawSpots(mission.traps1, {radius: 10, color: "red", weight: 1, opacity: 1}));
					}
					// Circles for flag checkpoints
					layergroup.addLayer(P.drawSpots(mission.flags, {radius: 2, color: "gold", weight: 2, opacity: 1}));
					
					P.LayerArray.Guild_Rush.push(layergroup);
					
					// Bind this mission's behavior
					elm.click(function()
					{
						var index = U.getSubintegerFromHTMLID($(this));
						var submap = P.Guild.Rush.data[index].submap;
						var state = I.toggleHighlight($(this));
						if (submap !== undefined)
						{
							M.toggleSubmap(submap, state);
						}
						M.toggleLayer(P.LayerArray.Guild_Rush[index]);
					});
					M.bindMapLinkBehavior(elm, M.ZoomEnum.Ground, M.Pin.Program);
				}
				finalizeGuildBook("Rush");
			});
			
			/*
			 * Puzzle generation.
			 */
			$("#gldButton_Puzzle").one("click", function()
			{
				P.Guild.Puzzle.usedSubmaps = [];
				U.sortObjects(P.Guild.Puzzle.data);
				for (var i in P.Guild.Puzzle.data)
				{
					var mission = P.Guild.Puzzle.data[i];
					var elm = insertMission("Puzzle", mission, i);
					
					// Submap image of interior map
					if (mission.submap !== undefined)
					{
						M.toggleSubmap(mission.submap, false);
						P.Guild.Puzzle.usedSubmaps.push(mission.submap);
					}
					
					var layergroup = new L.layerGroup();
					// Circles for interactive objects
					layergroup.addLayer(P.drawSpots(mission.interactions, {color: "gold"}));
					// Markers for finish chest
					layergroup.addLayer(L.marker(M.convertGCtoLC(mission.finish), {icon: M.createStandardIcon("img/map/chest.png")}));
					
					P.LayerArray.Guild_Puzzle.push(layergroup);
					
					// Bind this mission's behavior
					elm.click(function()
					{
						var index = U.getSubintegerFromHTMLID($(this));
						var submap = P.Guild.Puzzle.data[index].submap;
						var state = I.toggleHighlight($(this));
						if (submap !== undefined)
						{
							M.toggleSubmap(submap, state);
						}
						M.toggleLayer(P.LayerArray.Guild_Puzzle[index]);
					});
					M.bindMapLinkBehavior(elm, M.ZoomEnum.Ground, M.Pin.Program);
				}
				finalizeGuildBook("Puzzle");
			});
			
			/*
			 * Open the guild mission type if article query string is present.
			 */
			for (i in P.Guild)
			{
				U.verifyArticle(i, function()
				{
					$("#gldButton_" + i).trigger("click");
				});
			}
		});
	}
};
W = {
/* =============================================================================
 * @@World vs World Mists map and objectives, an extension of the M object
 * ========================================================================== */

	MapEnum: "wvw",
	OptionSuffix: "WvW",
	Continent: GW2T_CONTINENT_DATA["wvw"],
	ZoneAssociation: GW2T_LAND_ASSOCIATION,
	Subzones: {},
	cInitialZone: "eternal",
	Floors: [],
	isMappingIconsGenerated: false,
	ZoomEnum:
	{
		Adaptive: -2,
		Same: -1,
		Min: 0,
		Overview: 2,
		Default: 3,
		Space: 2,
		Sky: 4,
		Bird: 5,
		Ground: 6,
		Max: 6
	},
	Layer: {
		Overview: new L.layerGroup(),
		Pin: new L.layerGroup(),
		PersonalPin: new L.layerGroup(),
		PersonalPath: new L.layerGroup(),
		CompassIcon: new L.layerGroup(), // compass icon
		CompassCircle: new L.layerGroup(), // compass radius circle
		Destructible: new L.layerGroup(), // destructibles walls and gates
		Secondaries: new L.layerGroup(), // sentries, shrines, ruins, supply depots
		Objective: new L.layerGroup(), // camps, towers, keeps
		SpawnLabel: new L.layerGroup() // server name over their map spawns
	},
	LayerArray: {
		
	},
	Pin: {
		Program: {},
		Event: {},
		Over: {},
		Character: {},
		Camera: {}
	},
	
	/*
	 * WvW exclusive properties.
	 */
	LocaleThreshold:
	{
		Range: 99,
		AmericasPrefix: "1",
		Americas: 1000,
		Europe: 2000,
		EuropePrefix: "2",
		France: 2100,
		Germany: 2200,
		Spain: 2300
	},
	LocaleEnum:
	{
		Americas: "Americas",
		Europe: "Europe"
	},
	LeaderboardURL: {
		Americas: "https://leaderboards.guildwars2.com/en/na/wvw",
		Europe: "https://leaderboards.guildwars2.com/en/eu/wvw"
	},
	LocaleCurrent: null,
	Rotation: null, // Will refer to an associative array of zone nicks of the current rotation
	LandPrefix: {},
	isWvWPrepped: false,
	isWvWLoaded: false,
	isWvWPaused: false,
	Metadata: {},
	Servers: {}, // Server names and translations
	Matches: null, // For fallback API, array containing objects with same structure as "worlds" subobject in v2 API matches.json
	MatchupCurrent: null, // Formatted superobject containing teams (servers of a color) and reuseable translated strings
	Guilds: {}, // Holds retrieved API guild details objects
	Objectives: {},
	ObjectiveTimeout: {},
	ObjectiveTimestampIgnore: null,
	Compasses: {},
	Placement: {},
	MapType: {}, // Corresponds to "worlds" object from match API
	LandEnum: {}, // Corresponds to "map_type" property of objectives, example: "GreenHome"
	ObjectiveEnum: {}, // Corresponds to "type" property of objectives
	OwnerEnum: {}, // Corresponds to "owner" property from match API, example: "Green"
	MatchupIDCurrent: null,
	isObjectiveTickEnabled: false,
	isObjectiveTimerTickEnabled: false,
	isAPIFailed: false,
	isFallbackEnabled: false,
	numFailedAPICalls: 0,
	cOWNERS_PER_TIER: 3,
	cLEADERBOARD_SERVERS_CHAR_LIMIT: 32,
	cTOTAL_PPT_POSSIBLE: 0, // Will be assigned by the compute function
	cSECONDS_IMMUNITY: 300, // Righteous Indignation time
	cMSECONDS_IMMUNITY: 300000, // 5 minutes
	MatchStartTimeMS: null,
	MatchFinishTimeMS: null,
	MatchFinishTimeISO: null,
	secTillWvWReset: null,
	numSiegeSupply: 0,
	
	/*
	 * Changes variables to match the current borderlands rotation.
	 */
	initializeBorderlands: function()
	{
		// Zone Objects
		W.Rotation = W.Metadata.Rotation;
		for (var i in W.Rotation)
		{
			var landnick = W.Rotation[i];
			W.Zones[landnick] = GW2T_LAND_ADD[landnick];
			W.LandPrefix[i] = W.Zones[landnick].id + "-";
		}
		// Zone List
		$(".wvwZoneListBorderlands").each(function()
		{
			var landnick = W.Rotation[$(this).attr("data-zone")];
			$(this).attr("data-zone", landnick);
		});
	},
	
	/*
	 * Initializes the WvW map and starts the objective state and time functions.
	 */
	initializeWvW: function(pPage)
	{
		/*
		 * Merge W's unique variables and functions with M, and use that new
		 * object as W. This is a shallow copy, so objects within an object that
		 * are not shared/modified must be redeclared here in W.
		 */
		var now = new Date();
		$.extend(W, $.extend({}, M, W));
		W.Regions = GW2T_REALM_DATA;
		W.Zones = GW2T_LAND_DATA;
		W.Servers = GW2T_SERVER_DATA;
		W.Compasses = GW2T_WEAPON_DATA;
		W.Metadata = GW2T_WVW_METADATA;
		W.Placement = GW2T_PLACEMENT_DATA;
		W.MapType = W.Metadata.MapType;
		W.LandEnum = W.Metadata.LandEnum;
		W.ObjectiveEnum = W.Metadata.ObjectiveEnum;
		W.OwnerEnum = W.Metadata.OwnerEnum;
		W.initializeBorderlands();
		
		W.computeObjectivesValue();
		W.initializeObjectives();
		W.initializeMap();
		W.populateWvW();
		W.initializeLeaderboard();
		W.initializeLog();
		W.reinitializeServerChange();
		W.generateServerList();
		I.styleContextMenu("#wvwContext");
		U.convertExternalLink("#wvwHelpLinks a");
		$("#wvwToolsButton").one("mouseenter", W.initializeSupplyCalculator);
		$("#wvwHUDContainer").toggle(O.Options.bol_showHUDWvW);
		
		// Finally
		W.isWvWLoaded = true;
		
		// Show leaderboard the first time if requested by URL
		if (pPage === I.SpecialPageEnum.Leaderboard)
		{
			$("#lboRegion").trigger("click");
		}
		else
		{
			U.openSectionFromURL({aButton: "#lboRegion", aSection: "Leaderboard"});
		}
		
		// Write announcement if available
		var announcement = H.getAnnouncement(H.Announcement.NewsWVW, now);
		if (announcement)
		{
			W.addLogEntry(announcement);
		}
	},
	
	/*
	 * Initializes the objectives object to contain objectives specific to the
	 * current map rotation.
	 */
	initializeObjectives: function()
	{
		var objectivedata = GW2T_OBJECTIVE_DATA;
		for (var i in W.Rotation)
		{
			var landnick = W.Rotation[i];
			var landobjectives = objectivedata[landnick];
			for (var ii in landobjectives)
			{
				W.Objectives[ii] = landobjectives[ii];
			}
		}
	},
	
	/*
	 * Generates the WvW objectives markers and labels.
	 */
	populateWvW: function()
	{
		var obj, marker, subobjclass;
		for (var i in W.Objectives)
		{
			obj = W.Objectives[i];
			subobjclass = (obj.type === W.ObjectiveEnum.Ruins || obj.type === W.ObjectiveEnum.Bloodlust) ? "objSubobjective" : "";
			marker = L.marker(W.convertGCtoLC(obj.coord),
			{
				clickable: true,
				riseOnHover: true,
				icon: L.divIcon(
				{
					className: "",
					html: "<div id='obj_" + obj.id + "' class='objContainer " + subobjclass + "'>"
							+ "<span class='objUmbrellaContainer'><span class='objUmbrellaOuter'><span id='objUmbrella_" + obj.id + "' class='objUmbrella'></span></span></span>"
							+ "<time id='objTimer_" + obj.id + "' class='objTimer'></time>"
							+ "<span class='objProgressContainer'><span id='objProgressBar_" + obj.id
								+ "' class='objProgressBar'><var id='objProgress_" + obj.id + "' class='objProgress'></var></span></span>"
							+ "<span class='objIconContainer'><img id='objIcon_" + obj.id
								+ "' class='objIcon' src='" + U.URL_IMG.Placeholder + "'/></span>"
							+ "<span class='objInfo'><cite id='objClaim_" + obj.id + "' class='objClaim'></cite> <cite id='objAge_" + obj.id + "' class='objAge'></cite></span>"
						+ "</div>",
					iconSize: [38, 38],
					iconAnchor: [19, 19]
				})
			});
			// Show objective's raw information when clicked
			(function(iObj)
			{
				marker.on("click", function()
				{
					if (iObj.data)
					{
						I.prettyJSON(iObj.data);
					}
				});
			})(obj);
			W.bindMarkerZoomBehavior(marker, "contextmenu");
			obj.Marker = marker;
			W.Layer.Objective.addLayer(marker);
		}
		W.toggleLayer(W.Layer.Objective, true);
		
		// Generate labels over servers' map spawn points, the names will be reassigned by the objective function
		var labels = W.Metadata.SpawnLabels;
		for (var i in W.Rotation)
		{
			var landnick = W.Rotation[i];
			var landlabel = labels[landnick];
			for (var ii in landlabel)
			{
				var coord = landlabel[ii];
				marker = L.marker(W.convertGCtoLC(coord),
				{
					icon: L.divIcon(
					{
						className: "mapSec",
						html: "<span class='mapSecIn wvwSpawnContainer wvwColor" + ii + "' id='wvwSpawn_" + i + "_" + ii + "' data-owner='" + ii + "'>"
							+ "<var class='wvwSpawnLabel'></var>"
						+ "</span>",
						iconSize: [128, 64],
						iconAnchor: [64, 32]
					})
				});
				(function(iLand, iTeam)
				{
					marker.on("click", function()
					{
						$("#wvwZoneLink" + ((iLand === "Center") ? "Center" : iTeam)).trigger("click");
					});
					marker.on("dblclick", function()
					{
						$("#wvwZoneLink" + ((iLand === "Center") ? "Center" : iTeam)).trigger("dblclick");
					});
					marker.on("contextmenu", function()
					{
						W.goToDefault();
					});
				})(i, ii);
				W.Layer.SpawnLabel.addLayer(marker);
			}
		}
		W.toggleLayer(W.Layer.SpawnLabel, true);
		
		// Hide map labels if opted
		W.toggleObjectiveLabels();
		
		// Hide floor initially for projection
		if (I.isProjectionEnabled)
		{
			W.toggleFloor(false);
		}
		else
		{
			W.toggleFloor(true);
		}
		
		// The function below would have been called already if world completion icons were generated
		if (O.Options.bol_showWorldCompletionWvW === false)
		{
			W.finishPopulation();
		}
	},
	
	/*
	 * Does final touches to the map after the icons have been generated.
	 */
	finishPopulation: function()
	{
		W.toggleSecondaries();
		W.toggleWalls();
		W.bindMapVisualChanges();
		W.adjustZoomMapping();
		W.executeURLCommands();
	},
	
	/*
	 * Creates secondary objective markers or toggle them if already created.
	 */
	toggleSecondaries: function(pWantAdjust)
	{
		if (O.Options.bol_showSecondaries
			&& W.Layer.Secondaries.getLayers().length === 0)
		{
			var drawSecondary = function(pCoords, pImage, pZoneNick)
			{
				if (pCoords === undefined)
				{
					return;
				}
				for (var i in pCoords)
				{
					var offset = W.Metadata.Offsets[pZoneNick];
					var coord = pCoords[i];
					var marker = L.marker(W.convertGCtoLC([coord[0] + offset[0], coord[1] + offset[1]]),
					{
						clickable: false,
						icon: L.icon(
						{
							iconUrl: "img/wvw/secondaries/" + pImage + I.cPNG,
							iconSize: [32, 32],
							iconAnchor: [16, 16]
						}),
						opacity: 0.9
					});
					W.Layer.Secondaries.addLayer(marker);
				}
			};
			
			for (var i in W.Rotation)
			{
				var landnick = W.Rotation[i];
				var placementname = W.Metadata.PlacementAssociation[landnick];
				var pl = W.Placement[placementname];
				drawSecondary(pl.ShrineEarth, "shrine_earth", landnick);
				drawSecondary(pl.ShrineFire, "shrine_fire", landnick);
				drawSecondary(pl.ShrineAir, "shrine_air", landnick);
				drawSecondary(pl.Sentry, "sentry", landnick);
				drawSecondary(pl.Depot, "depot", landnick);
			}
			if (pWantAdjust)
			{
				W.adjustZoomMapping();
			}
		}
		W.toggleLayer(W.Layer.Secondaries, O.Options.bol_showSecondaries);
	},
	
	/*
	 * Draws paths representing destructible walls on the map or toggle them if
	 * already drawn.
	 */
	toggleWalls: function(pWantAdjust)
	{
		var barricadecolor = "coral";
		var wallcolor = "orange";
		var gatecolor = "yellow";
		
		if (O.Options.bol_showDestructibles
			&& W.Layer.Destructible.getLayers().length === 0)
		{
			var drawWall = function(pCoords, pColor, pZoneNick)
			{
				var offset = W.Metadata.Offsets[pZoneNick];
				for (var i in pCoords)
				{
					var coord = pCoords[i];
					var coordA = [(coord[0])[0] + offset[0], (coord[0])[1] + offset[1]];
					var coordB = [(coord[1])[0] + offset[0], (coord[1])[1] + offset[1]];
					var path = L.polyline(W.convertGCtoLCDual([coordA, coordB]),
					{
						clickable: false,
						color: pColor,
						opacity: 0.8,
						weight: 10,
						lineCap: "butt"
					});
					W.Layer.Destructible.addLayer(path);
				}
			};
			
			for (var i in W.Rotation)
			{
				var landnick = W.Rotation[i];
				var placementname = W.Metadata.PlacementAssociation[landnick];
				var pl = W.Placement[placementname];
				drawWall(pl.Barricade, barricadecolor, landnick);
				drawWall(pl.Wall, wallcolor, landnick);
				drawWall(pl.Gate, gatecolor, landnick);
			}
			
			if (pWantAdjust)
			{
				W.adjustZoomMapping();
			}
		}
		W.toggleLayer(W.Layer.Destructible, O.Options.bol_showDestructibles);
	},
	
	/*
	 * Toggles display of objective labels below its icon.
	 */
	toggleObjectiveLabels: function()
	{
		$(".objInfo, .wvwSpawnContainer").toggle(O.Options.bol_showObjectiveLabels);
	},
	
	/*
	 * Gets the time for the next WvW re-linking of server alliances.
	 * @param Date pDate from matches API, the reset weekday is same as relink.
	 * @returns object Date
	 */
	getWorldRelink: function(pDate)
	{
		var inputdate = pDate;
		var outputdate = new Date(pDate);
		var month = outputdate.getUTCMonth(), year = outputdate.getUTCFullYear();
		// Last target weekday of even numbered months, but check for oddness because month is zero-indexed
		if (month % 2 === 0)
		{
			month = (month % T.cMONTHS_IN_YEAR) + 1;
			outputdate.setUTCMonth(month);
		}
		
		var daysinmonth = T.getDaysInMonth(outputdate);
		// Look from the last day of the month back for the target weekday
		for (var i = daysinmonth; i > 0; i--)
		{
			if ((new Date(year, month, i)).getDay() === inputdate.getUTCDay())
			{
				outputdate.setUTCDate(i);
				break;
			}
		}
		if (outputdate < inputdate)
		{
			// If past that day but still on the same month, then get the next
			var nextmonth = month + 1;
			outputdate.setUTCMonth(nextmonth);
			if (nextmonth >= T.cMONTHS_IN_YEAR)
			{
				outputdate.setUTCFullYear(year + 1);
				outputdate.setUTCMonth(nextmonth % T.cMONTHS_IN_YEAR);
			}
			return W.getWorldRelink(outputdate);
		}
		// If here then that day will occur in this month
		return outputdate;
	},
	
	/*
	 * Gets the WvW metadata entry translations.
	 * @param string pString.
	 */
	getName: function(pEntry)
	{
		return D.getObjectName(W.Metadata[pEntry]);
	},
	getNick: function(pEntry)
	{
		return D.getObjectNick(W.Metadata[pEntry]);
	},
	
	/*
	 * Converts the API matchup object into a custom containing teams and
	 * formatted server names. A team is a set of servers on one color.
	 * @param object pMatchData from v2 or v1 API matches.json.
	 * return object matchup.
	 */
	formatMatchup: function(pMatchData)
	{
		var maxserversbeforeabbrev = 2;
		var id = 0;
		var numteams = W.Metadata.Teams.length;
		var teamnames = W.Metadata.Teams;
		var ithteamname, ithowner, worldid, teamserverids, hostserverid;
		var servers = new Array(numteams);
		var hosts = new Array(numteams);
		var names = new Array(numteams);
		var namelines = new Array(numteams);
		var namelinks = new Array(numteams);
		var nicks = new Array(numteams);
		var colors = new Array(numteams);
		
		// Create the object
		var custommatchup = {};
		custommatchup.id = id; // Match ID
		
		if (pMatchData.wvw_match_id) // Only v1 API matches.json has this property
		{
			id = pMatchData.wvw_match_id;
			for (var i = 0; i < numteams; i++)
			{
				ithteamname = teamnames[i];
				worldid = pMatchData[(ithteamname + "_world_id")];
				servers[i] = new Array();
				servers[i].push(W.Servers[worldid]);
			}
			// Initialize the one-server-per-team object
			custommatchup.worlds = W.convertWorlds(pMatchData);
		}
		else // Else assume it is v2 API matches.json
		{
			id = pMatchData.id;
			var teams = pMatchData.all_worlds;
			for (var i = 0; i < numteams; i++)
			{
				ithteamname = teamnames[i];
				teamserverids = teams[ithteamname];
				hostserverid = pMatchData.worlds[ithteamname];
				servers[i] = new Array();
				if (W.Servers[hostserverid] === undefined)
				{
					continue;
				}
				servers[i].push(W.Servers[hostserverid]); // Host server is index 0
				for (var ii = 0; ii < teamserverids.length; ii++)
				{
					if (teamserverids[ii] !== hostserverid && W.Servers[(teamserverids[ii])] !== undefined)
					{
						servers[i].push(W.Servers[(teamserverids[ii])]);
					}
				}
			}
			// Initialize the one-server-per-team object
			custommatchup.worlds = pMatchData.worlds;
		}
		
		// Memorize borderlands name
		var getServerNameFromColor = function(pColor)
		{
			return U.escapeHTML(D.getObjectName(W.Servers[custommatchup.worlds[pColor]]));
		};
		var blstr = W.getName("Borderlands");
		custommatchup.RedHome = D.orderModifier(blstr, getServerNameFromColor("red"));
		custommatchup.BlueHome = D.orderModifier(blstr, getServerNameFromColor("blue"));
		custommatchup.GreenHome = D.orderModifier(blstr, getServerNameFromColor("green"));
		custommatchup.Center = W.getName("Center");
		
		// Initialize reuseable formatted server names string
		for (var i = 0; i < numteams; i++)
		{
			ithteamname = teamnames[i];
			ithowner = U.toFirstUpperCase(ithteamname);
			names[i] = new Array();
			namelines[i] = new Array();
			namelinks[i] = new Array();
			nicks[i] = new Array();
			colors[i] = D.getObjectName(W.Metadata[ithowner]);
			
			for (var ii = 0; ii < servers[i].length; ii++)
			{
				var ithserver = (servers[i])[ii];
				ithserver.owner = ithowner; // Record the server's color
				var ithservername = U.escapeHTML(D.getObjectName(ithserver));
				var hostflag = "";
				if (ii === 0) // Hosts are supposed to be in the first index in the API
				{
					hosts[i] = ithserver;
					// Add a suffix next to the host server name if that server has allies
					if (servers[i].length > 1)
					{
						hostflag = "+";
					}
				}
				// Abbreviate the names if is non-host server and there are too many on one team
				if ((hostflag.length === 0 && servers[i].length >= maxserversbeforeabbrev) || servers[i].length > maxserversbeforeabbrev)
				{
					names[i] += D.getObjectNick(ithserver) + hostflag;
					namelinks[i] += "<a href='?page=WvW&enu_Server=" + ithserver.id + "' title='" + ithservername + "'>" + D.getObjectNick(ithserver) + hostflag + "</a>";
				}
				else
				{
					names[i] += ithservername + hostflag;
					namelinks[i] += "<a href='?page=WvW&enu_Server=" + ithserver.id + "'>" + ithservername + hostflag + "</a>";
				}
				namelines[i] += ithservername + hostflag;
				nicks[i] += D.getObjectNick(ithserver) + hostflag;
				if (servers[i].length > 1 && ii < servers[i].length - 1) // Spacing between server names
				{
					names[i] += " &amp; ";
					namelines[i] += "<br />";
					namelinks[i] += " &amp; ";
					nicks[i] += " ";
				}
				
				// If the iterated server is the user's home server, then assign the color/owner string
				if (ithserver.id === O.Options.enu_Server)
				{
					custommatchup.oOwnerCurrent = ithowner;
				}
			}
		}
		
		// Assign variables for all teams to the custom matchup object
		for (var i = 0; i < numteams; i++)
		{
			ithteamname = teamnames[i];
			custommatchup[ithteamname] = {
				oServers: servers[i],
				oHost: hosts[i],
				oNameStr: names[i],
				oNameLinesStr: namelines[i],
				oNameLinksStr: namelinks[i],
				oNickStr: nicks[i],
				oColor: colors[i]
			};
		}
		
		return custommatchup;
	},
	
	/*
	 * Gets the team object (of the custom matchup object) from an owner
	 * string, such as "Green".
	 * @param string pOwner.
	 * @returns object server.
	 */
	getTeamFromOwner: function(pOwner)
	{
		return W.MatchupCurrent[pOwner.toLowerCase()];
	},
	
	/*
	 * Gets a translated borderlands name.
	 * @param object pServer to get the server name, or an objective object.
	 * @param boolean pFullServer or false to get nick, optional.
	 * @param boolean pFullBorderlands or false to get nick, optional.
	 * @returns string phrase.
	 */
	getBorderlandsString: function(pServer, pSettings)
	{
		var Settings = pSettings || {};
		var server = (typeof pServer === "string") ? W.Servers[W.MatchupCurrent.worlds[pServer]] : pServer;
		var serverstr, blstr;
		
		// If the server is actually an objective object
		var maptype = pServer["map_type"];
		if (maptype !== undefined)
		{
			var land = W.MapType[maptype];
			if (land === "center")
			{
				// EBG does not include server name, so just return it here
				return W.getNick("Center");
			}
			else
			{
				server = W.Servers[(W.MatchupCurrent.worlds[land])];
			}
		}
		
		// Get the full strings abbreviated or not
		serverstr = (Settings.aWantServerNick) ? D.getObjectNick(server) : D.getObjectName(server);
		blstr = (Settings.aWantBorderlandsNick) ? W.getNick("Borderlands") : W.getName("Borderlands");
		
		// Adjust to grammar
		if (Settings.aWantPronoun && server.owner === W.MatchupCurrent.oOwnerCurrent)
		{
			return W.getName("Our") + " " + blstr;
		}
		return D.orderModifier(blstr, serverstr);
	},
	
	/*
	 * Gets an objective's nick, or generate one if it has a direction property.
	 * @param pObject pObjective.
	 * @param boolean pFullDirection or false for abbreviated compass direction.
	 */
	getObjectiveNick: function(pObjective, pFullDirection)
	{
		// Example: "Northwest Camp", "East Keep"
		if (pObjective.direction !== undefined)
		{
			var dirstr = (pFullDirection) ? W.getName(pObjective.direction) : W.getNick(pObjective.direction);
			var typestr = W.getName(pObjective.type);
			return dirstr + " " + typestr;
		}
		// Example: "Garrison"
		else if (pObjective.alias !== undefined)
		{
			return W.getName(pObjective.alias);
		}
		// Example: "Stonemist", "Umberglade"
		return D.getObjectNick(pObjective);
	},
	
	/*
	 * Gets the image source for an objective.
	 * @param object pObjective.
	 * @param string pOwner of the objective (color).
	 * @returns string URL.
	 */
	getObjectiveImage: function(pObjective, pOwner)
	{
		var owner = pOwner || pObjective.owner;
		if (pObjective.type === W.ObjectiveEnum.Ruins)
		{
			return "img/wvw/ruins/" + (pObjective.direction + "_" + owner).toLowerCase() + I.cPNG;
		}
		if (pObjective.type === W.ObjectiveEnum.Bloodlust)
		{
			return "img/wvw/ruins/" + (pObjective.alias + "_" + owner).toLowerCase() + I.cPNG;
		}
		return "img/wvw/objectives/" + (pObjective.type + "_" + owner).toLowerCase() + I.cPNG;
	},
	
	/*
	 * Computes the summed values of objectives based on their map.
	 */
	computeObjectivesValue: function()
	{
		var objs = W.Metadata.ObjectiveType;
		var objval, uniqueval;
		for (var i in objs)
		{
			objval = objs[i].Value.Each;
			objs[i].Value.Borderlands = objs[i].Quantity.Borderlands * objval;
			objs[i].Value.Battlegrounds = objs[i].Quantity.Battlegrounds * objval;
			objs[i].Value.All = (objs[i].Value.Borderlands + objs[i].Value.Battlegrounds) * W.cOWNERS_PER_TIER;
			uniqueval = (objs[i].Quantity.isUnique) ? objval : 0;
			W.cTOTAL_PPT_POSSIBLE += objs[i].Value.All + uniqueval;
		}
	},
	
	/*
	 * Gets the points worth for an objective type.
	 * @param string pObjectiveType such as "Camp".
	 * @returns int value.
	 */
	getObjectiveTypeValue: function(pObjectiveName)
	{
		return W.Metadata.ObjectiveType[pObjectiveName].Value.Each;
	},
	
	/*
	 * Gets the tier number from the match id. Example "2-5" returns 5.
	 * @param object pData matchup from API.
	 * @returns int tier.
	 */
	getMatchupTier: function(pData)
	{
		var key = (W.isFallbackEnabled) ? "match_id" : "id";
		return parseInt((pData[key].split("-"))[1]);
	},
	
	/*
	 * Generates a list of servers for the user to choose from.
	 */
	generateServerList: function()
	{
		// Put the server objects into an array so they can be alphabetized according to language
		var servers = [];
		for (var i in W.Servers)
		{
			servers.push(W.Servers[i]);
		}
		U.sortObjects(servers);
		
		// Write the list
		var container = $("#wvwServerListContainer");
		var searchdb = [];
		servers.forEach(function(iServer)
		{
			searchdb.push({
				name: D.getObjectName(iServer) + ((iServer.suffix) ? " " + iServer.suffix : ""),
				icon: "img/ui/flags/" + ((iServer.suffix) ? U.stripToAlphanumeric(iServer.suffix).toLowerCase() : "na") + I.cPNG,
				id: iServer.id
			});
		});
		I.createSearchBar(container, {
			aBarID: "wvwServerListBar",
			aResultsClass: "wvwServerListResults",
			aIsSelect: true,
			aWantClose: true,
			aDatabase: searchdb,
			aFillerText: D.getPhraseOriginal("Select Server"),
			aCallback: function(pServer)
			{
				O.Options.enu_Server = pServer.id;
				localStorage["enu_Server"] = O.Options.enu_Server;
				// Update address bar
				U.updateQueryString("enu_Server=" + pServer.id);
				// Restart the system
				W.reinitializeServerChange();
			}
		});
		
		// Prevent map scroll from interfering when using the list
		I.preventMapPropagation(container);
	},
	
	/*
	 * Generates stats of all servers in a server region.
	 */
	initializeLeaderboard: function()
	{
		// Bind the window buttons
		$("#lboToggle").click(function()
		{
			$("#opt_bol_showLeaderboard").trigger("click");
		});
		$("#lboCondense").click(function()
		{
			$("#opt_bol_condenseLeaderboard").trigger("click");
		});
		$("#lboRegion").click(function()
		{
			W.toggleRegionLeaderboard();
		});
		$("#lboStats").click(function()
		{
			W.generateStats();
		});
		$("#lboOpaque").click(function()
		{
			$("#opt_bol_opaqueLeaderboard").trigger("click");
		});
		$("#lboCountdown").click(function()
		{
			U.openExternalURL(W.LeaderboardURL[W.LocaleCurrent]);
		});
		
		// Apply the leaderboard appearance options
		W.toggleLeaderboard();
		W.opaqueLeaderboard();
		W.toggleLeaderboardWidth();
		I.bindScrollbar("#lboOther");
	},
	
	/*
	 * Retrieves data for all servers in the region and generates a scoreboard
	 * for each.
	 */
	toggleRegionLeaderboard: function()
	{
		var lb = $("#lboOther");
		// Toggle by adding or emptying content
		if (lb.is(":empty") === false || W.LocaleCurrent === null)
		{
			lb.animate({height: 0}, "fast", function()
			{
				lb.empty().css({height: "auto"});
			});
			return;
		}
		
		var matchids = W.Metadata.MatchIDs[W.LocaleCurrent];
		// Gather data for all matches for current server region
		for (var i in matchids)
		{
			var matchid = matchids[i];
			var url = (W.isFallbackEnabled) ? (U.URL_API.MatchFallback + matchid) : (U.URL_API.Matches + matchid);
			var htmlid = "lboOther_" + matchid;
			
			// Skip the current matchup because it is already shown
			if (matchid === W.MatchupIDCurrent)
			{
				continue;
			}
			lb.append("<div id='" + htmlid + "'></div>");
			(function(iID, iMatchID)
			{
				$.getJSON(url, function(pData)
				{
					var ithmatch = (W.isFallbackEnabled) ? W.formatMatchup(W.Matches[iMatchID]) : W.formatMatchup(pData);
					W.insertScoreboard(pData, ithmatch, $("#" + iID));
					W.readjustLeaderboard();
					I.updateScrollbar("#lboOther");
				});
			})(htmlid, matchid);
		}
	},
	
	/*
	 * Inserts a matchup/tier scoreboard into the leaderboard.
	 * @param object pData from matches API.
	 * @param object pMatchup custom matchup converted from matches API.
	 * @param jqobject pContainer to insert the scoreboard in, optional.
	 */
	insertScoreboard: function(pData, pMatchup, pContainer)
	{
		// Converts a v1 style "scores" array to v2 style object if using fallback
		var convertScores = function(pScores)
		{
			if (W.isFallbackEnabled)
			{
				return { red: pScores[0], blue: pScores[1], green: pScores[2] };
			}
			return pScores;
		};
		var createScores = function()
		{
			return { red: 0, blue: 0, green: 0 };
		};
		
		/*
		 * Collate objective points from each borderlands.
		 */
		var matchupdata = pMatchup || W.MatchupCurrent;
		var map, obj, apiobj, landprefix, objid;
		var land, value, nativeowner;
		var numowners = W.Metadata.Owners.length;
		var tier = W.getMatchupTier(pData);
		var scores = convertScores(pData.scores);
		var victoryscores = pData.victory_points || createScores(); // Dummy score if using fallback
		var PPT = {};
		var wantserver = true;
		// Initialize variables for the temp object
		for (var i in W.Metadata.Owners)
		{
			var owner = W.Metadata.Owners[i];
			PPT[owner] = {};
			(PPT[owner]).Total = 0;
			(PPT[owner])[W.LandEnum.RedHome] = 0;
			(PPT[owner])[W.LandEnum.BlueHome] = 0;
			(PPT[owner])[W.LandEnum.GreenHome] = 0;
			(PPT[owner])[W.LandEnum.Center] = 0;
			for (var ii in W.Metadata.Owners) // The division of "native" land in EBG
			{
				(PPT[owner])[W.LandEnum.Center + (W.Metadata.Owners[ii])] = 0;
			}
		}
		// Assign the values
		for (var i in pData.maps)
		{
			map = pData.maps[i];
			landprefix = W.LandPrefix[map.type];
			for (var ii in map.objectives)
			{
				apiobj = map.objectives[ii];
				objid = (W.isFallbackEnabled) ? landprefix + apiobj.id : apiobj.id;
				obj = W.Objectives[objid];
				if (obj === undefined) // Ignore unknown objectives
				{
					continue;
				}
				owner = apiobj.owner;
				land = obj.map_type; // Example: "RedHome"
				value = W.getObjectiveTypeValue(obj.type);
				nativeowner = obj.nativeowner;
				if (owner !== W.OwnerEnum.Neutral)
				{
					(PPT[owner]).Total += value;
					(PPT[owner])[land] += value;
					if (land === W.LandEnum.Center)
					{
						// Example: In EBG, Red took objectives that were natively owned by Green's side, such as Lowlands
						(PPT[owner])[W.LandEnum.Center + nativeowner] += value;
					}
				}
			}
		}
		
		/*
		 * Decide appropriate container to insert the scoreboard.
		 */
		var lb;
		if (pContainer === undefined)
		{
			lb = $("#lboCurrent");
			lb.empty();
			if (I.ModeCurrent === I.ModeEnum.Overlay || I.isProgramEmbedded)
			{
				wantserver = false;
			}
		}
		else
		{
			lb = pContainer;
		}
		var html = "<section>";
		for (var i = 0; i < numowners; i++)
		{
			/*
			 * Prepare variables to be inserted into the HTML.
			 */
			var owner = W.Metadata.Owners[i]; // Example: "Green" as in data
			var ownerkey = owner.toLowerCase(); // Example: "green" as in match API
			var rank = ((tier - 1) * W.cOWNERS_PER_TIER) + (i+1);
			var serverstr = (wantserver) ? "<aside class='lboRank'>" + rank + ".</aside>"
				+ "<aside class='lboName'>&nbsp;" + matchupdata[ownerkey].oNameLinksStr + "</aside>" : "";
			var scorestr = "";
			var score = scores[ownerkey];
			var scorehighest = (T.getMinMax(scores)).oMax;
			var scorepercent = (scores[ownerkey] / scorehighest) * T.cPERCENT_100;
			var victoryscore = victoryscores[ownerkey];
			var victoryscorehighest = (T.getMinMax(victoryscores)).oMax;
			var victoryscorepercent = (victoryscores[ownerkey] / victoryscorehighest) * T.cPERCENT_100;
			var ppttotal = (PPT[owner]).Total;
			var pptpercent = (ppttotal / W.cTOTAL_PPT_POSSIBLE) * T.cPERCENT_100;
			// Kills and Deaths
			var kdstr = "";
			if (pData.kills !== undefined && W.isFallbackEnabled === false)
			{
				var kills = (pData.kills !== undefined) ? pData.kills[ownerkey] : "";
				var deaths = (pData.deaths !== undefined) ? pData.deaths[ownerkey] : "";
				var kdratio = T.parseRatio((kills / deaths), 2);
				var kdbl = "";
				// This constrains the ratio between 0% and 200%, where 100% means the kills and deaths numbers are equal
				var kdpercent = T.parseRatio(T.clampCeil(kills / deaths, 2) / 2) * T.cPERCENT_100;
				var blkills, bldeaths;
				pData.maps.forEach(function(iMap)
				{
					blkills = iMap.kills[ownerkey];
					bldeaths = iMap.deaths[ownerkey];
					kdbl += "<dfn>" + blkills + " : " + bldeaths + " (" + T.parseRatio((blkills / bldeaths), 2) + ")</dfn> on " + matchupdata[iMap.type] +  "<br />";
				});
				kdstr = "<aside class='lboKD' title='<dfn>Kills to Deaths ratio: " + kdratio + "</dfn><br />" + kdbl + "'>"
					+ "<var class='lboKills'>" + kills.toLocaleString() + "</var>"
					+ "<samp><s style='width:" + kdpercent + "%'><mark></mark></s></samp>"
					+ "<var class='lboDeaths'>" + deaths.toLocaleString() + "</var>"
				+ "</aside>";
			}
			
			/*
			 * Server Focus is PPT from ownership of non-native objectives (including EBG).
			 */
			var focuses = [];
			var scoredifferences = [];
			var victoryscoredifferences = [];
			var otherservers = [];
			for (var ii = 0; ii < numowners; ii++)
			{
				var otherowner = W.Metadata.Owners[ii];
				var otherownerkey = otherowner.toLowerCase();
				if (otherowner !== owner)
				{
					var focus = (PPT[owner])[otherowner + "Home"] + (PPT[owner])[W.LandEnum.Center + otherowner];
					focuses.push(focus);
					scoredifferences.push(score - scores[otherownerkey]);
					victoryscoredifferences.push(victoryscore - victoryscores[otherownerkey]);
					var otherserver = W.Servers[(matchupdata.worlds[otherownerkey])];
					otherservers.push(U.escapeHTML(D.getObjectName(otherserver)));
				}
			}
			var totalfocus = (focuses[0] + focuses[1]);
			var focusApercent, focusBpercent;
			var focusclass = "";
			if (totalfocus > 0)
			{
				focusApercent = Math.round((focuses[0] / totalfocus) * T.cPERCENT_100);
				focusBpercent = Math.round((focuses[1] / totalfocus) * T.cPERCENT_100);
			}
			else
			{
				focusApercent = 0;
				focusBpercent = 0;
				focusclass = "lboFocusZero";
			}
			
			/*
			 * Borderlands Focus is score from non-native borderlands (excluding EBG).
			 */
			var blscoreA, blscoreB;
			for (var ii in pData.maps)
			{
				var map = pData.maps[ii];
				var mapscores = convertScores(map.scores);
				switch (map.type)
				{
					case ((W.Metadata.Opposites[owner])[0] + "Home"): blscoreA = mapscores[ownerkey]; break;
					case ((W.Metadata.Opposites[owner])[1] + "Home"): blscoreB = mapscores[ownerkey]; break;
				}
			}
			var totalblscore = blscoreA + blscoreB;
			var blscoreApercent, blscoreBpercent;
			var blscoreclass = "";
			if (totalblscore > 0)
			{
				blscoreApercent = Math.round((blscoreA / totalblscore) * T.cPERCENT_100);
				blscoreBpercent = Math.round((blscoreB / totalblscore) * T.cPERCENT_100);
			}
			else
			{
				blscoreApercent = 0;
				blscoreBpercent = 0;
				blscoreclass = "lboFocusZero";
			}
			
			/*
			 * Format the bar graph differently for v1 and v2 matches data.
			 */
			if (W.isFallbackEnabled)
			{
				scorestr = "<aside class='lboScoreLegacy' title='<dfn>" + scoredifferences[0] + " points</dfn> away from " + otherservers[0]
				+ "<br /><dfn>" + scoredifferences[1] + " points</dfn> away from " + otherservers[1] + "'>"
					+ "<var>" + score.toLocaleString() + "</var>"
					+ "<samp><s style='width:" + scorepercent + "%'></s></samp>"
				+ "</aside>"
				+ "<aside class='lboPPTLegacy' title='<dfn>Points-Per-Tick (PPT)</dfn>'>"
					+ "<samp><s style='width:" + pptpercent + "%'></s></samp>"
					+ "<var>+" + ppttotal + "</var>"
				+ "</aside>";
			}
			else
			{
				scorestr = "<aside class='lboVictory' title='<dfn>" + victoryscoredifferences[0] + " points</dfn> away from " + otherservers[0]
				+ "<br /><dfn>" + victoryscoredifferences[1] + " points</dfn> away from " + otherservers[1] + "'>"
					+ "<var><img class='lboVictoryIcon' src='img/wvw/victorypoint.png' />" + victoryscore.toLocaleString() + "</var>"
					+ "<samp><s style='width:" + victoryscorepercent + "%'></s></samp>"
				+ "</aside>"
				+ "<aside class='lboPPT' title='<dfn>Points-Per-Tick (PPT)</dfn>'>"
					+ "<samp><s style='width:" + pptpercent + "%'></s></samp>"
					+ "<var>+" + ppttotal + "</var>"
				+ "</aside>";
			}
			
			/*
			 * Write the HTML.
			 */
			html += "<article class='lboServer lboServer" + owner + "'>"
				+ serverstr
				+ scorestr
				+ "<aside class='lboLand' title='<dfn>PPT per borderlands</dfn>'>"
					+ "<var class='lboPPTGreen'>+" + (PPT[owner])[W.LandEnum.GreenHome] + "</var>"
					+ "<var class='lboPPTBlue'>+" + (PPT[owner])[W.LandEnum.BlueHome] + "</var>"
					+ "<var class='lboPPTRed'>+" + (PPT[owner])[W.LandEnum.RedHome] + "</var>"
					+ "<var class='lboPPTCenter'>+" + (PPT[owner])[W.LandEnum.Center] + "</var>"
				+ "</aside>"
				+ kdstr
				+ "<aside class='lboFocus lboFocus" + owner + "' title='<dfn>Server Focus (PPT Now)</dfn><br />"
						+ "<dfn>" + focuses[0] + " PPT</dfn> earnable from " + otherservers[0] + " native objectives<br />"
						+ "<dfn>" + focuses[1] + " PPT</dfn> earnable from " + otherservers[1] + " native objectives'>"
					+ "<var class='lboFocusA'>" + focusApercent + "%</var>"
					+ "<samp class='" + focusclass + "'><s style='width:" + focusApercent + "%'><mark></mark></s></samp>"
					+ "<var class='lboFocusB'>" + focusBpercent + "%</var>"
				+ "</aside>"
				+ "<aside class='lboFocus lboFocus" + owner + "' title='<dfn>Server Focus (Points Matchup)</dfn><br />"
						+ "<dfn>" + blscoreA + " points</dfn> earned from " + otherservers[0] + " Borderlands<br />"
						+ "<dfn>" + blscoreB + " points</dfn> earned from " + otherservers[1] + " Borderlands'>"
					+ "<var class='lboFocusA'>" + blscoreApercent + "%</var>"
					+ "<samp class='" + blscoreclass + "'><s style='width:" + blscoreApercent + "%'><mark></mark></s></samp>"
					+ "<var class='lboFocusB'>" + blscoreBpercent + "%</var>"
				+ "</aside>"
			+ "</article>";
		}
		html += "</section>";
		
		lb.append(html);
		I.qTip.init(lb.find("aside, a"));
		
		if (O.Options.bol_condenseLeaderboard)
		{
			W.toggleLeaderboardWidth();
		}
	},
	
	/*
	 * Toggles the leaderboard display.
	 */
	toggleLeaderboard: function()
	{
		if (O.Options.bol_showLeaderboard)
		{
			W.updateObjectives();
			$("#lboCurrent, #lboOther").show("fast", function()
			{
				$("#lboContainer").css({padding: ((I.ModeCurrent === I.ModeEnum.Overlay) ? 0 : 8) + "px"});
			});
			$(".lboExtra").show();
		}
		else
		{
			$("#lboCurrent, #lboOther").hide("fast", function()
			{
				$("#lboContainer").css({padding: 0});
			});
			$(".lboExtra").hide();
		}
	},
	opaqueLeaderboard: function()
	{
		I.toggleHUDOpacity("#lboContainer", "lbo", O.Options.bol_opaqueLeaderboard);
	},
	
	/*
	 * Condenses the leaderboard or revert it.
	 */
	toggleLeaderboardWidth: function(pWantAnimate)
	{
		var isshown = !O.Options.bol_condenseLeaderboard;
		var elms = $(".lboRank, .lboLand, .lboFocus");
		if (pWantAnimate)
		{
			if (isshown)
			{
				elms.show("fast");
			}
			else
			{
				elms.hide("fast");
			}
		}
		else
		{
			elms.toggle(isshown);
		}
	},
	readjustLeaderboard: function()
	{
		$("#lboOther").css({maxHeight: $(window).height() - $("#lboCurrent").height() * 2});
	},
	
	/*
	 * Binds the button to print the WvW stats of servers one by one.
	 */
	generateStats: function()
	{
		if (I.isConsoleShown())
		{
			return;
		}
		I.print(I.cThrobber, true);
		E.updateCoinInGem(function()
		{
			$.getJSON(U.getAPI("worlds", true), function(pData)
			{
				// Sort by population
				pData.forEach(function(iWorld)
				{
					iWorld.sortablePopulation = W.Metadata.PopulationPercent[iWorld.population];
				});
				U.sortObjects(pData, {aKeyName: "sortablePopulation", aIsDescending: true});
				// Generate table
				var html = "<table id='wvwStats' class='cssStats'>";
				html += "<thead><tr>"
					+ "<th>Server</th>"
					+ "<th>ID</th>"
					+ "<th>Population</th>"
					+ "<th>Transfer</th>"
					+ "<th>Conversion</th>"
				+ "</tr></thead><tbody>";
				pData.forEach(function(iWorld)
				{
					// Only insert server if it is in the same locale as the user's selected server
					if (iWorld.id.toString().charAt(0) === W.LocaleThreshold[W.LocaleCurrent + "Prefix"])
					{
						var servername = U.escapeHTML(D.getObjectName(W.Servers[iWorld.id]));
						var transfercost = W.Metadata.PopulationTransfer[iWorld.population];
						html += "<tr>"
							+ "<td><a class='wvwStatsLink wvwPopulation_" + U.escapeHTML(iWorld.population)
								+ "' href='?page=WvW&enu_Server=" + iWorld.id + "'>" + servername + "</a></td>"
							+ "<td>" + iWorld.id + "</td>"
							+ "<td>" + I.getBar(W.Metadata.PopulationPercent[iWorld.population]) + "</td>"
							+ "<td>" + E.formatGemString(transfercost, true) + "</td>"
							+ "<td>" + E.formatGemToCoin(transfercost) + "</td>"
						+ "</tr>";
					}
				});
				html += "</tbody></table>";
				I.print(html, true);
			});
		});
	},
	
	/*
	 * Writes the base HTML of the capture history log.
	 */
	initializeLog: function()
	{
		// Initialize element properties
		$("#wvwLogContainer").show();
		$("#logWindow").data("oldHeight", $("#logWindow").height());
		
		// Bind the window buttons
		$("#logToggle").click(function()
		{
			$("#opt_bol_showLog").trigger("click");
		});
		$("#logExpand").click(function()
		{
			$("#opt_bol_maximizeLog").trigger("click");
		});
		$("#logOpaque").click(function()
		{
			$("#opt_bol_opaqueLog").trigger("click");
		});
		// Apply the log appearance options
		W.toggleLog(true);
		W.opaqueLog();
		W.toggleLogHeight();
		I.bindScrollbar("#logWindow");
		I.loadImg($("#wvwLog"));
		O.mimicInput("#wvwZoomInput", "int_setInitialZoomWvW");
		
		// Bind the checkboxes to filter log entries
		for (var i in W.MapType)
		{
			(function(iFilter)
			{
				$("#opt_bol_log" + iFilter).change(function()
				{
					if (O.Options["bol_log" + iFilter])
					{
						$(".logEntry" + iFilter).show("fast", function() { I.updateScrollbar("#logWindow"); });
					}
					else
					{
						$(".logEntry" + iFilter).hide("fast", function() { I.updateScrollbar("#logWindow"); });
					}
				}).parent().dblclick(function()
				{
					// If double clicked the checkbox, then uncheck all the others except itself
					$("#logFilters input:checkbox").each(function()
					{
						X.setCheckboxEnumState($(this), X.ChecklistEnum.Unchecked);
					});
					X.setCheckboxEnumState($("#opt_bol_log" + iFilter), X.ChecklistEnum.Checked);
				});
			})(i);
		}
		
		// Label the narration filters
		var blstr = W.getName("Borderlands");
		X.relabelCheckbox("#opt_bol_narrateRedHome", D.orderModifier(blstr, W.getName("Red")));
		X.relabelCheckbox("#opt_bol_narrateBlueHome", D.orderModifier(blstr, W.getName("Blue")));
		X.relabelCheckbox("#opt_bol_narrateGreenHome", D.orderModifier(blstr, W.getName("Green")));
		X.relabelCheckbox("#opt_bol_narrateCenter", W.getName("Center"));
		X.relabelCheckbox("#opt_bol_narrateRuins", W.getName("Ruins"));
		X.relabelCheckbox("#opt_bol_narrateCamp", W.getName("Camp"));
		X.relabelCheckbox("#opt_bol_narrateTower", W.getName("Tower"));
		X.relabelCheckbox("#opt_bol_narrateKeep", W.getName("Keep"));
		X.relabelCheckbox("#opt_bol_narrateCastle", W.getName("Castle"));
		X.relabelCheckbox("#opt_bol_narrateClaimed", W.getName("Claimed"));
		
		// Mimic the master volumn slider
		I.preventMapPropagation(O.mimicInput("#logNarrateVolume", "int_setVolume"));
		O.Enact.bol_logNarrate();
		
		// Bind local time clock
		$("#logTime").click(function()
		{
			$("#opt_bol_use24Hour").trigger("click");
			// Update the timestamps of the log entries
			$("#logWindow li time").each(function()
			{
				var timestr = T.getTimeFormatted({aCustomTimeInDate: new Date($(this).attr("data-time"))}); 
				$(this).html(timestr);
			});
		});
		
		// Pause button
		$("#wvwPause").click(function()
		{
			W.isWvWPaused = !W.isWvWPaused;
			if (W.isWvWPaused)
			{
				W.addLogEntry("WvW updating paused.");
				D.stopSpeech();
			}
			else
			{
				W.addLogEntry("WvW updating resumed.");
				W.updateObjectives();
			}
		});
	},
	
	/*
	 * Toggles the log display.
	 */
	toggleLog: function(pIsInitial)
	{
		I.toggleElement("#wvwLog, .logExtra", O.Options.bol_showLog, "fast", pIsInitial);
	},
	opaqueLog: function()
	{
		I.toggleHUDOpacity("#wvwLog", "log", O.Options.bol_opaqueLog);
	},
	
	/*
	 * Adjusts the log window height.
	 */
	toggleLogHeight: function()
	{
		var log = $("#logWindow");
		var windowheight = $(window).height();
		var oldheight = log.data("oldHeight");
		var newheight = windowheight - ((I.ModeCurrent === I.ModeEnum.Overlay) ? 164 : 210); // Just enough to snap with the leaderboard

		if (O.Options.bol_maximizeLog)
		{
			log.show().animate({height: newheight}, 200, function()
			{
				I.updateScrollbar(log);
				O.Options.bol_maximizeLog = true;
			});
		}
		else
		{
			log.show().animate({height: oldheight}, 200, function()
			{
				I.updateScrollbar(log);
				O.Options.bol_maximizeLog = false;
			});
		}
	},
	
	/*
	 * Resizes the log if the browser window covers it.
	 */
	readjustLog: function()
	{
		if ($("#wvwLog").height() > $(window).height())
		{
			$("#logExpand").trigger("click").trigger("click");
		}
	},
	
	/*
	 * Adds an entry to the WvW log.
	 * @param string pString to insert.
	 * @param string pClass of the log entry, such as the map the event happened in.
	 * @param string pISOTime of the event, optional
	 * @param boolean pIsDisplayed whether shown initially.
	 */
	addLogEntry: function(pString, pClass, pISOTime, pIsDisplayed)
	{
		pString = pString || "";
		pClass = pClass || "";
		var timestr = "";
		if (pISOTime === undefined)
		{
			timestr = T.getTimeFormatted();
			pISOTime = (new Date()).toISOString();
		}
		else
		{
			timestr = T.getTimeFormatted({aCustomTimeInDate: new Date(pISOTime)});
		}
		var entry = $("<li class='logEntry " + pClass + "'><time data-time='" + pISOTime + "'>" + timestr + "</time><span>" + pString + "</span></li>")
			.prependTo("#logWindow");
		this.bindMapLinkBehavior(entry.find("dfn"));
		
		// Animate the new entry
		if (pIsDisplayed === false)
		{
			entry.hide();
		}
		else
		{
			var width = entry.width();
			entry.css({width: 0}).animate({width: width}, 400, function()
			{
				$(this).removeAttr("style");
			});
		}
		
		// Delete an old entry if over max limit
		var entries = $(".logEntry");
		if (entries.length > O.Options.int_numLogEntries)
		{
			entries.last().remove();
		}
		I.updateScrollbar("#logWindow");
	},
	
	/*
	 * Adds an entry pertaining to objectives.
	 * @param object pObjective.
	 * @param boolean pIsClaim if it is an objective claim, optional.
	 */
	addLogEntryObjective: function(pObjective, pIsClaim)
	{
		var prevobjectiveicon = "<img src='" + W.getObjectiveImage(pObjective, pObjective.prevowner) + "' />";
		var objectiveicon = "<img src='" + W.getObjectiveImage(pObjective, pObjective.owner) + "' />";
		var objectivenick = W.getObjectiveNick(pObjective, false);
		
		// Claiming shows the guild tag instead of the previous objective icon
		var isotime;
		if (pIsClaim)
		{
			prevobjectiveicon = objectiveicon;
			objectiveicon = "<cite>" + pObjective.oTag + "</cite>";
			isotime = pObjective.claimed_at;
		}
		else
		{
			isotime = pObjective.last_flipped;
		}
		var str = prevobjectiveicon + " ⇒ " + objectiveicon + " <dfn data-coord='" + pObjective.coord + "'>" + objectivenick + "</dfn>";
		var land = pObjective.map_type;
		var cssclass = "logEntry" + land;
		if ( ! pIsClaim)
		{
			pObjective.prevownerhtml = str;
		}
		
		// The entry will be added, but only shown if opted
		var isdisplayed = true;
		if ((land === W.LandEnum.RedHome && O.Options.bol_logRedHome === false)
			|| (land === W.LandEnum.BlueHome && O.Options.bol_logGreenHome === false)
			|| (land === W.LandEnum.GreenHome && O.Options.bol_logBlueHome === false)
			|| (land === W.LandEnum.Center && O.Options.bol_logCenter === false))
		{
			isdisplayed = false;
		}
		W.addLogEntry(str, cssclass, isotime, isdisplayed);
		
		// Narrate the capture event if opted
		if (O.Options.bol_logNarrate)
		{
			W.narrateLog(pObjective, pIsClaim);
		}
	},
	
	/*
	 * Speaks the objective that was captured and the capturer.
	 * @param object pObjective.
	 * @param boolean pIsClaim if it is an objective claim, optional.
	 */
	narrateLog: function(pObjective, pIsClaim)
	{
		// Do not proceed if does not pass the opted filters
		var land = pObjective.map_type;
		var type = pObjective.type;
		if ((pIsClaim && O.Options.bol_narrateClaimed === false)
			|| (land === W.LandEnum.RedHome && O.Options.bol_narrateRedHome === false)
			|| (land === W.LandEnum.BlueHome && O.Options.bol_narrateBlueHome === false)
			|| (land === W.LandEnum.GreenHome && O.Options.bol_narrateGreenHome === false)
			|| (land === W.LandEnum.Center && O.Options.bol_narrateCenter === false)
			|| (type === W.ObjectiveEnum.Bloodlust && O.Options.bol_narrateRuins === false)
			|| (type === W.ObjectiveEnum.Ruins && O.Options.bol_narrateRuins === false)
			|| (type === W.ObjectiveEnum.Camp && O.Options.bol_narrateCamp === false)
			|| (type === W.ObjectiveEnum.Tower && O.Options.bol_narrateTower === false)
			|| (type === W.ObjectiveEnum.Keep && O.Options.bol_narrateKeep === false)
			|| (type === W.ObjectiveEnum.Castle && O.Options.bol_narrateCastle === false))
		{
			return;
		}
		
		var objstr = W.getObjectiveNick(pObjective, true);
		var ownerstr;
		if (pIsClaim)
		{
			ownerstr = D.getSpeechInitials(pObjective.oTagInitial);
		}
		else if (pObjective.owner === W.MatchupCurrent.oOwnerCurrent)
		{
			ownerstr = W.getName("Us");
		}
		else
		{
			ownerstr = D.getSpeechInitials(D.getObjectNick(W.getTeamFromOwner(pObjective.owner).oHost));
		}
		// Only include the borderlands string if user opted for more than one land filter
		var blstr = ($("#logNarrateLand input:checked").length > 1) ? (W.getBorderlandsString(pObjective, {aWantPronoun: true}) + ". ") : "";
		var verbstr;
		if (pIsClaim)
		{
			verbstr = W.getName("Claimed");
		}
		else if (pObjective.owner === pObjective.nativeowner)
		{
			verbstr = W.getName("Retaken");
		}
		else
		{
			verbstr = W.getName("Captured");
		}
		
		// Separated to two speeches so the pause is longer
		var speech1 = blstr + objstr;
		var speech2 = verbstr + " " + ownerstr;
		D.speak(speech1);
		D.speak(speech2);
	},
	
	/*
	 * Generates the siege supply calculator.
	 */
	initializeSupplyCalculator: function()
	{
		var addSupply = function(pElement, pSupply)
		{
			var blcount = pElement.html();
			// Blank blueprint count means 0 blueprints requested
			blcount = (blcount === "") ? 0 : parseInt(blcount);
			if (pSupply < 0 && blcount === 0)
			{
				return;
			}
			var increment = (pSupply < 0) ? -1 : 1;

			W.numSiegeSupply += pSupply;
			$("#splNeed").html(W.numSiegeSupply);
			// If after increment the blueprint count is 0, then make it blank
			var finalblcount = blcount + increment;
			if (finalblcount === 0)
			{
				pElement.removeClass("splAdded");
				finalblcount = "";
			}
			else
			{
				pElement.addClass("splAdded");
			}
			pElement.html(finalblcount);
		};
		
		I.preventMapPropagation("#wvwSupply");
		for (var i in W.Metadata.BlueprintGrade)
		{
			for (var ii in W.Metadata.BlueprintType)
			{
				var grade = W.Metadata.BlueprintGrade[i];
				var blueprint = $("<ins class='spl spl_" + grade.toLowerCase() + "_" + ii + "'></ins>");
				var supply = (W.Metadata.BlueprintType[ii])[i];
				$("#splBlueprints" + grade).append(blueprint);
				(function(iSupply)
				{
					blueprint.click(function()
					{
						addSupply($(this), iSupply);
						$("#splHave").trigger("input");
					});
					blueprint.contextmenu(function()
					{
						addSupply($(this), -1 * iSupply);
						$("#splHave").trigger("input");
						return false; // Prevents context menu popping up
					});
				})(supply);
			}
		}
		
		// Bind reset button
		$("#splReset").click(function()
		{
			$("#splBlueprints ins").html("").removeClass("splAdded");
			$("#splNeed").html("0");
			W.numSiegeSupply = 0;
			$("#splHave").trigger("input");
		});
		
		// Bind supply have input
		$("#splHave").click(function()
		{
			$(this).select();
		}).on("input", function()
		{
			var value = T.parseQuantity($(this).val(), 0) - W.numSiegeSupply;
			var elm = $("#splRemain").html(value);
			I.colorizeValue(elm, value);
		});
	},
	
	/*
	 * Updates the server names for the current match wherever it is shown.
	 */
	updateParticipants: function()
	{
		if (W.MatchupCurrent !== null)
		{
			// Log server borderlands names
			X.relabelCheckbox("#opt_bol_logRedHome", W.MatchupCurrent["red"].oNameStr);
			X.relabelCheckbox("#opt_bol_logBlueHome", W.MatchupCurrent["blue"].oNameStr);
			X.relabelCheckbox("#opt_bol_logGreenHome", W.MatchupCurrent["green"].oNameStr);
			X.relabelCheckbox("#opt_bol_logCenter", W.getName("Center"));
			
			// Compass zone links borderlands names
			$("#wvwZoneLinkRed").html(W.MatchupCurrent["red"].oNameStr);
			$("#wvwZoneLinkBlue").html(W.MatchupCurrent["blue"].oNameStr);
			$("#wvwZoneLinkGreen").html(W.MatchupCurrent["green"].oNameStr);
			
			// Initial messages in the log window
			W.addLogEntry($("#wvwHelpLinks").html() + "<br /><br /><br />");
			W.addLogEntry(W.MatchupCurrent["green"].oNickStr + " : " + W.MatchupCurrent["blue"].oNickStr + " : " + W.MatchupCurrent["red"].oNickStr);
			
			// Update map spawn labels
			$(".wvwSpawnContainer").each(function()
			{
				var owner = $(this).attr("data-owner").toLowerCase();
				var label = W.MatchupCurrent[owner].oNameLinesStr;
				$(this).find(".wvwSpawnLabel").html(label);
			});
		}
	},
	
	/*
	 * Resets objective properties and updates the objectives.
	 * @param boolean pWipeLog;
	 */
	reinitializeServerChange: function(pWipeLog)
	{
		// Initialize properties to be later compared within the API
		for (var i in W.Objectives)
		{
			var obj = W.Objectives[i];
			obj.isImmune = false; // Boolean if is recently captured
			obj.owner = null; // String owner
			obj.last_flipped = null; // String ISO time
			obj.last_flipped_msec = null; // Integer
			obj.claimed_by = "none"; // String guild ID, the API can have actual "null" values
			obj.claimed_at = null; // String ISO time
			obj.prevownerhtml = null; // HTML created from log entry after ownership change
		}
		W.LocaleCurrent = (O.Options.enu_Server >= W.LocaleThreshold.Europe)
			? W.LocaleEnum.Europe : W.LocaleEnum.Americas;
		W.MatchupIDCurrent = null;
		W.MatchStartTimeMS = null;
		W.MatchFinishTimeMS = null;
		W.MatchFinishTimeISO = null;
		W.MatchupCurrent = null;
		$(".objUmbrellaContainer").hide();
		$(".objTimer").empty();
		$(".objProgressBar").hide();
		$("#lboCurrent").empty().append(I.cThrobber);
		$("#lboOther").empty();
		if (pWipeLog !== false)
		{
			$("#logWindow").empty();
		}
		
		// Stop the previous timeout and call the update function with initialization
		W.toggleObjectiveTick(false);
		W.toggleObjectiveTick(true);
	},
	
	/*
	 * Checks for changes in the match API data and updates objectives state.
	 */
	updateObjectives: function()
	{
		if (W.isWvWPaused)
		{
			return;
		}
		var timedb = {};
		var fliptime;
		var fliptimenumduplicate = 0;
		var fliptimeignore = null;
		var maxattemptsuntilfallback = 3;
		var maxduplicatefliptime = 18; // Number of non-neutral objectives in the borderlands during reset
		var now = new Date();
		var nowmsec = now.getTime();
		var succeedReconnection = function()
		{
			W.numFailedAPICalls = 0;
			W.isAPIFailed = false;
			W.isFallbackEnabled = false;
			I.write("WvW data connection reestablished at " + T.getTimeFormatted());
		};
		if (W.isFallbackEnabled)
		{
			W.updateObjectivesFallback();
		}
		
		// Attempt to retrieve objectives data
		U.getJSON(U.URL_API.Match + O.Options.enu_Server, function(pData)
		{
			if (W.isFallbackEnabled)
			{
				succeedReconnection();
				W.reinitializeServerChange(false);
				return;
			}
			var map, obj, apiobj;
			var numobjflipped = 0;
			var maxobjflipped = 16;
			var istoomanyflips = false;
			
			// Initialize stagnant variables once
			if (W.MatchFinishTimeISO !== pData.end_time)
			{
				var relinkdate = W.getWorldRelink(new Date(pData.end_time));
				var timetillrelink = relinkdate.getTime() - nowmsec;
				W.MatchFinishTimeISO = pData.end_time;
				W.MatchStartTimeMS = (new Date(pData.start_time)).getTime();
				W.MatchFinishTimeMS = (new Date(pData.end_time)).getTime();
				W.secTillWvWReset = Math.floor((W.MatchFinishTimeMS - nowmsec) / T.cMSECONDS_IN_SECOND);
				W.MatchupIDCurrent = pData.id;
				W.MatchupCurrent = W.formatMatchup(pData);
				W.updateParticipants();
				W.addLogEntry("Next server relink: " + T.formatLocal(relinkdate, {year: "numeric", month: "numeric", day: "numeric"})
					+ " (" + T.formatMilliseconds(timetillrelink) + ")");
			}
			
			// Update scoreboard
			if (O.Options.bol_showLeaderboard)
			{
				W.insertScoreboard(pData);
			}
			
			// First iteration to see if the objectives are resetted (all having the same flipped time)
			for (var i in pData.maps)
			{
				map = pData.maps[i];
				for (var ii in map.objectives)
				{
					fliptime = map.objectives[ii].last_flipped;
					if (timedb[fliptime] === undefined)
					{
						timedb[fliptime] = 0;
					}
					timedb[fliptime] += 1;
					if (timedb[fliptime] > fliptimenumduplicate)
					{
						fliptimenumduplicate = timedb[fliptime];
						if (fliptimenumduplicate > maxduplicatefliptime)
						{
							fliptimeignore = fliptime;
						}
					}
				}
			}
			
			// Update objectives
			for (var i in pData.maps)
			{
				map = pData.maps[i];
				for (var ii in map.objectives)
				{
					apiobj = map.objectives[ii];
					obj = W.Objectives[apiobj.id];
					if (obj === undefined) // Ignore unknown objectives
					{
						continue;
					}
					/*
					 * Only update the objectives if they have changed server ownership.
					 */
					if (obj.last_flipped !== apiobj.last_flipped)
					{
						if (obj.last_flipped !== null)
						{
							numobjflipped++;
						}
						// Reinitialize properties
						obj.last_flipped = apiobj.last_flipped;
						obj.last_flipped_msec = (new Date(apiobj.last_flipped)).getTime();
						obj.prevowner = obj.owner;
						obj.owner = apiobj.owner;
						obj.data = apiobj;
						W.updateObjectiveIcon(obj);
						W.updateObjectiveAge(obj);
						W.updateObjectiveTooltip(obj);

						// Mark the objective as immune if it is recently captured
						if ((nowmsec - obj.last_flipped_msec) < W.cMSECONDS_IMMUNITY
								&& obj.owner !== W.OwnerEnum.Neutral // Neutral objectives never have immunity
								&& obj.type !== W.ObjectiveEnum.Ruins) // Ruins do not have immunity
						{
							/*
							 * During reset or API server problems, numerous objectives may have the same last flipped timestamp,
							 * so ignore those objectives.
							 */
							if (fliptimeignore === null || ((fliptimeignore !== null) && (fliptimeignore !== obj.last_flipped)))
							{
								W.Objectives[obj.id].isImmune = true;
								$("#objProgressBar_" + obj.id).show().find("var").css({width: "0%"}).animate({width: "100%"}, 800);
							}
						}
					}
					/*
					 * Only update guild tag labels if claiming has changed.
					 */
					if (obj.claimed_by !== apiobj.claimed_by)
					{
						obj.prevclaimed_by = obj.claimed_by;
						obj.claimed_by = apiobj.claimed_by;
						obj.claimed_at = apiobj.claimed_at;
						W.updateObjectiveClaim(obj);
					}
					// If these many objectives flipped after an update then there might be an error with the API
					if (numobjflipped > maxobjflipped)
					{
						istoomanyflips = true;
						break;
					}
				}
				if (numobjflipped > maxobjflipped)
				{
					istoomanyflips = true;
					break;
				}
				
				// Update bloodlust, must simulate API structure of objective because bloodlust do not
				var apiobjowner = (map.bonuses && map.bonuses.length) ? map.bonuses[0].owner : W.OwnerEnum.Neutral;
				var landnick = W.Rotation[map.type];
				obj = W.Objectives[landnick + "_" + "bloodlust"];
				if (obj && obj.owner !== apiobjowner)
				{
					obj.last_flipped = nowmsec;
					obj.last_flipped_msec = nowmsec;
					obj.prevowner = obj.owner;
					obj.owner = apiobjowner;
					obj.claimed_by = null;
					W.updateObjectiveIcon(obj);
					W.updateObjectiveTooltip(obj);
				}
			}
			
			// Check for errors
			if (istoomanyflips)
			{
				D.stopSpeech();
				W.reinitializeServerChange(false);
				W.addLogEntry("Restarted due to API error.");
				I.write("Too many objectives updated. ArenaNet API server may be having problems.");
			}
			if (W.isAPIFailed)
			{
				succeedReconnection();
			}
		}, false).fail(function()
		{
			if (W.isFallbackEnabled === false)
			{
				W.numFailedAPICalls++;
				if (W.numFailedAPICalls > maxattemptsuntilfallback)
				{
					W.isFallbackEnabled = true;
					W.updateObjectives();
					I.print("<br />Too many failed API retrievals. Switched to backup API server.<br />"
						+ "If problem persists, please consult <a" + U.convertExternalAnchor(U.URL_API.Support + "?source=wvw") + ">ArenaNet API forum</a> for status updates.");
				}
				else
				{
					if (W.isAPIFailed === false)
					{
						W.isAPIFailed = true;
						// If failed near reset then tell so, otherwise generic error
						var errormessage = (W.secTillWvWReset !== null && W.secTillWvWReset < 10 * T.cSECONDS_IN_MINUTE)
							? "WvW reset is happening soon." : "The map will refresh automatically when ArenaNet servers are back online.";
						I.print("Unable to retrieve WvW data during " + T.getTimeFormatted() + ". Please wait...<br />" + errormessage);
					}
				}
			}
		});
	},
	
	/*
	 * Converts a v1 API matches.json match object to a v2 API worlds object.
	 * @param object pMatch.
	 * @returns object worlds.
	 */
	convertWorlds: function(pMatch)
	{
		return {
			red: pMatch.red_world_id,
			blue: pMatch.blue_world_id,
			green: pMatch.green_world_id
		};
	},
	
	/*
	 * Uses the v1 API to get objectives state. Reconstructs data as v2 API
	 * style objects so they can be reused.
	 */
	updateObjectivesFallback: function()
	{
		var now = new Date();
		var nowiso = now.toISOString();
		var nowmsec = now.getTime();
		// First find the matchup for the selected server
		if (W.MatchupIDCurrent === null || W.Matches === null)
		{
			U.getJSON(U.URL_API.MatchesFallback, function(pData)
			{
				if (W.isFallbackEnabled === false)
				{
					return;
				}
				W.Matches = {};
				for (var i in pData.wvw_matches)
				{
					var match = pData.wvw_matches[i];
					var serverid = parseInt(O.Options.enu_Server);
					W.Matches[match.wvw_match_id] = match;
					// Execute this function again now that the match ID is found
					if (match.red_world_id === serverid
						|| match.blue_world_id === serverid
						|| match.green_world_id === serverid)
					{
						W.MatchupIDCurrent = match.wvw_match_id;
						W.MatchStartTimeMS = (new Date(pData.start_time)).getTime();
						W.MatchFinishTimeMS = (new Date(pData.end_time)).getTime();
						W.secTillWvWReset = Math.floor((W.MatchFinishTimeMS - nowmsec) / T.cMSECONDS_IN_SECOND);
						// Initialize matchup data
						W.MatchupCurrent = W.formatMatchup(W.Matches[W.MatchupIDCurrent]);
						W.updateParticipants();
						W.updateObjectivesFallback();
					}
				}
			}, false);
		}
		else
		{
			U.getJSON(U.URL_API.MatchFallback + W.MatchupIDCurrent, function(pData)
			{
				if (W.isFallbackEnabled === false)
				{
					return;
				}
				var map, obj, apiobj, landprefix;
				var pastfar = new Date(nowmsec - W.cMSECONDS_IMMUNITY);
				var pastnear = new Date(nowmsec - (O.Options.int_secWvWRefresh * T.cMSECONDS_IN_SECOND));
				for (var i in pData.maps)
				{
					map = pData.maps[i];
					landprefix = W.LandPrefix[map.type];
					for (var ii in map.objectives)
					{
						apiobj = map.objectives[ii];
						obj = W.Objectives[landprefix + apiobj.id];
						if (obj === undefined) // Ignore unknown objectives
						{
							continue;
						}
						/*
						 * Only update the objectives if they have changed server ownership.
						 */
						var past = (obj.owner === null) ? pastfar : pastnear;
						if (obj.owner !== apiobj.owner)
						{
							// Reinitialize properties
							obj.last_flipped = past.toISOString();
							obj.last_flipped_msec = past.getTime();
							obj.prevowner = obj.owner;
							obj.owner = apiobj.owner;
							W.updateObjectiveIcon(obj);
							W.updateObjectiveAge(obj);
							W.updateObjectiveTooltip(obj);

							// Mark the objective as immune if it is recently captured
							if ((nowmsec - obj.last_flipped_msec) < W.cMSECONDS_IMMUNITY
									&& obj.owner !== W.OwnerEnum.Neutral) // If it is owned by Neutral (no immunity) then it is WvW reset
							{
								W.Objectives[obj.id].isImmune = true;
								$("#objProgressBar_" + obj.id).show().find("var").css({width: "0%"}).animate({width: "100%"}, 800);
							}
						}
						/*
						 * Only update guild tag labels if claiming has changed.
						 */
						if (obj.claimed_by !== apiobj.owner_guild)
						{
							obj.prevclaimed_by = obj.claimed_by;
							obj.claimed_by = apiobj.owner_guild;
							obj.claimed_at = nowiso;
							W.updateObjectiveClaim(obj);
						}
					}
				}

				// Update scoreboard
				if (O.Options.bol_showLeaderboard)
				{
					W.insertScoreboard(pData);
				}
			}, false);
		}
	},
	
	/*
	 * Refreshes the objective's icon, which is also its color, to the current owner.
	 * @param object pObjective.
	 */
	updateObjectiveIcon: function(pObjective)
	{
		// Update objective visuals
		var animationspeed = 2000;
		var objumbrella = $("#objUmbrella_" + pObjective.id); // A big circle over the objective icon
		var objicon = $("#objIcon_" + pObjective.id);
		var prevwidth = objicon.css("width");

		// If the objective is being reassigned from a known previous owner
		if (pObjective.prevowner !== null && pObjective.owner !== W.OwnerEnum.Neutral)
		{
			var prevcolor = W.Metadata[pObjective.prevowner].color;
			var color = W.Metadata[pObjective.owner].color;
			objumbrella.parent().parent().show(); // Show the umbrella container
			// Color the umbrella notification circle and blink it
			objumbrella.css({borderColor: prevcolor, boxShadow: "0px 0px 10px " + prevcolor});
			I.bloatElement(objumbrella, 1000, 100);
			// Squash the icon to 0 width, then change the icon image and stretch it back to previous width
			(function(iOwner, iUmbrella, iColor)
			{
				objicon.css({width: prevwidth}).animate({width: 0}, animationspeed, function()
				{
					iUmbrella.css({borderColor: iColor, boxShadow: "0px 0px 10px " + iColor});
					$(this).attr("src", W.getObjectiveImage(pObjective))
						.animate({width: prevwidth}, animationspeed, function()
						{
							iUmbrella.parent().parent().hide();
							W.adjustZoomMapping();
						});
				});
			})(pObjective.owner, objumbrella, color);
			// Log the change of ownership
			W.addLogEntryObjective(pObjective);
		}
		else
		{
			// If it is the first initialization (no previous known owner), then just assign the icons
			objicon.attr("src", W.getObjectiveImage(pObjective));
		}
	},
	
	/*
	 * Updates the HTML timer of recently captured objectives. To be called by
	 * the clock tick second function.
	 */
	updateObjectiveTimers: function()
	{
		var obj;
		var msec = (new Date()).getTime();
		var msecage, msecremaining, percentremaining;
		var msectolerance = 30000;
		
		for (var i in W.Objectives)
		{
			obj = W.Objectives[i];
			// Update the Righteous Indigntation timers
			if (obj.isImmune)
			{
				msecage = msec - obj.last_flipped_msec;
				msecremaining = W.cMSECONDS_IMMUNITY - msecage;
				percentremaining = (msecremaining / W.cMSECONDS_IMMUNITY) * T.cPERCENT_100;
				if (msecremaining > 0 && msecage + msectolerance > 0)
				{
					document.getElementById("objTimer_" + obj.id).innerHTML = T.formatTimeColon(msecremaining);
					document.getElementById("objProgress_" + obj.id).style.width = percentremaining + "%";
				}
				else if (msecage + msectolerance <= 0)
				{
					if (T.isTimeOutOfSync === false)
					{
						W.addLogEntry("Negative time detected. Your computer's time may be <a"
							+ U.convertExternalAnchor("https://www.google.com/search?q=synchronize+time") + ">out of sync!</a>");
						T.isTimeOutOfSync = true;
					}
				}
				else
				{
					// If the objective has become capturable
					$("#objTimer_" + obj.id).html("");
					$("#objProgressBar_" + obj.id).css({opacity: 1}).animate({opacity: 0}, 2000, function()
					{
						$(this).css({opacity: 1}).hide();
					});
					$("#objIcon_" + obj.id).css({opacity: 0}).animate({opacity: 1}, 2000);
					obj.isImmune = false;
					W.updateObjectiveAge(obj);
				}
			}
		}
	},
	
	/*
	 * Updates the label showing an objective's time since it was last captured.
	 * @param object pObjective.
	 */
	updateObjectiveAge: function(pObjective)
	{
		if (pObjective.last_flipped_msec)
		{
			var msecage = (new Date()).getTime() - pObjective.last_flipped_msec;
			// Minutely updates
			$("#objAge_" + pObjective.id).html(T.getShorthandTime(msecage));
		}
	},
	updateAllObjectiveAge: function()
	{
		// To be called minutely by the clock tick second function
		for (var i in W.Objectives)
		{
			W.updateObjectiveAge(W.Objectives[i]);
		}
	},
	
	/*
	 * Updates the label showing the guild tag of who claimed the objective.
	 * @param object pObjective.
	 */
	updateObjectiveClaim: function(pObjective)
	{
		var guildid = pObjective.claimed_by;
		var updateClaim = function()
		{
			var guild = Q.getCachedGuild(guildid);
			pObjective.oGuildName = guild.name;
			pObjective.oTagInitial = guild.tag;
			pObjective.oTag = guild.oTag;
			W.updateObjectiveTooltip(pObjective);
			var label = $("#objClaim_" + pObjective.id);
			var prevcolor = label.css("color");
			label.html(guild.oTag);
			// Also animate if guild has changed from previous known claimer
			if (pObjective.prevclaimed_by !== "none")
			{
				I.blinkElement(label, 2000, 200);
				W.addLogEntryObjective(pObjective, true);
			}
		};
		
		// If the objective was previously claimed but has become unclaimed
		if (guildid === null || guildid === undefined)
		{
			pObjective.oGuildName = null;
			pObjective.oTag = null;
			W.updateObjectiveTooltip(pObjective);
			$("#objClaim_" + pObjective.id).empty();
		}
		// If the objective changed claimers, update and use cached guild if available
		else
		{
			Q.getGuilds(guildid, function()
			{
				updateClaim();
			});
		}
	},
	
	/*
	 * Rewrites the objective marker's HTML tooltip with the current objective's
	 * properties data. To be called when objective changed owner or claim.
	 * @param object pObjective.
	 */
	updateObjectiveTooltip: function(pObjective)
	{
		// Initialize tooltip behavior for ith icon
		var obj = pObjective;
		var icon = $("#objIcon_" + obj.id);
		var claim = "";
		if (obj.claimed_by)
		{
			claim = "<aside><dfn>Claim:</dfn> " + (new Date(obj.claimed_at)).toLocaleString() + "</aside>"
				+ "<aside><dfn>Guild:</dfn> " + U.escapeHTML(obj.oGuildName + " " + obj.oTag) + "</aside>"
				+ "<aside class='cssCenter'><img class='objTooltipBanner' src='" + U.getGuildBannerURL(obj.oGuildName) + "' /></aside>";
		}
		
		var title = "<div class='objTooltip'>"
			+ "<aside><dfn class='objTooltipName'>" + D.getObjectName(obj) + "</dfn></aside>"
			+ "<aside class='cntDivider objTooltipDivider'></aside>"
			+ "<aside><dfn>Owner:</dfn> " + (new Date(obj.last_flipped)).toLocaleString() + "</aside>"
			+ ((pObjective.prevownerhtml) ? "<aside class='cssCenter'>" + pObjective.prevownerhtml + "</aside>" : "")
			+ claim
		+ "</div>";
		I.qTip.init(icon.attr("title", title));
	},
	
	/*
	 * Starts or stops the objectives tick function and sets associated variables.
	 * @param boolean pBoolean true to start.
	 */
	toggleObjectiveTick: function(pBoolean)
	{
		if (pBoolean)
		{
			W.isObjectiveTickEnabled = pBoolean;
			W.tickObjectives();
			W.isObjectiveTimerTickEnabled = pBoolean;
		}
		else
		{
			window.clearTimeout(W.ObjectiveTimeout);
			W.isObjectiveTickEnabled = pBoolean;
			W.isObjectiveTimerTickEnabled = pBoolean;
		}
	},
	
	/*
	 * Executes the update objectives function every few seconds.
	 */
	tickObjectives: function()
	{
		if (W.isObjectiveTickEnabled)
		{
			W.updateObjectives();
			window.clearTimeout(W.ObjectiveTimeout);
			W.ObjectiveTimeout = setTimeout(function()
			{
				W.tickObjectives();
			}, O.Options.int_secWvWRefresh * T.cMSECONDS_IN_SECOND);
		}
	}
};
J = {
/* =============================================================================
 * @@J Projection 3D display for overlay.
 * ========================================================================== */

	Renderer: {},
	Scene: {},
	Camera: {},
	isProjectionInitialized: false,

	initializeProjection: function()
	{
		J.Scene = new THREE.Scene();
		J.Camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

		J.Renderer = new THREE.WebGLRenderer({alpha: true});
		J.Renderer.setClearColor(0xffffff, 0);
		J.Renderer.setSize(window.innerWidth, window.innerHeight);
		document.getElementById("itemProjector").appendChild(J.Renderer.domElement);

		var geometry = new THREE.BoxGeometry(1, 1, 1);
		var material = new THREE.MeshBasicMaterial({color: 0x00ff00});
		var cube = new THREE.Mesh(geometry, material);
		//J.Scene.add(cube);

		//J.Camera.position.x = 3;
		//J.Camera.position.y = 4;
		J.Camera.position.z = 5;
		//J.Camera.lookAt(new THREE.Vector3(1, 0, 0));
		
		var geometry = new THREE.CircleGeometry(1, 32);
		var material = new THREE.MeshBasicMaterial({color: 0xffff00});
		var circle = new THREE.Mesh(geometry, material);
		J.Scene.add(circle);

		var render = function ()
		{
			requestAnimationFrame(render);

			cube.rotation.x += 0.1;
			cube.rotation.y += 0.1;

			J.Renderer.render(J.Scene, J.Camera);
		};

		render();
		
		J.isProjectionInitialized = true;
	}

};
T = {
/* =============================================================================
 * @@Time utilities, schedule, daily, and numeric functions
 * ========================================================================== */
	Daily: GW2T_DAILY_DATA,
	DailyAssociation: GW2T_DAILY_ASSOCIATION,
	DailyToday: null,
	DailyTomorrow: null,
	ResetToday: null,
	ResetTomorrow: null,
	Schedule: {},
	DryTopSets: {},
	DryTopCodes: {},
	
	DST_IN_EFFECT: 0, // Will become 1 and added to the server offset if DST is on
	SECONDS_TILL_DAILY: 0,
	SECONDS_TILL_WEEKLY: 0,
	TIMESTAMP_UNIX_SECONDS: 0,
	cUTC_OFFSET_USER: 0,
	cUTC_OFFSET_SERVER: -8, // Server is Pacific Time, 8 hours behind UTC
	cUTC_OFFSET_HAWAII: -10,
	cUTC_OFFSET_EASTERN: -4,
	// Natural constants
	cMSECONDS_IN_SECOND: 1000,
	cMSECONDS_IN_MINUTE: 60000,
	cMSECONDS_IN_DAY: 86400000,
	cSECONDS_IN_MINUTE: 60,
	cSECONDS_IN_HOUR: 3600,
	cSECONDS_IN_DAY: 86400,
	cSECONDS_IN_WEEK: 604800,
	cSECONDS_IN_MONTH: 2592000,
	cSECONDS_IN_YEAR: 31536000,
	cMINUTES_IN_HOUR: 60,
	cMINUTES_IN_2_HOURS: 120,
	cMINUTES_IN_DAY: 1440,
	cHOURS_IN_MERIDIEM: 12,
	cHOURS_IN_DAY: 24,
	cDAYS_IN_WEEK: 7,
	cDAYS_IN_BIWEEK: 14,
	cDAYS_IN_MONTH: 30,
	cDAYS_IN_YEAR: 365,
	cMONTHS_IN_YEAR: 12,
	cSECONDS_IN_TIMEFRAME: 900,
	cMINUTES_IN_TIMEFRAME: 15,
	cMINUTES_IN_MINIFRAME: 5,
	cNUM_TIMEFRAMES_IN_HOUR: 4,
	cSECS_MARK_0: 0,
	cSECS_MARK_1: 900,
	cSECS_MARK_2: 1800,
	cSECS_MARK_3: 2700,
	cSECS_MARK_4: 3599,
	cBASE_10: 10,
	cBASE_16: 16,
	cPERCENT_100: 100,
	// Geometry and velocity constants
	cCIRCLE_RIGHT_DEGREE: 90,
	cCIRCLE_HALF_DEGREE: 180,
	cCIRCLE_FULL_DEGREE: 360,
	cRADIAN_TO_DEGREE: 180 / Math.PI,
	cUNITS_TO_POINTS: 1 / 24, // Map coordinates "points" versus game range "units"
	cPOINTS_TO_UNITS: 24, // 1 game "unit" is 1 "inch"
	cUNITS_TO_METERS: 0.0254,
	cMETERS_TO_UNITS: 1 / 0.0254,
	cUNITS_PER_SECOND: 386, // Units traveled in one second while on swiftness buff
	// Game constants
	cWEEKLY_RESET_SECONDS: 113400, // Monday 07:30 UTC, seconds since Sunday 00:00 UTC
	cDAYTIME_DAY_MINUTES: 80,
	cDAYTIME_NIGHT_MINUTES: 40,
	cDAYTIME_DAY_START: 25,
	cDAYTIME_NIGHT_START: 45,
	cDAYTIME_TRANSITION_MINUTES: 5,
	ReferenceEnum:
	{
		UTC: 0,
		Local: 1,
		Server: 2
	},
	UnitEnum:
	{
		Milliseconds: 0,
		Seconds: 1,
		Minutes: 2,
		Hours: 3
	},
	DayEnum:
	{
		Sunday: 0,
		Monday: 1,
		Tuesday: 2,
		Wednesday: 3,
		Thursday: 4,
		Friday: 5,
		Saturday: 6
	},
	isTimeOutOfSync: false,
	secondsTillResetWeekly: -1,
	isChecklistCountdownsStarted: false,
	
	/*
	 * Gets a clipboard text of the current Dry Top events.
	 * @param int pOffset frames from the current.
	 * @returns string of events for that event frame.
	 */
	getCurrentDryTopEvents: function(pOffset)
	{
		return T.DryTopCodes[T.getDryTopMinute(pOffset)].chat + I.siteTagCurrent;
	},
	getCurrentDryTopColor: function(pOffset)
	{
		return T.DryTopCodes[T.getDryTopMinute(pOffset)].color;
	},
	
	/*
	 * Gets the minute in the current event frame.
	 * @param int pOffset from current.
	 * @returns string minute.
	 */
	getDryTopMinute: function(pOffset)
	{
		pOffset = pOffset || 0;
		var now = new Date();
		var min = now.getUTCMinutes();
		var minute = (Math.floor(min / T.cMINUTES_IN_MINIFRAME) * T.cMINUTES_IN_MINIFRAME) + (pOffset * T.cMINUTES_IN_MINIFRAME);
		minute = T.wrapInteger(minute, T.cMINUTES_IN_HOUR);
		
		return T.padZero(minute);
	},
	
	/*
	 * Initializes Dry Top event sets to be used in clipboard text.
	 */
	initializeDryTopStrings: function()
	{
		var getDryTopSet = function(pSet)
		{
			var events = T.DryTopSets[pSet];
			var str = "";
			for (var i in events)
			{
				str += D.getObjectName(events[i]) + "@" + events[i].wp + " ";
			}
			return str.trim();
		};

		T.DryTopSets = GW2T_DRYTOP_SETS;
		T.DryTopCodes = GW2T_DRYTOP_CODES;
		for (var i in T.DryTopCodes) // Initialize chatcodes
		{
			T.DryTopCodes[i].chat += getDryTopSet(T.DryTopCodes[i].set);
		}
		
		K.updateDryTopClipboard();
		$("#itemDryTopClip").show();
	},
	
	/*
	 * Initializes a slot in the schedule. All units are in minutes since UTC midnight.
	 * @param int pTime minute.
	 * Example of expected schedule:
	 *	T.Schedule =
	 *	{
	 *	   "0": {SchedTime: 0 SchedChains: [C.Taidha, C.Tequatl]},
	 *	  "15": {SchedTime: 15, SchedChains: [C.Maw]},
	 *	  "30": {SchedTime: 30, SchedChains: [C.Megades]},
	 *	  "45": {SchedTime: 45, SchedChains: [C.FE]},
	 *		...
	 *	}
	 */
	initializeScheduleSlot: function(pTime)
	{
		if (T.Schedule[pTime] === undefined)
		{
			T.Schedule[pTime] = {SchedTime: pTime, SchedChains: []};
		}
	},
	
	/*
	 * Inserts a chain into the schedule.
	 * @param object pChain.
	 * @param array/object pTime array of strings of HH:MM format,
	 * or an object with the timing pattern:
	 * hourInitial: the first UTC hour the chain starts on.
	 * hourMultiplier: the repetition on every so hours.
	 * minuteOffset: the UTC minutes from those hours.
	 */
	insertChainToSchedule: function(pChain)
	{
		var utcminute = 0;
		var timing = pChain.timing;
		// If given an array of start times
		if (Array.isArray(timing))
		{
			for (var i in timing)
			{
				utcminute = T.parseChainTime(timing[i]);
				T.initializeScheduleSlot(utcminute);
				T.Schedule[utcminute].SchedChains.push(pChain);
			}
		}
		// If given a pattern of the start times
		else
		{
			for (utcminute = (timing.hourInitial * T.cMINUTES_IN_HOUR) + timing.minuteOffset;
				utcminute < T.cMINUTES_IN_DAY;
				utcminute += timing.hourMultiplier * T.cMINUTES_IN_HOUR)
			{
				T.initializeScheduleSlot(utcminute);
				T.Schedule[utcminute].SchedChains.push(pChain);
			}
		}
	},
	
	/*
	 * Initializes the schedule used by chains, clock, and timeline.
	 */
	initializeSchedule: function()
	{
		var i, ii, iii;
		var slot;
		
		// Initialize Living Story events, if available
		if (H.Story.isEnabled)
		{
			if (T.isTimely(H.Story, new Date()))
			{
				H.isStoryEnabled = true;
				// Determine living story placement
				if (I.isProgramEmbedded
					|| I.ModeCurrent !== I.ModeEnum.Website
					|| O.Options.bol_showHUD === false
					|| O.Options.bol_showDashboard === false)
				{
					H.isStoryDashboard = false;
				}
			}
		}
		
		// Initialize chains
		if (D.isLanguageLogographic)
		{
			C.cEventCharLimit = C.cEventCharLimitLogographic;
		}
		X.initializeChecklist(X.Checklists.Chain, C.Chains.length + C.UnscheduledChainsLength);
		X.initializeChecklist(X.Checklists.ChainSubscription, C.Chains.length + C.UnscheduledChainsLength);
		C.initializeScheduledChains();
		I.initializeChainsUI();
		// Initial recoloring of chain titles
		$("#sectionChains_Scheduled .chnBar h1, #sectionChains_Drytop .chnBar h1, #dsbStory .chnBar h1")
			.addClass("chnTitleFutureFar");
		
		// Every scheduled chain gets an array of schedule keys (UTC minutes) of where it is in the schedule
		for (i in C.ScheduledChains)
		{
			T.insertChainToSchedule(C.ScheduledChains[i]);
		}
		for (i in T.Schedule)
		{
			slot = T.Schedule[i];
			for (ii in C.ScheduledChains)
			{
				for (iii in slot.SchedChains)
				{
					if (C.ScheduledChains[ii].nexus === slot.SchedChains[iii].nexus)
					{
						C.ScheduledChains[ii].scheduleKeys.push(i);
						break;
					}
				}
			}
		}
		
		// Initialize for the touring function to access current active event
		C.CurrentChainSD = T.getStandardChain();
	},
	
	/*
	 * Gets the minutes for specified slot.
	 * @param int pKey of schedule slot.
	 * @returns int minutes.
	 */
	getScheduleSlotTime: function(pKey)
	{
		return T.Schedule[pKey].SchedTime;
	},
	
	/*
	 * Gets the chain array in schedule by specified key.
	 * @param string pKey of schedule slot.
	 * @returns array chains.
	 */
	getScheduleSlotChainsByKey: function(pKey)
	{
		return T.Schedule[pKey].SchedChains;
	},
	
	/*
	 * Gets the earliest minutes since UTC midnight that is divisible by the
	 * timeframe minutes.
	 * @returns int minutes.
	 */
	getCurrentTimeframe: function()
	{
		var minutes = T.getTimeSinceMidnight(T.ReferenceEnum.UTC, T.UnitEnum.Minutes);
		return minutes - (minutes % T.cMINUTES_IN_TIMEFRAME);
	},
	
	/*
	 * Gets the minutes since midnight UTC corresponding to a schedule slot
	 * divisible by the timeframe minutes.
	 * @param int pOffset number of timeframes from the current.
	 * @returns int minutes.
	 */
	getTimeframe: function(pOffset)
	{
		pOffset = pOffset || 0;
		var frameminute = T.getCurrentTimeframe() + (pOffset * T.cMINUTES_IN_TIMEFRAME);
		return T.wrapInteger(frameminute, T.cMINUTES_IN_DAY);
	},
	
	/*
	 * Gets an array of chains for specified timeframe.
	 * @param int pOffset number of timeframes from the current.
	 * @returns array chains, current active chains if offset is 0.
	 */
	getTimeframeChains: function(pOffset)
	{
		return T.Schedule[T.getTimeframe(pOffset)].SchedChains;
	},
	
	/*
	 * Gets a chain of particular series for specified timeframe.
	 * @param int pOffset number of timeframes from the current.
	 * @param string pSeries to filter the chains array.
	 */
	getTimeframeChainBySeries: function(pOffset, pSeries)
	{
		var chains = T.getTimeframeChains(pOffset);
		
		for (var i in chains)
		{
			if (chains[i].series === pSeries)
			{
				return chains[i];
			}
		}
		return null;
	},
	getTimeframeChainsBySeries: function(pOffset, pSeries)
	{
		var chains = T.getTimeframeChains(pOffset);
		var retchains = [];
		
		for (var i in chains)
		{
			if (chains[i].series === pSeries)
			{
				retchains.push(chains[i]);
			}
		}
		return retchains;
	},
	getStandardChain: function(pOffset)
	{
		return T.getTimeframeChainBySeries(pOffset, C.ChainSeriesEnum.Standard);
	},
	getHardcoreChain: function(pOffset)
	{
		/*
		 * Because there are gaps in the "hardcore schedule", the return needs
		 * to be checked before using since it can be null.
		 */
		return T.getTimeframeChainBySeries(pOffset, C.ChainSeriesEnum.Hardcore);
	},
	getLivingStoryChain: function(pOffset)
	{
		return T.getTimeframeChainBySeries(pOffset, C.ChainSeriesEnum.LivingStory);
	},
	getMiscellaneousChains: function(pOffset)
	{
		return T.getTimeframeChainsBySeries(pOffset, C.ChainSeriesEnum.Miscellaneous);
	},
	
	/*
	 * Gets the key from current timeframe offset.
	 * @param int pOffset number of timeframes from the current.
	 * @returns string key for the schedule slot.
	 */
	getTimeframeKey: function(pOffset)
	{
		return (T.getTimeframe(pOffset)).toString();
	},
	
	/*
	 * Gets the local time in seconds for when a chain starts in the schedule.
	 * @param string pKey in the schedule.
	 * @returns int seconds since midnight local time.
	 */
	convertScheduleKeyToLocalSeconds: function(pKey)
	{
		var time = (T.getScheduleSlotTime(pKey) * T.cSECONDS_IN_MINUTE)
			- ((new Date()).getTimezoneOffset() * T.cSECONDS_IN_MINUTE);
		return T.wrapInteger(time, T.cSECONDS_IN_DAY);
	},
	convertScheduleKeyToUTCMinutes: function(pKey)
	{
		// Removes the time prefix from the key to get the minutes
		return parseInt(pKey);
	},
	
	/*
	 * Gets the time the current chain has been running.
	 * @returns int seconds or minutes elapsed since chain started.
	 */
	getCurrentTimeframeElapsedTime: function(pUnit)
	{
		var now = new Date();
		var min = now.getUTCMinutes();
		var sec = now.getUTCSeconds();
		
		if (pUnit === T.UnitEnum.Minutes)
		{
			return min % T.cMINUTES_IN_TIMEFRAME;
		}
		return ((min % T.cMINUTES_IN_TIMEFRAME) * T.cSECONDS_IN_MINUTE) + sec;
	},
	
	/*
	 * Gets the seconds until a chain start by subtracting the current time from
	 * the chain start time; both of which are seconds since midnight. Because
	 * the timer uses the 24 hour cyclical system, this function faces the
	 * design problem of deciding whether the chain start time is ahead or
	 * behind the local time when past midnight.
	 * @param object pChain to get start time.
	 * @returns int seconds remaining, negative if it started already.
	 * @pre Chain's scheduleKeys array was refreshed with the earliest start
	 * time at the first index.
	 */
	getSecondsUntilChainStarts: function(pChain)
	{
		var secondschain = (T.convertScheduleKeyToLocalSeconds(pChain.scheduleKeys[0]));
		var secondscurrent = T.getTimeSinceMidnight(T.ReferenceEnum.Local, T.UnitEnum.Seconds);
		var rolloverthreshold = (T.cSECONDS_IN_TIMEFRAME * T.cNUM_TIMEFRAMES_IN_HOUR); // This is 3600 seconds
		
		/*
		 * It is known that the program looks at most 4 chains ahead of the
		 * current to display the clock icons. Deal with the midnight problem by
		 * enforcing a one hour threshold before and after midnight, so for
		 * example the current time is 23:00:00 and the target chain starts at
		 * 00:15:00, it would return 01:15:00 (in seconds). Without the
		 * threshold, it would return -22:45:00.
		 */
		if (secondschain >= (T.cSECONDS_IN_DAY - rolloverthreshold)
			&& secondscurrent <= rolloverthreshold)
		{
			return (T.cSECONDS_IN_DAY - secondschain) + secondscurrent;
		}
		if (secondscurrent >= (T.cSECONDS_IN_DAY - rolloverthreshold)
			&& secondschain <= rolloverthreshold)
		{
			return (T.cSECONDS_IN_DAY - secondscurrent) + secondschain;
		}
		
		return secondschain - secondscurrent;
	},
	
	/*
	 * Gets a readable string of minutes and hours until a chain starts.
	 * @param object pChain to tell time.
	 * @param string pFormat of the time words.
	 * @returns string time string.
	 */
	getTimeTillChainFormatted: function(pChain, pFormat)
	{
		var secondsleft = T.getSecondsUntilChainStarts(pChain);
		var min = Math.floor(secondsleft / T.cSECONDS_IN_MINUTE) % T.cSECONDS_IN_MINUTE;
		var hour = Math.floor(secondsleft / T.cSECONDS_IN_HOUR);
		var minword = D.getTranslation("m");
		var hourword = D.getTranslation("h");
		
		if (pFormat === "speech")
		{
			minword = " " + D.getSpeechWord("minute");
			hourword = " " + D.getSpeechWord("hour");
			if (Math.abs(min) > 1)
			{
				minword = " " + D.getSpeechWord("minutes");
			}
			if (Math.abs(hour) > 1)
			{
				hourword = " " + D.getSpeechWord("hours");
			}
			if (hour === 0 && Math.abs(min) === 30)
			{
				min = D.getTranslation("half an hour");
				minword = "";
				hourword = "";
			}
		}
		hourword += " ";

		min = min + minword;
		if (Math.abs(secondsleft) >= T.cSECONDS_IN_HOUR)
		{
			hour = hour + hourword;
		}
		else
		{
			hour = "";
		}
		
		if (secondsleft < 0)
		{
			return " " + hour + min + " " + D.getTranslation("ago");
		}
		return " " + D.getTranslation("in") + " " + hour + min;
	},
	
	/*
	 * Gets a random integer between inclusive range.
	 * @param int pMin value.
	 * @param int pMax value.
	 * @returns int random.
	 */
	getRandomIntRange: function(pMin, pMax)
	{
		return Math.floor(Math.random() * (pMax - pMin + 1)) + pMin;
	},
	
	/*
	 * Gets the lowest and highest value inside an array.
	 * @param array pArray.
	 * @param string pProperty of array if the value is a property.
	 * @returns object contains min and max values, and their key/index.
	 */
	getMinMax: function(pArray, pProperty)
	{
		var hasprop = !(pProperty === undefined);
		var min = Number.POSITIVE_INFINITY;
		var max = Number.NEGATIVE_INFINITY;
		var minkey = null;
		var maxkey = null;
		var ith;
		for (var i in pArray)
		{
			ith = hasprop ? (pArray[i])[pProperty] : pArray[i];
			if (ith < min)
			{
				min = ith;
				minkey = i;
			}
			if (ith > max)
			{
				max = ith;
				maxkey = i;
			}
		}
		return {
			oMin: min,
			oMax: max,
			oMinKey: minkey,
			oMaxKey: maxkey
		};
	},
	
	/*
	 * Adjusts an integer so that it is within 0 to the specified limit. Example:
	 * Integer 26 with Limit 24 returns 2. Integer -4 with Limit 24 returns 20.
	 * For use in circular arrays.
	 * @param int pInteger to readjust within limit.
	 * @param int pMax limit of the quantity.
	 * @param boolean pIsInclusive whether Integer 24 with Limit 24 returns 24 or 0, optional.
	 * @returns int natural number rolled over.
	 */
	wrapInteger: function(pInteger, pMax, pIsInclusive)
	{
		var i = pInteger;
		// Inclusive case
		if (pIsInclusive && (pInteger / pMax === 0))
		{
			return pInteger;
		}
		// Rollover
		i = i % pMax;
		
		// Adjust for negative
		if (i < 0)
		{
			i = pMax + i;
		}
		return i;
	},
	
	/*
	 * Constraints a number to the min or max value if it is out of those bounds.
	 * @param int pNumber.
	 * @param int pMin.
	 * @param int pMax.
	 * @returns int.
	 */
	clampInteger: function(pNum, pMin, pMax)
	{
		if (pNum < pMin)
		{
			return pMin;
		}
		if (pNum > pMax)
		{
			return pMax;
		}
		return pNum;
	},
	clampFloor: function(pNum, pMin)
	{
		return T.clampInteger(pNum, pMin, Number.POSITIVE_INFINITY);
	},
	clampCeil: function(pNum, pMax)
	{
		return T.clampInteger(pNum, Number.NEGATIVE_INFINITY, pMax);
	},
	
	/*
	 * Gets a stepped output of a linear equation.
	 * @param int pX
	 * @param int pDivisor
	 * @param int pMin
	 * @param int pMax
	 * @param int pMultiplier
	 * @returns int y, or pMin or pMax if out of these range.
	 */
	stepFunction: function(pX, pDivisor, pMin, pMax, pMultiplier)
	{
		var result = (Math.floor(pX / pDivisor) * pMultiplier) + pMin;
		return (result > pMax) ? pMax : result;
	},
	
	/*
	 * Parses a counting number.
	 * @param number or string pQuantity.
	 * @param number pDefault value.
	 * @returns cleaned quantity.
	 */
	parseQuantity: function(pQuantity, pDefault)
	{
		if (pDefault === undefined)
		{
			pDefault = 1;
		}
		var quantity = parseInt(pQuantity);
		if ( ! isFinite(quantity)) { quantity = pDefault; }
		return quantity;
	},
	
	/*
	 * Parses a quotient.
	 * @param number pRatio.
	 * @param int pDigits of decimals to show.
	 * @returns cleaned decimal.
	 */
	parseRatio: function(pRatio, pDigits)
	{
		if (pRatio === 0 || isNaN(pRatio))
		{
			return 0;
		}
		else if (pRatio === 1 || pRatio === Number.POSITIVE_INFINITY || pRatio === Number.NEGATIVE_INFINITY)
		{
			return 1;
		}
		return (pDigits !== undefined) ? pRatio.toFixed(pDigits) : pRatio;
	},
	
	/*
	 * Converts a time string to seconds.
	 * @param string pTime in X:XX:XX or X:XX or 0 format.
	 * @returns int seconds totaled.
	 * @pre Time string contains at most 1 "~" and at most 2 ":".
	 */
	parseEventTime: function(pTime)
	{
		/*
		 * Time string with the ~ are preformatted as the minimum time plus the
		 * window time (two time strings), for example "1:30:00~30:00" is 1.5 hour
		 * wait, and 0.5 hour window during which the next event can happen.
		 */
		var time = [];
		if (pTime.indexOf("~") !== -1)
		{
			time = pTime.split("~");
			// Sum the minimum wait with the expected (half) time of the window
			return T.parseEventTime(time[0]) + Math.floor(T.parseEventTime(time[1]) / 2);
		}
		if (pTime === "*")
		{
			return 0;
		}
		// If just a number without colons, assume it is already seconds
		if (pTime.indexOf(":") === -1)
		{
			return parseInt(pTime, T.cBASE_10);
		}

		time = pTime.split(":");
		if (time.length === 2)
		{
			return parseInt(time[0], T.cBASE_10) * T.cSECONDS_IN_MINUTE
				+ parseInt(time[1], T.cBASE_10);
		}
		if (time.length === 3)
		{
			return parseInt(time[0]) * T.cSECONDS_IN_HOUR
				+ parseInt(time[1], T.cBASE_10) * T.cSECONDS_IN_MINUTE
				+ parseInt(time[2], T.cBASE_10);
		}
		return NaN;
	},
	
	/*
	 * Converts "XX:XX" (hours:minutes) to minutes.
	 * @param string pTime to convert.
	 * @returns int minutes totaled.
	 */
	parseChainTime: function(pTime)
	{
		var time = pTime.split(":");
		return parseInt(time[0], T.cBASE_10) * T.cMINUTES_IN_HOUR
			+ parseInt(time[1], T.cBASE_10);
	},
	unparseChainTime: function(pMinutes)
	{
		var hours = Math.floor(pMinutes / T.cMINUTES_IN_HOUR);
		var minutes = pMinutes % T.cSECONDS_IN_MINUTE;
		return T.padZero(hours) + ":" + T.padZero(minutes);
	},

	/*
	 * The DST global integer is added to the server hour, which is incremented if
	 * DST is in effect. The code is from https://javascript.about.com/library/bldst.htm
	 */
	checkDST: function()
	{
		Date.prototype.stdTimezoneOffset = function()
		{
			var jan = new Date(this.getFullYear(), 0, 1);
			var jul = new Date(this.getFullYear(), 6, 1);
			return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
		};
		Date.prototype.dst = function()
		{
			return this.getTimezoneOffset() < this.stdTimezoneOffset();
		};

		var now = new Date();
		T.DST_IN_EFFECT = (now.dst() && O.Options.bol_detectDST) ? 1 : 0;
	},
	
	/*
	 * Pad an hour, minute, or second string with a zero if less than 10 (decimal).
	 * @param string pTime.
	 * @returns string padded time.
	 */
	padZero: function(pTime)
	{
		return (pTime < T.cBASE_10) ? "0" + pTime : pTime;
	},

	/*
	 * Gets a formatted time string, arguments are taken as key-value pairs.
	 * @objparam string aReference place to offset the time, default is local.
	 * @objparam boolean aWant24 to format as 24 hour or not (AM/PM).
	 * @objparam boolean aWantSeconds to include the seconds.
	 * @objparam boolean aWantHours to include the hours.
	 * @objparam boolean aWantLetters to format #h #m #s instead of colons. Overrides want24.
	 * @objparam boolean aWantNegative allow negative time.
	 * @objparam Date aCustomTimeInDate to convert to time string.
	 * @objparam int aCustomTimeInSeconds to convert to a time string, will use
	 * current time if undefined.
	 * @returns 23:59:59 or 11:59:59 PM or 23h 59m 59s time string.
	 */
	getTimeFormatted: function(pSettings)
	{
		var Settings = $.extend({
			aReference: T.ReferenceEnum.Local,
			aWant24: O.Options.bol_use24Hour,
			aWantSeconds: true,
			aWantHours: true,
			aWantLetters: false
		}, pSettings);
		
		var sec, min, hour;
		var negsym = "";
		var now = (Settings.aCustomTimeInDate === undefined) ? (new Date()) : Settings.aCustomTimeInDate;
		if (Settings.aCustomTimeInSeconds === undefined)
		{
			switch (Settings.aReference)
			{
				case T.ReferenceEnum.Local:
				{
					sec = now.getSeconds();
					min = now.getMinutes();
					hour = now.getHours();
				} break;
				case T.ReferenceEnum.Server:
				{
					sec = now.getSeconds();
					min = now.getMinutes();
					hour = now.getUTCHours() + T.cUTC_OFFSET_SERVER + T.DST_IN_EFFECT;
					hour = T.wrapInteger(hour, T.cHOURS_IN_DAY);
				} break;
				case T.ReferenceEnum.UTC:
				{
					sec = now.getUTCSeconds();
					min = now.getUTCMinutes();
					hour = now.getUTCHours();
				} break;
			}
		}
		else
		{
			// Regard negative input
			var cust = Settings.aCustomTimeInSeconds;
			if (Settings.aWantNegative)
			{
				if (cust < 0)
				{
					cust = Math.abs(cust);
					negsym = I.Symbol.Negative;
				}
			}
			else
			{
				cust = T.wrapInteger(Settings.aCustomTimeInSeconds, T.cSECONDS_IN_DAY);
			}
			
			sec = cust % T.cSECONDS_IN_MINUTE;
			min = Math.floor(cust / T.cSECONDS_IN_MINUTE) % T.cMINUTES_IN_HOUR;
			hour = Math.floor(cust / T.cSECONDS_IN_HOUR);
		}
		
		var minsec = "";
		// Include the seconds else don't
		if (Settings.aWantSeconds)
		{
			if (Settings.aWantLetters)
			{
				if (hour === 0 && min === 0)
				{
					minsec = sec + D.getWord("s");
				}
				else
				{
					minsec = min + D.getWord("m") + " " + sec + D.getWord("s");
				}
			}
			else if (Settings.aWantHours === false)
			{
				minsec = min + ":" + T.padZero(sec);
			}
			else
			{
				minsec = T.padZero(min) + ":" + T.padZero(sec);
			}
		}
		else
		{
			if (Settings.aWantLetters)
			{
				minsec = min + D.getWord("m");
			}
			else
			{
				minsec = T.padZero(min);
			}
		}
		
		// Possible returns
		if (Settings.aWantLetters)
		{
			if (hour === 0 || Settings.aWantHours === false)
			{
				return negsym + minsec;
			}
			return negsym + hour + D.getWord("h") + " " + minsec;
		}
		if (Settings.aWant24)
		{
			if (Settings.aWantHours === false)
			{
				return minsec;
			}
			return T.padZero(hour) + ":" + minsec;
		}
		// Else shift the hour and suffix the meridiem
		var period = " AM";
		if (hour >= T.cHOURS_IN_MERIDIEM)
		{
			if (hour > T.cHOURS_IN_MERIDIEM)
			{
				hour = hour % T.cHOURS_IN_MERIDIEM;
			}
			period = " PM";
		}
		else if (hour === 0)
		{
			hour = T.cHOURS_IN_MERIDIEM;
		}
		return hour + ":" + minsec + period;
	},
	
	/*
	 * Gets a "0m" "1m" "59m" "1.0h" "25.9h" single unit approximated time string.
	 * @param int pMilliseconds of time.
	 * @returns string shorthand.
	 */
	getShorthandTime: function(pMilliseconds)
	{
		var seconds = Math.floor(pMilliseconds / T.cMSECONDS_IN_SECOND);
		// Return minutes
		if (seconds < T.cSECONDS_IN_MINUTE)
		{
			return 0 + D.getWord("m");
		}
		if (seconds < T.cSECONDS_IN_HOUR)
		{
			return (Math.floor(seconds / T.cSECONDS_IN_MINUTE) % T.cMINUTES_IN_HOUR) + D.getWord("m");
		}
		// Return hours
		return (seconds / T.cSECONDS_IN_HOUR).toFixed(1) + D.getWord("h");
	},
	
	/*
	 * Gets an ISO-like timestamp in local time.
	 * @returns string timestamp.
	 */
	getLocalTimestamp: function()
	{
		var now = new Date();
		var z = function(n)
		{
			return T.padZero(n);
		};
		return (now.getFullYear() + "-" + z(now.getMonth() + 1) + "-" + z(now.getDate())
			+ "_"
			+ z(now.getHours()) + "." + z(now.getMinutes()) + "." + z(now.getSeconds()));
	},
	
	/*
	 * Gets a "Days:Hours:Minutes:Seconds" string from seconds.
	 * @param int pMilliseconds of time.
	 * @returns string formatted time.
	 */
	formatTimeColon: function(pMilliseconds, pWantDeciseconds)
	{
		var signstr = "";
		var ms = pMilliseconds;
		if (ms < 0)
		{
			ms *= -1;
			signstr = I.Symbol.Negative;
		}
		var seconds = Math.floor(ms / T.cMSECONDS_IN_SECOND);
		var day, hour, min, sec;
		var daystr = "";
		var hourstr = "";
		var minstr = "";
		var secstr = "";
		var msstr = "";
		
		if (seconds >= T.cSECONDS_IN_DAY)
		{
			day = Math.floor(seconds / T.cSECONDS_IN_DAY);
			daystr = day + "::";
		}
		if (seconds >= T.cSECONDS_IN_HOUR)
		{
			hour = Math.floor(seconds / T.cSECONDS_IN_HOUR) % T.cHOURS_IN_DAY;
			hourstr = hour + ":";
			if (daystr !== "" && hour < T.cBASE_10)
			{
				hourstr = "0" + hourstr;
			}
		}
		if (seconds >= T.cSECONDS_IN_MINUTE)
		{
			min = Math.floor(seconds / T.cSECONDS_IN_MINUTE) % T.cMINUTES_IN_HOUR;
			minstr = min + ":";
			if (hourstr !== "" && min < T.cBASE_10)
			{
				minstr = "0" + minstr;
			}
		}
		else
		{
			minstr = "0:";
		}
		sec = seconds % T.cSECONDS_IN_MINUTE;
		secstr = sec.toString();
		if (sec < T.cBASE_10)
		{
			secstr = "0" + secstr;
		}
		if (pWantDeciseconds)
		{
			var deciseconds = Math.floor((ms % T.cMSECONDS_IN_SECOND) / T.cBASE_10);
			msstr = "." + deciseconds;
			if (deciseconds < T.cBASE_10)
			{
				msstr = ".0" + deciseconds;
			}
		}
		
		return signstr + daystr + hourstr + minstr + secstr + msstr;
	},
	
	/*
	 * Gets a "1w 6d 23h 59m 59s" string from seconds.
	 * Months instead of weeks if duration >= 30 days.
	 * Years and days instead of lower denominations if duration >= 365 days.
	 * @param int pSeconds of time.
	 * @returns string formatted time.
	 */
	formatTimeLetter: function(pSeconds, pWantSeconds, pWantShort)
	{
		var seconds = pSeconds;
		var year, month, week, day, hour, min, sec;
		var yearstr = "";
		var monthstr = "";
		var weekstr = "";
		var daystr = "";
		var hourstr = "";
		var minstr = "";
		var secstr = "";
		var signstr = "";
		var daydivisor = T.cDAYS_IN_YEAR;
		
		// Case zero
		if (pSeconds === 0)
		{
			return "0" + D.getWord("s");
		}
		
		// Sign string
		if (seconds < 0)
		{
			seconds = seconds * -1;
			signstr = I.Symbol.Negative;
		}
		// Year, month, and week string
		if (seconds < T.cSECONDS_IN_YEAR)
		{
			if (seconds >= T.cSECONDS_IN_MONTH)
			{
				month = Math.floor(seconds / T.cSECONDS_IN_MONTH);
				monthstr = month + D.getWord("mo") + " ";
				daydivisor = T.cDAYS_IN_MONTH;
			}
			else
			{
				if (seconds >= T.cSECONDS_IN_WEEK)
				{
					week = Math.floor(seconds / T.cSECONDS_IN_WEEK);
					weekstr = week + D.getWord("w") + " ";
				}
				daydivisor = T.cDAYS_IN_WEEK;
			}
		}
		else
		{
			year = Math.floor(seconds / T.cSECONDS_IN_YEAR);
			yearstr = year + D.getWord("y") + " ";
		}
		// Day string
		if (seconds >= T.cSECONDS_IN_DAY)
		{
			if (pWantShort)
			{
				return Math.floor(seconds / T.cSECONDS_IN_DAY) + D.getWord("d");
			}
			day = Math.floor(seconds / T.cSECONDS_IN_DAY) % daydivisor;
			daystr = day + D.getWord("d") + ((seconds < T.cSECONDS_IN_YEAR) ? " " : "");
		}
		// Include hms only if duration is less than a year
		if (seconds < T.cSECONDS_IN_YEAR)
		{
			if (seconds >= T.cSECONDS_IN_HOUR)
			{
				hour = Math.floor(seconds / T.cSECONDS_IN_HOUR) % T.cHOURS_IN_DAY;
				hourstr = hour + D.getWord("h") + " ";
			}
			if (seconds >= T.cSECONDS_IN_MINUTE)
			{
				min = Math.floor(seconds / T.cSECONDS_IN_MINUTE) % T.cMINUTES_IN_HOUR;
				minstr = min + D.getWord("m") + ((pWantSeconds || seconds < T.cSECONDS_IN_MINUTE) ? " " : "");
			}
			if (pWantSeconds || seconds < T.cSECONDS_IN_MINUTE)
			{
				sec = seconds % T.cSECONDS_IN_MINUTE;
				secstr = sec.toString() + D.getWord("s");
			}
		}
		
		return signstr + yearstr + monthstr + weekstr + daystr + hourstr + minstr + secstr;
	},
	formatMilliseconds: function(pMilliseconds)
	{
		return T.formatTimeLetter(Math.floor(pMilliseconds / T.cMSECONDS_IN_SECOND));
	},
	formatMinutes: function(pMinutes)
	{
		return T.formatTimeLetter(pMinutes * T.cSECONDS_IN_MINUTE);
	},
	formatISO: function(pDate)
	{
		return pDate.toISOString().split(".")[0]; // "YYYY-MM-DDTHH:mm:ss.sssZ" so milliseconds is excluded
	},
	
	/*
	 * Formats the succinct time format of ingame tooltips. Example: "59 s", "59 m", "23 h", "1 d"
	 * @param int pMilliseconds
	 * @returns string.
	 */
	formatTooltipTime: function(pSeconds, pWantSpace)
	{
		var sec = pSeconds;
		var space = (pWantSpace) ? " " : "";
		var divisors = [T.cSECONDS_IN_MINUTE, T.cSECONDS_IN_HOUR, T.cSECONDS_IN_DAY, T.cSECONDS_IN_YEAR];
		var units = ["m", "h", "d"];
		if (sec < T.cSECONDS_IN_MINUTE)
		{
			return sec + space + D.getWord("s");
		}
		for (var i = 0; i < units.length; i++)
		{
			if (sec < divisors[i+1])
			{
				return Math.floor(sec / divisors[i]) + space + D.getWord(units[i]);
			}
		}
		return "";
	},
	formatTooltipTimeMS: function(pMilliseconds, pWantSpace)
	{
		return T.formatTooltipTime(Math.floor(pMilliseconds / T.cMSECONDS_IN_SECOND), pWantSpace);
	},
	
	/*
	 * Gets standard localized time string with weekday word included.
	 * @param Date pDate object.
	 * @param boolean pWantTime to include other time units.
	 * @returns string.
	 */
	formatWeektime: function(pDate, pWantTime)
	{
		var date = (pDate instanceof Date) ? pDate : (new Date(pDate));
		var options = {year: "numeric", month: "numeric", day: "numeric", weekday: "long"};
		if (pWantTime)
		{
			options.hour = "numeric";
			options.minute = "numeric";
		}
		return date.toLocaleString(window.navigator.language, options);
	},
	formatLocal: function(pDate, pOptions)
	{
		return pDate.toLocaleString(window.navigator.language, pOptions);
	},
	
	/*
	 * Checks a time sensitive object if its Start and Finish date objects fits
	 * the provided time range.
	 * @param object pObject to check.
	 * @param Date pDate time to compare with, such as now.
	 * @param int pGracePeriod seconds to add to the finish time, optional.
	 */
	isTimely: function(pObject, pDate, pGracePeriod)
	{
		var comparedate = pDate || new Date(); // If comparison and start time is not provided then use now time
		var start = pObject.Start || comparedate;
		var finish = (pGracePeriod === undefined)
			? pObject.Finish : (new Date(pObject.Finish.getTime() + pGracePeriod * T.cMSECONDS_IN_SECOND));
		if (comparedate >= start && comparedate <= finish)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Tells if current UTC time is daytime in game or not (night).
	 * @returns true if daytime.
	 */
	isDaylight: function()
	{
		var now = new Date();
		var hour = now.getUTCHours();
		var min = now.getUTCMinutes();
		if (hour % 2 === 0) // If hour is even
		{
			if (min >= T.cDAYTIME_DAY_START)
			{
				return true;
			}
		}
		else // If hour is odd
		{
			if (min < T.cDAYTIME_NIGHT_START)
			{
				return true;
			}
		}
		return false;
	},
	
	/*
	 * Gets a preformatted string of the minutes of daylight or night remaining.
	 * Also sets the clock's background dimming.
	 * @returns string.
	 */
	getDayPeriodRemaining: function()
	{
		var now = new Date();
		var hour = now.getUTCHours();
		var min = now.getUTCMinutes();
		var minremain = ""; // Dim the clock background
		if (hour % 2 === 0)
		{
			if (min >= T.cDAYTIME_DAY_START) // Day
			{
				minremain = (T.cDAYTIME_DAY_START + T.cDAYTIME_DAY_MINUTES - min);
				// Light transitions only happen during day time, night is always fully dimmed
				if (minremain > T.cDAYTIME_TRANSITION_MINUTES)
				{
					if (minremain >= T.cDAYTIME_DAY_MINUTES - T.cDAYTIME_TRANSITION_MINUTES)
					{
						K.setDimming((T.cDAYTIME_DAY_MINUTES - minremain + 1) / T.cDAYTIME_TRANSITION_MINUTES, true);
					}
					else
					{
						K.setDimming(1);
					}
				}
				else
				{
					K.setDimming(minremain / T.cDAYTIME_TRANSITION_MINUTES, true);
				}
				// Is transitioning to day
				if (min === T.cDAYTIME_DAY_START && O.Options.bol_alertDaylight)
				{
					D.speak(D.getPhraseTitle("approaching day"));
					I.notify({
						aTitle: D.getWordCapital("day"),
						aIcon: "img/notification/day.png"
					});
				}
			}
			else // Night
			{
				minremain = (T.cDAYTIME_DAY_START - min);
				K.setDimming(0.1);
			}
		}
		else
		{
			if (min < T.cDAYTIME_NIGHT_START) // Day
			{
				minremain = (T.cDAYTIME_NIGHT_START - min);
				if ((minremain > T.cDAYTIME_TRANSITION_MINUTES))
				{
					K.setDimming(1);
				}
				else
				{
					K.setDimming((minremain / T.cDAYTIME_TRANSITION_MINUTES), true);
				}
			}
			else // Night
			{
				minremain = (T.cDAYTIME_NIGHT_START + T.cDAYTIME_NIGHT_MINUTES - min);
				K.setDimming(0.1);
				// Is transitioning to night
				if (min === T.cDAYTIME_NIGHT_START && O.Options.bol_alertDaylight)
				{
					D.speak(D.getPhrase("approaching night"));
					I.notify({
						aTitle: D.getWordCapital("night"),
						aIcon: "img/notification/night.png"
					});
				}
			}
		}
		return minremain + D.getWord("m");
	},
	
	/*
	 * Gets a Date object of the previous UTC midnight
	 * @returns Date.
	 */
	getUTCMidnight: function()
	{
		return (new Date()).setUTCHours(0, 0, 0, 0);
	},

	/*
	 * Gets the time in units since midnight at the point of reference.
	 * @param string pTimeUnit time unit to convert from.
	 * @param string pReference place to offset the time, default is UTC.
	 * @returns number seconds, minutes, or hours.
	 */
	getTimeSinceMidnight: function(pReference, pTimeUnit)
	{
		pTimeUnit = pTimeUnit || T.UnitEnum.Seconds;
		pReference = pReference || T.ReferenceEnum.UTC;
		
		var now = new Date();
		var hour = now.getUTCHours();
		var min = now.getUTCMinutes();
		var sec = now.getUTCSeconds();
		
		switch (pReference)
		{
			case T.ReferenceEnum.UTC: break;
			case T.ReferenceEnum.Server: hour = hour + T.cUTC_OFFSET_SERVER + T.DST_IN_EFFECT; break;
			case T.ReferenceEnum.Local:
			{
				 hour = now.getHours();
				 min = now.getMinutes();
				 sec = now.getSeconds();
			} break;
		}
		hour = T.wrapInteger(hour, T.cHOURS_IN_DAY);

		if (pTimeUnit === T.UnitEnum.Hours)
		{ 
			return hour;
		}
		if (pTimeUnit === T.UnitEnum.Minutes)
		{
			return (hour * T.cMINUTES_IN_HOUR) + min;
		}
		// Default return seconds
		return (hour * T.cSECONDS_IN_HOUR) + (min * T.cSECONDS_IN_MINUTE) + sec;
	},
	
	/*
	 * Gets the number of days between two dates.
	 * @param Date pStart.
	 * @param Date pFinish.
	 * @returns int.
	 */
	getDaysSince: function(pStart, pFinish)
	{
		return Math.floor(Math.abs((pStart.getTime() - pFinish.getTime()) / T.cMSECONDS_IN_DAY));
	},
	
	/*
	 * Gets the seconds since Sunday 00:00 UTC.
	 */
	getSecondsSinceWeekstart: function(pSecondsSinceMidnight)
	{
		return ((new Date()).getUTCDay() * T.cSECONDS_IN_DAY) + pSecondsSinceMidnight;
	},
	
	/*
	 * Gets the seconds since 1970 January 1 00:00:00 UTC.
	 * @returns int seconds.
	 */
	getUNIXSeconds: function()
	{
		return Math.floor((new Date()).getTime() / T.cMSECONDS_IN_SECOND);
	},
	
	/*
	 * Increments a Date object by number of days.
	 * @param object pDate.
	 * @param int pDays to increment. Can be negative.
	 * @returns object Date.
	 */
	addDaysToDate: function(pDate, pDays)
	{
		var newdate = new Date(pDate);
		newdate.setDate(pDate.getDate() + pDays);
		return newdate;
	},
	
	/*
	 * Gets the number of days in a month.
	 * @param object pDate
	 * @returns int days
	 * Source: https://stackoverflow.com/questions/1184334/get-number-days-in-a-specified-month-using-javascript
	 */
	getDaysInMonth: function(pDate)
	{
		return (new Date(pDate.getUTCFullYear(), pDate.getUTCMonth() + 1, 0)).getUTCDate();
	},
	
	/*
	 * Gets the minutes elapsed in the current even hour of UTC.
	 * Example: 14:00 = 0, 14:20 = 20, 15:59 = 119, 16:00 = 0
	 * @returns int minutes.
	 */
	getCurrentBihourlyMinutesUTC: function()
	{
		var now = new Date();
		return ((now.getUTCHours() % 2) * T.cMINUTES_IN_HOUR) + now.getUTCMinutes();
	},
	
	/*
	 * Gets the timestamp for the current two-hour period.
	 * @param int pOffset minutes since the start of the current even hour.
	 * @returns string timestamp.
	 */
	getCurrentBihourlyTimestampLocal: function(pOffset)
	{
		var now = new Date();
		var hour = now.getUTCHours();
		var evenhour = (hour % 2 === 0) ? hour : (hour - 1);
		
		var time = ((evenhour * T.cMINUTES_IN_HOUR)) - now.getTimezoneOffset();
		time = T.wrapInteger(time, T.cMINUTES_IN_DAY);
		return T.getTimeFormatted({
			aCustomTimeInSeconds: ((time + pOffset) * T.cSECONDS_IN_MINUTE),
			aWantSeconds: false
		});
	},
	
	/*
	 * Gets the seconds until a time within a week.
	 * @param int pWeekTime the target time in seconds since Sunday 00:00 UTC.
	 * @param int pCurrentTimestamp UNIX seconds.
	 * @param int pSecondsSinceMidnight UTC.
	 * @returns int seconds.
	 */
	getSecondsTillWeektime: function(pWeekTime, pSecondsSinceMidnight)
	{
		var secondssinceweekstart = T.getSecondsSinceWeekstart(pSecondsSinceMidnight);
		return (secondssinceweekstart > pWeekTime) ?
			((T.cSECONDS_IN_WEEK - secondssinceweekstart) + pWeekTime) :
			(pWeekTime - secondssinceweekstart);
	},
	
	/*
	 * Counts down till weekly reset. For use by the personal checklist.
	 */
	updateChecklistCountdowns: function()
	{
		var dstr = T.formatTimeLetter(T.SECONDS_TILL_DAILY, true);
		var wstr = T.formatTimeLetter(T.SECONDS_TILL_WEEKLY, true);
		$(".jsCountdownToDaily").text(dstr);
		$(".jsCountdownToWeekly").text(wstr);
	},
	
	/*
	 * Converts an API daily object to a nickname based object with similar structure.
	 * @param object pObj from API.
	 * @returns object reformatted.
	 */
	convertDailyObject: function(pObj)
	{
		var dailyobj = {
			pve: [],
			pvp: [],
			wvw: [],
			fractals: []
		};
		var a = T.DailyAssociation;
		var newpve = [];
		for (var i = 0; i < pObj.pve.length; i++)
		{
			var ithdaily = pObj.pve[i];
			// Only allow max level and max expansion access dailies
			if (ithdaily.level.max === Q.GameLimit.LevelMax)
			{
				for (var ii = 0; ii < ithdaily.required_access.length; ii++)
				{
					if (ithdaily.required_access[ii] === Q.AccessEnum.Max)
					{
						newpve.push(ithdaily);
						break;
					}
				}
			}
		}
		var sets = {
			pve: newpve,
			pvp: pObj.pvp,
			wvw: pObj.wvw
		};
		
		// Turn the achievement IDs into achievement nicknames
		for (var i in sets)
		{
			var ithset = sets[i];
			for (var ii in ithset)
			{
				if (a[(ithset[ii].id)])
				{
					// First keyword in the daily string is the achievement ID
					dailyobj[i].push(ithset[ii].id + " " + a[(ithset[ii].id)]);
				}
				else
				{
					dailyobj[i].push("0 unknown");
				}
			}
		}
		
		// Flatten API's fractal array of objects into an array of IDs
		for (var i in pObj.fractals)
		{
			var id = pObj.fractals[i].id;
			dailyobj.fractals.push(id);
		}
		
		return dailyobj;
	},
	
	/*
	 * Extracts the daily world boss from a daily object.
	 * @param object pDaily that was converted from the API object.
	 * @returns object chain or null if invalid boss.
	 */
	extractDailyChain: function(pDaily)
	{
		if (pDaily && pDaily.pve)
		{
			for (var i in pDaily.pve)
			{
				var dcode = pDaily.pve[i].split(" ");
				if (dcode[1] === "Boss")
				{
					return C.getChainByAlias(dcode[2].toLowerCase());
				}
			}
		}
		return null;
	},
	
	/*
	 * Initializes the daily object and the today chain object.
	 * @objparam boolean aWantGetTomorrow whether to get tomorrow's daily object instead.
	 * @objparam boolean aWantSetTomorrow whether to set today's daily object as tomorrow's.
	 * @objparam boolean aIsReset whether to also do daily reset related functions.
	 * @returns jqXHR object.
	 */
	getDaily: function(pSettings)
	{
		var Settings = pSettings || {};
		var retrywaitminutes = 3;
		var url = (Settings.aWantGetTomorrow || Settings.aWantSetTomorrow) ? U.URL_API.Tomorrow : U.URL_API.Daily;
		
		return $.getJSON(url, function(pData)
		{
			if (Settings.aWantGetTomorrow) // Get tomorrow
			{
				T.DailyTomorrow = T.convertDailyObject(pData);
				C.ChainTomorrow = T.extractDailyChain(T.DailyTomorrow);
			}
			else // Get today
			{
				T.DailyToday = T.convertDailyObject(pData);
				// Initialize today chain object
				var dailychain = T.extractDailyChain(T.DailyToday);
				var currentmins = T.getTimeSinceMidnight(T.ReferenceEnum.UTC, T.UnitEnum.Minutes);
				var startmins;

				if (dailychain !== null)
				{
					startmins = T.convertScheduleKeyToUTCMinutes(dailychain.scheduleKeys[0]);
					
					if (Settings.aWantSetTomorrow)
					{
						C.ChainToday = dailychain; // SUCCESS SET TOMORROW
					}
					else
					{
						/*
						 * If the today chain object was already parsed, make sure that
						 * the retrieved API daily object is different from it, in case
						 * the API server was not updated immediately at reset time.
						 */
						if (C.ChainToday !== null && Settings.aIsReset)
						{
							var previousalias = C.ChainToday.alias;
							C.ChainToday = null; // Single recursion base case
							C.refreshChainDailyIcon();
							if (dailychain.alias === previousalias)
							{
								// Wait a while and retrieve the daily object hoping it is updated
								setTimeout(function()
								{
									T.getDaily({aIsReset: true});
								},  retrywaitminutes * T.cMSECONDS_IN_MINUTE);
								return;
							}
						}

						// Make sure today's boss can still spawn before server reset at UTC midnight
						if (startmins + T.cMINUTES_IN_TIMEFRAME >= currentmins)
						{
							C.ChainToday = dailychain; // SUCCESS SET TODAY
						}
						// Else get tomorrow's boss
						else
						{
							T.getDaily({aWantSetTomorrow: true});
						}
					}
				}
				else
				{
					// No boss for this day
					C.ChainToday = null;
				}

				/*
				 * If successfully retrieved today chain object.
				 */
				if (C.ChainToday)
				{
					// Update daily icons
					C.refreshChainDailyIcon();
					if (Settings.aIsReset === true)
					{
						if (O.isServerReset)
						{
							// Tell today's world boss closest scheduled time if server resetted
							var dailybossstr = D.getModifiedWord("boss", "daily", U.CaseEnum.Sentence) + " "
								+ D.getObjectName(C.ChainToday) + " " + D.getTranslation("will start") + " " + D.getTranslation("at") + " "
								+ T.getTimeFormatted(
								{
									aWantSeconds: false,
									aCustomTimeInSeconds: T.convertScheduleKeyToLocalSeconds(C.ChainToday.scheduleKeys[0])
								}) + " " + D.getTranslation("in") + " "
								+ T.getTimeFormatted(
								{
									aWantLetters: true,
									aWantSeconds: false,
									aCustomTimeInSeconds: T.getSecondsUntilChainStarts(C.ChainToday)
								});
							I.greet(dailybossstr, 15);
						}

						// Subscribe to daily chain
						if (O.Options.bol_alertAutosubscribe &&
							O.Options.int_setAlarm === O.IntEnum.Alarm.Subscription)
						{
							var subscriptionbutton = $("#chnTime_" + C.ChainToday.nexus);
							if ( ! subscriptionbutton.hasClass("chnTimeSubscribed"))
							{
								subscriptionbutton.trigger("click");
							}
						}
					}
				}
				if (Settings.aIsReset === true && O.isServerReset)
				{
					// Mention special dailies if appropriate
					if (T.DailyToday.pve && T.DailyToday.pve[1].indexOf("Forger") !== -1)
					{
						var dailyspecialstr = U.convertExternalString(H.Announcement.Messages.Forger);
						I.greet(dailyspecialstr, 25);
						if (O.Options.bol_alertMystic)
						{
							setTimeout(function()
							{
								D.speak(U.toText(dailyspecialstr));
								I.notify({
									aTitle: "Daily Forger",
									aIcon: "img/notification/forge.png"
								});
							}, 5000);
						}
					}
				}
			}
		});
	}
	
};
H = {
/* =============================================================================
 * @@Horologe dashboard, timeline, and time sensitive content
 * ========================================================================== */

	Announcement: GW2T_DASHBOARD_DATA.Announcement,
	Countdown: GW2T_DASHBOARD_DATA.Countdown,
	Story: GW2T_DASHBOARD_DATA.Story,
	Faux: GW2T_DASHBOARD_DATA.Faux,
	Sale: GW2T_SALE_DATA,
	Pact: GW2T_DASHBOARD_DATA.Pact,
	SaleCountdowns: null, // Will contain expiration date in UNIX seconds, accessed by Items array index number
	GemSubscription: null,
	isDashboardEnabled: true,
	isAnnouncementEnabled: false,
	isCountdownEnabled: false,
	isCountdownTickEnabled: false,
	isStoryEnabled: false,
	isStoryDashboard: true,
	isDailyEnabled: true,
	isSaleEnabled: false,
	isSaleOpened: false,
	isGemPaused: false,
	isPactEnabled: true,
	isVertical: true,
	
	Timeline: GW2T_TIMELINE,
	isTimelineEnabled: true,
	isTimelineGenerated: false,
	minutesInTimelineSpacing: null, // Must be a divisor of 120 minutes

	/*
	 * Initializes dashboard components.
	 * Must be executed before the clock tick function executes.
	 */
	initializeDashboard: function()
	{
		var now = new Date();
		// Verify countdown: if at least one countdown has not expired
		for (var i = 0; i < H.Countdown.Events.length; i++)
		{
			if (H.Countdown.Events[i].Finish && now < H.Countdown.Events[i].Finish)
			{
				H.isCountdownEnabled = true;
				break;
			}
		}
		
		// Verify announcement: if announcement exists
		var announcement = H.getAnnouncement(H.Announcement.NewsPVE);
		if (announcement)
		{
			var annprefix = "<strong>" + D.getWordCapital("new") + ": </strong>";
			var announcementlinks = $("#dsbAnnouncement").show().html(annprefix + announcement).find("a");
			U.convertExternalLink(announcementlinks);
			U.convertInternalLink(announcementlinks);
			M.bindMapLinks("#dsbAnnouncement");
			H.isAnnouncementEnabled = true;
		}
		
		// Verify sale: if sale exists and has not expired
		if (H.Sale.Items.length - H.Sale.numPaddingItems > 0 && T.isTimely(H.Sale, now))
		{
			H.isSaleEnabled = true;
		}
		
		// Make sure at least one component of the dashboard is enabled, else disable the dashboard
		if ((H.isCountdownEnabled === false
				&& H.isAnnouncementEnabled === false
				&& H.isSaleEnabled === false
				&& H.isPactEnabled === false)
			|| H.isDashboardEnabled === false)
		{
			H.isDashboardEnabled = false;
			return;
		}
		else
		{
			if (O.Options.bol_showDashboard === false)
			{
				H.toggleDashboard(true);
			}
			H.isCountdownTickEnabled = true;
		}
		
		// Button to toggle the dashboard
		$("#dsbToggle").click(function()
		{
			$("#opt_bol_showDashboard").trigger("click");
		});
		
		// Initialize countdown entries
		if (H.isCountdownEnabled)
		{
			$("#dsbCountdown").show();
			var urlkey = D.getURLKey();
			var ctd;
			var countdownname;
			var url;
			
			// Initialize countdowns
			for (var i = 0; i < H.Countdown.Events.length; i++)
			{
				// Initialize countdown properties
				ctd = H.Countdown.Events[i];
				if (now > ctd.Finish)
				{
					continue;
				}
				ctd.isTimely = true;
				ctd.StartStamp = T.formatWeektime(ctd.Start, true);
				ctd.FinishStamp = T.formatWeektime(ctd.Finish, true);
				// Use default name if available, or use the translated name
				countdownname = (ctd.name === undefined) ? D.getObjectName(ctd) : ctd.name;
				// If available: set the URL as the official news page, the translated url, or a regular url
				url = (ctd.official === undefined) ? ctd[urlkey] : U.getGW2OfficialLink(ctd.official);
				url = (url === undefined) ? ctd.url : url;
				if (url.indexOf(I.cSiteURL) !== -1)
				{
					// Don't externalize URL if self link
					ctd.Anchor = "<a href='" + url + "'>" + countdownname + "</a>";
				}
				else
				{
					ctd.Anchor = "<a" + U.convertExternalAnchor(url) + ">" + countdownname + "</a>";
				}
				// Activate festival switches for those countdowns
				if (T.isTimely(ctd))
				{
					if (ctd.isHalloween)
					{
						K.isHalloween = true;
					}
					if (ctd.isWintersday)
					{
						K.isWintersday = true;
					}
				}
				
				/*
				 * code: the colored bullet point for activity status
				 * time: the countdown time
				 * abbr: the up or down arrow for start or finish start
				 * var: the start or finish time
				 */
				$("#dsbCountdown").append(
					"<div id='dsbCountdown_" + i + "' class='dsbCountdownEntry'>"
						+ "<div class='dsbCountdownSide0'><code></code>" + ctd.Anchor + "</div> "
						+ "<div class='dsbCountdownSide1'>"
							+ "<time id='dsbCountdownTime_" + i + "'></time> "
							+ "<span class='dsbCountdownDate'><abbr></abbr> <var></var></span>"
						+ "</div>"
					+ "</div>");
			}
			I.qTip.init("#dsbCountdown");
			H.refreshDashboard(now);
		}
		
		// Initialize Living Story
		if (H.isStoryEnabled && H.isStoryDashboard)
		{
			var storytitle = D.getObjectName(H.Story);
			var storystr = (H.Story.url.length) ? "<a" + U.convertExternalAnchor(H.Story.url) + ">" + storytitle + "</a>" : storytitle;
			$("#dsbStory").prepend("<div id='dsbStoryTitle'>" + storystr + "</div>").show();
		}
		
		// Initialize sale
		if (H.isSaleEnabled)
		{
			H.generateDashboardSaleHeader();
		}
		
		// Initialize vendor
		if (H.isPactEnabled)
		{
			H.generateDashboardPactHeader();
		}
		
		// Initialize daily
		if (H.isDailyEnabled)
		{
			H.generateDashboardDailyHeader(now);
		}
		
		I.toggleToggleIcon(".dsbToggleIcon", false, false);
	},
	
	/*
	 * Gets an announcement string if its object has timely content.
	 * @param object pAnnouncement
	 * @returns boolean
	 */
	getAnnouncement: function(pAnnouncement, pDate)
	{
		if (pAnnouncement && pAnnouncement.content.length > 0 && T.isTimely(pAnnouncement, pDate))
		{
			return pAnnouncement.content;
		}
		return null;
	},
	getUrgent: function(pAnnouncement, pDate)
	{
		var announcement = H.getAnnouncement(pAnnouncement, pDate);
		if (announcement)
		{
			I.urge(announcement);
		}
	},
	
	/*
	 * Generates the header for the sale feature.
	 */
	generateDashboardSaleHeader: function()
	{
		var item;
		var gemarray = [];
		var isdiscounted = false;
		// Determine price range and whether a discount exists
		for (var i = 0; i < H.Sale.Items.length; i++)
		{
			item = H.Sale.Items[i];
			if (item.side === undefined) // Skip padding items which are headers
			{
				if (item.discount && (isFinite(item.discount) || (item.discount.length && item.discount[0].length > 2)))
				{
					isdiscounted = true;
				}
				if (item.p && item.p.gem >= 0)
				{
					gemarray.push(item.p.gem);
				}
			}
		}
		var range = T.getMinMax(gemarray);
		var rangestr = (range.oMin === range.oMax) ? range.oMax : (range.oMin + "-" + range.oMax);
		// Create "button" to toggle list of items on sale
		$("#dsbMenuSale").append("<div><kbd id='dsbSaleHeader' class='curToggle'>"
			+ "<img id='dsbSaleSymbol' src='" + U.URL_IMG.Placeholder + "' /><img id='dsbSaleToggleIcon' class='dsbToggleIcon' src='img/ui/toggle.png' />"
			+ "<var>" + (H.Sale.Items.length - H.Sale.numPaddingItems) + " " + D.getWordCapital("promotions") + "</var> "
			+ "<span class='dsbSalePriceCurrent'>" + rangestr + "<ins class='s16 s16_gem'></ins></span></kbd>"
		+ "</div>").addClass("dsbTabEnabled");
		$("#dsbSale").append("<div id='dsbSaleTable' class='jsScrollable'></div>");
		// Determine if the current sale has price reduction
		$("#dsbSaleSymbol").attr("src", "img/ui/" + ((isdiscounted) ? "gemstore_special" : "gemstore") + I.cPNG);
		// Bind buttons
		$("#dsbMenuSale").click(function()
		{
			H.generateDashboardSale();
		});
	},
	generateDashboardSale: function()
	{
		var getPercentOffString = function(pPriceNew, pPriceOld)
		{
			return "<span class='dsbSalePercent'>" + U.convertRatioToPercent(-1 * (1 - (pPriceNew / pPriceOld)), 0) + "</span> ";
		};
		var getOldPriceString = function(pPriceNew, pPriceOld, pPriceOldBulk)
		{
			var oldpricestr = (pPriceOldBulk === undefined) ? pPriceOld : pPriceOldBulk;
			return getPercentOffString(pPriceNew, pPriceOld) + "<span class='dsbSalePriceOld'>" + oldpricestr + "</span> ";
		};
		var animationspeed = 200;
		var table = $("#dsbSaleTable");
		if (H.isVertical)
		{
			table.addClass("dsbSaleVertical");
		}
		
		var doGenerate = function()
		{
			I.toggleToggleIcon("#dsbSaleToggleIcon", true);
			table.empty();
			if (H.Sale.note.length > 0)
			{
				table.append("<div class='dsbNote'>Note: " + U.convertExternalString(H.Sale.note) + "</div>");
			}
			table.append("<div id='dsbSaleSide0'></div><div id='dsbSaleSide1'></div>");

			var gemstr = "<ins class='s16 s16_gem'></ins>";
			// Include the exchange rate "items" after determining range
			H.SaleCountdowns = {};
			var idstofetch = [];
			var side = 0;
			for (var i = 0; i < H.Sale.Items.length; i++)
			{
				// Initialize variables
				var item = H.Sale.Items[i];
				var itemid = item.i;
				var itemname = item.n;
				var itemprice = E.getPaymentAmount(item);
				var itemdiscount = item.discount;
				var url = item.url || U.getWikiSearchDefault(itemname);
				var video = U.getYouTubeLink(itemname);
				side = (item.side !== undefined) ? item.side : side;
				if (item.Finish)
				{
					// Skip expired items, if has expiration
					if (T.isTimely(item) === false)
					{
						continue;
					}
					H.SaleCountdowns[i] = Math.floor(item.Finish.getTime() / T.cMSECONDS_IN_SECOND);
				}

				var oldprice = null;
				// Old price also includes percent off by dividing the new with the old
				oldprice = (U.isInteger(itemdiscount)) ? itemdiscount : oldprice;
				oldprice = (Array.isArray(itemdiscount) && itemdiscount[0].length > 2) ? ((itemdiscount[0])[2]) : oldprice;
				var oldpricestr = (oldprice !== null) ? getOldPriceString(itemprice, oldprice) : "";
				// Write bulk discount hover information if available
				var discountstr = "";
				if (itemdiscount && Array.isArray(itemdiscount))
				{
					discountstr += "<span class='dsbDiscount'>";
					for (var ii = 0; ii < itemdiscount.length; ii++)
					{
						var disc = itemdiscount[ii];
						var priceper = Math.ceil(disc[1] / disc[0]);
						// Percent off for bulk discount comes from the price per item in the bulk--divided by the old price for a single (non-bulk) item
						var oldpriceinner = (disc.length > 2) ? getOldPriceString(priceper, (itemdiscount[0])[2], disc[2]) : getPercentOffString(priceper, (itemdiscount[0])[1]);
						var divisorstr = (disc[0] > 1) ? ("/" + disc[0] + " = " + Math.ceil(disc[1] / disc[0]) + gemstr) : "";
						discountstr += oldpriceinner + "<span class='dsbSalePriceCurrent'>" + " " + E.formatGemToCoin(disc[1]) + I.Symbol.ArrowRight + disc[1] + gemstr + divisorstr + "</span>"
							+ " " + "<br />";
					}
					discountstr += "</span>";
				}
				// Price display
				var pricestr = "";
				if (item.p["gem"] >= 0)
				{
					pricestr = "<span class='dsbSalePriceCoin'>" + E.formatGemToCoin(itemprice) + " " + I.Symbol.ArrowRight + " </span>"
						+ "<span class='dsbSalePriceMoney'>" + E.formatGemToMoney(itemprice) + " = </span>"
						+ "<span class='dsbSalePriceCurrent'>" + itemprice + gemstr + "</span>";
				}
				else if (item.p["coin"] >= 0)
				{
					pricestr = "<span class='dsbSalePriceCurrent'>" + E.formatGemString(E.convertCoinToGem(itemprice)) + "</span> " + I.Symbol.ArrowRight + " "
						+ "<span class='dsbSalePriceCoin'>" + E.formatCoinStringShort(itemprice) + "</span>"
						+ "<span class='dsbSalePriceMoney'> = " + E.formatGemToMoney(E.convertCoinToGem(itemprice)) + "</span>";
				}
				else if (item.p["blticket"] >= 0)
				{
					pricestr = "<span class='dsbSalePriceCurrent'>" + E.formatPayment("blticket", itemprice) + "</span>";
				}
				// Format the presentation of this item
				var idisimg = isNaN(itemid) && Q.Boxes.Items[itemid] === undefined;
				if (idisimg === false)
				{
					idstofetch.push(itemid);
				}
				var idprop = (idisimg) ? "" : ("id='dsbSaleEntry_" + itemid + "'");
				var imgsrc = (idisimg) ? itemid : U.URL_IMG.Placeholder;
				$("#dsbSaleSide" + side).append("<div class='dsbSaleEntry' " + idprop + ">"
					+ "<div class='dsbSaleItem'>"
						+ "<a" + U.convertExternalAnchor(url) + "><img class='dsbSaleIcon' src='" + imgsrc + "' /></a> "
						+ "<span class='dsbSaleVideo'> <a" + U.convertExternalAnchor(video) + "'><ins class='s16 s16_youtube'></ins></a> </span>"
						+ "<var class='dsbSaleName'>" + itemname + "</var>"
					+ "</div>"
					+ "<div class='dsbSaleInfo'>"
						+ "<span id='dsbSaleCountdown_" + i + "' class='dsbSaleCountdown'></span>"
						+ pricestr
						+ oldpricestr
						+ discountstr
					+ "</div>"
				+ "</div>");
			}

			var height = table.height();
			table.css({height: 0}).animate({height: height}, animationspeed, function()
			{
				$(this).css({height: "auto"});
			});
			// Retrieve item info
			Q.getItems(idstofetch, function()
			{
				for (var i in idstofetch)
				{
					var item = Q.getCachedItem(idstofetch[i]);
					if (item)
					{
						var entry = $("#dsbSaleEntry_" + idstofetch[i]);
						Q.scanItem(item, {aElement: entry.find(".dsbSaleIcon").attr("src", item.icon)});
						entry.find(".dsbSaleName").html(item.name).addClass(Q.getRarityClass(item.rarity));
					}
				}
			});
		};
		
		// Dashboard tab functionality
		if (table.is(":empty") === false)
		{
			H.isSaleOpened = false;
			I.toggleToggleIcon("#dsbSaleToggleIcon", false);
			table.animate({height: 0}, animationspeed, function()
			{
				$(this).css({height: "auto"}).empty();
				$("#dsbSale").hide();
				$("#dsbMenuSale").removeClass("dsbTabActive");
			});
		}
		else
		{
			H.isSaleOpened = true;
			$("#dsbSale").show();
			$("#dsbMenuSale").addClass("dsbTabActive");
			table.append(I.cThrobber);
			Q.initializeFaux();
			H.updateSaleData(function()
			{
				if (I.isAPIEnabled)
				{
					doGenerate();
				}
				else
				{
					Q.loadItemsSubdatabase("gem", function()
					{
						doGenerate();
					});
				}
			});
		}
	},
	updateDashboardSaleCountdown: function()
	{
		for (var i in H.SaleCountdowns)
		{
			var sec = H.SaleCountdowns[i] - T.TIMESTAMP_UNIX_SECONDS;
			if (sec > T.cSECONDS_IN_DAY)
			{
				$("#dsbSaleCountdown_" + i).html("<span class='dsbSaleCountdownFar'>" + T.formatTimeLetter(sec, true, true) + "</span>");
				delete H.SaleCountdowns[i]; // These will be restored when the gem dashboard is reopened
			}
			else
			{
				$("#dsbSaleCountdown_" + i).html(T.formatTimeLetter(sec, true));
			}
		}
	},
	
	/*
	 * Macro function for redownloading the sale data and exchange rates.
	 * @param function pCallback
	 */
	updateSaleData: function(pCallback)
	{
		U.getScript(U.URL_DATA.Sale, function()
		{
			H.Sale = GW2T_SALE_DATA;
			E.updateExchangeRatios(function()
			{
				pCallback();
			});
		}, false);
	},
	
	/*
	 * Initializes the gem store subscription object.
	 * @param boolean pWantClear whether to wipe all subscriptions.
	 * @returns object
	 */
	initializeGemSubscription: function(pWantClear)
	{
		var key = O.Utilities.GemSubscription.key;
		H.GemSubscription = {};
		if (localStorage[key] === undefined || pWantClear)
		{
			localStorage[key] = JSON.stringify(H.GemSubscription);
		}
		if (pWantClear !== true)
		{
			try
			{
				var tempsubs = JSON.parse(localStorage[key]);
				// Convert legacy format of two arrays into one assoc
				if (Array.isArray(tempsubs.Available) && Array.isArray(tempsubs.Discounted))
				{
					tempsubs.Available.forEach(function(iID)
					{
						H.subscribeGemAvailable(iID);
					});
					tempsubs.Discounted.forEach(function(iID)
					{
						H.subscribeGemDiscounted(iID);
					});
					H.saveGemSubscription();
				}
				else if (typeof tempsubs === "object")
				{
					H.GemSubscription = tempsubs;
				}
			}
			catch (e) {}
		}
	},
	subscribeGemAvailable: function(pID)
	{
		H.GemSubscription[pID] = X.ChecklistEnum.Tracked;
	},
	subscribeGemDiscounted: function(pID)
	{
		H.GemSubscription[pID] = X.ChecklistEnum.Found;
	},
	isGemSubscribedForAvailable: function(pID)
	{
		if (H.GemSubscription[pID] === X.ChecklistEnum.Tracked)
		{
			return true;
		}
		return false;
	},
	isGemSubscribedForDiscounted: function(pID)
	{
		if (H.GemSubscription[pID] === X.ChecklistEnum.Found)
		{
			return true;
		}
		return false;
	},
	isGemSubscribed: function(pID)
	{
		if (H.GemSubscription[pID])
		{
			return true;
		}
		return false;
	},
	unsubscribeGem: function(pID)
	{
		delete H.GemSubscription[pID];
	},
	saveGemSubscription: function()
	{
		localStorage[O.Utilities.GemSubscription.key] = JSON.stringify(H.GemSubscription);
	},
	
	/*
	 * Downloads the gem record and checks against subscription for alerts.
	 * @param function pCallback if and for generating the gem store gallery.
	 * If no callback is provided then assume it is a checkup call.
	 */
	updateGemSubscription: function(pCallback)
	{
		var section = "Gem";
		var getUnsubscribeLink = function(pID)
		{
			return "<a class='jsGemUnsubscribe' data-item='" + pID + "'>" + D.getPhraseOriginal("Unsubscribe this item") + "?</a>";
		};
		var checkSubscriptions = function()
		{
			if (H.GemSubscription === null)
			{
				H.initializeGemSubscription();
			}
			// Initialize price assoc
			var item, amount;
			var issalecurrent = T.isTimely(H.Sale);
			for (var i = 0; i < H.Sale.Items.length; i++)
			{
				item = H.Sale.Items[i];
				// Allow integer IDs or faux IDs and ignore expired
				if (item.side === undefined && (T.isTimely(item) || (item.Finish === undefined && issalecurrent)))
				{
					// An item may have its own expiration, otherwise the entire sale's expiration is used for comparison
					amount = E.getPaymentAmount(item);
					H.Sale.Values[item.i] = amount;
					// If any item has 0 price then initialize the free faux item
					if (amount === 0 && H.Sale.Values["free_gem_store_item"] === undefined)
					{
						H.Sale.Values["free_gem_store_item"] = 0;
					}
				}
			}
			
			// Execute gem store gallery callback
			if (pCallback)
			{
				pCallback();
				return;
			}
			
			// Do the subscription alerts if gallery callback not provided
			var record = U.getRecordData(section);
			var isavailable = false;
			var isdiscounted = false;
			var alertstr = D.getWord("alarm");
			var availablestr = D.getPhraseOriginal(" gem item is available");
			var discountstr = D.getPhraseOriginal(" gem item discount");
			A.iterateRecord(record, function(pEntry)
			{
				var id = pEntry.i;
				var value = E.getPaymentAmount(pEntry);
				var salevalue = H.Sale.Values[id];
				var isavailableinrecord = false;
				var isavailableinsale = false;
				var isdiscountedinsale = false;
				if (value > 0)
				{
					isavailableinrecord = true;
				}
				if (salevalue >= 0)
				{
					isavailableinsale = true;
					value = Math.abs(value); // If exists in promotions then consider as available in the record
				}
				if (salevalue < value || salevalue === 0)
				{
					isdiscountedinsale = true;
				}
				
				// Check for available
				if (H.isGemSubscribedForAvailable(id) && (isavailableinsale || isavailableinrecord))
				{
					I.print(pEntry.n + availablestr + "! " + getUnsubscribeLink(id));
					I.notify({
						aTitle: pEntry.n,
						aBody: D.getWordCapital("available"),
						aIcon: "img/notification/store.png"
					});
					isavailable = true;
				}
				// Check for discount
				if (H.isGemSubscribedForDiscounted(id))
				{
					if (isdiscountedinsale)
					{
						I.print(pEntry.n + discountstr + "! " + E.formatGemString(value) + " − "
							+ E.formatGemString(value - salevalue) + " = " + E.formatGemString(salevalue) + " " + getUnsubscribeLink(id));
						I.notify({
							aTitle: pEntry.n,
							aBody: D.getWordCapital("discount"),
							aIcon: "img/notification/store.png"
						});
						isdiscounted = true;
					}
					// If item is no longer available, then convert the discount subscription to an availability subscription
					else if (salevalue === undefined && isavailableinrecord === false)
					{
						H.subscribeGemAvailable(id);
						H.saveGemSubscription();
					}
				}
			});
			
			// Bind the printed unsubscribe link
			$(".jsGemUnsubscribe").each(function()
			{
				var id = $(this).removeClass("jsGemUnsubscribe").attr("data-item");
				if (id)
				{
					$(this).click(function()
					{
						H.unsubscribeGem(id);
						H.saveGemSubscription();
						I.print(D.getWordCapital("done") + ".");
					});
				}
			});
			
			// Speak the alert
			if (O.Options.bol_alertGem)
			{
				if (isavailable)
				{
					D.speak(alertstr + "! " + availablestr);
				}
				if (isdiscounted)
				{
					D.speak(alertstr + "! " + discountstr);
				}
			}
			if (isavailable || isdiscounted)
			{
				I.print("<a data-page='Gem'>" + D.getPhraseOriginal("View Gem Wishlist") + "</a> - "
					+ "<a id='dsbGemPause_" + T.TIMESTAMP_UNIX_SECONDS + "'>" + D.getPhraseOriginal("Pause alarm") + "</a> - "
					+ "<a href='https://gw2timer.com/?bol_alertGem=false'>" + D.getPhraseOriginal("Disable alarm") + "</a>");
				I.bindConsoleLink();
				$("#dsbGemPause_" + T.TIMESTAMP_UNIX_SECONDS).click(function()
				{
					H.isGemPaused = true;
					I.clear();
				});
			}
		};
		
		// Retrieve data first
		U.getScript(U.URL_DATA.Gem, function()
		{
			H.updateSaleData(function()
			{
				checkSubscriptions();
			});
		}, false);
	},
	
	/*
	 * Generates the header for the vendor feature.
	 */
	generateDashboardPactHeader: function(pIsReset)
	{
		var weekdaylocation = H.getDashboardPactWeekday();
		var vendorname = D.getObjectName(H.Pact);
		var vendorcodes = "";
		for (var i in H.Pact.Codes)
		{
			vendorcodes += i + "@" + (H.Pact.Codes[i])[weekdaylocation] + " ";
		}
		vendorcodes += "- " + vendorname;
		var menubutton = $("#dsbMenuPact");
		menubutton.empty().append("<div><kbd id='dsbPactHeader' class='curToggle'>"
			+ "<img src='img/map/vendor_karma.png' /><img id='dsbPactToggleIcon' class='dsbToggleIcon' src='img/ui/toggle.png' />"
			+ "<var>" + vendorname + "</var></kbd></div>").addClass("dsbTabEnabled");
		$("#dsbPact").empty().append("<div id='dsbPactMenu'>"
			+ "<img data-src='img/map/waypoint.png' style='width:32px;height:32px;' /><input id='dsbPactCodes' class='cssInputText jsTitle' type='text' value='" + vendorcodes + "' "
				+ "title='<dfn>Copy and paste</dfn> this into game chat to follow.' /> "
			+ ((I.isMapEnabled) ? "<img data-src='img/map/path.png' /><dfn class='curZoom' id='dsbPactDraw'>" + D.getPhrase("draw route", U.CaseEnum.Every) + "</dfn> " : "")
			+ "<a class='jsTitle'" + U.convertExternalAnchor("https://wiki.guildwars2.com/wiki/Pact_Supply_Network_Agent")
				+ "title='New items at daily reset.<br />New vendor locations 8 hours after that.<br />Limit 1 purchase per vendor per day.'>"
				+ "<img data-src='img/ui/menu/info.png' />" + D.getWordCapital("info") + "</a> "
			+ "<a id='dsbPactHistoryLink' class='jsTitle' data-page='Pact' title='Previous recipes and frequency statistics.'>"
				+ "<img data-src='img/ui/tradingpost.png' />" + D.getWordCapital("history") + "</a> "
			+ "<a id='dsbPactProfitLink' class='jsTitle' " + U.convertExternalAnchor("https://wiki.guildwars2.com/wiki/Map_bonus_reward/profit")
				+ "title='Buy Pact Scout Mapping Materials from vendors and consume in profitable zone weeks.'>"
				+ "<img data-src='img/ui/coin_gold.png' />" + D.getWordCapital("profit") + "</a> "
			+ "<a class='jsTitle'" + U.convertExternalAnchor(H.Pact.SpreadsheetEdit)
				+ "title='Update and verify the collaborative daily offers list.'>"
				+ "<img data-src='img/ui/import.png' />" + D.getWordCapital("update") + "</a>"
			+ "</div><div id='dsbPactTable' class='jsScrollable'></div>").hide();
		I.qTip.reinit();
		U.convertInternalLink("#dsbPactHistoryLink");

		// Bind buttons
		var vendorcopy = I.bindInputSelect("#dsbPactCodes");
		I.bindClipboard(vendorcopy, vendorcodes);
		if (pIsReset)
		{
			menubutton.unbind("click");
		}
		menubutton.click(function()
		{
			H.generateDashboardPact();
		});
		$("#dsbPactDraw").click(function()
		{
			if ($(this).data("hasDrawn") !== true)
			{
				var coords = [];
				for (var i in H.Pact.Coords)
				{
					var coord = (H.Pact.Coords[i])[weekdaylocation];
					if (coord !== undefined)
					{
						coords.push(coord);
					}
				}
				M.redrawPersonalPath(P.getGreedyPath(coords), "default");
				$(this).data("hasDrawn", true);
			}
			else
			{
				M.clearPersonalPins();
				$(this).data("hasDrawn", false);
			}
		});
	},
	generateDashboardPact: function()
	{
		var animationspeed = 200;
		var weekdaylocation = H.getDashboardPactWeekday();
		var defaultcoords = H.Pact.Coords[H.Pact.DefaultVendor];
		var table = $("#dsbPactTable");
		
		var finalizePactTable = function(pUpdateTime)
		{
			var height = table.height();
			table.css({height: 0}).animate({height: height}, animationspeed, function()
			{
				$(this).css({height: "auto"});
			});
			I.removeThrobber(table);
			// Insert timestamp of daily offers
			var timestamp = "";
			var expiredstr = "";
			if (pUpdateTime)
			{
				var updatetime = new Date(pUpdateTime);
				var now = new Date();
				timestamp = T.formatWeektime(pUpdateTime, true) + " (" + T.formatMilliseconds(now - updatetime) + " " + D.getWord("ago") + ")";
				expiredstr = (updatetime > T.ResetToday && updatetime < T.ResetTomorrow) ? "" : D.getWordCapital("expired") + ". ";
			}
			table.append("<div id='dsbPactNote'>This daily recipes list is user contributed. "
				+ "Please correct items using the <a" + U.convertExternalAnchor(H.Pact.SpreadsheetEdit) + ">Update</a> link.</div>");
//				+ "<br />" + expiredstr + "<time id='dsbPactTime'>" + timestamp + "</time></div>");
		};
		
		var getDateNumber = function(pDate)
		{
			return pDate.toISOString().split("T")[0].replace(/-/g, "");
		};
		
		var doGenerate = function(pData)
		{
			var updatetime;
			var recipelist = {};
			var timelist = {};
			var iserror = true;
			try
			{
				var values = pData.values;
				var ids = values[1];
				var times = values[2];
				var today = getDateNumber(new Date());
				for (var i in H.Pact.OffersAssoc)
				{
					var key = H.Pact.OffersAssoc[i];
					var id = parseInt(ids[key]);
					var time = times[key];
					if (id || H.Pact.Products[id])
					{
						recipelist[i] = id;
						timelist[i] = time && (getDateNumber(new Date(time)) < today);
						iserror = false;
					}
					else
					{
						recipelist[i] = Q.GameLimit.UnknownItem;
					}
				}
				updatetime = (new Date()).toISOString();
			}
			catch (e) {}
			if (iserror)
			{
				I.removeThrobber(table);
				I.write("Error parsing external data. Please collaboratively update the list.");
				return;
			}
			
			var idstofetch = [];
			for (var i in H.Pact.OffersAssoc)
			{
				var recipeid = recipelist[i];
				var productid = H.Pact.Products[recipeid] || recipeid;
				idstofetch.push(recipeid);
				idstofetch.push(productid);
			}
			Q.getPricedItems(idstofetch, function()
			{
				for (var i in H.Pact.OffersAssoc)
				{
					var recipeid = recipelist[i];
					if (recipeid === undefined)
					{
						continue;
					}
					var productid = H.Pact.Products[recipeid] || recipeid;
					var recipe = Q.getCachedItem(recipeid);
					var product = Q.getCachedItem(productid) || recipe || {
						icon: "img/ui/unknown.png",
						name: productid.toString()
					};
					recipe = recipe || product;
					
					var wikiquery = (D.isLanguageDefault) ? recipe.name : recipeid.toString();
					$("<div id='dsbPactEntry_" + i + "' class='dsbPactEntry'></div>").appendTo(table).html(
						"<div class='dsbPactItem'>"
							+ "<a" + U.convertExternalAnchor(U.getWikiSearchDefault(wikiquery)) + "><img id='dsbPactIcon_" + i + "' class='dsbPactIcon' src='" + U.URL_IMG.Placeholder + "' /></a> "
							+ "<span id='dsbPactName_" + i + "' class='dsbPactName curZoom " + Q.getRarityClass(recipe.rarity)
								+ "' data-coord='" + (H.Pact.Coords[i] || defaultcoords)[weekdaylocation] + "'>" + product.name + "</span> "
							+ "</div>"
						+ "<div class='dsbPactInfo'>"
							+ "<span>" + (timelist[i] ? (D.getWordCapital("expired") + " ") : "") + "</span>"
							+ "<span class='dsbPactPriceCoin' id='dsbPactPriceCoin_" + i + "'></span> "
							+ "<span class='dsbPactVendor'>" + i + "</span> "
							+ "<span class='dsbPactPriceKarma'>" + E.formatKarmaString(H.Pact.Prices[recipeid] || H.Pact.PriceDefault) + "</span>"
						+ "</div>");
					// Get TP prices also
					var recipeprice = E.getCachedPrice(recipeid);
					var recipepricestr = (recipeprice) ? (E.formatCoinStringColored(recipeprice.oPriceSell)) : E.formatCoinStringColored(0);
					$("#dsbPactPriceCoin_" + i).html(recipepricestr);
					M.bindMapLinkBehavior($("#dsbPactName_" + i), M.ZoomEnum.Ground, M.Pin.Program);
					// Get the product that the recipe crafts
					var icon = $("#dsbPactIcon_" + i);
					icon.attr("src", product.icon);
					Q.scanItem(product, {aElement: icon});
				}
				finalizePactTable(updatetime);
			});
		};
		
		// Collapse and empty the table if currently expanded, else generate
		if ($("#dsbPactMenu").is(":visible"))
		{
			I.toggleToggleIcon("#dsbPactToggleIcon", false);
			table.animate({height: 0}, animationspeed, function()
			{
				$(this).css({height: "auto"}).empty();
				$("#dsbPact").hide();
				$("#dsbMenuPact").removeClass("dsbTabActive");
			});
		}
		else
		{
			$("#dsbPact").show();
			$("#dsbMenuPact").addClass("dsbTabActive");
			I.loadImg($("#dsbPactMenu"));
			I.toggleToggleIcon("#dsbPactToggleIcon", true);
			table.empty();
			
			if (H.Pact.isEnabled)
			{
				table.append(I.cThrobber);
				U.getJSON(H.Pact.SpreadsheetData, function(pData)
				{
					if (I.isAPIEnabled)
					{
						doGenerate(pData);
					}
					else
					{
						Q.loadItemsSubdatabase("pact", function()
						{
							doGenerate(pData);
						});
					}
				}, false);
			}
			else
			{
				for (var i in H.Pact.OffersAssoc)
				{
					var elm = $("<dfn id='dsbPactName_" + i + "' class='dsbPactName' data-coord='"
						+ (H.Pact.Coords[i] || defaultcoords)[weekdaylocation] + "'>" + i + "</dfn>").appendTo(table);
					M.bindMapLinkBehavior(elm, M.ZoomEnum.Ground, M.Pin.Program);
				}
			}
		}
	},
	getDashboardPactWeekday: function()
	{
		var now = new Date();
		var weekday = now.getUTCDay();
		var hour = now.getUTCHours();
		return (hour < H.Pact.resetHour) ? T.wrapInteger(weekday - 1, T.cDAYS_IN_WEEK) : weekday;
	},
	
	/*
	 * Generates the header for the daily feature.
	 */
	generateDashboardDailyHeader: function(pDate)
	{
		$("#dsbMenuDaily").empty().append("<div><kbd id='dsbDailyHeader' class='curToggle'>"
			+ "<img src='img/ui/daily.png' /><img id='dsbDailyToggleIcon' class='dsbToggleIcon' src='img/ui/toggle.png' />"
			+ "<var>" + D.getModifiedWord("achievements", "daily", U.CaseEnum.Every) + "</var></kbd>"
		+ "</div>").addClass("dsbTabEnabled").click(function()
		{
			H.generateDashboardDaily();
		}).one("click", function()
		{
			I.loadStylesheet("features");
		});
	},
	generateDashboardDaily: function()
	{
		var animationspeed = 200;
		var table = $("#dsbDaily");
		var now = new Date();
		
		// Collapse and empty the table if currently expanded, else generate
		if (table.is(":empty") === false)
		{
			I.toggleToggleIcon("#dsbDailyToggleIcon", false);
			table.animate({height: 0}, animationspeed, function()
			{
				$(this).css({height: "auto"}).empty();
				table.hide();
				$("#dsbMenuDaily").removeClass("dsbTabActive");
			});
		}
		else
		{
			table.show();
			$("#dsbMenuDaily").addClass("dsbTabActive");
			I.loadImg($("#dsbDailyMenu"));
			I.toggleToggleIcon("#dsbDailyToggleIcon", true);
			var calendar = $("<div class='dlyCalendar'></div>").appendTo(table);
			G.fillDailyCalendar(calendar, now, H.isVertical);
		}
	},
	
	/*
	 * Updates the countdown time in each countdown entries.
	 * Called by the clock tick function every 1 second.
	 * @param Date pDate for getting time.
	 */
	updateDashboardCountdown: function(pDate)
	{
		for (var i = 0; i < H.Countdown.Events.length; i++)
		{
			var ctd = H.Countdown.Events[i];
			if (ctd.isTimely)
			{
				var ithtime = (ctd.isIndefinite) ? I.Symbol.Infinity : T.formatTimeLetter(Math.floor((ctd.DesiredTime.getTime() - pDate.getTime()) / T.cMSECONDS_IN_SECOND), true);
				document.getElementById("dsbCountdownTime_" + i).innerHTML = ithtime;
			}
		}
	},
	
	/*
	 * Refreshes timely components in the dashboard.
	 * Called by the clock tick function every 5 minutes.
	 * @param Date pDate to compare with deadlines.
	 */
	refreshDashboard: function(pDate)
	{
		var hour = pDate.getUTCHours();
		var minute = pDate.getUTCMinutes();
		
		// Update countdown text elements, or deactivate a countdown entry if expired
		for (var i in H.Countdown.Events)
		{
			var ctd = H.Countdown.Events[i];
			if (ctd.isTimely)
			{
				var countdownhtml = $("#dsbCountdown_" + i);
				var bulletclass;
				var arrow;
				var stamp;
				// Don't generate countdown for those that are past the start time
				if (pDate < ctd.Start)
				{
					ctd.DesiredTime = ctd.Start;
					bulletclass = "cssStateInactive";
					arrow = I.Symbol.ArrowUp + "@";
					stamp = ctd.StartStamp;
				}
				else if (pDate < ctd.Finish)
				{
					ctd.DesiredTime = ctd.Finish;
					bulletclass = "cssStateActive";
					arrow = I.Symbol.ArrowDown + "@";
					stamp = ctd.FinishStamp;
				}
				else
				{
					ctd.isTimely = false;
					countdownhtml.remove();
				}
				if (ctd.isIndefinite !== undefined)
				{
					bulletclass = "cssStateWaiting";
					stamp = I.Symbol.Infinity;
				}

				if (ctd.isTimely)
				{
					countdownhtml.find("code").removeClass().addClass("cssState " + bulletclass);
					countdownhtml.find("abbr").text(arrow);
					countdownhtml.find("var").text(stamp);
				}
			}
		}
		
		// Deactivate outdated Living Story
		if (T.isTimely(H.Story, pDate) === false)
		{
			H.isStoryEnabled = false;
			$("#dsbStory").hide();
		}
		
		// Deactivate outdated sale
		if (T.isTimely(H.Sale, pDate) === false)
		{
			H.isSaleEnabled = false;
			$("#dsbSale").hide();
		}
		
		// Refresh vendor header at its specific time
		if (hour === H.Pact.resetHour && minute === 0)
		{
			H.generateDashboardPactHeader(true);
		}
	},
	
	/*
	 * Shows or hides the dashboard.
	 */
	toggleDashboard: function(pIsInitial)
	{
		I.toggleElement("#dsbContainer", O.Options.bol_showDashboard, "fast", pIsInitial);
	},
	
	/*
	 * Generates the timeline HTML.
	 */
	generateTimeline: function()
	{
		var getInterim = function(pTime, pDuration)
		{
			let obj =
			{
				time: T.unparseChainTime(pTime),
				duration: T.unparseChainTime(pDuration),
				primacy: 0, name_en: "", name_de: "", name_es: "", name_fr: "", name_zh: ""
			};
			return obj;
		};
		
		H.isTimelineGenerated = true;
		$("#tmlTitle").text(D.getWordCapital("timeline"));
		// Container for all the timelines
		var container = $("#tmlContainer").append("<div class='tmlLine curToggle' id='tmlHeader'></div>");
		$("#tmlHeader").click(function()
		{
			$("#opt_bol_condenseTimelineHeader").trigger("click");
		});
		// Initialize "checklist" so collapsed lines are remembered as so
		X.initializeChecklist(X.Checklists.Timeline, H.Timeline.length);
		
		// Insert space non-event into the timeline
		for (var i = 0; i < H.Timeline.length; i++)
		{
			var chain = H.Timeline[i];
			var segments = [];
			var segmentNext, segTime, segDuration, segNextTime, segNextExpectedTime;
			var length = chain.Segments.length;
			for (var ii = 0; ii < length; ii++)
			{
				var segment = chain.Segments[ii];
				segTime = T.parseChainTime(segment.time);
				segDuration = T.parseChainTime(segment.duration);
				segNextExpectedTime = segTime + segDuration;
				// Initial segment
				if (ii === 0 && segTime !== 0)
				{
					segments.push(getInterim(0, segTime));
				}
				// Actual segment
				segments.push(segment);
				// Following segment
				if (ii+1 < length)
				{
					segmentNext = chain.Segments[ii+1];
					segNextTime = T.parseChainTime(segmentNext.time);
					if (segNextExpectedTime < segNextTime)
					{
						segments.push(getInterim(segNextExpectedTime, segNextTime - segNextExpectedTime));
					}
				}
				// Final segment
				if (ii+1 === length)
				{
					if (segTime + segDuration < T.cMINUTES_IN_2_HOURS)
					{
						segments.push(getInterim(segNextExpectedTime, T.cMINUTES_IN_2_HOURS - segNextExpectedTime));
					}
				}
			}
			chain.Segments = segments;
		}
		
		// Create timeline
		for (var i = 0; i < H.Timeline.length; i++)
		{
			var chain = H.Timeline[i];
			var name = U.escapeHTML((chain.zone === undefined) ? D.getObjectName(chain) : M.getZoneName(chain.zone));
			// Container for segments of a timeline (chain)
			var linetitle = (chain.isWB) ? "" : ("title='<dfn>" + name + "</dfn>'");
			var lineclass = (chain.isWB) ? "tmlLineWB" : "tmlLineStandard";
			var line = $("<div class='tmlLine " + lineclass + "' " + linetitle + "></div>").appendTo(container);
			for (var ii = 0; ii < chain.Segments.length; ii++)
			{
				// Segments of a timeline (event)
				var event = chain.Segments[ii];
				var segmentprefix = "";
				var segmentname = (D.getObjectName(event) || "");
				var emptyclass = (event.primacy < C.EventPrimacyEnum.Primary) ? "tmlTimesliceEmpty" : "";
				var wbclass = (chain.isWB) ? "tmlTimesliceWB" : "";
				var wbdata = (chain.isWB) ? "data-offset='" + ii + "'" : "";
				var bossclass = (event.primacy === C.EventPrimacyEnum.Boss) ? "tmlSegmentNameBoss" : "";
				switch (event.primacy)
				{
					case C.EventPrimacyEnum.Normal: segmentprefix = I.Symbol.Ellipsis; break;
					case C.EventPrimacyEnum.Boss: segmentprefix = I.Symbol.Star + " "; break;
				}
				event.duration = T.parseChainTime(event.duration);
				event.time = T.parseChainTime(event.time);
				var width = (event.duration / T.cMINUTES_IN_2_HOURS) * T.cPERCENT_100;
				line.append(
				"<div class='tmlSegment tmlTimeslice " + wbclass + " " + emptyclass + "' style='width:" + width + "%' "
				+ "data-start='" + event.time + "' data-finish='" + (event.time + event.duration) + "' " + wbdata + ">"
					+ "<div class='tmlSegmentContent'>"
						+ "<span class='tmlSegmentName " + bossclass + "'>" + segmentprefix + segmentname + "</span>"
						+ "<span class='tmlSegmentCountdown'></span>"
						+ "<var class='tmlSegmentSpecial'></var>"
					+ "</div>"
				+ "</div>");
			}
			// Line collapse behavior
			(function(iLine, iIndex)
			{
				$("<kbd class='tmlLineCollapse jsSleepable' title='" + D.getWordCapital("hide") + " <dfn>" + name + "</dfn>'></kbd>").appendTo(iLine).click(function()
				{
					iLine.hide("fast");
					X.setChecklistItem(X.Checklists.Timeline, iIndex, X.ChecklistEnum.Disabled);
				});
			})(line, i);
			if (X.getChecklistItem(X.Checklists.Timeline, i) === X.ChecklistEnum.Disabled)
			{
				line.hide();
			}
		}
		
		// Bind window buttons
		$("#tmlToggle").click(function()
		{
			$("#opt_bol_showTimeline").trigger("click");
		});
		$("#tmlCondense").click(function()
		{
			$("#opt_bol_condenseTimelineLine").trigger("click");
		});
		$("#tmlOpaque").click(function()
		{
			$("#opt_bol_opaqueTimeline").trigger("click");
		});
		
		// Initialize
		O.Enact.bol_condenseTimelineHeader(true);
		O.Enact.bol_condenseTimelineLine(true);
		H.toggleTimeline(true);
		H.opaqueTimeline();
		I.qTip.init(".tmlLine");
		$("#itemTimeline").show();
	},
	
	/*
	 * Moves the "minute hand" and updates countdowns. Should be called every 1 minute.
	 */
	updateTimelineIndicator: function()
	{
		if (H.isTimelineGenerated === false)
		{
			return;
		}
		var cycleminutes = T.cMINUTES_IN_2_HOURS;
		var currentminute = T.getCurrentBihourlyMinutesUTC();
		var offsetpercent = (currentminute / cycleminutes) * T.cPERCENT_100;
		$("#tmlIndicator").css({left: offsetpercent + "%"});
		$(".tmlLineName").css({left: offsetpercent + "%"});
		
		// Update the countdowns next to the segment names
		$(".tmlTimeslice").each(function()
		{
			// Show the time until event start
			var isactive = $(this).hasClass("tmlSegmentActive");
			var countdown = $(this).find(".tmlSegmentCountdown");
			var minutesremaining = $(this).data("start") - currentminute;
			minutesremaining = (minutesremaining === 0) ? cycleminutes : T.wrapInteger(minutesremaining, cycleminutes);
			if (($(this).hasClass("tmlTimesliceWB") && isactive) || $(this).hasClass("tmlTimesliceEmpty"))
			{
				// If timeslice is for active world bosses
				countdown.html("");
			}
			else
			{
				countdown.html(T.formatMinutes(minutesremaining));
			}
		});
		
		// Update current time
		if (I.ModeCurrent === I.ModeEnum.Overlay)
		{
			// If on overlay then change the current active timestamp
			$(".tmlTimestampActive").find(".tmlSegmentTimestamp").text(K.currentDaytimeString);
		}
		else
		{
			// Otherwise change the indicator's text
			$("#tmlIndicatorTime").html(K.currentDaytimeText);
		}
		
		// Reposition the indicator's time text if outside of screen
		var indtime = $("#tmlIndicatorTime");
		var indtimepadding = 12;
		if (offsetpercent > 90)
		{
			indtime.css({marginLeft: -(indtime.width() + indtimepadding) + "px"});
		}
		else
		{
			indtime.css({marginLeft: 0});
		}
	},
	
	/*
	 * Highlights the active segments. Should be called every 5 minutes.
	 */
	updateTimelineSegments: function(pForceWB)
	{
		if (H.isTimelineGenerated === false)
		{
			return;
		}
		var numwbslices = T.cMINUTES_IN_2_HOURS / T.cMINUTES_IN_TIMEFRAME;
		var wbcurrentoffset = 0;
		var currentminute = T.getCurrentBihourlyMinutesUTC();
		var currenttimestamp = currentminute - (currentminute % H.minutesInTimelineSpacing);
		
		// Refresh the header if approached new bihour
		if (currentminute === 0)
		{
			H.updateTimelineHeader();
		}
		else
		{
			// Update the timestamp just behind the indicator with future time
			var previoustimestamp = currentminute - H.minutesInTimelineSpacing;
			$("#tmlSegmentTimestamp_" + previoustimestamp)
				.html(T.getCurrentBihourlyTimestampLocal(previoustimestamp + T.cMINUTES_IN_2_HOURS))
				.removeClass("tmlSegmentTimestampCurrent").addClass("tmlSegmentTimestampFutureFar")
				.parent().css({opacity: 0}).animate({opacity: 1}, 1000)
				.closest(".tmlSegment").removeClass("tmlTimestampActive");
		}
		
		// Highlight active segments
		$("#tmlSegmentTimestamp_" + currenttimestamp).closest(".tmlSegment").addClass("tmlTimestampActive");
		$(".tmlTimeslice").each(function()
		{
			if (currentminute >= $(this).data("start") && currentminute < $(this).data("finish"))
			{
				if ( ! $(this).hasClass("tmlSegmentActive"))
				{
					$(this).addClass("tmlSegmentActive");
				}
				if ($(this).hasClass("tmlTimesliceWB"))
				{
					wbcurrentoffset = parseInt($(this).attr("data-offset"));
				}
			}
			else
			{
				$(this).removeClass("tmlSegmentActive");
			}
		});
		
		// Update the world boss slices, executes every 15 minutes
		if (currentminute % T.cMINUTES_IN_TIMEFRAME === 0 || pForceWB)
		{
			var wbcounteroffset = 0;
			$(".tmlTimesliceWB").each(function()
			{
				var inner = $(this).find(".tmlSegmentName").empty();
				var innerspecial = $(this).find(".tmlSegmentSpecial").empty();
				var bossicon, bossstripe;
				var thisoffset = parseInt($(this).attr("data-offset"));
				var timeframeoffset;
				if (thisoffset >= wbcurrentoffset)
				{
					timeframeoffset = wbcounteroffset;
					wbcounteroffset++;
				}
				else
				{
					timeframeoffset = (numwbslices - wbcurrentoffset) + thisoffset;
				}
				var wbchains = T.getTimeframeChains(timeframeoffset);
				for (var i in wbchains)
				{
					if (wbchains[i].series !== C.ChainSeriesEnum.DryTop)
					{
						(function(iChain)
						{
							var innersegment = (iChain.flags.isSpecial) ? innerspecial : inner;
							bossicon = $("<img class='tmlIcon curZoom chnSlot_" + iChain.nexus + "' src='" + iChain.iconSrc + "' />").appendTo(innersegment);
							bossicon.attr("title", "<dfn>" + D.getObjectName(iChain) + "</dfn>").click(function()
							{
								C.viewChainFinale(iChain);
							}).contextmenu(function(pEvent)
							{
								pEvent.preventDefault();
								C.viewChainFinale(iChain);
							}).dblclick(function()
							{
								$("#chnCheck_" + iChain.nexus).trigger("click");
							});
							I.preventMapPropagation(bossicon);
							bossstripe = $("<span class='tmlStripe'>" + D.getObjectName(iChain) + "<span>").insertAfter(bossicon);
							X.reapplyChainIconState(iChain, bossicon, true);
							I.bindClipboard(bossicon, iChain.waypointText);
						})(wbchains[i]);
					}
				}
			});
			I.qTip.init(".tmlIcon");
		}
	},
	
	/*
	 * Fills the top header line with timestamps. Should be called every 120 minutes.
	 */
	updateTimelineHeader: function()
	{
		if (H.isTimelineGenerated === false)
		{
			return;
		}
		var currentminute = T.getCurrentBihourlyMinutesUTC();
		var line = $("#tmlHeader").empty();
		var divisions = T.cMINUTES_IN_2_HOURS / H.minutesInTimelineSpacing;
		var ithminute, timestamp;
		for (var i = 0; i < divisions; i++)
		{
			var width = T.cPERCENT_100 / divisions;
			var condensedclass = (O.Options.bol_condenseTimelineHeader) ? "tmlSegmentTimestampCondensed" : "";
			var tenseclass = "";
			ithminute = H.minutesInTimelineSpacing * i;
			if (ithminute < currentminute - H.minutesInTimelineSpacing)
			{
				// Timestamps behind the current minute indicator becomes two hours ahead
				timestamp = T.getCurrentBihourlyTimestampLocal(ithminute + T.cMINUTES_IN_2_HOURS);
				tenseclass = "tmlSegmentTimestampFutureFar";
			}
			else
			{
				timestamp = T.getCurrentBihourlyTimestampLocal(ithminute);
			}
			line.append("<div class='tmlSegment' style='width:" + width + "%'><div class='tmlSegmentContent'>"
				+ "<span id='tmlSegmentTimestamp_" + ithminute + "' class='tmlSegmentTimestamp "
					+ condensedclass + " " + tenseclass + "'>" + timestamp + "</span></div></div>");
		}
	},
	
	/*
	 * Toggles timeline icons for special chains.
	 * @param boolean pBoolean.
	 */
	toggleSpecialIcons: function(pBoolean)
	{
		$(".tmlSegmentSpecial").css({visibility: ((pBoolean) ? "visible" : "hidden")});
		$(".tmlLineWB").toggleClass("tmlLineSpecial", pBoolean);
	},
	
	/*
	 * Shows or hides the timeline.
	 */
	toggleTimeline: function(pIsInitial)
	{
		I.toggleElement("#tmlContainer", O.Options.bol_showTimeline, "fast", pIsInitial);
		$("#tmlTitle").toggle(!O.Options.bol_showTimeline);
	},
	opaqueTimeline: function()
	{
		I.toggleHUDOpacity("#itemTimeline", "tml", O.Options.bol_opaqueTimeline);
	}
};
K = {
/* =============================================================================
 * @@Klock analog and by-the-second and frame refreshes
 * ========================================================================== */

	isClockStyled: false,
	tickerFrequency: 250, // Must be a divisor of 1000 milliseconds
	tickerSecondPrevious: null,
	stopwatchFrequency: 50,
	awakeTimestampPrevious: 0,
	awakeTimestampTolerance: 5,
	currentFrameOffsetMinutes: 0,
	currentPredictionColor: "",
	currentDaytimeSymbol: "",
	currentDaytimeWord: "",
	currentDaytimeString: "",
	currentDaytimeText: "",
	oldQuadrantAngle: 0,
	paneSizePrevious: 0,
	isHalloween: false,
	isWintersday: false,
	
	// Clock DOM elements
	handSecond: {}, handMinute: {}, handHour: {},
	clockBackground: {}, clockCircumference: {}, timeProgress0: {}, timeProgress1: {},
	timeDaylight: {}, timeLocal: {}, timeDaytime: {}, timeDirectory: {}, timeSimple: {}, timeMap: {}, timeWvW: {}, timeLog: {}, countdownWvW: {},
	timestampUTC: {}, timestampLocal: {}, timestampServer: {}, timestampReset: {},
	stopwatchUp: {}, stopwatchDown: {},
	
	// These will be DOM elements
	WpChain0: {}, WpChain1: {}, WpChain2: {}, WpChain3: {},
	// These will be jQuery "elements"
	IconSD0: {}, IconSD1: {}, IconSD2: {}, IconSD3: {},
	IconHC0: {}, IconHC1: {}, IconHC2: {}, IconHC3: {},
	IconsStandard: [],
	IconsHardcore: [],
	lsClipboards: [],
	TickerTimeout: {},
	
	// Stopwatch properties
	StopwatchTimeout: {},
	StopwatchTimestamp: 0,
	StopwatchTimesleep: 0,
	isStopwatchPaused: false,
	StopwatchTimerStart: 0,
	StopwatchTimerFinish: 0,
	
	/*
	 * Starts the clock.
	 */
	initializeClock: function()
	{
		// Create directory and dashboard beforehand
		H.generateTimeline();
		H.updateTimelineSegments(true);
		H.initializeDashboard();
		I.initializeDirectory();
		// Remember frequently accessed elements
		K.handSecond = $("#clkSecondHand")[0];
		K.handMinute = $("#clkMinuteHand")[0];
		K.handHour = $("#clkHourHand")[0];
		K.clockBackground = $("#paneClockBackground")[0];
		K.clockCircumference = $("#clkCircumference")[0];
		K.timeProgress0 = $("#chnProgress0")[0];
		K.timeProgress1 = $("#chnProgress1")[0];
		K.timeLocal = $("#itemTimeLocalActual")[0];
		K.timeDaytime = $("#itemTimeDayTime")[0];
		K.timeDirectory = $("#dirHeaderClock")[0];
		K.timeSimple = $("#itemSimpleTime")[0];
		K.timeMap = $("#mapTime")[0];
		K.timeWvW = $("#wvwTime")[0];
		K.timeLog = $("#logTime")[0];
		K.countdownWvW = $("#lboCountdown")[0];
		K.timestampUTC = $("#optTimestampUTC")[0];
		K.timestampReset = $("#optTimeTillReset")[0];
		K.stopwatchUp = $("#watUp")[0];
		K.stopwatchDown = $("#watDown")[0];
		
		K.updateTimeFrame(new Date()); // This also calls the server reset check function
		T.getDaily();
		K.updateDaytimeIcon();
		K.tickFrequent();
		K.updateDigitalClockMinutely();
		K.initializeClipboard();
		K.refreshFestival();
		
		// Hide chain progress bar for main mode
		if (I.ModeCurrent === I.ModeEnum.Website && O.Options.int_setClock !== O.IntEnum.Clock.None)
		{
			$("#chnProgressBar").hide();
		}
		
		// Other clickable elements
		$("#itemTimeLocalActual").click(function()
		{
			$("#opt_bol_use24Hour").trigger("click");
		});
		
		// Toggle clock pane shortcut button
		$("#clkToggle").click(function()
		{
			if (O.Options.int_setClock !== O.IntEnum.Clock.None)
			{
				K.paneSizePrevious = O.Options.int_setClock;
				X.setFieldsetState("int_setClock", O.IntEnum.Clock.None);
			}
			else
			{
				X.setFieldsetState("int_setClock", K.paneSizePrevious);
			}
		});
	},
	
	/*
	 * Sets the clock's background image, and custom if during festival.
	 * The clock is not visible when viewed on the website's main page, so don't
	 * load its images until shown.
	 */
	styleClock: function()
	{
		if (K.isClockStyled === false)
		{
			K.isClockStyled = true;
			if (K.isHalloween)
			{
				$("#paneClock").addClass("clkHalloween");
			}
			if (K.isWintersday)
			{
				$("#paneClock").addClass("clkWintersday");
			}
			$("#paneClockFace").addClass("paneClockFace");
		}
	},
	
	/*
	 * Sets the clock pane's dimension and element positions according to options.
	 */
	setClock: function()
	{
		var animationspeed = 200;
		var clockpaneheight = 0;

		switch (O.Options.int_setClock)
		{
			case O.IntEnum.Clock.Compact:
			{
				$("#paneClock").show();
				$("#itemTimeLocal, #itemTimeDaytime").show();
				// Reposition clock items
				I.bulkAnimate([
					{s: "#itemClock", p: {top: "0px", left: "70px", width: "220px", height: "220px"}},
					{s: "#paneClockFace", p: {width: "360px", height: "360px", top: "-70px", left: "0px"}},
					{s: "#paneClockIcons .iconSD", p: {"border-radius": "32px"}},
					{s: "#paneClockIcons .iconHC", p: {"border-radius": "24px"}},
					{s: "#clkIconSD0", p: {top: "4px", left: "290px"}},
					{s: "#clkIconSD1", p: {top: "148px", left: "290px"}},
					{s: "#clkIconSD2", p: {top: "148px", left: "4px"}},
					{s: "#clkIconSD3", p: {top: "4px", left: "4px"}},
					{s: "#clkIconHC0", p: {top: "52px", left: "306px"}},
					{s: "#clkIconHC1", p: {top: "132px", left: "306px"}},
					{s: "#clkIconHC2", p: {top: "132px", left: "20px"}},
					{s: "#clkIconHC3", p: {top: "52px", left: "20px"}},
					{s: "#clkWaypoint0", p: {top: "24px", left: "274px"}},
					{s: "#clkWaypoint1", p: {top: "164px", left: "274px"}},
					{s: "#clkWaypoint2", p: {top: "164px", left: "52px"}},
					{s: "#clkWaypoint3", p: {top: "24px", left: "52px"}}
				], animationspeed);
				$("#paneClockIcons .iconHC").css({width: "32px", height: "32px"});
				// Restyle text items
				$("#itemTimeLocal").css({
					width: "100%",
					right: "auto", bottom: "90px",
					"text-align": "center",
					opacity: 0.5
				});
				$("#itemTimeDaytime").css({
					width: "100%",
					top: "90px", bottom: "auto", left: "auto",
					"text-align": "center",
					opacity: 0.5
				});

				clockpaneheight = I.cPANE_CLOCK_HEIGHT_COMPACT;
			} break;

			case O.IntEnum.Clock.Full:
			{
				$("#paneClock").show();
				$("#itemTimeLocal, #itemTimeDaytime").show();
				// Reposition clock items
				I.bulkAnimate([
					{s: "#itemClock", p: {top: "70px", left: "70px", width: "220px", height: "220px"}},
					{s: "#paneClockFace", p: {width: "360px", height: "360px", top: "0px", left: "0px"}},
					{s: "#paneClockIcons .iconSD", p: {"border-radius": "12px"}},
					{s: "#paneClockIcons .iconHC", p: {"border-radius": "12px"}},
					{s: "#clkIconSD0", p: {top: "4px", left: "148px"}},
					{s: "#clkIconSD1", p: {top: "148px", left: "290px"}},
					{s: "#clkIconSD2", p: {top: "290px", left: "148px"}},
					{s: "#clkIconSD3", p: {top: "148px", left: "4px"}},
					{s: "#clkIconHC0", p: {top: "12px", left: "212px"}},
					{s: "#clkIconHC1", p: {top: "212px", left: "298px"}},
					{s: "#clkIconHC2", p: {top: "298px", left: "100px"}},
					{s: "#clkIconHC3", p: {top: "100px", left: "12px"}},
					{s: "#clkWaypoint0", p: {top: "52px", left: "164px"}},
					{s: "#clkWaypoint1", p: {top: "164px", left: "274px"}},
					{s: "#clkWaypoint2", p: {top: "274px", left: "164px"}},
					{s: "#clkWaypoint3", p: {top: "164px", left: "52px"}}
				], animationspeed);
				$("#paneClockIcons .iconHC").css({width: "48px", height: "48px"});
				// Restyle text items
				$("#itemTimeLocal").css({
					width: "auto",
					right: "10px", bottom: "10px",
					"text-align": "left",
					opacity: 1
				});
				$("#itemTimeDaytime").css({
					width: "auto",
					top: "auto", bottom: "10px", left: "10px",
					"text-align": "left",
					opacity: 1
				});

				clockpaneheight = I.cPANE_CLOCK_HEIGHT;
			} break;

			case O.IntEnum.Clock.Bar:
			{
				$("#paneClock").show();
				$("#itemTimeLocal, #itemTimeDaytime").hide();
				// Reposition clock items
				I.bulkAnimate([
					{s: "#itemClock", p: {top: "0px", left: "0px", width: "85px", height: "85px"}},
					{s: "#paneClockFace", p: {width: "132px", height: "132px", top: "-24px", left: "-24px"}},
					{s: "#paneClockIcons .iconSD", p: {"border-radius": "32px"}},
					{s: "#paneClockIcons .iconHC", p: {"border-radius": "24px"}},
					{s: "#clkIconSD0", p: {top: "0px", left: "82px"}},
					{s: "#clkIconSD1", p: {top: "0px", left: "152px"}},
					{s: "#clkIconSD2", p: {top: "0px", left: "222px"}},
					{s: "#clkIconSD3", p: {top: "0px", left: "292px"}},
					{s: "#clkIconHC0", p: {top: "48px", left: "98px"}},
					{s: "#clkIconHC1", p: {top: "48px", left: "168px"}},
					{s: "#clkIconHC2", p: {top: "48px", left: "238px"}},
					{s: "#clkIconHC3", p: {top: "48px", left: "308px"}},
					{s: "#clkWaypoint0", p: {top: "-8px", left: "98px"}},
					{s: "#clkWaypoint1", p: {top: "-8px", left: "168px"}},
					{s: "#clkWaypoint2", p: {top: "-8px", left: "238px"}},
					{s: "#clkWaypoint3", p: {top: "-8px", left: "308px"}}
				], animationspeed);
				$("#paneClockIcons .iconHC").css({width: "32px", height: "32px"});

				clockpaneheight = I.cPANE_CLOCK_HEIGHT_BAR;
			} break;

			case O.IntEnum.Clock.None:
			{
				/*
				 * There are three panes on the right panel: Clock, Menu, and Content
				 * all absolutely positioned, so to move them the CSS "top" attribute
				 * needs to be changed: less to go up, more to go down.
				 */
				$("#plateMenu").animate({top: 0}, animationspeed);
				$("#paneContent").animate({top: I.cPANE_MENU_HEIGHT,
					"min-height": I.cPANEL_HEIGHT_MIN - (I.cPANE_MENU_HEIGHT) + "px"}, animationspeed,
					function()
					{
						$("#paneClock").hide();
					});
			} break;
		}
		
		// Height for repositioning the beam menu, which is fixed position
		I.CLOCK_AND_MENU_HEIGHT = clockpaneheight + I.cPANE_MENU_HEIGHT;

		// Readjust panes to new height if showing clock
		if (O.Options.int_setClock !== O.IntEnum.Clock.None)
		{
			// Resize panes by animation
			$("#plateMenu").animate({top: clockpaneheight}, animationspeed);
			$("#paneClock, #paneClockWall, #paneClockBackground, #paneClockIcons, #paneClockCanvas")
				.animate({height: clockpaneheight}, animationspeed);

			// Readjust content pane
			$("#paneContent").animate({top: clockpaneheight + I.cPANE_MENU_HEIGHT,
				"min-height": I.cPANEL_HEIGHT_MIN - (clockpaneheight + I.cPANE_MENU_HEIGHT) + "px"}, animationspeed);
		}
	},
	
	/*
	 * Sets the clock's background dimming opacity.
	 * @param float pPercent.
	 */
	setDimming: function(pPercent, pWantAnimate)
	{
		if (O.Options.int_setDimming === 0 && I.ModeCurrent !== I.ModeEnum.Simple)
		{
			if (pWantAnimate)
			{
				$(K.clockBackground).animate({opacity: pPercent});
			}
			else
			{
				K.clockBackground.style.opacity = pPercent;
			}
		}
	},

	/*
	 * Sets a marker (small spikes at clock circumference) to specified angle.
	 * @param object pElement element to set angle.
	 * @param int pSeconds seconds from the hour.
	 */
	setMarkerAngle: function(pElement, pSeconds)
	{
		$(pElement).attr("transform", "rotate(" + pSeconds/10 + ", 50, 50)");
	},

	/*
	 * Sets a clock element by angle.
	 * @param object pElement to set angle.
	 * @param int pAngle angle 0-360.
	 */
	rotateClockElement: function(pElement, pAngle)
	{
		pElement.setAttribute("transform", "rotate(" + pAngle + ", 50, 50)");
	},
	
	/*
	 * Removes the filter attribute from SVG elements that have them (as in
	 * the shadow effect), then re-adds the filter. Workaround for a Firefox bug
	 * https://bugzilla.mozilla.org/show_bug.cgi?id=652991
	 */
	reapplyFilters: function()
	{
		if (I.BrowserCurrent === I.BrowserEnum.Firefox)
		{
			var c = $("#clkCircumference");
			var h = $("#clkHands");
			var f1 = "url(#clkFilterShadowOuter)";
			var f2 = "url(#clkGradientCircumference)";
			var f3 = "url(#clkFilterShadowHand)";
			c.removeAttr("filter").attr("filter", f1);
			c.css("stroke", f2);
			h.removeAttr("filter").attr("filter", f3);
		}
	},
	
	/*
	 * Initializes array of clock items for iteration and binds the clock chain
	 * icons to view map event when clicked, or check off when double clicked.
	 * @pre data attribute of icon was updated to get associated chain object.
	 */
	initializeClockItems: function()
	{
		K.IconsStandard = null;
		K.IconsHardcore = null;
		K.IconsStandard = new Array(K.IconSD0, K.IconSD1, K.IconSD2, K.IconSD3);
		K.IconsHardcore = new Array(K.IconHC0, K.IconHC1, K.IconHC2, K.IconHC3);
		
		// Change behavior of overlay mode because the user uses the clock more
		var checkbossbehavior = "click";
		var zoombossbehavior = "dblclick";
		if (I.ModeCurrent === I.ModeEnum.Website && I.isProgramEmbedded === false)
		{
			checkbossbehavior = "dblclick";
			zoombossbehavior = "click";
		}
		
		// Bind behavior
		for (var i = 0; i < T.cNUM_TIMEFRAMES_IN_HOUR; i++)
		{
			$([K.IconsStandard[i], K.IconsHardcore[i]]).each(function()
			{
				$(this).unbind(zoombossbehavior).on(zoombossbehavior, function()
				{
					C.viewChainFinale(C.Chains[$(this).data(C.cIndexSynonym)]);
				}).unbind(checkbossbehavior).on(checkbossbehavior, function()
				{
					$("#chnCheck_" + C.Chains[$(this).data(C.cIndexSynonym)].nexus).trigger("click");
				});
			});
		}
	},
	
	/*
	 * Called when the user checks a chain on the checklist, this will see if
	 * that chain is on the clock, and if it is, change visual based on the
	 * check state.
	 * @param string pIndex of the chain to check off in the clock.
	 * @pre Icons jQuery objects array was initialized and icons are in
	 * proper clock position.
	 */
	checkoffChainIcon: function(pIndex)
	{
		var i;
		var chain = C.Chains[pIndex]; // Chain that is clicked on checklist
		var ithchain; // Chain that is on the clock
		var iconchain;
		
		if (chain.series === C.ChainSeriesEnum.Standard
			|| chain.series === C.ChainSeriesEnum.Hardcore)
		{
			for (i = 0; i < T.cNUM_TIMEFRAMES_IN_HOUR; i++)
			{
				switch (chain.series)
				{
					case C.ChainSeriesEnum.Standard:
					{
						ithchain = T.getStandardChain(i);
						iconchain = K.IconsStandard[i];
					} break;
					case C.ChainSeriesEnum.Hardcore:
					{
						ithchain = T.getHardcoreChain(i);
						iconchain = K.IconsHardcore[i];
					} break;
				}

				// If clicked chain is on the clock
				if (ithchain && pIndex === ithchain.nexus)
				{
					X.reapplyChainIconState(ithchain, iconchain);
				}
			}
		}
	},
	
	/*
	 * Colors the minute hand and chain progress bar depending on current chain's prediction.
	 * @param string pColor.
	 */
	colorPrediction: function(pColor)
	{
		if (pColor !== K.currentPredictionColor)
		{
			K.currentPredictionColor = pColor;
			K.handMinute.style.stroke = pColor;
			K.timeProgress0.style.background = "linear-gradient(to right, transparent 0%, " + pColor + " 100%)";
		}
	},

	/*
	 * Although the tick effects are supposed to happen every 1 second, the
	 * function is actually ran multiple times per second so setTimeout
	 * is in sync with the Date object.
	 */
	tickFrequent: function()
	{
		var now = new Date();
		var sec = now.getSeconds();
		if (K.tickerSecondPrevious === sec)
		{
			// If the Date second has not changed, then don't do the effects
			K.TickerTimeout = setTimeout(K.tickFrequent, K.tickerFrequency);
			return;
		}
		else
		{
			// Else update the second variable and do the effects
			K.tickerSecondPrevious = sec;
			K.tickSecond(now);
		}
	},
	
	/*
	 * Clock ticker runs every second to update the hands and do effects to the
	 * clock when appropriate, like when a chain starts at 15 minute mark.
	 */
	tickSecond: function(pDate)
	{
		/*
		 * Things in this outer block runs every second, so core JS is used
		 * instead of jQuery for performance.
		 */
		var localtime = T.getTimeFormatted();
		var sec = pDate.getSeconds();
		var secondssincemidnight = T.getTimeSinceMidnight();
		T.TIMESTAMP_UNIX_SECONDS = T.getUNIXSeconds();
		T.SECONDS_TILL_DAILY = T.cSECONDS_IN_DAY - secondssincemidnight;
		T.SECONDS_TILL_WEEKLY = T.getSecondsTillWeektime(T.cWEEKLY_RESET_SECONDS, secondssincemidnight);
		var min = pDate.getMinutes();
		var hour = pDate.getHours() % T.cHOURS_IN_MERIDIEM;
		var secinhour = min * T.cSECONDS_IN_MINUTE + sec;
		var secangle = sec * 6; // 6 degrees per second
		var minangle = min * 6 + (sec / 10); // 1/10 degrees per second
		var hourangle = hour * 30 + (min / 2); // 1/240 degrees per second
		// Simulates mechanical recoil movement for second hand
		var vibrateSecond = function(pPattern, pCounter)
		{
			if (pCounter === undefined)
			{
				pCounter = 0;
			}
			setTimeout(function()
			{
				K.rotateClockElement(K.handSecond, secangle + pPattern[pCounter]);
				if (pCounter < pPattern.length - 1)
				{
					vibrateSecond(pPattern, pCounter + 1);
				}
			}, 50);
		};
		K.rotateClockElement(K.clockCircumference, minangle);
		K.rotateClockElement(K.handMinute, minangle);
		K.rotateClockElement(K.handHour, hourangle);
		if (O.Options.bol_showSecondHand)
		{
			vibrateSecond([-0.5, 1, -0.5, 0.25, 0]);
		}
		
		// Value 0.0 through 1.0 based on how far into the 15 minutes frame
		var timeframeprogress = 1 - ((min % T.cMINUTES_IN_TIMEFRAME)*60 + sec) / (T.cSECONDS_IN_TIMEFRAME);
		// Progress bar over chains page to show how far in timeframe
		var percent = (T.cPERCENT_100 * timeframeprogress);
		K.timeProgress0.style.width = (100 - percent) + "%";
		K.timeProgress1.style.width = percent + "%";
		
		/*
		 * If crossing a 15 minute mark (IMPORTANT).
		 */
		if (min % T.cMINUTES_IN_TIMEFRAME === 0 && sec === 0)
		{
			$(K.timeProgress0).css({width: "100%"}).animate({width: "0%"}, 800);
			$(K.timeProgress1).css({width: "0%"}).animate({width: "100%"}, 800);
			K.updateTimeFrame(pDate);
			// Check gem store alerts if opted
			if (O.Options.bol_alertGem && H.isGemPaused === false)
			{
				H.updateGemSubscription();
			}
		}
		else // If crossing a 1 second mark and hasn't crossed the 15 minute mark
		{
			/*
			 * For devices that goes to sleep, check the UNIX timestamp (which
			 * is updated every second if the device is awake) to see if it's
			 * out of sync, and refresh the clock if so.
			 */
			var awaketimestampcurrent = T.TIMESTAMP_UNIX_SECONDS;
			if (K.awakeTimestampPrevious < (awaketimestampcurrent - K.awakeTimestampTolerance))
			{
				K.updateTimeFrame(pDate);
			}
			// Update the timestamp
			K.awakeTimestampPrevious = awaketimestampcurrent;
		}
		
		// If crossing a 1 second mark (given)
		C.CurrentChains.forEach(C.updateCurrentChainTimeHTML);
		
		if (sec === 0)
		{
			/*
			 * If crossing a 5 minute mark.
			 */
			if (min % T.cMINUTES_IN_MINIFRAME === 0)
			{
				K.updateDaytimeIcon();
				K.updateDryTopClipboard();
				H.updateTimelineSegments();
				if (H.isDashboardEnabled)
				{
					H.refreshDashboard(pDate);
				}
			}
			
			/*
			 * If crossing a 1 minute mark.
			 */
			K.refreshFestival();
			K.updateDigitalClockMinutely();
			// Refresh the chain time countdown opted
			C.updateChainsTimeHTML();
			K.updateWaypointsClipboard();
			
			// Alert subscribed chain
			if (O.Options.int_setAlarm === O.IntEnum.Alarm.Subscription)
			{
				K.doSubscribedSpeech(O.Options.int_alertSubscribedFirst);
				K.doSubscribedSpeech(O.Options.int_alertSubscribedSecond);
			}
			// Check new build
			if (O.Options.bol_alertBuild)
			{
				O.enforceBuildVersion();
			}
		}
		
		// Mode dependent repeated functions
		switch (I.ModeCurrent)
		{
			case I.ModeEnum.Simple:
			{
				// Tick the two digital clocks below the analog clock
				K.timeSimple.innerHTML =
				T.getTimeFormatted(
				{
					aWant24: true,
					aWantHours: false,
					aWantLetters: true,
					aCustomTimeInSeconds: T.cSECONDS_IN_TIMEFRAME - T.getCurrentTimeframeElapsedTime()
				});
			} break;
			
			case I.ModeEnum.Overlay:
			{
				P.switchMapCheck();
			} break; 
		}
		
		K.timeLocal.innerHTML = localtime;
		K.timeDirectory.innerHTML = localtime;
		// Times in the Options page Debug section
		K.timestampUTC.innerHTML = T.TIMESTAMP_UNIX_SECONDS;
		K.timestampReset.innerHTML = T.getTimeFormatted(
		{
			aCustomTimeInSeconds: T.SECONDS_TILL_DAILY,
			aWant24: true
		});
		
		// Change the minute hand if passing colored marker
		if (secinhour >= K.currentFrameOffsetMinutes
			&& secinhour < (K.currentFrameOffsetMinutes + C.CurrentChainSD.minFinish))
		{
			K.colorPrediction("lime");
		}
		else if (secinhour >= (K.currentFrameOffsetMinutes + C.CurrentChainSD.minFinish)
			&& secinhour < (K.currentFrameOffsetMinutes + C.CurrentChainSD.avgFinish))
		{
			K.colorPrediction("orange");
		}
		else if (secinhour >= (K.currentFrameOffsetMinutes + C.CurrentChainSD.avgFinish))
		{
			K.colorPrediction("red");
		}
		
		// Trigger other ticking functions
		if (T.isChecklistCountdownsStarted)
		{
			T.updateChecklistCountdowns();
		}
		if (H.isCountdownTickEnabled)
		{
			H.updateDashboardCountdown(pDate);
		}
		if (H.isSaleOpened)
		{
			H.updateDashboardSaleCountdown();
		}
		if (K.StopwatchTimerStart !== 0)
		{
			K.tickStopwatchDown();
		}
		if (W.isObjectiveTimerTickEnabled)
		{
			K.timeLog.innerHTML = localtime;
			W.updateObjectiveTimers();
			if (W.MatchFinishTimeMS !== null)
			{
				K.countdownWvW.innerHTML = T.formatTimeLetter(W.secTillWvWReset--, true);
			}
			if (sec === 0)
			{
				W.updateAllObjectiveAge();
			}
		}
		
		// Loop this function, can use variable to halt it
		K.TickerTimeout = setTimeout(K.tickFrequent, K.tickerFrequency);
	},
	
	/*
	 * Macro function to get a speech if the subscribed boss is within the opted time
	 * @param int pMinutes before a chain starts as set by the user.
	 */
	doSubscribedSpeech: function(pMinutes)
	{
		if (pMinutes > 0)
		{
			var minutestill = T.cMINUTES_IN_TIMEFRAME - T.getCurrentTimeframeElapsedTime(T.UnitEnum.Minutes);
			var chainsd = C.NextChainSD1;
			var chainhc = C.NextChainHC1;
			var chainls = C.NextChainLS1;
			var wantsd = false;
			var wanthc = false;
			var wantls = false;
			var wantms = false;
			var speechwb = "";
			var speechms = "";
			var speechls = "";

			// If alarm minutes is beyond the timeframe range, check the chains beyond
			if (pMinutes > T.cMINUTES_IN_TIMEFRAME)
			{
				chainsd = C.NextChainSD2;
				chainhc = C.NextChainHC2;
				chainls = C.NextChainLS2;
				minutestill += T.cMINUTES_IN_TIMEFRAME;
			}
			
			if (pMinutes === minutestill)
			{
				// Make sure the chain is not null/undefined (if it does not exist in the time slot)
				var conjunction = " " + D.getSpeechWord("and") + " ";
				var timestr = D.getPluralTime(minutestill, "minute");
				var timephrase = " " + D.getSpeechWord("will start") + timestr;
				
				speechwb = D.getSpeechWord(D.orderModifier(D.orderModifier("boss", "world"), "subscribed")) + " ";
				wantsd = U.objToBool(chainsd) && (C.isChainSubscribed(chainsd) && C.isChainUnchecked(chainsd));
				wanthc = U.objToBool(chainhc) && (C.isChainSubscribed(chainhc) && C.isChainUnchecked(chainhc));
				wantls = U.objToBool(chainls) && (C.isChainSubscribed(chainls) && C.isChainUnchecked(chainls));
				
				if (wantsd || wanthc)
				{
					if (wantsd && wanthc)
					{
						speechwb += D.getChainPronunciation(chainsd) + conjunction + D.getChainPronunciation(chainhc);
					}
					else if (wantsd)
					{
						speechwb += D.getChainPronunciation(chainsd);
					}
					else if (wanthc)
					{
						speechwb += D.getChainPronunciation(chainhc);
					}
					D.speak(speechwb);
					D.speak(timephrase);
					
					if (wantsd)
					{
						I.notify({
							aTitle: D.getObjectName(chainsd),
							aBody: timestr,
							aIcon: chainsd.iconSrc
						});
					}
					if (wanthc)
					{
						I.notify({
							aTitle: D.getObjectName(chainhc),
							aBody: timestr,
							aIcon: chainhc.iconSrc
						});
					}
				}

				// Miscellaneous chains can happen simultaneously in a timeframe
				var chainms;
				var chainsms = (pMinutes > T.cMINUTES_IN_TIMEFRAME) ? C.NextChainsMS2 : C.NextChainsMS1;
				if (chainsms.length > 0)
				{
					speechms = D.getSpeechWord("event", "subscribed") + " ";
					for (var i = 0; i < chainsms.length; i++)
					{
						chainms = chainsms[i];
						if (U.objToBool(chainms) && (C.isChainSubscribed(chainms) && C.isChainUnchecked(chainms)))
						{
							speechms += D.getChainPronunciation(chainms);
							// Append a conjunction between names
							if (i+1 < chainsms.length && chainsms.length > 1)
							{
								speechms += conjunction;
							}
							wantms = true;
						}
					}
					if (wantms)
					{
						speechms += timephrase;
						D.speak(speechms);
						I.notify({
							aTitle: D.getObjectName(chainms),
							aBody: speechms,
							aIcon: chainms.iconSrc
						});
					}
				}

				// Living Story chain
				if (H.isStoryEnabled && wantls)
				{
					speechls = D.getSpeechWord("event", "subscribed") + " " + D.getChainPronunciation(chainls);
					speechls += timephrase;
					D.speak(speechls);
					I.notify({
						aTitle: D.getObjectName(chainls),
						aBody: speechls,
						aIcon: chainls.iconSrc
					});
				}
			}
		}
	},

	/*
	 * The megaserver world bosses are spaced by 15 minutes between chain starts
	 * beginning at the hour, so time calculation can be conveniently spaced into
	 * the four quadrants of an analog clock. Most chains last much shorter than that.
	 * Q1: X:00-X:15 (or 12-3 o'clock)
	 * Q2: X:15-X:30 (or 3-6 o'clock)
	 * Q3: X:30-X:45 (or 6-9 o'clock)
	 * Q4: X:45-X:00 (or 9-12 o'clock)
	 * @param Date pTime to determine the current timeframe.
	 */
	updateTimeFrame: function(pDate)
	{
		// Check if server reset happened
		O.checkResetTimestamps(pDate);
		
		// Remember current chain to reference variable
		C.CurrentChainSD = T.getStandardChain();
		C.NextChainSD1 = T.getStandardChain(1);
		C.NextChainSD2 = T.getStandardChain(2);
		C.NextChainSD3 = T.getStandardChain(3);
		C.NextChainSD4 = T.getStandardChain(4);
		C.CurrentChainsSD = [C.CurrentChainSD, C.NextChainSD1, C.NextChainSD2, C.NextChainSD3];
		
		C.CurrentChainHC = T.getHardcoreChain();
		C.NextChainHC1 = T.getHardcoreChain(1);
		C.NextChainHC2 = T.getHardcoreChain(2);
		C.NextChainHC3 = T.getHardcoreChain(3);
		C.NextChainHC4 = T.getHardcoreChain(4);
		
		if (H.isStoryEnabled)
		{
			// These are for subscription alarm reference
			C.NextChainLS1 = T.getLivingStoryChain(1);
			C.NextChainLS2 = T.getLivingStoryChain(2);
		}
		C.NextChainsMS1 = T.getMiscellaneousChains(1);
		C.NextChainsMS2 = T.getMiscellaneousChains(2);
		
		C.PreviousChains2 = T.getTimeframeChains(-2);
		C.PreviousChains1 = T.getTimeframeChains(-1);
		C.CurrentChains = T.getTimeframeChains();
		C.NextChains1 = T.getTimeframeChains(1);
		
		// Sort the chains list
		C.sortChainsListHTML();
		
		// Queue the highlighting of the current chain's events
		C.CurrentChains.forEach(C.queueEventsHighlight);
		
		// Update board in simple mode
		if (I.ModeCurrent === I.ModeEnum.Simple)
		{
			$("#itemSimpleCurrentSD").text(D.getObjectName(C.CurrentChainSD));
			$("#itemSimpleNextSD").text(D.getObjectName(C.NextChainSD1));
			$("#itemSimpleCurrentHC").text("");
			$("#itemSimpleNextHC").text("");
			if (C.CurrentChainHC || C.NextChainHC1)
			{
				$("#itemSimpleHC").show();
				if (C.CurrentChainHC)
				{
					$("#itemSimpleCurrentHC").text(D.getObjectName(C.CurrentChainHC));
				}
				if (C.NextChainHC1)
				{
					$("#itemSimpleNextHC").text(D.getObjectName(C.NextChainHC1));
				}
			}
			else
			{
				$("#itemSimpleHC").hide();
			}
		}
		
		// Alert current chain
		if (O.Options.int_setAlarm === O.IntEnum.Alarm.Checklist && O.Options.bol_alertAtEnd)
		{
			var checked = ", " + D.getSpeechWord("checked");
			var checkedcurrentsd = "";
			var checkednextsd = "";
			var checkedcurrenthc = "";
			var checkednexthc = "";
			var wantcurrentsd = U.objToBool(C.CurrentChainSD);
			var wantcurrenthc = U.objToBool(C.CurrentChainHC);
			var wantnextsd = U.objToBool(C.NextChainSD1);
			var wantnexthc = U.objToBool(C.NextChainHC1);
			var speech = D.getSpeechWord("world boss", "current") + " " + D.getSpeechWord("is") + " ";
			
			if (C.CurrentChainSD && ( ! C.isChainUnchecked(C.CurrentChainSD)))
			{
				checkedcurrentsd = checked;
			}
			if (C.CurrentChainHC && ( ! C.isChainUnchecked(C.CurrentChainHC)))
			{
				checkedcurrenthc = checked;
			}
			if (C.NextChainSD1 && ( ! C.isChainUnchecked(C.NextChainSD1)))
			{
				checkednextsd = checked;
			}
			if (C.NextChainHC1 && ( ! C.isChainUnchecked(C.NextChainHC1)))
			{
				checkednexthc = checked;
			}
			// Don't alert if current boss is checked off and user opted not to hear
			if (O.Options.bol_alertChecked === false)
			{
				if (checkedcurrentsd.length > 0) { wantcurrentsd = false; }
				if (checkedcurrenthc.length > 0) { wantcurrenthc = false; }
				if (checkednextsd.length > 0) { wantnextsd = false; }
				if (checkednexthc.length > 0) { wantnexthc = false; }
			}
			
			// Announce current bosses
			if (wantcurrentsd && wantcurrenthc)
			{
				D.speak(speech + D.getChainPronunciation(C.CurrentChainSD) + checkedcurrentsd, 5);
				D.speak(D.getSpeechWord("and") + ", " + D.getChainPronunciation(C.CurrentChainHC) + checkedcurrenthc, 4);
			}
			else if (wantcurrentsd)
			{
				D.speak(speech + D.getChainPronunciation(C.CurrentChainSD) + checkedcurrentsd, 5);
			}
			else if (wantcurrenthc)
			{
				D.speak(speech + D.getChainPronunciation(C.CurrentChainHC) + checkedcurrenthc, 5);
			}
			// Popup
			if (wantcurrentsd)
			{
				I.notify({
					aTitle: D.getObjectName(C.CurrentChainSD),
					aBody: D.getWordCapital("current"),
					aIcon: C.CurrentChainSD.iconSrc
				});
			}
			if (wantcurrenthc)
			{
				I.notify({
					aTitle: D.getObjectName(C.CurrentChainHC),
					aBody: D.getWordCapital("current"),
					aIcon: C.CurrentChainHC.iconSrc
				});
			}
			
			// Announce next bosses only if the current has been announced too
			if (wantcurrentsd || wantcurrenthc)
			{
				if (wantnextsd && wantnexthc)
				{
					D.speak(D.getSpeechWord("then") + ", " + D.getChainPronunciation(C.NextChainSD1) + checkednextsd, 4);
					D.speak(D.getSpeechWord("and") + ", " + D.getChainPronunciation(C.NextChainHC1) + checkednexthc, 4);
				}
				else if (wantnextsd)
				{
					D.speak(D.getSpeechWord("then") + ", " + D.getChainPronunciation(C.NextChainSD1) + checkednextsd, 4);
				}
				else if (wantnexthc)
				{
					D.speak(D.getSpeechWord("then") + ", " + D.getChainPronunciation(C.NextChainHC1) + checkednexthc, 4);
				}
				// Popup
				if (wantnextsd)
				{
					I.notify({
						aTitle: D.getObjectName(C.NextChainSD1),
						aBody: D.getWordCapital("next"),
						aIcon: C.NextChainSD1.iconSrc
					});
				}
				if (wantnexthc)
				{
					I.notify({
						aTitle: D.getObjectName(C.NextChainHC1),
						aBody: D.getWordCapital("next"),
						aIcon: C.NextChainHC1.iconSrc
					});
				}
			}
		}
		
		var sec = pDate.getSeconds();
		var min = pDate.getMinutes();
		var secinhour = min*60 + sec;
		// Blacken all markers
		$("#clkMarkers line").each(function()
		{
			$(this).attr("stroke", "black");
		});
		$("#paneClockIcons .iconSD").removeClass("clkIconCurrent clkIconNext");
		$("#paneClockIcons .iconHC").removeClass("clkIconCurrent clkIconNext");
		
		// Macro function for the following conditionals
		var repositionMarkers = function(pMarkerStart, pMarker0A, pMarker0B, pMarkerNext,
			pMarker1A, pMarker1B, pMarker2A, pMarker2B, pMarker3A, pMarker3B,
			pOffsetMark0, pOffsetMark1, pOffsetMark2, pOffsetMark3)
		{
			// Highlight active chain icon
			$([K.IconSD0, K.IconHC0]).each(function()
			{
				$(this).addClass("clkIconCurrent");
			});
			$([K.IconSD1, K.IconHC1]).each(function()
			{
				$(this).addClass("clkIconNext");
			});
			
			// Update chain markers
			K.setMarkerAngle(pMarker0A, C.CurrentChainSD.minFinish + pOffsetMark0);
			K.setMarkerAngle(pMarker0B, C.CurrentChainSD.avgFinish + pOffsetMark0);
			K.setMarkerAngle(pMarker1A, C.NextChainSD1.minFinish + pOffsetMark1);
			K.setMarkerAngle(pMarker1B, C.NextChainSD1.avgFinish + pOffsetMark1);
			K.setMarkerAngle(pMarker2A, C.NextChainSD2.minFinish + pOffsetMark2);
			K.setMarkerAngle(pMarker2B, C.NextChainSD2.avgFinish + pOffsetMark2);
			K.setMarkerAngle(pMarker3A, C.NextChainSD3.minFinish + pOffsetMark3);
			K.setMarkerAngle(pMarker3B, C.NextChainSD3.avgFinish + pOffsetMark3);
			// Update chain icons, fade if checked off
			var restyleIcon = function(pChain, pIcon)
			{
				if (pChain)
				{
					pIcon.show();
					pIcon.attr("src", pChain.iconSrc);
					pIcon.data(C.cIndexSynonym, pChain.nexus);
					pIcon.attr("title", "<dfn>" + D.getObjectName(pChain) + "</dfn>");
					I.qTip.init(pIcon);
					X.reapplyChainIconState(pChain, pIcon);
				}
				else
				{
					// Don't show icon if hardcore boss is not scheduled at that timeframe
					pIcon.hide();
				}
			};
			restyleIcon(C.CurrentChainSD, K.IconSD0);
			restyleIcon(C.NextChainSD1, K.IconSD1);
			restyleIcon(C.NextChainSD2, K.IconSD2);
			restyleIcon(C.NextChainSD3, K.IconSD3);
			restyleIcon(C.CurrentChainHC, K.IconHC0);
			restyleIcon(C.NextChainHC1, K.IconHC1);
			restyleIcon(C.NextChainHC2, K.IconHC2);
			restyleIcon(C.NextChainHC3, K.IconHC3);
			// Colorize the active chain's markers
			$(pMarkerStart).attr("stroke", "lime");
			$(pMarker0A).attr("stroke", "orange");
			$(pMarker0B).attr("stroke", "red");
			$(pMarkerNext).attr("stroke", "green");
		};
		
		// Macro function for styling various clock pane elements
		var restyleClock = function(pTimeframeMark)
		{
			var i0, i1, i2, i3;
			switch (pTimeframeMark)
			{
				case T.cSECS_MARK_0: { i0 = "0"; i1 = "1"; i2 = "2"; i3 = "3"; } break;
				case T.cSECS_MARK_1: { i0 = "1"; i1 = "2"; i2 = "3"; i3 = "0"; } break;
				case T.cSECS_MARK_2: { i0 = "2"; i1 = "3"; i2 = "0"; i3 = "1"; } break;
				case T.cSECS_MARK_3: { i0 = "3"; i1 = "0"; i2 = "1"; i3 = "2"; } break;
			}
			K.currentFrameOffsetMinutes = pTimeframeMark;

			K.WpChain0 = $("#clkWaypoint" + i0); K.IconSD0 = $("#clkIconSD" + i0);
			K.WpChain1 = $("#clkWaypoint" + i1); K.IconSD1 = $("#clkIconSD" + i1);
			K.WpChain2 = $("#clkWaypoint" + i2); K.IconSD2 = $("#clkIconSD" + i2);
			K.WpChain3 = $("#clkWaypoint" + i3); K.IconSD3 = $("#clkIconSD" + i3);
			K.IconHC0 = $("#clkIconHC" + i0);
			K.IconHC1 = $("#clkIconHC" + i1);
			K.IconHC2 = $("#clkIconHC" + i2);
			K.IconHC3 = $("#clkIconHC" + i3);
			
			C.refreshChainDailyIcon();
			
			repositionMarkers(
				$("#clkMarker" + i0), $("#clkMarker" + i0 + "A"), $("#clkMarker" + i0 + "B"),
				$("#clkMarker" + i1), $("#clkMarker" + i1 + "A"), $("#clkMarker" + i1 + "B"),
				$("#clkMarker" + i2 + "A"), $("#clkMarker" + i2 + "B"),
				$("#clkMarker" + i3 + "A"), $("#clkMarker" + i3 + "B"),
				T["cSECS_MARK_" + i0], T["cSECS_MARK_" + i1], T["cSECS_MARK_" + i2], T["cSECS_MARK_" + i3]
			);
	
			// Animate quadrant rotation
			var quad = document.getElementById("clkQuadrant");
			var newquadangle = parseInt(i0) * T.cCIRCLE_RIGHT_DEGREE;
			if (newquadangle === 0 && K.oldQuadrantAngle !== 0)
			{
				newquadangle = T.cCIRCLE_FULL_DEGREE;
			}
			
			$({angle: K.oldQuadrantAngle}).animate({angle: newquadangle}, {
				duration: 600,
				step: function() { K.rotateClockElement(quad, this.angle); },
				done: function() { K.rotateClockElement(quad, newquadangle); }
			});
			
			if (newquadangle === T.cCIRCLE_FULL_DEGREE)
			{
				newquadangle = 0;
			}
			K.oldQuadrantAngle = newquadangle;
		};
		
		// Recolor the active event's markers and rotate clock quadrant
		// Note that clock elements' IDs are suffixed with numbers 0-3 for easy iteration
		if (secinhour >= T.cSECS_MARK_0 && secinhour < T.cSECS_MARK_1)
		{
			restyleClock(T.cSECS_MARK_0);
		}
		else if (secinhour >= T.cSECS_MARK_1 && secinhour < T.cSECS_MARK_2)
		{
			restyleClock(T.cSECS_MARK_1);
		}
		else if (secinhour >= T.cSECS_MARK_2 && secinhour < T.cSECS_MARK_3)
		{
			restyleClock(T.cSECS_MARK_2);
		}
		else if (secinhour >= T.cSECS_MARK_3 && secinhour <= T.cSECS_MARK_4)
		{
			restyleClock(T.cSECS_MARK_3);
		}
		
		// Refresh waypoints because the icon's clock position changed
		K.updateWaypointsClipboard();
		K.updateDryTopClipboard();
		K.initializeClockItems();
	},

	/*
	 * Initializes the array containing Clipboard objects.
	 * Each clock waypoint icon (4 img tags) will have the data attribute set to
	 * a waypoint text by the time updater.
	 */
	initializeClipboard: function()
	{
		for (var i = 0; i < T.cNUM_TIMEFRAMES_IN_HOUR; i++)
		{
			I.bindClipboard("#clkWaypoint" + i);
		}
	},
	
	/*
	 * Updates the daytime icon based on current game daylight.
	 */
	updateDaytimeIcon: function()
	{
		var isdaylight = T.isDaylight();
		var symbol = (isdaylight) ? I.Symbol.Day : I.Symbol.Night;
		var word = (isdaylight) ? D.getWord("day") : D.getWord("night");
		K.currentDaytimeSymbol = symbol;
		K.currentDaytimeWord = word;
		$("#itemTimeDayIcon").text(symbol);
	},
	
	/*
	 * Updates the digital clock with minutely information.
	 */
	updateDigitalClockMinutely: function()
	{
		// Daytime clock updates time remaining
		var daytime = T.getDayPeriodRemaining();
		K.timeDaytime.innerHTML = daytime;
		K.currentDaytimeString = T.getTimeFormatted({aWantSeconds: false}) + " " + K.currentDaytimeSymbol + daytime;
		K.currentDaytimeText = K.currentDaytimeString + " " + K.currentDaytimeWord;
		// Clock on the map shown in overlay mode
		K.timeMap.innerHTML = K.currentDaytimeString;
		K.timeWvW.innerHTML = K.currentDaytimeString;
		// Local clock updates additional times in tooltip
		K.timeLocal.title =
			T.formatWeektime(new Date(), true) + "<br />" +
			"<dfn>Anet:</dfn> " + T.getTimeFormatted(
			{
				aReference: T.ReferenceEnum.Server,
				aWantSeconds: false
			}) + "<br />" +
			"<dfn>UTC:</dfn> " + T.getTimeFormatted(
			{
				aReference: T.ReferenceEnum.UTC,
				aWantSeconds: false,
				aWant24: true
			}) + "<br />" +
			"<dfn>Daily:</dfn> " + T.formatTimeLetter(T.SECONDS_TILL_DAILY, false) + "<br />" +
			"<dfn>Weekly:</dfn> " + T.formatTimeLetter(T.SECONDS_TILL_WEEKLY, false);
		K.timeDirectory.title = K.timeLocal.title;
		I.qTip.init(K.timeLocal);
		I.qTip.init(K.timeDirectory);
		// Also update timeline
		H.updateTimelineIndicator();
	},
	
	/*
	 * Updates waypoint icons' copy text.
	 * @pre The waypoint icon's position on the clock was updated.
	 * Standard bosses' schedule does not have gaps, hardcore may have gaps.
	 */
	updateWaypointsClipboard: function()
	{
		var updateWaypoint = function(pWaypoint, pChainSD, pChainHC, pChainSDAfter, pChainHCAfter)
		{
			var text = "";
			
			// Chains for the clicked timeframe
			text += pChainSD.waypoint + " " + D.getChainAlias(pChainSD);
			// If hardcore chain doesn't exist
			if ( ! pChainHC || pChainHC.flags.isClipped === false)
			{
				text += T.getTimeTillChainFormatted(pChainSD);
			}
			else if (pChainHC.flags.isClipped !== false)
			{
				text += " " + D.getTranslation("and") + " " + pChainHC.waypoint
					+ " " + D.getChainAlias(pChainHC)
					+ T.getTimeTillChainFormatted(pChainHC);
			}
			
			// Chains for the timeframe after that
			text += ", " + D.getTranslation("then") + " " + pChainSDAfter.waypoint
				+ " " + D.getChainAlias(pChainSDAfter);
			if ( ! pChainHCAfter || pChainHCAfter.flags.isClipped === false)
			{
				text += T.getTimeTillChainFormatted(pChainSDAfter);
			}
			else if (pChainHCAfter.flags.isClipped !== false)
			{
				text += " " + D.getTranslation("and") + " " + pChainHCAfter.waypoint
					+ " " + D.getChainAlias(pChainHCAfter)
					+ T.getTimeTillChainFormatted(pChainHCAfter);
			}
			
			text = text + I.siteTagCurrent;
			I.updateClipboard(pWaypoint, text);
		};
		
		updateWaypoint(K.WpChain0, C.CurrentChainSD, C.CurrentChainHC, C.NextChainSD1, C.NextChainHC1);
		updateWaypoint(K.WpChain1, C.NextChainSD1, C.NextChainHC1, C.NextChainSD2, C.NextChainHC2);
		updateWaypoint(K.WpChain2, C.NextChainSD2, C.NextChainHC2, C.NextChainSD3, C.NextChainHC3);
		updateWaypoint(K.WpChain3, C.NextChainSD3, C.NextChainHC3, C.NextChainSD4, C.NextChainHC4);
	},
	
	/*
	 * Updates the current and next Dry Top events icons' clipboard text.
	 */
	updateDryTopClipboard: function()
	{
		if (C.isDryTopGenerated)
		{
			var s0 = T.getCurrentDryTopEvents();
			var s1 = T.getCurrentDryTopEvents(1);
			I.updateClipboard("#chnDryTopWaypoint0", s0);
			I.updateClipboard("#chnDryTopWaypoint1", s1);
			var clip0 = $("#mapDryTopClip0");
			var clip1 = $("#mapDryTopClip1");
			if (C.isDryTopIconsShown)
			{
				clip0.val(s0);
				clip1.val(s1);
			}
			I.updateClipboard(clip0, s0);
			I.updateClipboard(clip1, s1);
		}
	},
	
	/*
	 * Initializes the stopwatch and egg timer on the chains page options popup.
	 */
	initializeStopwatch: function()
	{
		// Bind toggle button on top of the digits
		$("#watToggle").click(function()
		{
			$("#itemStopwatch").toggle("fast");
		});
		
		// Start button acts as Start/Pause/Resume
		$("#watStart").click(function()
		{
			$("#watToggle").show();
			$("#itemStopwatch").show().css("font-size", O.Options.int_sizeStopwatchFont);
			var nowms = (new Date()).getTime();
			// Start the first time
			if (K.StopwatchTimestamp === 0)
			{
				var offsetminutes = parseInt($("#watOffsetMinutes").val()) * T.cMSECONDS_IN_MINUTE;
				var offsetseconds = parseInt($("#watOffsetSeconds").val()) * T.cMSECONDS_IN_SECOND;
				K.StopwatchTimestamp = (new Date()).getTime() - (offsetminutes + offsetseconds);
				K.tickStopwatchUp();
			}
			// Resume after pause
			else if (K.isStopwatchPaused)
			{
				K.isStopwatchPaused = false;
				K.StopwatchTimestamp = K.StopwatchTimestamp + (nowms - K.StopwatchTimesleep);
				K.tickStopwatchUp();
			}
			// Pause
			else
			{
				window.clearTimeout(K.StopwatchTimeout);
				K.StopwatchTimesleep = nowms;
				K.isStopwatchPaused = true;
			}
		});
		
		// Stop button resets the countup
		$("#watStop").click(function()
		{
			if (K.StopwatchTimerStart === 0)
			{
				// Only the toggle button if the personal timer isn't running also
				$("#watToggle").hide();
			}
			window.clearTimeout(K.StopwatchTimeout);
			K.isStopwatchPaused = false;
			K.StopwatchTimestamp = 0;
			K.stopwatchUp.innerHTML = "";
		});
		
		// Lap button prints the current moment
		$("#watLap").click(function()
		{
			if (K.StopwatchTimestamp !== 0)
			{
				I.print(K.stopwatchUp.innerHTML);
			}
			else
			{
				I.write("Stopwatch must be running to lap time.");
			}
		});
		
		/*
		 * Egg timer.
		 */
		$("#watTimerStart").click(function()
		{
			$("#watToggle").show();
			$("#itemStopwatch").show().css("font-size", O.Options.int_sizeStopwatchFont);
			var offsetseconds = parseInt($("#watOffsetSeconds").val()) * T.cMSECONDS_IN_SECOND;
			K.StopwatchTimerStart = (new Date()).getTime();
			K.StopwatchTimerFinish = K.StopwatchTimerStart + (O.Options.int_minStopwatchAlert * T.cMSECONDS_IN_MINUTE) + offsetseconds;
			I.write("Alert set for " + (new Date(K.StopwatchTimerFinish)).toLocaleString());
			// Initial call to the update function
			D.verifyNativeTTS();
			K.tickStopwatchDown();
		});
		$("#opt_int_minStopwatchAlert").onEnterKey(function()
		{
			// Pressing enter on the minute input triggers the egg timer start button
			$(this).trigger("change");
			$("#watTimerStart").trigger("click");
		});
		$("#watTimerStop").click(function()
		{
			if (K.StopwatchTimestamp === 0)
			{
				// Only the toggle button if the stopwatch isn't running also
				$("#watToggle").hide();
			}
			K.StopwatchTimerStart = 0;
			K.stopwatchDown.innerHTML = "";
		});
		I.bindInputSelect("#mapAlarmStopwatchUp input, #mapAlarmStopwatchDown input");
	},
	
	/*
	 * Updates the stopwatch countup.
	 */
	tickStopwatchUp: function()
	{
		var elapsedms = (new Date()).getTime() - K.StopwatchTimestamp;
		K.stopwatchUp.innerHTML = T.formatTimeColon(elapsedms, true);
		K.StopwatchTimeout = setTimeout(function()
		{
			K.tickStopwatchUp();
		}, K.stopwatchFrequency);
	},
	
	/*
	 * Updates the personal countdown timer.
	 * To be called by the clock tick second function.
	 */
	tickStopwatchDown: function()
	{
		var now = new Date();
		var msec = K.StopwatchTimerFinish - now.getTime();
		if (msec > 0)
		{
			K.stopwatchDown.innerHTML = T.formatTimeLetter(Math.floor(msec / T.cMSECONDS_IN_SECOND), true);
		}
		else
		{
			// If negative then timer has finished
			$("#watTimerStop").trigger("click");
			var timestr = now.toLocaleString();
			var speech = O.Options.str_textStopwatchAlert;
			I.print(timestr + ": " + U.escapeHTML(speech));
			D.speak(speech);
			I.notify({
				aTitle: speech,
				aBody: timestr,
				aIcon: "img/notification/alert.png",
				aDelay: 60
			});
			// Start alarm again if opted repeat
			if (O.Options.bol_repeatStopwatchAlert) {
				$("#watTimerStart").trigger("click");
			}
		}
	},
	
	/*
	 * Festival decorative function.
	 */
	refreshFestival: function()
	{
		if (K.isWintersday)
		{
			var numsnowflakes = 144;
			var canvas = document.getElementById("paneClockCanvas");
			var context = canvas.getContext("2d");
			// Erase previous snowflakes
			context.clearRect(0, 0, canvas.width, canvas.height);
			// Sprinkle new snowflakes
			var x, y;
			for (var i = 0; i < numsnowflakes; i++)
			{
				x = T.getRandomIntRange(0, canvas.width);
				y = T.getRandomIntRange(0, canvas.height);
				context.fillStyle = "rgba(255,255,255,255)";
				context.fillRect(x, y, 1, 1);
			}
		}
	}
};
I = {
/* =============================================================================
 * @@Interface HTML and CSS content manipulation
 * ========================================================================== */

	cSiteName: "GW2Timer.com",
	cSiteLink: "gw2timer.com/",
	cSiteURL: "https://gw2timer.com/",
	cSiteExternal: "https://gw2timer.com/out/?u=",
	cSiteTitle: "",
	cImageHost: "https://i.imgur.com/",
	cGameName: "Guild Wars 2",
	cGameNick: "GW2",
	cErrorAPI: "ArenaNet API server may be down.",
	cAJAXGlobalTimeout: 30000, // milliseconds
	cPNG: ".png", // Almost all used images are PNG
	cJSON: ".json", // Format of API files
	cTXT: ".txt", // Plain text and test files
	cThrobber: "<div class='itemThrobber'><em></em></div>",
	cChatcodePrefix: "[&",
	cChatencodedPrefix: "%255B%2526",
	cChatcodeSuffix: "]",
	cTextDelimiterChar: "|",
	cTextDelimiterRegex: /[|]/g,
	cTextReplace: "{0}",
	cOptionsDelimiter: ": ",
	cClipboardAttribute: "data-clipboard-text",
	cClipboardSuccessText: "Text copied to clipboard :)<br />",
	cTooltipAttribute: "data-tip",
	cPageAttribute: "data-page",
	consoleTimeout: {},
	siteTagDefault: " - gw2timer.com",
	siteTagCurrent: " - gw2timer.com",
	Symbol:
	{
		Filler: "&zwnj;", // Place this inside empty elements to give them dimension
		Unicode: "中",
		ArrowUp: "⇑",
		ArrowDown: "⇓",
		ArrowLeft: "⇐",
		ArrowRight: "⇒",
		ArrowClockwise: "↻",
		ArrowCounterwise: "↺",
		Horizontal: "⇄",
		Vertical: "⇅",
		TriUp: "▲",
		TriDown: "▼",
		TriRight: "►",
		TriLeft: "◄",
		Block: "■",
		Star: "☆",
		Wait: "⏳",
		Infinity: "∞",
		Approx: "≈",
		Negative: "−",
		Quantity: "×",
		Ellipsis: "…",
		Day: "☀",
		Night: "☽",
		Expand: "◢",
		Collapse: "◣",
		External: "↗",
		Help: "[?]",
		StateActive: "<span class='cssState cssStateActive'></span>",
		StateInactive: "<span class='cssState cssStateInactive'></span>",
		StateWaiting: "<span class='cssState cssStateWaiting'></span>"
	},
	
	// HTML/CSS pixel units
	cOUT_OF_VIEW: -9999,
	cPANEL_WIDTH: 360,
	cPANEL_HEIGHT_MIN: 220,
	cPANE_CLOCK_HEIGHT: 360,
	cPANE_CLOCK_HEIGHT_COMPACT: 220,
	cPANE_CLOCK_HEIGHT_BAR: 85,
	cPANE_MENU_HEIGHT: 48,
	cTOOLTIP_MOUSEMOVE_MS: 20,
	cTOOLTIP_NUM_RERENDER: 8, // Times to trigger the tooltip move function so the tooltip resizes to its ultimate size
	cTOOLTIP_OFFSET_ADD_X: 0,
	cTOOLTIP_OFFSET_ADD_Y: 56,
	cTOOLTIP_OVERFLOW_ADD_X: 16,
	cTOOLTIP_OVERFLOW_ADD_Y: 38,
	cTOOLTIP_PADDING_ADD_Y: 12,
	CLOCK_AND_MENU_HEIGHT: 0,
	posX: 0, // Mouse position
	posY: 0,
	// Overlay sleep detector
	isSleeping: false,
	cMSECONDS_SLEEP: 3000,
	SleepTimeout: {},
	Scrl: { // Autoscroll
		Anchor: {},
		Interval: {},
		Container: {},
		isOn: false,
		posX: 0,
		posY: 0
	},
	
	isProgramLoaded: false,
	isProgramEmbedded: false,
	isProgramExternal: false, // If is embedded in another site rather self-embedded
	isProgramFocused: true, // Whether the user's current browser tab is this site
	isAPIEnabled: true, // This will be changed asynchronously by the populate map function
	isMapEnabled: true,
	isTouchEnabled: false,
	isCustomScrollEnabled: true,
	isSpeechSynthesisEnabled: false,
	isSpeechNativeEnabled: false,
	isSpeechNativeLoaded: false,
	isProjectionEnabled: false,
	ModeCurrent: null,
	// Content-Plate-Page and Section-Header
	ModeEnum:
	{
		Website: "Website",
		Mobile: "Mobile",
		Simple: "Simple",
		Tile: "Tile",
		Overlay: "Overlay",
		Projection: "Projection"
	},
	cPlatePrefix: "#plate",
	cPlateMenuPrefix: "#plateMenu_",
	PageInitial: "",
	PageCurrent: "",
	PagePrevious: "",
	PlateEnum: // The pages displayed by the side app panel
	{
		Directory: "Directory",
		Chains: "Chains",
		Map: "Map",
		Help: "Help",
		Options: "Options"
	},
	isMapPlateInitialized: false,
	isAccountPanelInitialized: false,
	SpecialPageEnum:
	{
		Account: "Account",
		Audit: "Audit",
		WvW: "WvW",
		Leaderboard: "Leaderboard"
	},
	LoadedStylesheets: {}, // Holds names of stylesheets to not download again
	/*
	 * Enumeration for opening a valid page or section (subpage) upon site load, if URL provided.
	 * Page names must be unique, and may be in sentence case or all caps.
	 */
	PageEnum:
	{
		Chains:
		{
			Scheduled: "Scheduled",
			Special: "Special",
			Drytop: "Drytop",
			Legacy: "Legacy",
			Temple: "Temple",
			Timetable: "Timetable"
		},
		Map:
		{
			Daily: "Daily",
			Resource: "Resource",
			JP: "JP",
			Collectible: "Collectible",
			Guild: "Guild",
			TP: "TP",
			Notepad: "Notepad",
			Personal: "Personal"
		},
		Help:
		{
			FAQ: "FAQ",
			About: "About",
			Embed: "Embed",
			Schedules: "Schedules",
			Legacies: "Legacies",
			Temples: "Temples",
			Contested: "Contested"
		},
		Account:
		{
			Manager: "Manager",
			Bank: "Bank",
			Materials: "Materials",
			Vault: "Vault",
			Wardrobe: "Wardrobe",
			Outfits: "Outfits",
			Gliders: "Gliders",
			Dyes: "Dyes",
			Minis: "Minis",
			Carriers: "Carriers",
			Champions: "Champions",
			Finishers: "Finishers",
			Nodes: "Nodes",
			Cats: "Cats",
			Achievements: "Achievements",
			Masteries: "Masteries",
			Raids: "Raids",
			Dungeons: "Dungeons",
			
			Characters: "Characters",
			Hero: "Hero",
			Possessions: "Possessions",
			Ascended: "Ascended",
			Inventory: "Inventory",
			Catalog: "Catalog",
			Cleanup: "Cleanup",
			Recipes: "Recipes",
			Crafting: "Crafting",
			SAB: "SAB",
			
			Trading: "Trading",
			Gem: "Gem",
			Museum: "Museum",
			Pact: "Pact",
			Buying: "Buying",
			Selling: "Selling",
			Bought: "Bought",
			Sold: "Sold"
			
			/*PVP: "PVP",
			Guilds: "Guilds",
			Achievements: "Achievements"*/
		}
	},
	/*
	 * Outline of the directory menu. Format:
	 * Grouping: {Page: "Translatable Name"}
	 */
	Directory:
	{
		Directory:
		{
			Scheduled: "Boss Timers",
			Map: "World Map",
			Leaderboard: "WvW Leaderboard",
			Manager: "Account Manager",
//			Gem: "Gem Alarm",
			Options: "Options"
		},
		Events:
		{
			Tile: "Timers Only",
			Timetable: "Full Timetable",
			Special: "Special Bosses",
			DryTop: "Dry Top",
			Help: "Help",
			Forum: "Forum"
		},
		Map:
		{
			Resource: "Resource Nodes",
			JP: "Jumping Puzzles",
			Collectible: "Collectible Items",
			Guild: "Guild Missions"
		},
		Checklist:
		{
			Personal: "Personal",
			Notepad: "Notepad",
			Daily: "Dailies",
			Raids: "Raids",
			Dungeons: "Dungeons"
		},
		Account:
		{
			Audit: "Audit",
			Characters: "Characters",
			Hero: "Hero",
			Achievements: "Achievements",
			Masteries: "Masteries",
			Recipes: "Recipes"
		},
		Inventory:
		{
			Inventory: "Inventory",
			Bank: "Bank",
			Materials: "Materials",
			Vault: "Vault",
			Possessions: "Possessions",
			Catalog: "Catalog",
			Cleanup: "Cleanup",
			Ascended: "Ascended"
		},
		Wardrobe:
		{
			Wardrobe: "Skins",
			Outfits: "Outfits",
			Gliders: "Gliders",
			Dyes: "Dyes",
			Minis: "Minis",
			Carriers: "Carriers",
			Champions: "Champions",
			Finishers: "Finishers",
			Nodes: "Nodes",
			Cats: "Cats",
			SAB: "SAB"
		},
		Trading:
		{
			TP: "Tracker",
			Trading: "Exchange",
			Buying: "Buying",
			Selling: "Selling",
			Bought: "Bought",
			Sold: "Sold",
			Museum: "Museum",
			Pact: "Pact"
		}
	},
	DirectoryExternal: // Associative array of URL that opens a new window
	{
		Forum: U.URL_META.Forum
	},
	DirectoryCompound: // Associative array of compound translation buttons
	{
		Special: true,
		Timetable: true,
		DryTop: true
	},
	/*
	 * Number used to open a section's subcontent, written as 1-indexed via
	 * query string, but used as 0-indexed.
	 */
	SectionCurrent: {},
	ArticleCurrent: null,
	contentCurrentPlate: "", // This is cContentPrefix + contentCurrent
	isContentLoaded_Map: false,
	isContentLoaded_Help: false,
	isSectionLoaded_Daily: false,
	cHeaderPrefix: "#header",
	
	// User information
	BrowserCurrent: -1,
	BrowserEnum:
	{
		Unknown: -1,
		IE: 0,
		Opera: 1,
		Firefox: 2,
		Chrome: 3
	},
	ClickEnum:
	{
		Left: 1,
		Middle: 2,
		Right: 3
	},
	// Screen width in pixels, for determining map zoom values
	ScreenWidth:
	{
		Huge: 2560,
		Large: 1024,
		Medium: 640
	},
	
	/*
	 * Does things that need to be done before everything else.
	 * @pre This function is ran before any initialization functions.
	 */
	initializeFirst: function()
	{
		// Manually clear the TTS iframe to prevent old sound from playing
		D.stopSpeech();

		// Detect iFrame embedding
		if (window !== window.top)
		{
			I.isProgramEmbedded = true;
			try
			{
				// If self-embedded
				parent.document;
			}
			catch (e)
			{
				// If embedded in another website
				I.isProgramExternal = true;
			}
		}
		
		// Get URL arguments and do appropriate changes
		U.enforceURLArgumentsFirst();
		I.enforceProgramMode();
		U.updateLanguageLinks();
		
		// Tell if DST is in effect
		T.checkDST();
		// If user lives in the Americas then use AM/PM time format by default
		T.cUTC_OFFSET_USER = -((new Date()).getTimezoneOffset() / T.cMINUTES_IN_HOUR);
		if (T.cUTC_OFFSET_USER <= T.cUTC_OFFSET_EASTERN
			&& T.cUTC_OFFSET_USER >= T.cUTC_OFFSET_HAWAII)
		{
			O.Options.bol_use24Hour = false;
		}
		
		// Initialize timestamps
		var currenttimestamp = T.getUNIXSeconds();
		O.initializeTimestamp(O.Utilities.timestampDaily);
		O.initializeTimestamp(O.Utilities.timestampWeekly);
		
		// Initial sync of the sleep detection variable
		K.awakeTimestampPrevious = currenttimestamp;
		
		// Tailor the initial zoom for WvW so all borderlands fit in the screen
		if (screen.height >= 800)
		{
			O.Options.int_setInitialZoomWvW = 3;
		}
		else if (screen.height >= 480)
		{
			O.Options.int_setInitialZoomWvW = 2;
		}
		else
		{
			O.Options.int_setInitialZoomWvW = 1;
		}
		// Pre-set account bank width
		if (screen.width < 1200)
		{
			O.Options.bol_condenseBank = true;
		}
		
		// Remember user's browser maker
		var useragent = navigator.userAgent;
		if (useragent.indexOf("MSIE") !== -1 || useragent.indexOf("Trident") !== -1)
		{
			I.BrowserCurrent = I.BrowserEnum.IE;
		}
		else if (useragent.indexOf("Chrome") !== -1)
		{
			I.BrowserCurrent = I.BrowserEnum.Chrome;
		}
		else if (useragent.indexOf("Firefox") !== -1)
		{
			I.BrowserCurrent = I.BrowserEnum.Firefox;
		}
		else if (useragent.indexOf("Opera") !== -1)
		{
			I.BrowserCurrent = I.BrowserEnum.Opera;
		}
		
		// Detect TTS capability
		try {
			if (window.speechSynthesis && I.BrowserCurrent === I.BrowserEnum.Chrome && I.ModeCurrent !== I.ModeEnum.Overlay)
			{
				I.isSpeechSynthesisEnabled = true;
				// Automatically reload the asynchronous voices
				window.speechSynthesis.onvoiceschanged = function()
				{
					window.speechSynthesis.getVoices();
				};
			}
		}
		catch (e) {}
		
		// Set the maximum wait time for all non-custom AJAX requests, such as getJSON
		$.ajaxSetup({ timeout: I.cAJAXGlobalTimeout });
		
		// Initialize first interfaces
		I.Scrl.Anchor = $("#itemAutoscroll");
		I.qTip.start();
		
		// Temporary transfer of old named compasses
		if (localStorage["obj_utlStoredWeapons"])
		{
			localStorage["obj_utlStoredCompasses"] = localStorage["obj_utlStoredWeapons"];
		}
		if (localStorage["obj_utlStoredWeaponsWvW"])
		{
			localStorage["obj_utlStoredCompassesWvW"] = localStorage["obj_utlStoredWeaponsWvW"];
		}
	},
	
	/*
	 * Does things that need to be done after everything was initially loaded
	 * (does not count AJAX loaded content).
	 */
	initializeLast: function()
	{
		// Initializes all UI
		I.initializeTooltip();
		I.bindHelpButtons("#plateOptions");
		I.bindWindowReadjust();
		I.initializePlateMenu();
		I.initializeHUD();
		I.styleContextMenu("#mapContext");
		I.askNotifications(true);
		$("#mapHUDContainer").toggle(O.Options.bol_showHUD);
		// Bind switch map buttons
		$("#mapSwitchButton").click(function()
		{
			I.switchMap();
		});
		$("#wvwSwitchButton").click(function()
		{
			I.switchMap();
		});
		$(".mapDisplayButton").click(function()
		{
			$("#opt_bol_showPanel").trigger("click");
		});
		// Bind account button
		$("#mapAccountButton, #wvwAccountButton").one("click", function()
		{
			I.loadAccountPanel();
		}).click(function()
		{
			I.toggleAccount();
		});
		
		// Do special commands from the URL
		U.enforceURLArgumentsLast();
		// Open Chains section if on that page
		if (I.PageCurrent === I.PlateEnum.Chains)
		{
			U.openSectionFromURL();
		}
		
		// Clear the non-load warning after everything succeeded
		$("#itemWarning").remove();
		// Bind console buttons
		$("#cslClose").click(function()
		{
			I.clear();
		});
		$("#cslSelect").click(function()
		{
			I.selectConsole();
		});
		$("#cslToggle").click(function()
		{
			I.getConsole().toggle("fast");
		});
		$(".hudItem").one("mouseenter", function()
		{
			$(this).find("img").each(function()
			{
				$(this).attr("src", $(this).attr("data-src"));
			});
		});
		// Initialize the elements in the chain options popup
		$("#mapAlarmPopup").one("mouseenter", function()
		{
			I.loadImg($(this));
			K.initializeStopwatch();
			$("#optAlarmSpeaker").click(function()
			{
				D.speak(D.getWord("alarm"));
			});
			$("#optMute").click(function()
			{
				D.stopSpeech();
			});
		});
		// Make all links to other sites open a new tab
		U.convertExternalLink(".linkExternal");
		
		// Cursors on these Leaflet elements cause slowdown in IE, only add them for other browsers
		if (I.BrowserCurrent !== I.BrowserEnum.IE)
		{
			$("head").append("<style>.leaflet-clickable{cursor: url('img/cursor/pointer.cur'), pointer;}</style>");
		}
		
		// Bind browser tab focus
		$(window).focus(function()
		{
			I.isProgramFocused = true;
		}).blur(function()
		{
			I.isProgramFocused = false;
		});
		
		// Bind special popup elements that can be removed if user clicks anywhere not on it
		$(document).mouseup(function(iEvent)
		{
			$(".jsRemovable, .jsHidable").each(function()
			{
				if ( ! $(this).is(iEvent.target) && $(this).has(iEvent.target).length === 0)
				{
					if ($(this).hasClass("jsHidable"))
					{
						$(this).hide();
					}
					if ($(this).hasClass("jsRemovable"))
					{
						$(this).remove();
					}
				}
			});
		}).onEscapeKey(function()
		{
			// Handler for escape key
			if (I.isConsoleShown())
			{
				I.clear();
			}
		});
		// Stop autoscrolling if user moves the scroll wheel
		if (I.isCustomScrollEnabled)
		{
			$(document).on("ps-scroll-y", function()
			{
				I.clearAutoscroll();
			});
		}

		// Initialize scroll bars for pre-loaded plates
		if (I.isMapEnabled)
		{
			I.bindScrollbar("#cslContent, #plateDirectory, #plateChains, #plateOptions");
		}
		
		// Clean the localStorage of unrecognized variables
		O.cleanLocalStorage();
		
		// Update and notify user of version change
		O.enforceProgramVersion();
		
		// Post translations
		D.translateAfter();
		U.initializeLanguageButton();
		
		// View map event or map center
		if (P.wantTourPrediction())
		{
			$("#chnEvent_" + C.CurrentChainSD.nexus + "_"
				+ C.CurrentChainSD.CurrentPrimaryEvent.num).trigger("click");
		}
		else if (I.isMapEnabled)
		{
			// Initialize the "current moused zone" variable for showing waypoints
			M.showCurrentZone(M.getZoneCenter(M.cInitialZone));
			M.goToDefault(O.Options.int_setInitialZoom);
			if (I.ModeCurrent === I.ModeEnum.Overlay)
			{
				P.updateCharacter(0);
			}
		}
		
		// Set tile after viewing the coordinate so it downloads the tiles last
		if (I.isMapEnabled)
		{
			if (I.isProjectionEnabled)
			{
				M.toggleFloor(false);
			}
			else
			{
				if (I.PageInitial === "wvw")
				{
					$("#wvwSwitchButton").one("click", function()
					{
						M.toggleFloor(true);
					});
				}
				M.toggleFloor(true);
			}
		}
		
		// Check gem store alerts if opted
		if (O.Options.bol_alertGem)
		{
			H.updateGemSubscription();
		}
		
		// Finally
		I.isProgramLoaded = true;
	},
	
	/*
	 * Binds chains list expansion behavior.
	 */
	initializeChainsUI: function()
	{
		/*
		 * Chains list collapsible headers.
		 */
		$("#plateChains header").click(function()
		{
			var section = U.getSubstringFromHTMLID($(this));
			
			$(this).next().slideToggle("fast", function()
			{
				var headerid = $(this).attr("id");
				// Change the toggle icon after finish toggling
				if ($(this).is(":visible"))
				{
					// EXPANDED
					I.updateScrollbar();
					var container = $(I.cPlatePrefix + I.PlateEnum.Chains);
					var header = $(this).prev();
					header.find("kbd").html(I.Symbol.Collapse);
					// Automatically scroll to the clicked header
					I.scrollToElement(header, {aContainer: container, aSpeed: "fast"});
					
					// View the map at Dry Top if it is that chain list
					switch (headerid)
					{
						case "sectionChains_Drytop": 
						{
							if (I.isMapEnabled)
							{
								M.goToZone("dry", M.ZoomEnum.Bird);
								P.toggleDryTopIcons(true);
							}
							$("#mapHUDContainerInner").hide();
						} break;
						case "sectionChains_Special":
						{
							H.toggleSpecialIcons(true);
						} break;
					}
					// Update current section variable, ignore if on Scheduled section of Chains page
					I.SectionCurrent[I.PlateEnum.Chains] = (section === I.PageEnum.Chains.Scheduled) ? "" : section;
				}
				else
				{
					// COLLAPSED
					I.updateScrollbar();
					$(this).prev().find("kbd").html(I.Symbol.Expand);
					// Reset Dry Top page variable
					switch (headerid)
					{
						case "sectionChains_Drytop": 
						{
							P.toggleDryTopIcons(false);
							$("#mapHUDContainerInner").show();
						} break;
						case "sectionChains_Special":
						{
							H.toggleSpecialIcons(false);
						} break;
					}
					// Nullify current section variable
					I.SectionCurrent[I.PlateEnum.Chains] = "";
				}
				U.updateQueryString();
			});
		});
		
		// Add collapse text icon to headers; first one is pre-expanded
		$("#plateChains header:not(:first)").each(function()
		{
			$(this).next().toggle(0);
			$(this).find("kbd").html(I.Symbol.Expand);
		});
		$("#plateChains header:first").each(function()
		{
			$(this).find("kbd").html(I.Symbol.Collapse);
		});

		// Create chain bars for unscheduled chains only when manually expanded the header
		if (I.ModeCurrent === I.ModeEnum.Tile)
		{
			$("#headerChains_Drytop").hide();
			$("#sectionChains_Scheduled .chnDetails").hide();
		}
		else
		{
			$("#headerChains_Drytop").one("click", function()
			{
				P.generateDryTop();
			});
		}
		$("#headerChains_Legacy").one("click", function()
		{
			C.initializeUnscheduledChains(C.LegacyChains);
			I.readjustTile();
		});
		$("#headerChains_Temple").one("click", function()
		{
			C.initializeUnscheduledChains(C.TempleChains);
			I.readjustTile();
		});
		
		// Button to toggle the chain bar expand option
		$("#chnToggle").click(function()
		{
			$("#opt_bol_expandWB").trigger("click");
		});

		// Generate a full timetable of the chains when clicked on that header
		$("#headerChains_Timetable").one("click", function(){
			C.isTimetableGenerated = true;
			C.initializeTimetableHTML();
			I.readjustTile();
		});
		I.readjustTile();
	},
	openChainsSection: function(pSection)
	{
		// Collapse all currently expanded sections
		$("#plateChains section").each(function()
		{
			var section = U.getSubstringFromHTMLID($(this));
			if ($(this).is(":visible") && section !== pSection)
			{
				$(this).prev().trigger("click");
			}
		});
		// Expand the requested section if not already
		if (pSection)
		{
			if ($("#sectionChains_" + pSection).is(":visible") === false)
			{
				$("#headerChains_" + pSection).trigger("click");
			}
		}
	},
	
	/*
	 * Gets the console content element for appending.
	 * @returns jqobject
	 */
	getConsole: function(pWantShow)
	{
		if (pWantShow)
		{
			$("#itemConsole").show();
		}
		return $("#cslContent");
	},
	
	/*
	 * Gets the human reading duration for a string.
	 * @param string pString
	 * @param boolean pWantSeconds
	 * @returns int milliseconds
	 */
	getTextDuration: function(pString, pWantSeconds)
	{
		var characterspersecond = 18;
		var seconds = 3 + parseInt(pString.length / characterspersecond);
		return pWantSeconds ? seconds : seconds * T.cMSECONDS_IN_SECOND;
	},
	
	/*
	 * Proceeds with the browser notification permission request if user enabled
	 * the preliminary option.
	 */
	askNotifications: function(pIsInitial)
	{
		if (O.Options.bol_alertDesktop)
		{
			if (!("Notification" in window))
			{
				if (!pIsInitial)
				{
					I.write("Your browser does not seem to support desktop notifications.");
				}
			}
			else if (Notification.permission !== "denied")
			{
				Notification.requestPermission(function(permission)
				{
					if (!pIsInitial)
					{
						I.notify("This is an example of a notification you will receive.");
					}
				});
			}
		}
	},
	isNotificationsAllowed: function()
	{
		return (O.Options.bol_alertDesktop && "Notification" in window && Notification.permission === "granted");
	},
	
	/*
	 * Shows notification popup if allowed.
	 * @param string pString text content.
	 * @objparam string aTitle header.
	 * @objparam string aBody text message.
	 * @objparam string aIcon URL of image.
	 * @objparam int aDelay milliseconds before popup disappears.
	 */
	notify: function(pSettings)
	{
		if (O.Options.bol_alertConsole || I.isNotificationsAllowed())
		{
			pSettings = (typeof pSettings === "string") ? { aTitle: pSettings } : pSettings;
			var Settings = $.extend({
				aTitle: I.cSiteName,
				aBody: "",
				aIcon: "img/meta/logo_192x192.png",
				aDelay: O.Options.int_secAlertDesktop
			}, pSettings);
			Settings.aDelay *= T.cMSECONDS_IN_SECOND;
		}
		
		// Console message
		if (O.Options.bol_alertConsole)
		{
			var consoleicon = Settings.aIcon ? "<img src='" + Settings.aIcon + "' />&nbsp;" : "";
			var consolemessage = Settings.aTitle + " - " + Settings.aBody;
			I.write(consoleicon + consolemessage, O.Options.int_secAlertDesktop);
		}
		
		// Desktop popup
		if (I.isNotificationsAllowed())
		{
			// Create popup
			var notif = new Notification(Settings.aTitle, {
				icon: Settings.aIcon,
				body: Settings.aBody
			});
			// Open the originating browser tab and close the popup when clicked on
			notif.onclick = function(pEvent)
			{
				window.focus();
				this.close();
			};
			// Self close after duration
			setTimeout(notif.close.bind(notif), Settings.aDelay);
		}
	},
	
	/*
	 * Writes an HTML string to the "console" area in the top left corner of
	 * the website that disappears after a while.
	 * @param string pString to write.
	 * @param float pSeconds to display the console with that string. 0 for infinite.
	 * @param boolean pClear to empty the console before printing.
	 * @param boolean pWantBreak to insert break at the end.
	 * @pre If input was from an outside source it must be escaped first!
	 */
	write: function(pString, pSeconds, pClear, pWantBreak)
	{
		$("#itemConsole").show();
		var content = $("#cslContent").show();
		
		
		if (pString === undefined)
		{
			pString = "undefinedstring";
		}
		else if (pString === null)
		{
			pString = "nullstring";
		}
		else
		{
			pString = pString.toString();
		}
		if (pClear === undefined)
		{
			pClear = false;
		}
		if (pClear === true)
		{
			content.empty();
		}
		if (isFinite(pSeconds) === false)
		{
			pSeconds = I.getTextDuration(pString, true);
		}
		var breakstr = (pWantBreak !== false) ? "<br />" : "";
		content.append(pString + breakstr);
		I.updateScrollbar(content);
		
		// Ignore previous display time, which is how long before the console is cleared
		window.clearTimeout(I.consoleTimeout);
		// Only queue to clear the console if seconds is not set as so
		if (pSeconds !== 0)
		{
			I.consoleTimeout = setTimeout(function()
			{
				content.css({opacity: 1}).animate({opacity: 0}, 600, function()
				{
					$(this).empty().css({opacity: 1});
					$("#itemConsole").hide();
				});
			}, pSeconds * T.cMSECONDS_IN_SECOND);
		}
	},
	greet: function(pString, pSeconds, pClear)
	{
		// For messages that are shown when the program has just loaded
		if (I.isProgramEmbedded === false && I.PageInitial !== "wvw")
		{
			I.write(pString, pSeconds, pClear);
		}
	},
	
	/*
	 * Writes HTML into the console without disappearing, with fast DOM implementation.
	 * @param string pString to write.
	 * @param boolean pClear to empty the console before printing.
	 * @param boolean pWantBreak to insert break at the end.
	 */
	print: function(pString, pClear, pWantBreak)
	{
		if (pClear)
		{
			I.clear();
		}
		window.clearTimeout(I.consoleTimeout);
		var console = document.getElementById("itemConsole");
		var content = document.getElementById("cslContent");
		var breakstr = (pWantBreak !== false) ? "<br />" : "";
		console.style.display = "block";
		content.insertAdjacentHTML("beforeend", pString + breakstr);
	},
	
	/*
	 * Writes a textarea to the console that autocopies its contents.
	 * @param string pString
	 */
	paste: function(pString)
	{
		I.print("Click the box below to auto-copy:");
		$("<textarea class='cssInputText cslText'></textarea>").appendTo(I.getConsole()).val(pString);
		I.print("");
		I.bindConsoleInput();
	},
	
	/*
	 * Writes HTML into the console in a slim window format.
	 * @param string pString to write.
	 */
	help: function(pString)
	{
		I.print("<div class='cslModal cntComposition'>" + pString + "</div>", true);
		U.convertExternalLink("#cslContent a");
	},
	
	/*
	 * Prints a warning message of API retrieval failure.
	 * @param string pFeature that was failed to be retrieved.
	 * @param boolean pWantPrint so the message stays on.
	 */
	warn: function(pFeature, pWantPrint)
	{
		var msg = "Unable to retrieve " + pFeature + ". " + I.cErrorAPI;
		if (pWantPrint)
		{
			I.print(msg);
		}
		else
		{
			I.write(msg);
		}
	},
	
	/*
	 * Prints an urgent message with high visibility
	 * @param string pString
	 */
	urge: function(pString, pSeconds)
	{
		var str = "<div class='cslUrgent'>" + pString + "</div>";
		I.write(str, pSeconds, false, false);
		I.bindConsoleLink();
	},
	
	/*
	 * Clears the console of all previous text.
	 */
	clear: function()
	{
		window.clearTimeout(I.consoleTimeout);
		$("#itemConsole").hide();
		$("#cslContent").empty();
	},
	selectConsole: function()
	{
		I.selectText("#cslContent");
	},
	
	/*
	 * Alternative for print but used for testing and easier to find and remove.
	 */
	log: function(pString, pClear)
	{
		if (typeof pString === "string")
		{
			I.print(pString, pClear);
		}
		else
		{
			I.prettyJSON(pString, pClear);
		}
	},
	
	/*
	 * Prints an object in JSON format.
	 * @param object pObject.
	 */
	printJSON: function(pObject)
	{
		I.print(U.escapeJSON(pObject));
	},
	prettyJSON: function(pObject)
	{
		I.print("<pre>" + U.escapeJSON(pObject) + "</pre>");
	},
	
	/*
	 * Tells if the console is shown and autoclears it if showing.
	 * @returns boolean.
	 */
	isConsoleShown: function()
	{
		var isshown = $("#itemConsole").is(":visible");
		if (isshown)
		{
			I.clear();
		}
		return isshown;
	},
	
	/*
	 * Makes any input element in the console autoselect when clicked on.
	 */
	bindConsoleInput: function()
	{
		I.getConsole().find(".cssInputText").each(function()
		{
			I.bindClipboard($(this), $(this).val(), false);
			$(this).unbind("click").click(function()
			{
				$(this).select();
			});
		});
	},
	bindConsoleLink: function()
	{
		var links = I.getConsole().find("a");
		if (links.length)
		{
			U.convertExternalLink(links);
			U.convertInternalLink(links);
		}
	},
	
	/*
	 * Selects text from an element (as if the user clicked on text and dragged
	 * mouse to select text).
	 * @param string pSelector DOM to get the element with text.
	 */
	selectText: function(pSelector)
	{
		var element = document.querySelector(pSelector);
		var selection = window.getSelection();
		var range = document.createRange();
		range.selectNodeContents(element);
		selection.removeAllRanges();
		selection.addRange(range);
	},
	
	/*
	 * Scrolls to an element at specified rate, or the top if specified no element.
	 * @param string pElement selector to scroll to.
	 * @objparam string aContainer selector container with the scroll bar, optional.
	 * @objparam function aCallback to execute after scrolling, optional.
	 * @objparam int or string aSpeed duration to animate, optional.
	 * @objparam int aOffset from scroll point, optional.
	 */
	scrollToElement: function(pElement, pSettings)
	{
		var Settings = pSettings || {};
		
		var elm = $(pElement);
		var container;
		// Mobile mode webpage height is dynamic
		switch (I.ModeCurrent)
		{
			case I.ModeEnum.Mobile: {
				$("body").scrollTop(elm.offset().top);
			} break;
			
			case I.ModeEnum.Tile: {
				$("#windowMain").animate(
				{
					scrollTop: elm.offset().top - $("#windowMain").offset().top
						+ $("#windowMain").scrollTop()
				}, Settings.aSpeed || 0);
			} break;
			
			default: {
				Settings.aContainer = Settings.aContainer || elm.closest(".jsScrollable");
				if (Settings.aContainer)
				{
					container = $(Settings.aContainer);
					container.animate(
					{
						scrollTop: elm.offset().top - container.offset().top
							+ container.scrollTop() + (Settings.aOffset || 0)
					}, Settings.aSpeed || 0, function()
					{
						if (Settings.aCallback)
						{
							Settings.aCallback();
						}
					});
				}
				else
				{
					// Scroll to top of element without animation
					elm.scrollTop(0);
					if (Settings.aCallback)
					{
						Settings.aCallback();
					}
				}
			}
		}
	},
	
	/*
	 * Finds throbber elements (spinning icon used before AJAX content is loaded)
	 * and removes it.
	 * @param string pContainer selector.
	 */
	removeThrobber: function(pContainer)
	{
		$(pContainer).find(".itemThrobber").remove();
	},
	
	/*
	 * Gets standard HTML for displaying a small static progress bar.
	 * @param float pPercentage.
	 * @param boolean pWantRight whether to align the progress fill to the right.
	 */
	getBar: function(pPercentage, pWantRight, pWantMarker)
	{
		var percentage = (pPercentage > 100) ? 100 : pPercentage;
		return "<samp>"
			+ "<s class='" + (pWantRight ? "cssRight" : "") + "' style='width:" + percentage + "%'>"
				+ (pWantMarker ? "<mark></mark>" : "")
			+ "</s>"
		+ "</samp>";
	},
	
	/*
	 * Animates multiple elements simultaneously.
	 * @param array pRequests array of objects.
	 *	@objparam string s selector for elements.
	 *	@objparam object p properties to animate.
	 * @param int pSpeed of animation.
	 */
	bulkAnimate: function(pRequests, pSpeed)
	{
		for (var i = 0; i < pRequests.length; i++)
		{
			var r = pRequests[i];
			$(r.s).animate(r.p, {duration: pSpeed, queue: false});
		}
	},
	
	/*
	 * Toggles an HTML element.
	 * @param jqobject or string pElement
	 * @param boolean pBoolean
	 * @param string pSpeed
	 * @param boolean pIsInitial to not animate on initial call.
	 */
	toggleElement: function(pElement, pBoolean, pSpeed, pIsInitial)
	{
		var elm = $(pElement);
		if (pIsInitial)
		{
			elm.toggle(pBoolean);
		}
		else
		{
			if (pBoolean)
			{
				elm.show(pSpeed);
			}
			else
			{
				elm.hide(pSpeed);
			}
		}
	},
	
	/*
	 * Toggles the opacity of a HUD window element by toggling a CSS class.
	 * @param jqboject pElement.
	 * @param string pSuffix for getting the associated CSS class.
	 * @param boolean pBoolean.
	 * @pre CSS class was defined in the stylesheet.
	 */
	toggleHUDOpacity: function(pElement, pPrefix, pBoolean)
	{
		var elm = $(pElement);
		if (pBoolean)
		{
			elm.addClass(pPrefix + "Opaque");
			elm.removeClass(pPrefix + "OpaqueNot");
		}
		else
		{
			elm.addClass(pPrefix + "OpaqueNot");
			elm.removeClass(pPrefix + "Opaque");
		}
	},
	
	/*
	 * Toggles a standard arrowhead icon by rotating it.
	 * @param string pSelector of the element.
	 * @param boolean pBoolean true is open state, false is closed state.
	 * @param boolean pWantAnimation
	 */
	toggleToggleIcon: function(pSelector, pBoolean, pWantAnimation)
	{
		if (pWantAnimation || pWantAnimation === undefined)
		{
			if (pBoolean)
			{
				$(pSelector).animate({rotation: 0}, 200);
			}
			else
			{
				$(pSelector).animate({rotation: -90}, 200);
			}
		}
		else
		{
			if (pBoolean)
			{
				$(pSelector).css({rotation: 0});
			}
			else
			{
				$(pSelector).css({rotation: -90});
			}
		}
	},
	
	/*
	 * Shows and hides an element to create a blinking effect.
	 * @param string pSelector of the element.
	 * @param int pDuration in milliseconds.
	 * @param int pSpeed in milliseconds.
	 * @post Element is shown at the final frame.
	 */
	blinkElement: function(pSelector, pDuration, pSpeed)
	{
		var times = parseInt(pDuration / pSpeed);
		// Have to have even numbered times so show and hide equals
		times = (times % 2 === 0) ? times : times + 1;
		var isshown = true;
		var counter = 1;
		var elm = $(pSelector);
		
		var interval = setInterval(function()
		{
			if (isshown)
			{
				elm.css({visibility: "hidden"});
			}
			else
			{
				elm.css({visibility: "visible"});
			}
			isshown = !isshown;
			if (counter === times)
			{
				clearInterval(interval);
			}
			counter++;
		}, pSpeed);
	},
	bloatElement: function(pSelector, pDuration, pSpeed)
	{
		var times = parseInt(pDuration / pSpeed);
		// Have to have even numbered times so show and hide equals
		times = (times % 2 === 0) ? times : times + 1;
		var isshown = true;
		for (var i = 0; i < times; i++)
		{
			if (isshown)
			{
				$(pSelector).hide(pSpeed);
			}
			else
			{
				$(pSelector).show(pSpeed);
			}
			isshown = !isshown;
		}
	},
	
	/*
	 * Executes a callback function over time.
	 * @param int pTarget the number "animate" from 0% to 100% of its value.
	 * @param function pStep to execute.
	 * @param int pDuration milliseconds.
	 */
	animateNumber: function(pTarget, pStep, pDuration, pEasing)
	{
		$({value: 0}).animate({value: T.cPERCENT_100}, {
			duration: pDuration || 3000,
			easing: pEasing || "swing",
			step: function(pCurrentPercent) {
				pStep(pTarget * (pCurrentPercent / T.cPERCENT_100));
			}
		});
	},
	
	/*
	 * Colors the text of an element depending on its numeric value.
	 * @param jqobject pElement.
	 * @param int pValue to compare.
	 * @param int pLimit to compare.
	 */
	colorizeValue: function(pElement, pValue, pLimit)
	{
		var elm = $(pElement);
		elm.removeClass("cssLimitEqual cssLimitWithin cssLimitExceed");
		var cssclass;
		
		if (pLimit === undefined)
		{
			cssclass = (pValue > 0) ? "cssLimitWithin" : ((pValue < 0) ? "cssLimitExceed" : "cssLimitEqual");
		}
		else
		{
			cssclass = (pValue <= pLimit) ? "cssLimitWithin" : "cssLimitExceed";
		}
		elm.addClass(cssclass);
		return elm;
	},
	
	/*
	 * Toggles a generic highlight class to an element.
	 * @param jqobject pElement to toggle.
	 * @param boolean pBoolean manual.
	 * @returns boolean new highlight state.b
	 */
	toggleHighlight: function(pElement, pBoolean)
	{
		if (pBoolean === undefined)
		{
			// Toggle
			if (pElement.hasClass("cssHighlight"))
			{
				pElement.removeClass("cssHighlight");
				return false;
			}
			else
			{
				pElement.addClass("cssHighlight");
				return true;
			}
		}
		else
		{
			// Use boolean
			if (pBoolean)
			{
				pElement.addClass("cssHighlight");
				return true;
			}
			else
			{
				pElement.removeClass("cssHighlight");
				return false;
			}
		}
	},
	
	/*
	 * Makes an element unclickable and have the appearance of so.
	 * @param jqobject pElement.
	 * @param boolean pBoolean to suspend or reactivate.
	 */
	suspendElement: function(pElement, pBoolean)
	{
		if (pBoolean === undefined || pBoolean === true)
		{
			$(pElement).addClass("jsSuspended");
		}
		else
		{
			$(pElement).removeClass("jsSuspended");
		}
	},
	
	/*
	 * Styles and translates a custom context menu.
	 * @param string pMenu name of the menu.
	 */
	styleContextMenu: function(pMenu)
	{
		$(pMenu).addClass("jsHidable").find("li").each(function()
		{
			if ($(this).hasClass("jsIgnore"))
			{
				return;
			}
			// If it is a menu item
			if ($(this).hasClass("itemContextSubmenu") === false)
			{
				if (D.isLanguageDefault === false)
				{
					$(this).text(D.getPhraseOriginal($(this).text()));
				}
			}
			// If it is a label for a submenu
			else
			{
				var label = $(this).find("> span");
				label.html(D.getPhraseOriginal(label.text())).append(" <kbd>" + I.Symbol.TriRight + "</kbd>");
			}
			// Add bullet point decoration
			$(this).prepend("<ins class='s16 s16_bullet'></ins> ");
		});
		
		// Repositions the submenus when they appear outside of screen
		$(pMenu).find(".itemContextSubmenu").each(function()
		{
			$(this).mouseenter(function()
			{
				var parent = $(this);
				var submenu = $(this).find("ul").first();
				var offset = parent.offset();
				var addX = (parent.width() / 2);
				var addY = 6;
				var posX = offset.left + addX;
				var posY = offset.top;
				var width = submenu.width();
				var height = submenu.height();
				var winwidth = $(window).width();
				var winheight = $(window).height();
				var adjustX = (posX + width > winwidth) ? -(width - addX) + "px" : "50%";
				var adjustY = (posY + height > winheight) ? (winheight - (posY + height + addY)) + "px" : "auto";
				submenu.css({left: adjustX});
				submenu.css({marginTop: adjustY});
			});
		});
	},
	
	/*
	 * Shows a context menu element while respecting screen edges.
	 * @param string pID of context menu.
	 */
	showContextMenu: function(pID)
	{
		var elm = $(pID);
		var menuwidth = elm.width();
		var menuheight = elm.height();
		var winwidth = $(window).width();
		var winheight = $(window).height();
		var offsetX = 0;
		var offsetY = 0;
		var padding = 4;
		
		if (I.posX + menuwidth > winwidth)
		{
			offsetX = (I.posX + menuwidth + padding) - winwidth;
		}
		if (I.posY + menuheight > winheight)
		{
			offsetY = (I.posY + menuheight + padding) - winheight;
		}
		
		elm.css({
			top: I.posY - offsetY,
			left: I.posX - offsetX
		}).show();
	},
	
	/*
	 * Binds a search input to filter in matching keywords.
	 * @param jqobject pContainer to create search bar.
	 * @param jqobject pElements to filter.
	 * @param string pParentSelector to filter container of elements, optional.
	 * @param jqobject pHideElements to hide while results exist, optional.
	 * @param string pText search bar placeholder text.
	 * @pre Each element must have its data "keywords" assigned for the matching.
	 */
	createFilterBar: function(pContainer, pElements, pParentSelector, pHideElements, pText)
	{
		var container = $(pContainer);
		var elements = $(pElements);
		var searchbar = $("<input class='cntSearch cssInputText' type='text' />").appendTo(container);
		I.bindInputBarText(searchbar, pText);
		searchbar.on("input", $.throttle(Q.cSEARCH_LIMIT, function()
		{
			var query = $(this).val().toLowerCase();
			var queries = [];
			var keywords = "";
			var isanymatch = false;
			if (query.length > 0)
			{
				queries = query.split(" ");
				// Search for every substring in the user's query, which is space separated
				elements.each(function()
				{
					keywords = $(this).data("keywords") || $(this).val();
					var ismatch = true;
					if (keywords)
					{
						for (var i = 0; i < queries.length; i++)
						{
							// If at least one substring of the search query isn't found, then hide that item
							if (keywords.indexOf(queries[i]) === -1)
							{
								if (pParentSelector)
								{
									$(this).closest(pParentSelector).hide();
								}
								else
								{
									$(this).hide();
								}
								ismatch = false;
								break;
							}
						}
						// The boolean is only true if every substrings were found
						if (ismatch)
						{
							isanymatch = true;
							$(this).show();
						}
					}
				});
				if (isanymatch)
				{
					if (pHideElements)
					{
						$(pHideElements).hide();
					}
				}
			}
			else
			{
				elements.each(function()
				{
					if (pParentSelector)
					{
						$(this).closest(pParentSelector).show();
					}
					else
					{
						$(this).show();
					}
				});
				if (pHideElements)
				{
					$(pHideElements).show();
				}
			}
		})).click(function(pEvent)
		{
			pEvent.stopPropagation();
			$(this).select();
		});
		
		return searchbar;
	},
	
	/*
	 * Creates and binds a search bar.
	 * @param jqobject pContainer to append the search bar.
	 * @param object pSettings for the bind search function.
	 * @objparam string aBarClass class of the search bar, optional.
	 * @objparam string aBarID ID of the search bar, optional.
	 * @returns jqobject search bar.
	 */
	createSearchBar: function(pContainer, pSettings)
	{
		var Settings = pSettings || {};
		var idstr = (Settings.aBarID) ? "id='" + Settings.aBarID + "'" : "";
		var searchbar = $("<input " + idstr + " class='cntSearch cssInputText " + (Settings.aBarClass || "") + "' type='text' />").appendTo($(pContainer));
		Q.bindItemSearch(searchbar, pSettings);
		return searchbar;
	},
	
	/*
	 * Binds an input bar to have a "default text" that disappears after the user
	 * have clicked on it, but reappears after the user clears their input text.
	 * @param jqobject pInput to bind.
	 * @param string pText default.
	 */
	bindInputBarText: function(pInput, pText)
	{
		var fillertext = pText || D.getWordCapital("search") + "...";
		$(pInput).attr("placeholder", fillertext);
	},
	
	/*
	 * Makes an input autoselect its text when clicked on.
	 * @param jqobject pElement
	 * @returns jqobject
	 */
	bindInputSelect: function(pElement)
	{
		return $(pElement).click(function()
		{
			$(this).select();
		});
	},
	
	/*
	 * Stops map DOM events from interfering with an element.
	 * @param string pSelector of elements to be protected.
	 */
	preventMapPropagation: function(pSelector)
	{
		return $(pSelector).each(function()
		{
			var elm = L.DomUtil.get($(this)[0]);
			if ( ! L.Browser.touch)
			{
				L.DomEvent.disableClickPropagation(elm);
				L.DomEvent.on(elm, "mousewheel", L.DomEvent.stopPropagation);
				L.DomEvent.on(elm, "contextmenu", L.DomEvent.stopPropagation);
			}
			else
			{
				L.DomEvent.on(elm, "click", L.DomEvent.stopPropagation);
			}
		});
	},
	
	/*
	 * Binds an element for clipboard behavior.
	 * @param string or DOM element pSelector for selecting the element.
	 * @param string pText to set element's initial clipboard text, optional.
	 * @returns object Clipboard.
	 */
	bindClipboard: function(pSelector, pText, pWantMessage)
	{
		var elm = (pSelector instanceof jQuery) ? pSelector[0] : pSelector;
		var cb = new Clipboard(elm);
		var wantmessage = pWantMessage || pWantMessage === undefined;
		if (wantmessage)
		{
			cb.on("success", function(pEvent)
			{
				I.write(I.cClipboardSuccessText + pEvent.text, 5);
			});
		}
		if (pText)
		{
			I.updateClipboard(elm, pText);
		}
		return cb;
	},
	
	/*
	 * Sets the text to be copied for that clipboard element.
	 * @param string or jqobject pSelector.
	 * @param string pText to copy.
	 */
	updateClipboard: function(pSelector, pText)
	{
		$(pSelector).attr(I.cClipboardAttribute, pText);
	},
	
	/*
	 * Binds a custom scroll bar for specified element using defined settings.
	 * Container requirements: position relative, overflow hidden.
	 * @param jqobject pElement to initialize.
	 */
	bindScrollbar: function(pSelector, pWantHorizontal)
	{
		if (I.isCustomScrollEnabled)
		{
			try
			{
				var container = $(pSelector).addClass("jsScrollable");
				var wheelspeed = 1;
				switch (I.BrowserCurrent)
				{
					case I.BrowserEnum.Opera: wheelspeed = 5; break;
					case I.BrowserEnum.Firefox: wheelspeed = 3; break;
				}

				container.perfectScrollbar({
					wheelSpeed: wheelspeed,
					suppressScrollX: ((pWantHorizontal === undefined) ? true : !pWantHorizontal)
				});
				container.one("mouseenter", function()
				{
					// Show the scrollbar when hovered over the first time
					container.perfectScrollbar("update");
				});
				I.bindAutoscroll(container);
			}
			catch (e) {}
		}
	},
	
	/*
	 * Updates the scroll bar of a container.
	 * @param jqobject pElement of or container that was initialized with the scroll plugin.
	 */
	updateScrollbar: function(pElement)
	{
		if (I.isCustomScrollEnabled)
		{
			var element = $(pElement);
			if (I.isMapEnabled)
			{
				try
				{
					// Update the pages if element is not specified
					if (pElement === undefined)
					{
						$("#plateDirectory").perfectScrollbar("update");
						$("#plateChains").perfectScrollbar("update");
						$("#plateMap").perfectScrollbar("update");
						$("#plateHelp").perfectScrollbar("update");
						$("#plateOptions").perfectScrollbar("update");
					}
					else
					{
						// If the provided element is not a scroll container then find the closest parent that is
						if (element.hasClass("ps-container") === false)
						{
							element = element.closest(".ps-container");
						}
						if (element)
						{
							element.perfectScrollbar("update");
						}
					}
				}
				catch (e) {}
			}
			else
			{
				$("#windowMain").perfectScrollbar("update");
			}
		}
	},
	
	/*
	 * Binds autoscrolling functionality for a custom scrollbar initialized container.
	 * @param jqobject pContainer.
	 */
	bindAutoscroll: function(pContainer)
	{
		pContainer.mousedown(function(pEvent)
		{
			if (pEvent.which === I.ClickEnum.Middle)
			{
				clearInterval(I.Scrl.Interval);
				if (I.Scrl.isOn)
				{
					I.clearAutoscroll();
				}
				else
				{
					I.Scrl.isOn = true;
					I.Scrl.Anchor.css({
						top: I.posY,
						left: I.posX,
						backgroundImage: "url('img/cursor/autoscroll.png')"
					}).show();
					I.Scrl.posX = I.posX;
					I.Scrl.posY = I.posY;
					I.Scrl.Container = $(this);
					I.tickAutoscroll();
				}
			}
			else if (pEvent.which === I.ClickEnum.Left || pEvent.which === I.ClickEnum.Right)
			{
				if (I.Scrl.isOn)
				{
					I.clearAutoscroll();
				}
			}
		});
	},
	
	/*
	 * Hides the autoscroll anchor and stops the scrolling.
	 */
	clearAutoscroll: function()
	{
		clearInterval(I.Scrl.Interval);
		I.Scrl.isOn = false;
		I.Scrl.Anchor.hide();
	},
	
	/*
	 * Continuously scrolls the current container depending on the cursor's
	 * position away from the autoscroll anchor.
	 */
	tickAutoscroll: function()
	{
		if (I.Scrl.isOn)
		{
			I.Scrl.Interval = setInterval(function()
			{
				var mindistance = 5;
				var maxdistance = 720;
				var difference = I.posY - I.Scrl.posY;
				var initialstrength = 32;
				var strengthdispersion = 32;
				var sign = (difference < 0) ? -1 : 1;
				difference = Math.abs(difference);
				// Scroll rate function
				var scrolldistance = Math.pow(2, (difference + initialstrength) / strengthdispersion);
				// Do not scroll farther than the max distance allowed (per tick)
				if (scrolldistance > maxdistance)
				{
					scrolldistance = maxdistance;
				}
				// Begin scrolling if outside of the anchor threshold distance
				if (difference > mindistance)
				{
					I.Scrl.Container.scrollTop(I.Scrl.Container.scrollTop() + (sign * scrolldistance));
				}
			}, 50);
		};
	},
	
	/*
	 * Binds an HTML table to have its <th></th> elements clickable to sort
	 * the table's elements with "data-value" attribute initialized.
	 * @param jqobject pTable
	 * @objparam boolean aIsList whether the "table" is just one column of <li></li>, optional.
	 * @objparam int aPresortColumn 0 indexed number of column to presort, optional.
	 */
	bindSortableTable: function(pTable, pSettings)
	{
		var table = $(pTable);
		var Settings = pSettings || {};
		var islist = Settings.aIsList;
		
		var sortTable = function(pColumn, pOrder)
		{
			var sortable = [];
			// Loop every row, except the first which should be the header
			var rows = (islist) ? table.find("li") : table.find("tr");
			rows.slice(1).each(function()
			{
				var value = (islist) ? $(this).attr("data-value") : $(this).find("td:eq(" + pColumn + ")").attr("data-value");
				sortable.push({
					item: $(this),
					value: isNaN(value) ? value : parseFloat(value)
				});
			});
			U.sortObjects(sortable, {aKeyName: "value", aIsDescending: pOrder});

			for (var i = 0; i < sortable.length; i++)
			{
				(sortable[i].item).appendTo(table);
			}
		};
		
		// Bind the headers
		var column = 0;
		var headers = (islist) ? table.find("li:first") : table.find("th");
		headers.each(function()
		{
			(function(iHeader, iColumn)
			{
				iHeader.addClass("curToggle").append("&nbsp;<span class='jsSortableHeaderSymbol'>" + I.Symbol.TriDown + "</span>")
					.click(function()
				{
					I.toggleSortableHeader($(this));
					sortTable(iColumn, $(this).data("isdescending"));
				});
			})($(this), column);
			column++;
		});
		
		// Trigger click on header to presort if requested
		if (Settings.aPresortColumn)
		{
			headers.eq(Settings.aPresortColumn).trigger("click");
		}
	},
	
	/*
	 * Toggles the order symbol and boolean data value of a sortable table's header.
	 * @param jqobject pHeader to bind.
	 */
	toggleSortableHeader: function(pHeader)
	{
		var header = $(pHeader);
		// Sort and toggle the boolean
		var isdescending = header.data("isdescending");
		if (isdescending === undefined)
		{
			isdescending = false;
		}
		header.data("isdescending", !isdescending);
		// Change symbol
		var symbol = (isdescending) ? I.Symbol.TriUp : I.Symbol.TriDown;
		header.find(".jsSortableHeaderSymbol").html(symbol);
	},
	
	/*
	 * Binds headers with the jsSection class to toggle display of its sibling
	 * container element. Creates a submenu as an alternate for clicking
	 * the headers; also creates another button-like text at the bottom of the
	 * container to collapse it again.
	 * Example: <header class="jsSection">Example Title</header><div></div>
	 * That container div should contain everything that needs to be collapsed/expanded
	 * by clicking that header tag.
	 * @param string pPlate HTML ID of plate in the content pane.
	 */
	generateSectionMenu: function(pPlate)
	{
		// Don't bind unless there exists
		if ($(pPlate + " header.jsSection").length <= 0)
		{
			return;
		}
		var plate = pPlate.substring(I.cPlatePrefix.length, pPlate.length);
		
		$(pPlate + " header.jsSection").each(function()
		{
			var header = $(this);
			var section = U.getSubstringFromHTMLID($(this));
			var sectioncontent = header.next().addClass("cntSection");
			var headercontent = $(this).children("var").first();
			// Translate header if available
			var headertext = (headercontent.length && D.isLanguageDefault === false)
				? D.getModifiedPhrase(header.text().toLowerCase(), U.CaseEnum.Title) : header.text();
			headercontent.text(headertext);
			// Hide the entire collapsible div tag next to the header tag
			sectioncontent.hide();
			header.wrapInner("<span></span>");
			header.append("<sup>" + I.Symbol.Expand + "</sup>");
			
			// Bind click the header to toggle the sibling collapsible container
			header.click(function()
			{
				var istobeexpanded = false;
				if ($(this).next().is(":visible"))
				{
					// TO BE COLLAPSED
					$(this).children("sup").text(I.Symbol.Expand);
					
					I.displaySectionMarkers(section, false); // Hide this section's map icons
					I.SectionCurrent[plate] = ""; // Nullify current section variable
					
					// Show all headers again
					$(pPlate + " header.jsSection").show();
					$(pPlate + " header.cntHeader").show();
				}
				else
				{
					// TO BE EXPANDED
					istobeexpanded = true;
					$(this).children("sup").text(I.Symbol.Collapse);
					$(pPlate + " .plateBeamIcon[data-section='" + section + "']")
						.addClass("plateBeamIconActive");
					
					I.displaySectionMarkers(section, true); // Show associated map icons
					I.SectionCurrent[plate] = section;
					
					// If clicked from beam menu then hide the other headers to save space
					if ($(this).data("beamclicked") === true)
					{
						$(pPlate + " header.jsSection").not(this).hide();
						$(pPlate + " header.cntHeader").hide();
						$(this).removeData("beamclicked");
					}
					// Default the map view if the header has this CSS class
					if ($(this).hasClass("jsMapDefault"))
					{
						M.goToDefault();
					}
				}
				U.updateQueryString();
				
				// Do the collapse/expand
				if ($(this).data("donotanimate") !== true)
				{
					if (I.ModeCurrent === I.ModeEnum.Website)
					{
						$(this).next().toggle("fast", function()
						{
							I.updateScrollbar(pPlate);
						});
					}
					else
					{
						$(this).next().toggle();
						I.updateScrollbar(pPlate);
					}
				}
				else
				{
					$(this).next().toggle();
				}
				$(this).removeData("donotanimate");
				
				// Scroll to header if expanding, top of page if collapsing
				if (istobeexpanded)
				{
					I.scrollToElement($(this), {aContainer: pPlate, aSpeed: "fast", aOffset: -12});
				}
			});
			
			// Opening the section the first time will load that section's img tags
			header.one("click", function()
			{
				I.loadImg($(this).next());
			});
			
			// Create and bind the additional bottom header to collapse the container
			$("<div class='curClick jsSectionDone'><img src='img/ui/close.png' />" + headertext + "</div>")
			.appendTo(sectioncontent).click(function()
			{
				$(this).parent().prev().trigger("click");
			});
			
			/*
			 * Side menu icons as alternative for headers. Clicking an icon
			 * shows the associated header's sibling container (section) by
			 * triggering that header's handler.
			 */
			if (I.isMapEnabled || header.hasClass("mapOnly") === false)
			{
				header.find("img").attr("id", "plateBeamIcon_" + section).addClass("plateBeamIcon curClick").click(function(pEvent)
				{
					pEvent.stopPropagation();
					// Hide all the collapsible sections
					$(pPlate + " header.jsSection").each(function()
					{
						if ($(this).next().is(":visible") && $(this).attr("id") !== header.attr("id"))
						{
							// Don't animate so the scrolling to the section-to-be-opened works properly
							$(this).data("donotanimate", true);
							$(this).trigger("click");
						}
					});
					// Show the requested section
					header.data("beamclicked", true);
					header.trigger("click");
				});
			}
		});

		// Side menu icon to close all the sections
		$("<img id='plateBeamIconCollapse_" + plate + "' class='plateBeamIcon plateBeamIconCollapse curClick' src='img/ui/adjust_minus.png' "
			+ "title='&lt;dfn&gt;" + D.getPhraseTitle("collapse all section") + "&lt;/dfn&gt;' />")
		.prependTo(pPlate).click(function()
		{
			$(pPlate + " header.jsSection").each(function()
			{
				if ($(this).next().is(":visible"))
				{
					$(this).trigger("click");
				}
			});
			$(pPlate + " .plateBeamIcon").removeClass("plateBeamIconActive");
		});
		
		// Make tooltips for the beam menu icons
		I.qTip.init(pPlate + " .plateBeamIcon");
	},
	
		
	/*
	 * Shows or hides a section's map icons by triggering its toggle button.
	 * Whether the button will hide or show icons depends on its boolean data attribute.
	 * @param string pSection name.
	 * @param boolean pWantShow to show or hide its icons.
	 */
	displaySectionMarkers: function(pSection, pWantShow)
	{
		var button = $("#mapToggle_" + pSection);
		var isshown;
		var wanthideonly;
		if (button.length)
		{
			isshown = button.data("checked");
			wanthideonly = button.data("hideonly");
			
			// If toggle button only serves to hide icons
			if (wanthideonly)
			{
				if ( ! pWantShow)
				{
					button.trigger("click");
				}
			}
			// If toggle button is two-states
			else
			{
				if (pWantShow)
				{
					if ( ! isshown)
					{
						button.trigger("click");
						button.data("checked", true);
					}
				}
				else
				{
					if (isshown)
					{
						button.trigger("click");
						button.data("checked", false);
					}
				}
			}
		}
	},
	
	/*
	 * Loads a stylesheet file from the default directory.
	 * @param string pName filename without extension.
	 */
	loadStylesheet: function(pName)
	{
		if (pName === I.ModeEnum.Website)
		{
			return;
		}
		if (I.LoadedStylesheets[pName] === undefined)
		{
			$("head").append("<link rel='stylesheet' type='text/css' href='style/" + pName.toLowerCase() + ".css' />");
			I.LoadedStylesheets[pName] = true;
		}
	},
	
	/*
	 * Converts img tags with the data-src attribute to src, thereby loading the image.
	 * @param jqobject pContainer to find img tags tag.
	 */
	loadImg: function(pContainer)
	{
		var elms = (typeof pContainer === "string") ? $(pContainer) : pContainer.find("img");
		elms.each(function()
		{
			if ($(this).attr("data-src"))
			{
				$(this)[0].src = $(this).data("src");
			}
		});
	},
	
	/*
	 * Bind tooltip or expand collapsible behavior for [?] "buttons".
	 * @param string pPlate HTML ID of plate in the content pane.
	 */
	bindHelpButtons: function(pPlate)
	{
		// These buttons expand its sibling container which is initially hidden
		$(pPlate + " .jsHelpCollapsible").each(function()
		{
			$(this).text("[?+]").attr("title", "<dfn>More Info</dfn>");
			
			$(this).next().hide();
			$(this).click(function()
			{
				$(this).next().toggle();
				
				if ($(this).next().is(":visible"))
				{
					$(this).text("[?-]");
				}
				else
				{
					$(this).text("[?+]");
				}
			});
		});
		
		// These buttons show a tooltip with description when hovered
		$(pPlate + " .jsHelpTooltip").each(function()
		{
			var title = "<dfn>Info:</dfn> " + $(this).attr("title");
			$(this).text(I.Symbol.Help).attr("title", title);
		});
		
		I.qTip.init(pPlate + " .jsHelpCollapsible");
		I.qTip.init(pPlate + " .jsHelpTooltip");
	},
	
	/*
	 * Toggles the data attribute "checked state" of a button, which basically functions as a checkbox.
	 * @param jqobject pElement to bind.
	 * @returns boolean new toggled state.
	 */
	toggleButtonState: function(pElement)
	{
		var bool = !(pElement.data("checked"));
		pElement.data("checked", bool);
		return bool;
	},
	
	/*
	 * Makes an element have a checkbox change appearance behavior, but does not
	 * actually write to any checklist.
	 * @param string pSelector to bind.
	 * @param float pOpacity when the element is checked.
	 */
	bindPseudoCheckbox: function(pSelector, pOpacity)
	{
		if (pOpacity === undefined)
		{
			pOpacity = 0.3;
		}
		$(pSelector).click(function()
		{
			if ($(this).data("checked") !== true)
			{
				$(this).css({opacity: pOpacity});
				$(this).data("checked", true);
			}
			else
			{
				$(this).css({opacity: 1});
				$(this).data("checked", false);
			}
		});
	},
	
	/*
	 * Generates the front page directory on the app panel.
	 */
	initializeDirectory: function()
	{
		var dir = $("#dirContent");
		var isnondefaultlang = !D.isLanguageDefault;
		var group, groupname, groupstr, groupheader, headerclass, grouplist, pagename, pagestr, pagebutton;
		var index = 0;
		// Initialize the checklist storing which directory group was collapsed
		X.initializeChecklist(X.Checklists.Directory, U.getObjectLength(I.Directory));
		// Generate the directory groups
		for (var i in I.Directory)
		{
			group = $("<div class='dirGroup'></div>").appendTo(dir);
			groupname = i.toLowerCase();
			groupstr = ((isnondefaultlang) ? D.getWordCapital(groupname) : i);
			headerclass = (index === 0) ? "dirHeaderPrimary" : "dirHeaderSecondary curToggle";
			groupheader = $("<h2 class='dirHeader " + headerclass + "'>"
				+ "<ins class='dirHeaderIcon mnu mnu_" + groupname + "'></ins><var class='dirHeaderName'>"
				+ groupstr + "</var></h2>").appendTo(group);
			grouplist = $("<ul id='dirList_" + index + "' class='dirList'></ul>").appendTo(group);
			// Only create a dashboard container (first group) for mobile, and nothing else
			if (I.ModeCurrent === I.ModeEnum.Mobile)
			{
				break;
			}
			// Bind header collapsible behavior
			if (index !== 0)
			{
				groupheader.click(function()
				{
					var thisgrouplist = $(this).next();
					X.setChecklistItem(X.Checklists.Directory, U.getSubintegerFromHTMLID(thisgrouplist),
						thisgrouplist.is(":visible") ? X.ChecklistEnum.Checked : X.ChecklistEnum.Unchecked);
					thisgrouplist.toggle();
				});
				if (X.getChecklistItem(X.Checklists.Directory, index) === X.ChecklistEnum.Checked)
				{
					grouplist.hide();
				}
			}
			// Generate page links for this group
			for (var ii in I.Directory[i])
			{
				// Page translation
				pagename = (I.Directory[i])[ii];
				pagestr = pagename;
				if (I.DirectoryCompound[ii])
				{
					pagestr = D.getTranslation(pagename);
				}
				else if (isnondefaultlang)
				{
					pagestr = D.getModifiedPhrase(pagename.toLowerCase(), U.CaseEnum.Title);
				}
				// Page action
				pagebutton = $("<li class='curClick'>" + pagestr + "</li>").appendTo(grouplist).data("keywords", (groupstr + " " + pagestr).toLowerCase());
				(function(iPage)
				{
					pagebutton.click(function(pEvent)
					{
						if (pEvent.which === I.ClickEnum.Left)
						{
							if (I.DirectoryExternal[iPage])
							{
								U.openExternalURL(I.DirectoryExternal[iPage]);
							}
							else
							{
								U.interpretPage(iPage);
							}
						}
					});
				})(ii);
			}
			index++;
		}
		
		// First group is for dashboard and general pages
		var primaryheader = $(".dirHeaderPrimary").first();
		primaryheader.find(".dirHeaderName").addClass("curToggle").attr("id", "dirHeaderClock").click(function()
		{
			$("#opt_bol_use24Hour").trigger("click");
		});
		// Align language selector with dashboard top header
		$("#itemLanguage").appendTo(primaryheader);
		
		// Move the dashboard to a group now that the directory is generated
		if (I.ModeCurrent !== I.ModeEnum.Tile)
		{
			$("#itemDashboard").insertAfter(primaryheader);
			var search = I.createFilterBar($("<div id='dirSearch'></div>")
				.insertAfter("#dsbContainer"), ".dirGroup .curClick", null, ".dirHeaderSecondary", "Wiki...")
				.onEnterKey(function()
			{
				U.openExternalURL(U.getWikiSearchLanguage($(this).val()));
				search.val("").trigger("input");
			});
			Q.bindItemSearch(search, {
				aFillerText: null,
				aCallback: function(pItem)
				{
					Q.printItemInfo(pItem, true);
					search.val("").trigger("input");
				},
				aCancel: function()
				{
					search.val("").trigger("input");
				}
			});
		}
	},
	
	/*
	 * Menu event handlers and UI postchanges.
	 */
	initializePlateMenu: function()
	{
		/*
		 * Menu click icon to show respective content plate (page).
		 */
		$(".plateMenuButton").each(function()
		{
			$(this).click(function()
			{
				var plate = $(this).attr("id");
				$(".plateMenuButton").removeClass("plateMenuButtonActive");
				$(this).addClass("plateMenuButtonActive");
				I.PageCurrent = plate.substring(I.cPlateMenuPrefix.length - 1, plate.length);
				I.contentCurrentPlate = I.cPlatePrefix + I.PageCurrent;
				if (P.MapSwitchWebsite === P.MapEnum.Mists)
				{
					I.PagePrevious = I.PageCurrent;
				}
				switch (I.PageCurrent)
				{
					case I.PlateEnum.Directory:
					{
						if (O.Options.bol_hideHUD)
						{
							$("#mapHUDContainerInner").show();
						}
						C.isTouringManual = false;
						if (I.ModeCurrent === I.ModeEnum.Website)
						{
							// Hide any opened chains sections
							I.openChainsSection();
							// Hide any opened map sections
							$("#plateBeamIconCollapse_Map").trigger("click");
						}
					} break;
					case I.PlateEnum.Chains:
					{
						if (O.Options.bol_hideHUD)
						{
							$("#mapHUDContainerInner").show();
						}
						C.isTouringManual = false;
					} break;
					case I.PlateEnum.Map:
					{
						if (I.isMapEnabled)
						{
							M.movePin(M.Pin.Event);
						}
					} break;
				}
				$("#paneContent article").hide(); // Hide all plates
				if ((I.PageCurrent !== I.PlateEnum.Chains && I.PageCurrent !== I.PlateEnum.Directory) && O.Options.bol_hideHUD)
				{
					$("#mapHUDContainerInner").hide();
				}
				
				// App panel page animation
				if (I.isCustomScrollEnabled)
				{
					$(I.contentCurrentPlate + " .cntHeader").css({opacity: 0}).animate( // Fade page title
					{
						opacity: 1
					}, 400);
					$(I.contentCurrentPlate).animate( // Show requested page
					{
						width: "show"
					}, 200);
				}
				$(I.contentCurrentPlate).show();
				
				// Update the address bar URL with the current page name
				U.updateQueryString();
				
				// Also hide chain paths if on the map page
				if (I.isMapEnabled)
				{
					M.toggleLayer(M.ZoneCurrent.Layers.Path, P.isChainPathsAllowed());
				}
			}).one("click", K.styleClock);
		});

		/*
		 * AJAX load the separate HTML files into the content plate when user
		 * clicks on respective menu icon. Most content are not generated until
		 * the user expand a section of the content.
		*/
		// Map plate
		$(I.cPlateMenuPrefix + "Map").one("click", I.loadMapPlate);
		// Help plate
		$(I.cPlateMenuPrefix + "Help").one("click", I.loadHelpPlate);
		// Options plate
		$(I.cPlateMenuPrefix + "Options").one("click", I.loadOptionsPlate);
		
	}, // End of menu initialization
	
	/*
	 * Switches between the API continents, and update associated variables.
	 */
	switchMap: function(pPage)
	{
		// When first switching to the WvW, do initializations
		if (P.MapSwitchWebsite === P.MapEnum.Tyria && W.isWvWPrepped === false)
		{
			W.isWvWPrepped = true;
			I.loadStylesheet("wvw");
			I.loadImg("#wvwHUDPane .hudButton");
			$("#lboCurrent").append(I.cThrobber);
			/*
			 * WvW requires CSS to be loaded first before scripts execute.
			 * To know that the CSS has been loaded, a CSS property is checked,
			 * and this property must be changed here also if it was changed in
			 * the stylesheet.
			 */
			var waitForWvWStylesheet = setInterval(function()
			{
				if ($("#wvwLeaderboard").css("position") === "absolute")
				{
					window.clearInterval(waitForWvWStylesheet);
					U.getScript(U.URL_DATA.WvW, function()
					{
						W.initializeWvW(pPage);
					});
				}
			}, 100);
		}
		
		// Execute map switch
		switch (P.MapSwitchWebsite)
		{
			case P.MapEnum.Tyria: {
				$("#mapPane").hide();
				$("#wvwPane").show();
				if (W.isMapInitialized)
				{
					W.refreshMap();
				}
				I.PagePrevious = I.PageCurrent;
				I.PageCurrent = I.SpecialPageEnum.WvW;
				P.MapSwitchObject = W;
				P.MapSwitchWebsite = P.MapEnum.Mists;
				P.MapSwitchSuffix = W.OptionSuffix;
			} break;
			
			case P.MapEnum.Mists: {
				$("#wvwPane").hide();
				$("#mapPane").show();
				M.refreshMap();
				I.PageCurrent = I.PagePrevious;
				I.PagePrevious = I.SpecialPageEnum.WvW;
				P.MapSwitchObject = M;
				P.MapSwitchWebsite = P.MapEnum.Tyria;
				P.MapSwitchSuffix = M.OptionSuffix;
			} break;
		}
		U.updateQueryString();
	},
	
	/*
	 * Shows or hides the account panel.
	 */
	toggleAccount: function()
	{
		var panel = $("#panelAccount");
		var content = $("#accContent");
		if (panel.is(":visible")) // Hide
		{
			content.hide();
			A.reinitializePanel();
			panel.css({width: "100%"}).animate({width: 0}, "fast", function()
			{
				$(this).hide();
				if (I.isMapEnabled)
				{
					$("#panelMap").show();
					switch (P.MapSwitchWebsite)
					{
						case P.MapEnum.Tyria: {
							$("#mapPane").show();
							M.refreshMap();
						} break;

						case P.MapEnum.Mists: {
							$("#wvwPane").show();
							if (W.isMapInitialized)
							{
								W.refreshMap();
							}
						} break;
					}
				}
			});
			I.PageCurrent = I.PagePrevious;
			I.PagePrevious = I.SpecialPageEnum.Account;
		}
		else // Show
		{
			panel.show().css({width: 0}).animate({width: "100%"}, "fast", function()
			{
				content.show();
				A.adjustAccountPanel();
			});
			I.PagePrevious = I.PageCurrent;
			I.PageCurrent = I.SpecialPageEnum.Account;
			$("#panelMap").hide();
		}
		U.updateQueryString();
	},
	
	/*
	 * Loads the account page into its panel.
	 */
	loadAccountPanel: function(pPage)
	{
		if (A.isAccountInitialized === false && I.isAccountPanelInitialized === false)
		{
			I.isAccountPanelInitialized = true;
			I.loadStylesheet("account");
			$("#panelAccount").load(U.getPageSrc("account"), function()
			{
				U.getScript(U.URL_DATA.Account, function()
				{
					A.initializeAccount(pPage);
				});
			});
		}
	},
	
	/*
	 * Macro function for various written content added functionality. Must be
	 * run at the beginning of any load function's done block.
	 */
	bindAfterAJAXContent: function(pPlateEnum)
	{
		var plate = I.cPlatePrefix + pPlateEnum;
		I.generateSectionMenu(plate);
		if (I.isMapEnabled)
		{
			I.bindScrollbar(plate);
		}
		I.bindHelpButtons(plate);
		M.bindMapLinks(plate);
		// Open links on new window
		U.convertExternalLink(plate + " a");
		I.qTip.init("button");
		
		// Expand a header if requested in the URL
		U.openSectionFromURL();
		D.translateElements();
	},
	
	/*
	 * Loads the map HTML into the map content plate.
	 */
	loadMapPlate: function(pPage)
	{
		if (I.isMapPlateInitialized)
		{
			return;
		}
		I.isMapPlateInitialized = true;
		if (pPage)
		{
			$(I.cPlateMenuPrefix + "Map").trigger("click");
		}
		I.loadStylesheet("features");
		$("#plateMap").append(I.cThrobber).load(U.getPageSrc("map"), function()
		{
			I.bindAfterAJAXContent(I.PlateEnum.Map);
			
			// Hide map dependent sections in mobile mode
			if (I.ModeCurrent === I.ModeEnum.Mobile)
			{
				$(".mapOnly").remove();
			}
			
			// Create daily markers
			$("#headerMap_Daily").one("click", function()
			{
				G.generateAndInitializeDailies();
				I.isSectionLoaded_Daily = true;
			});
			// Create node markers and checkboxes
			$("#headerMap_Resource").one("click", function()
			{
				G.generateAndInitializeResources();
			});
			// Create JP checklist
			$("#headerMap_JP").one("click", function()
			{
				G.generateAndInitializeJPs();
			});
			// Create custom checklists
			$("#headerMap_Personal").one("click", function()
			{
				X.initializePersonalChecklist();
			});
			// Create trading calculator
			$("#headerMap_TP").one("click", function()
			{
				E.initializeCalculator();
				E.initializeTrading();
				E.initializeExchange();
			});
			// Create notepad
			$("#headerMap_Notepad").one("click", function()
			{
				X.initializeNotepad();
			});
			// Create collectible markers and checkboxes
			$("#headerMap_Collectible").one("click", function()
			{
				G.generateCollectiblesUI();
			});
			// Create guild mission subsections
			$("#headerMap_Guild").one("click", function()
			{
				G.generateGuildUI();
			});
			I.qTip.init("#plateMap label");
			
			// Open a section if initially requested
			if (typeof pPage === "string")
			{
				$("#plateBeamIcon_" + pPage).trigger("click");
			}
		});
	},
	
	/*
	 * Loads the help HTML into the help content plate.
	 */
	loadHelpPlate: function()
	{
		$("#plateHelp").append(I.cThrobber).load(U.getPageSrc("help"), function()
		{
			I.bindAfterAJAXContent(I.PlateEnum.Help);
			I.bindInputSelect(".jsCopyCode");
		});
	},
	
	/*
	 * Initializes extra features on the options page.
	 */
	loadOptionsPlate: function()
	{
		$("#plateOptions label").each(function()
		{
			$(this).data("keywords", $(this).text().toLowerCase());
		});
		I.createFilterBar("#optSearch", "#plateOptions label", null, "#plateOptions h2");
	},
	
	/*
	 * Binds Map pane special effects on HUD GUI elements.
	 */
	initializeHUD: function()
	{
		U.convertModeLink(".hudHelpColumn a");
		U.convertExternalLink(".hudHelpColumn a");
		I.bindScrollbar(".hudHelpScroll");
		$(".hudPeripheral").css({visibility: "visible"});
	},
	
	/*
	 * Shows an icon link to the main site without URL parameters.
	 */
	showHomeLink: function()
	{
		var home = $("#itemHome").css({display: "table"});
		$("<a id='itemHomeButton' title='&lt;dfn&gt;Switch back to full site.&lt;/dfn&gt;' href='./'>"
			+ " <img id='iconSimpleHome' src='img/ui/about.png' /></a>").appendTo(home);
		I.qTip.init(home);
	},
	
	/*
	 * Changes program look based on mode.
	 */
	enforceProgramMode: function()
	{
		// Projection mode is overlay mode but tailored for full view over the game
		if (I.ModeCurrent === I.ModeEnum.Projection)
		{
			var gamebuttonsheight = 32;
			I.ModeCurrent = I.ModeEnum.Overlay;
			I.isProjectionEnabled = true;
			$("#panelMap, #windowMain").css({background: "transparent"});
			$("#itemVignette").remove();
			$("#itemProjector, #prjController").show();
			// Move the timeline lower so it doesn't block the game buttons on top left
			$("#itemTimeline").css({top: gamebuttonsheight + "px"});
			// Bind special buttons
			$("#prjController").contextmenu(function(pEvent)
			{
				pEvent.preventDefault();
				var htmlidprefix = "#" + P.MapSwitchWebsite;
				I.showContextMenu(htmlidprefix + "Context");
			});
			$("#prjToggleTerrain").click(function()
			{
				P.MapSwitchObject.toggleFloor();
			});
			$("#prjToggleHUD").click(function()
			{
				$("#opt_bol_showHUD" + P.MapSwitchSuffix).trigger("click");
			});
			$("#prjTogglePanel").click(function()
			{
				$("#opt_bol_showPanel").trigger("click");
			});
			// Initialize this submode
			if (false) // Temporary disable
			{
				U.getScript(U.URL_API.ThreeDimensional, function()
				{
					J.initializeProjection();
				});
			}
		}
		
		// Load respective stylesheet
		I.loadStylesheet(I.ModeCurrent);
		
		// Structural and behavioral changes
		switch (I.ModeCurrent)
		{
			case I.ModeEnum.Website:
			{
				$("head").append("<link rel='alternate' media='only screen and (max-width: 640px)' href='https://gw2timer.com/?mode=Mobile'>");
			} break;
			case I.ModeEnum.Overlay:
			{
				I.cPANE_MENU_HEIGHT = 32;
				I.loadImg("#mapGPSIcon");
				$(".hudSelect").removeAttr("title");
				K.styleClock();
				// Manually assign F5 key browser reload functionality
				$(document.body).on("keydown", this, function (event)
				{
					if (event.keyCode === 116)
					{
						window.location.reload(true);
					}
				});
			} break;
			case I.ModeEnum.Simple:
			{
				I.isMapEnabled = false;
				I.showHomeLink();
				// Readjust panels
				$("#itemTimeline").appendTo("#panelApp");
				$("#itemLanguage").insertAfter("#itemHome");
				I.readjustSimple();
				K.styleClock();
			} break;
			case I.ModeEnum.Mobile:
			{
				I.isMapEnabled = false;
				I.isCustomScrollEnabled = false;
				I.showHomeLink();
				$("head").append("<meta name='viewport' content='width=device-width, initial-scale=1' />")
					.append("<link rel='canonical' href='https://gw2timer.com' />");
				$("#itemLanguage").insertAfter("#itemHome");
			} break;
			case I.ModeEnum.Tile:
			{
				I.isMapEnabled = false;
				H.isVertical = false;
				I.showHomeLink();
				$("#itemLanguage").prependTo("#plateChains");
				$("#itemLanguage").insertAfter("#itemHome");
				// Show the timeline if the website is not embedded
				if (I.isProgramEmbedded)
				{
					// Less whitespace for embedded window
					$("<style type='text/css'>.chnBar, .chnSlot {margin-bottom:4px !important; margin-right: 4px !important;}</style>").appendTo("head");
				}
				else
				{
					var timelinemargintop = parseInt($("#chnProgressBar").css("margin-top"));
					$("#itemTimeline").prependTo("#panelApp");
					// Move the chain progress bar to the top of the screen if scrolled past the timeline
					$("#windowMain").scroll(function(){
						if ($("#itemTimeline").is(":visible"))
						{
							$("#chnProgressBar").css("margin-top", Math.max(
								-$("#itemTimeline").outerHeight(true) + timelinemargintop,
								-$("#windowMain").scrollTop())
							);
						}
						else
						{
							$("#chnProgressBar").css("margin-top", timelinemargintop);
						}
					});
					// Dashboard
					var dashboard = $("#itemDashboard");
					var dashboardcontainer = $("<div id='dsbContainerOuter'></div>").appendTo("#plateChains");
					dashboard.appendTo(dashboardcontainer);
					$(".dsbTab").click(function()
					{
						setTimeout(function()
						{
							I.updateScrollbar("#windowMain");
							I.scrollToElement(dashboard);
						}, 600); // Time for the dashboard section to animate toggle
					});
				}
				I.bindScrollbar("#windowMain");
			} break;
		}
		if (I.isMapEnabled === false)
		{
			$("#itemDisplayButton").remove();
		}
		
		// Change CSS for overlay specific
		if (I.ModeCurrent === I.ModeEnum.Website && I.isProgramEmbedded === false)
		{
			$("#paneClockIcons img").addClass("curZoom");
		}
		else
		{
			$("#paneClockIcons img").addClass("curClick");
		}
		
		// Also streamline other UI elements if website is embedded in another website
		if (I.isProgramEmbedded)
		{
			$("#itemWarning, .hudTitle").remove();
			$(".btnSite, .hudLinks").hide();
		}
		
		// Disable dashboard for non-using modes
		if (I.ModeCurrent === I.ModeEnum.Simple)
		{
			if (I.ModeCurrent !== I.ModeEnum.Overlay)
			{
				H.isDashboardEnabled = false;
			}
		}
		
		// Set the initial plate on the app panel
		if (I.isProgramEmbedded || I.ModeCurrent === I.ModeEnum.Mobile || I.ModeCurrent === I.ModeEnum.Tile)
		{
			I.setInitialPlate(I.PlateEnum.Chains);
			if (I.isMapEnabled === false)
			{
				// Move the alarm options from the map popup to the app panel
				$("#mapAlarmPopup").appendTo("#chnAlarm").removeClass("hudPopup").addClass("cntPopup");
				I.loadImg($("#chnAlarm"));
			}
			if (I.ModeCurrent !== I.ModeEnum.Tile)
			{
				K.styleClock();
			}
		}
		else
		{
			I.setInitialPlate(I.PlateEnum.Directory);
		}
	},
	getMode: function()
	{
		return (I.isProjectionEnabled) ? I.ModeEnum.Projection : I.ModeCurrent;
	},
	setInitialPlate: function(pPlate)
	{
		// Default content plate
		I.PageCurrent = pPlate;
		$("#plate" + pPlate).show();
		$(I.cPlateMenuPrefix + pPlate).addClass("plateMenuButtonActive");
	},
	
	/*
	 * Changes appearance after program inactivity, to be called repeatedly.
	 */
	sleepOverlay: function()
	{
		if (I.isSleeping)
		{
			I.isSleeping = false;
			$(".jsSleepable, .hudPeripheral, .btnWindow").removeClass("jsSleeped");
		}
		window.clearTimeout(I.SleepTimeout);
		I.SleepTimeout = setTimeout(function()
		{
			if (!M.isMouseOnHUD && !W.isMouseOnHUD)
			{
				var filterclass = (I.isProjectionEnabled) ? ".mapDisplayButton" : "";
				I.isSleeping = true;
				$(".jsSleepable, .hudPeripheral, .btnWindow").not(filterclass).addClass("jsSleeped");
			}
		}, I.cMSECONDS_SLEEP);
	},
	
	/*
	 * Binds functions that activate when the user resizes the browser/screen/window.
	 */
	bindWindowReadjust: function()
	{
		$(window).on("resize", $.throttle(200, function()
		{
			// Resize elements' CSS properties to be more legible in the current window size
			switch (I.ModeCurrent)
			{
				case I.ModeEnum.Simple: I.readjustSimple(); break;
				case I.ModeEnum.Tile: I.readjustTile(); break;
			}
			
			// Resize elements that may have overflowed when the user resized the browser
			if (W.isWvWLoaded)
			{
				W.readjustLeaderboard();
				W.readjustLog();
			}
			if (A.isAccountInitialized)
			{
				A.adjustAccountPanel();
			}
		}));
	},
	
	/*
	 * Centers the clock in the browser window.
	 */
	readjustSimple: function()
	{
		var height = $(window).height() / 2;
		var width = $(window).width() / 2;
		var half = I.cPANE_CLOCK_HEIGHT / 2;
		$("#paneSimple").css({
			"margin-top": height - half - 72
		});
		$("#paneClock").css(
		{
			"margin-top": height - half,
			"margin-left": width - half
		});
	},
	readjustTile: function()
	{
		if (I.ModeCurrent !== I.ModeEnum.Tile)
		{
			return;
		}
		var result = T.stepFunction($(window).width(), 200, 14, 22, 1);
		$(".chnTitle h1, .chnTitle time").css({fontSize: result + "px"});
	},
	
	/*
	 * Initializes custom tooltips and sets mouse-tooltip behavior.
	 */
	initializeTooltip: function()
	{
		// Bind these tags with the title attribute for tooltip
		I.qTip.init("#mapAlarm img, a, ins, kbd, span, time, fieldset, label, input, button");
	},
	
	/*
	 * qTip tooltip plugin by Craig Erskine http://qrayg.com (modified from 2008 version)
	 */
	qTip:
	{
		name: "qTip",
		offsetX: 0,
		offsetY: 0,
		TipElm: null,
		/*
		 * Binds matched elements with title attribute to show a popup div with
		 * that title as content when hovered over the element.
		 * @param string s jQuery selector.
		 */
		start: function()
		{
			this.TipElm = document.createElement("div");
			this.TipElm.setAttribute("id", this.name);
			document.body.appendChild(this.TipElm);
			document.onmousemove = $.throttle(I.cTOOLTIP_MOUSEMOVE_MS, function(pEvent)
			{
				I.qTip.move(pEvent);
			});
		},
		init: function(pSelector)
		{
			var elm, content;
			$(pSelector).each(function()
			{
				elm = $(this)[0];
				content = elm.getAttribute("title");
				if (elm && content)
				{
					elm.setAttribute(I.cTooltipAttribute, content);
					elm.removeAttribute("title");
					elm.removeAttribute("alt");
					elm.onmouseenter = function()
					{
						I.qTip.show(this.getAttribute(I.cTooltipAttribute));
					};
					elm.onmouseleave = function()
					{
						I.qTip.hide();
					};
				}
			});
		},
		reinit: function()
		{
			$(".jsTitle").each(function()
			{
				$(this).removeClass("jsTitle");
				I.qTip.init($(this));
			});
		},
		move: function(pEvent)
		{
			if (pEvent)
			{
				I.posX = pEvent.pageX;
				I.posY = pEvent.pageY;
			}
			var tipwidth = $("#qTip").width();
			var tipheight = $("#qTip").height();
			var tipwidthplus = tipwidth + I.cTOOLTIP_OVERFLOW_ADD_X;
			var tipheightplus = tipheight + I.cTOOLTIP_OVERFLOW_ADD_Y;
			var winwidth = $(window).width();
			var winheight = $(window).height();
			
			// Mouse movement as detector for program use
			if (I.ModeCurrent === I.ModeEnum.Overlay)
			{
				I.sleepOverlay();
			}
			
			/*
			 * Make the tooltip appear within the visible window by detecting current
			 * tooltip size and mouse position.
			 */
			this.offsetX = I.cTOOLTIP_OFFSET_ADD_X;
			this.offsetY = -(tipheight + I.cTOOLTIP_OFFSET_ADD_Y);
			// Tooltip overflows top edge
			if (I.posY + this.offsetY < 0)
			{
				if (I.posY + tipheightplus < winheight)
				{
					this.offsetY = I.cTOOLTIP_OVERFLOW_ADD_Y;
				}
				else
				{
					this.offsetY = winheight - (tipheight + I.posY + I.cTOOLTIP_PADDING_ADD_Y);
				}
			}
			// Tooltip overflows right edge threshold
			if ((I.posX + tipwidthplus > winwidth) || (I.posX + I.cPANEL_WIDTH > winwidth))
			{
				// For case when window is too small and tooltip overflows left edge
				if (I.posX - tipwidthplus < 0)
				{
					this.offsetX = -I.posX;
				}
				else
				{
					this.offsetX = -tipwidthplus;
				}
			}
			
			this.TipElm.style.left = I.posX + this.offsetX + "px";
			this.TipElm.style.top = I.posY + this.offsetY + "px";
		},
		show: function(pAttributeName)
		{
			this.TipElm.innerHTML = pAttributeName;
			this.TipElm.style.display = "block";
			this.TipElm.classList.add("cssFadeIn");
			for (var i = 0; i < I.cTOOLTIP_NUM_RERENDER; i++)
			{
				I.qTip.move();
			}
		},
		hide: function()
		{
			this.TipElm.innerHTML = "";
			this.TipElm.style.display = "none";
			this.TipElm.classList.remove("cssFadeIn");
		}
	}
};

/* =============================================================
 * Executions, the order matters!
 * ============================================================= */
I.initializeFirst(); // initialize variables that need to be first
O.initializeOptions(); // load stored or default options to the HTML input
T.initializeSchedule(); // compute event data and write HTML
P.initializeMap(); // instantiate the map and populate it
K.initializeClock(); // start the clock and infinite loop
I.initializeLast(); // bind event handlers for misc written content




});//]]>// END OF JQUERY NEST