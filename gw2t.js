/*
	GW2Timer.com timer, map, and misc single-page application driver.
	jQuery-dependent (v1.11.0), with other plugins in plugins.js.
	Coded in NetBeans; debugged in Chrome Developer Tools.
	IDE recommended for viewing and collapsing code sections.
	Version: see int_utlProgramVersion - 2014.04.18 created

	LIBRARIES:
	Below are inline libraries, for the rest, see http://gw2timer.com/plugins.js
	Vladimir Agafonkin - LeafletJS map library
	Craig Erskine - qTip tooltip
	David Flanagan - SVG clock based on example from "JavaScript The Definitive Guide 6e"
	Cliff Spradlin - GW2 API Documentation
	Google, ResponsiveVoice.JS, and meSpeak.js - Text-To-Speech service and engine

	CONVENTIONS:
	Local variables are all lower case: examplevariable.
	Instance variables are lower camel case: exampleVariable.
	Global variables are all caps spaced by underscore: EXAMPLE_VARIABLE.
	Constants are camel case and starts with "c": cExampleVariable.
	Objects are camel case: ExampleObject.
	Array names are plural (end with s or es): exampleElements.
	Functions are lower camel case and starts with a verb: getExample().
	~~ operator (reverse bits twice) is shorthand for parseInt and is used in integer division.
	Functions that are repeated in milliseconds should use core JS instead of jQuery.
	Arguments in double quotes: $("argument"), single quotes for HTML generation.
	Parameters are camel case and start with "p": function(pExampleParameter).
	Settings inside an object used as a function argument starts with "a", like parameters.
	Properties of returned template objects start with "o", like parameters.
	Parameters inside loops start with "i": forEach(function(iExampleParameter){}).
	CSS classes and IDs are named like instance variables: exampleID.
	Allman indentation (braces align vertically) unless it is repetitive code.
	4 space-size tabs, you are free to Replace All tab characters with spaces.

	TABLE OF CONTENTS (Ctrl+F "AtsignAtsignLetter" to jump to section)

	O - Options for user
	X - Checklists
	U - URL management
	Z - Console commands
	A - Account management
	V - View account information
	B - Bank generation
	Q - Quantity items
	E - Economy Trading Post
	D - Dictionary for translations
	C - Chains events
	M - Map Leaflet
	P - Populate map and GPS
	G - Generated map page content
	W - World vs World
	J - 3D overlay projection
	T - Time utilities and schedule
	H - Dashboard and timeline
	K - Clock ticker
	I - Interface UI

*/

$(window).on("load", function() { "use strict";

/* =============================================================================
 * Single letter objects serve as namespaces.
 * ========================================================================== */
var A, B, C, D, E, G, H, I, J, K, M, O, P, Q, T, U, V, W, X, Z;

O = {
/* =============================================================================
 * @@Options for the user
 * ========================================================================== */

	cLengthOfPrefixes: 3,
	cPrefixOption: "opt_",
	cPrefixLabel: "lbl_",
	legalLocalStorageKeys: {},
	isServerReset: false,

	/*
	 * These utility variables will also be stored in localStorage.
	 * O.Utilities, O.Options, and X.Checklists/Textlists share a namespace in
	 * localStorage and must together have unique variable names.
	 */
	Utilities:
	{
		programVersion: {key: "int_utlProgramVersion", value: 170527},
		buildVersion: {key: "int_utlBuildVersion", value: 0},
		timestampDaily: {key: "int_utlTimestampDaily", value: 0},
		timestampWeekly: {key: "int_utlTimestampWeekly", value: 0},
		APITokens: {key: "obj_utlAPITokens", value: []},
		APICache: {key: "obj_utlAPICache", value: {}},
		AuditHistory: {key: "obj_utlAuditHistory", value: {}},
		CustomCatalog: {key: "obj_utlCustomCatalog", value: []},
		GemSubscription: {key: "obj_utlGemSubscription", value: {}},
		BackupPins: {key: "obj_utlBackupPins", value: []},
		BackupPinsWvW: {key: "obj_utlBackupPinsWvW", value: []},
		BackupCompasses: {key: "obj_utlBackupCompasses", value: []},
		BackupCompassesWvW: {key: "obj_utlBackupCompassesWvW", value: []},
		StoredPins: {key: "obj_utlStoredPins", value: []},
		StoredPinsWvW: {key: "obj_utlStoredPinsWvW", value: []},
		StoredCompasses: {key: "obj_utlStoredCompasses", value: []},
		StoredCompassesWvW: {key: "obj_utlStoredCompassesWvW", value: []}
	},
	
	/*
	 * Updates and notifies user of version change.
	 */
	enforceProgramVersion: function()
	{
		var currentversion = O.Utilities.programVersion.value;
		var usersversion = parseInt(localStorage[O.Utilities.programVersion.key]);
		// If is a major version, not first visit, and version is mismatch, then notify new version
		if (isFinite(usersversion) && usersversion !== currentversion)
		{
			var wait = (I.ModeCurrent === I.ModeEnum.Overlay) ? 15 : 30;
			I.clear();
			I.greet(I.cSiteName + " was updated since your last visit.<br />"
				+ "This version: " + currentversion + "<br />"
				+ "Your version: " + usersversion + "<br />"
				+ "Would you like to see the <a class='urlUpdates' href='" + U.URL_META.News + "'>changes</a>?<br />", wait);
			U.convertExternalLink(".urlUpdates");
		}
		
		localStorage[O.Utilities.programVersion.key] = O.Utilities.programVersion.value;
	},
	
	/*
	 * Checks the game build ID API to alert when a new patch is released.
	 */
	enforceBuildVersion: function()
	{
		$.getJSON(U.URL_API.Build, function(pData)
		{
			if (pData && pData.id)
			{
				var key = O.Utilities.buildVersion.key;
				var valA = parseInt(pData.id);
				var valB = localStorage[key];
				O.Utilities.buildVersion.value = valA;
				if (valB !== undefined && parseInt(valB) !== valA)
				{
					var message = "New game build available";
					I.print("<a" + U.convertExternalAnchor(U.URL_META.BuildNotes) + ">" + message + "!</a> "
						+ "GW2 Build ID: " + valA + " " + I.Symbol.ArrowLeft + " " + valB + " Diff: " + (valA - parseInt(valB)) + "<br />"
						+ T.formatWeektime(new Date(), true) + " - <a href='./?bol_alertBuild=false'>Turn off patch alarm?</a>");
					D.speak("Alert! " + message);
					localStorage[key] = valA;
				}
				else if (valB === undefined || parseInt(valB) !== valA)
				{
					localStorage[key] = valA;
				}
			}
		});
	},
	
	/*
	 * All of these URL overridable options should have an associated input tag
	 * in the HTML that users interact with, and their IDs are in the form
	 * prefixOption + optionkey, where prefix is the option's data type.
	 * "str_" and "int_num" are protected from URL override.
	 */
	Options:
	{
		// Enumeration is an exception, being set by URL or special functions only
		enu_Language: "en",
		enu_Server: "1008",
		// Timer
		bol_showSecondHand: true,
		bol_hideChecked: false,
		bol_expandWB: true,
		bol_collapseChains: true,
		int_setClock: 0,
		int_setDimming: 0,
		int_setPredictor: 0,
		// Panel
		bol_alignPanelRight: true,
		bol_ignoreTouch: false,
		bol_showPanel: true,
		bol_showHUD: true,
		bol_showHUDWvW: true,
		bol_showDashboard: true,
		bol_showTimeline: true,
		bol_opaqueTimeline: false,
		bol_condenseTimelineLine: true,
		bol_condenseTimelineHeader: true,
		bol_hideHUD: true,
		// Map
		int_setFloor: 1,
		int_setFloorWvW: 1,
		int_setInitialZoom: 3,
		int_setInitialZoomWvW: 4,
		bol_showCoordinatesBar: true,
		bol_showZoneBorders: false,
		bol_showZoneGateways: false,
		bol_showChainPaths: true,
		bol_tourPrediction: true,
		bol_showWorldCompletion: false,
		bol_showZoneOverview: true,
		bol_displaySectors: true,
		bol_displayWaypoints: true,
		bol_displayPOIs: true,
		bol_displayVistas: true,
		bol_displayChallenges: true,
		bol_displayMasteries: true,
		bol_displayHearts: true,
		bol_displayHeartsArea: false,
		bol_displaySectorsArea: false,
		bol_displayEvents: false,
		bol_showWorldCompletionWvW: false,
		bol_showZoneOverviewWvW: true,
		bol_displaySectorsWvW: true,
		bol_displayWaypointsWvW: true,
		bol_displayPOIsWvW: true,
		bol_displayVistasWvW: true,
		bol_displayChallengesWvW: true,
		str_colorPersonalPath: "#ffffff",
		int_opacityPersonalPath: 40,
		// WvW
		int_secWvWRefresh: 10,
		int_numLogEntries: 128,
		bol_showLog: true,
		bol_opaqueLog: false,
		bol_maximizeLog: false,
		bol_logRedHome: true,
		bol_logBlueHome: true,
		bol_logGreenHome: true,
		bol_logCenter: true,
		bol_logNarrate: false,
		bol_narrateRedHome: true,
		bol_narrateBlueHome: true,
		bol_narrateGreenHome: true,
		bol_narrateCenter: true,
		bol_narrateClaimed: false,
		bol_narrateRuins: false,
		bol_narrateCamp: true,
		bol_narrateTower: true,
		bol_narrateKeep: true,
		bol_narrateCastle: true,
		bol_showLeaderboard: true,
		bol_opaqueLeaderboard: false,
		bol_condenseLeaderboard: false,
		bol_showDestructibles: false,
		bol_showObjectiveLabels: true,
		bol_showSecondaries: false,
		// GPS
		int_setFollow: 1,
		bol_displayCharacter: true,
		int_setFollowWvW: 2,
		bol_displayCharacterWvW: true,
		int_msecGPSRefresh: 50,
		// Alarm
		int_setAlarm: 0,
		int_setVolume: 75,
		bol_alertArrival: true,
		bol_alertAtStart: true,
		bol_alertAtEnd: true,
		bol_alertChecked: false,
		int_alertSubscribedFirst: 1,
		int_alertSubscribedSecond: 15,
		bol_alertAutosubscribe: true,
		bol_alertUnsubscribe: true,
		bol_alertBuild: false,
		bol_alertDaylight: false,
		bol_alertMystic: false,
		bol_alertGem: false,
		// Account
		bol_showRarity: false,
		bol_condenseBank: false,
		bol_auditTransactions: true,
		bol_auditVault: true,
		bol_auditAccountOnReset: false,
		bol_auditHistoryConverted: false,
		int_numAuditReports: 1024,
		// Trading
		bol_refreshPrices: true,
		int_numTradingCalculators: 25,
		int_numTradingResults: 50,
		int_secTradingRefresh: 60,
		// Tools
		int_minStopwatchAlert: 5,
		str_textStopwatchAlert: "Alert, alert, alert!",
		int_sizeStopwatchFont: 64,
		int_sizeNotepadFont: 12,
		int_sizeNotepadHeight: 400,
		// Daily
		bol_clearChainChecklistOnReset: true,
		bol_clearPersonalChecklistOnReset: true,
		int_numChecklistDaily: 12,
		int_numChecklistWeekly: 12,
		// Advanced
		bol_use24Hour: true,
		bol_detectDST: true,
		bol_useSiteTag: true
	},
	/*
	 * All Options of a numeric type must have an associated legal range to be
	 * used in sanitation of user submitted ones. This object is updated by the
	 * function O.initializeOptions() that initializes HTML input tags.
	 */
	OptionRange: {},
	LanguageMeta:
	{
		ISOCode:
		{
			// This enum corresponds to the language enum and is used for Google TTS
			en: "en-US",
			de: "de-DE",
			es: "es-ES",
			fr: "fr-FR",
			cs: "cs-CZ", // Unsupported
			it: "it-IT",
			pl: "pl-PL", // Unsupported
			pt: "pt-BR", // Unsupported
			ru: "ru-RU", // Unsupported
			zh: "zh-CN",
			tw: "zh-CN"
		},
		VoiceCode:
		{
			// This enum corresponds to the voices available from window.speechSynthesis.getVoices() array
			en: "Google US English",
			de: "Google Deutsch",
			es: "Google español",
			fr: "Google français",
			cs: "native",
			it: "Google italiano",
			pl: "Google polski",
			pt: "Google português do Brasil",
			ru: "Google русский",
			zh: "Google 國語（臺灣）",
			tw: "Google 國語（臺灣）"
		},
		isFullySupported:
		{
			en: true,
			es: true,
			fr: true,
			de: true
		},
		isModifierFirst:
		{
			// If adjective-noun or adverb-verb modifier is before the modified
			en: true,
			de: true,
			cs: true,
			pl: true,
			ru: true
		},
		isLogographic:
		{
			// If logograms instead of letters
			zh: true,
			tw: true
		}
	},
	/*
	 * All Options of an enumerated type ("enu") must have a matching named
	 * object of enums here.
	 */
	OptionEnum:
	{
		Language:
		{
			Default: "en",
			English: "en",
			German: "de",
			Spanish: "es",
			French: "fr",
			Czech: "cs",
			Italian: "it",
			Polish: "pl",
			Portuguese: "pt",
			Russian: "ru",
			ChineseSimplified: "zh",
			ChineseTraditional: "tw"
		},
		Server:
		{
			AnvilRock: "1001",
			BorlisPass: "1002",
			YaksBend: "1003",
			HengeofDenravi: "1004",
			Maguuma: "1005",
			SorrowsFurnace: "1006",
			GateofMadness: "1007",
			JadeQuarry: "1008",
			FortAspenwood: "1009",
			EhmryBay: "1010",
			StormbluffIsle: "1011",
			Darkhaven: "1012",
			SanctumofRall: "1013",
			CrystalDesert: "1014",
			IsleofJanthir: "1015",
			SeaofSorrows: "1016",
			TarnishedCoast: "1017",
			NorthernShiverpeaks: "1018",
			Blackgate: "1019",
			FergusonsCrossing: "1020",
			Dragonbrand: "1021",
			Kaineng: "1022",
			DevonasRest: "1023",
			EredonTerrace: "1024",
			FissureofWoe: "2001",
			Desolation: "2002",
			Gandara: "2003",
			Blacktide: "2004",
			RingofFire: "2005",
			Underworld: "2006",
			FarShiverpeaks: "2007",
			WhitesideRidge: "2008",
			RuinsofSurmia: "2009",
			SeafarersRest: "2010",
			Vabbi: "2011",
			PikenSquare: "2012",
			AuroraGlade: "2013",
			GunnarsHold: "2014",
			JadeSea: "2101",
			FortRanik: "2102",
			AuguryRock: "2103",
			VizunahSquare: "2104",
			Arborstone: "2105",
			Kodash: "2201",
			Riverside: "2202",
			ElonaReach: "2203",
			AbaddonsMouth: "2204",
			DrakkarLake: "2205",
			MillersSound: "2206",
			Dzagonur: "2207",
			BaruchBay: "2301"
		}
	},
	/*
	 * These enums correspond to radio buttons.
	 */
	IntEnum:
	{
		Predictor:
		{
			Auto: 0,
			Min: 1,
			MinAvg: 2,
			Avg: 3
		},
		Clock:
		{
			Compact: 0,
			Full: 1,
			Bar: 2,
			None: 3
		},
		Alarm:
		{
			Off: 0,
			Checklist: 1,
			Subscription: 2
		},
		Follow:
		{
			Off: 0,
			Character: 1,
			Zone: 2
		}
	},
	
	/*
	 * Checks if the specified value is in the enum object, and returns it
	 * if found, or returns the default if not.
	 * @param string pEnumName of the enum object.
	 * @param string pEnumValue to check.
	 * @returns string valid enum or the default.
	 */
	validateEnum: function(pEnumName, pValue)
	{
		var i;
		var enumobject = O.OptionEnum[U.getVariableSuffix(pEnumName)];
		for (i in enumobject)
		{
			if (enumobject[i] === pValue)
			{
				return pValue;
			}
		}
		return O.Options[pEnumName];
	},
	
	/*
	 * Initializes the associative array of strings of legal localStorage
	 * variable keys so other functions can erase all unrecognized variables.
	 * @pre All legal variable keys are unique.
	 */
	initializeLegalLocalStorageKeys: function()
	{
		var i;
		for (i in O.Utilities)
		{
			O.legalLocalStorageKeys[O.Utilities[i].key] = true;
		}
		for (i in O.Options)
		{
			O.legalLocalStorageKeys[i] = true;
		}
		for (i in X.Checklists)
		{
			O.legalLocalStorageKeys[X.Checklists[i].key] = true;
		}
		for (i in X.Collectibles)
		{
			O.legalLocalStorageKeys[X.Collectibles[i].key] = true;
		}
		for (i in X.Textlists)
		{
			O.legalLocalStorageKeys[X.Textlists[i].key] = true;
		}
	},
	
	/*
	 * Checks localStorage for unrecognized variables and removes them.
	 */
	cleanLocalStorage: function()
	{
		var key;
		for (var i = 0; i < localStorage.length; i++)
		{
			key = localStorage.key(i);
			if (O.legalLocalStorageKeys[key] === undefined)
			{
				localStorage.removeItem(key);
			}
		}
	},
	
	/*
	 * localStorage stores everything as string. This function converts the
	 * data back to the proper type.
	 * @param string pString localStorage value.
	 * @returns proper type of value.
	 */
	convertLocalStorageDataType: function(pString)
	{
		var s = pString.toLowerCase();
		if (s === "true")
		{
			return true;
		}
		if (s === "false")
		{
			return false;
		}
		if (isFinite(s)) // Is a number
		{
			if (s % 0 === 0) // Integer shouldn't have a remainder
			{
				return parseInt(s);
			}
			return parseFloat(s);
		}
		return pString;
	},
	
	/*
	 * Loads a compressed JSON object from localStorage.
	 * @param string pKey name of storage entry.
	 * @returns object that was parsed.
	 */
	loadCompressedObject: function(pKey)
	{
		var obj = localStorage[pKey];
		if (obj)
		{
			// See if the string is already an uncompressed object (legacy code)
			try
			{
				return JSON.parse(obj);
			}
			catch (e)
			{
				try
				{
					return JSON.parse(LZString.decompressFromUTF16(obj));
				}
				catch (e) {}
			}
		}
		return null;
	},
	saveCompressedObject: function(pKey, pObject)
	{
		localStorage[pKey] = LZString.compressToUTF16(JSON.stringify(pObject));
	},
	
	/*
	 * Loads a stored timestamp if it exists, is a number, and not from the
	 * future, else initializes it.
	 * @param object pTimestamp from options' Utilities object.
	 */
	initializeTimestamp: function(pTimestamp)
	{
		var currenttimestamp = T.getUNIXSeconds();
		var storedtimestamp = parseInt(localStorage[pTimestamp.key]);
		if (localStorage[pTimestamp.key] === undefined
			|| isFinite(storedtimestamp) === false
			|| storedtimestamp > currenttimestamp)
		{
			pTimestamp.value = currenttimestamp;
			localStorage[pTimestamp.key] = pTimestamp.value;
		}
		else
		{
			pTimestamp.value = storedtimestamp;
		}
	},
	
	/*
	 * Sets a timestamp to the current time.
	 * @param object pTimestamp from options' Utilities object
	 */
	updateResetTimestamp: function(pTimestamp)
	{
		pTimestamp.value = T.getUNIXSeconds();
		localStorage[pTimestamp.key] = pTimestamp.value;
	},
	
	/*
	 * Checks if the reset timestamps expired or is expiring, and do clearings if so.
	 * @param Date pDate.
	 */
	checkResetTimestamps: function()
	{
		// Initialize time values
		var currenttimestamp = T.getUNIXSeconds();
		var secondssincemidnight = T.getTimeSinceMidnight();
		var secondssinceweekstart = T.getSecondsSinceWeekstart(secondssincemidnight);
		// Get yesterday's reset timestamp
		var yesterdaysresettime = currenttimestamp - secondssincemidnight;
		// Get last week's reset timestamp
		var lastweeksresettime = (secondssinceweekstart > T.cWEEKLY_RESET_SECONDS) ?
			(currenttimestamp - (secondssinceweekstart - T.cWEEKLY_RESET_SECONDS)) :
			((currenttimestamp - T.cSECONDS_IN_WEEK) + (T.cWEEKLY_RESET_SECONDS - secondssinceweekstart));
		// If the reset happens while the program is running
		var isdailyreset = (secondssincemidnight === 0);
		var isweeklyreset = (secondssinceweekstart === T.cWEEKLY_RESET_SECONDS);
		
		// Execute clear functions if the timestamp expired or on exact reset time
		if (O.Utilities.timestampDaily.value < yesterdaysresettime || isdailyreset)
		{
			O.clearDailySensitiveOptions(isdailyreset);
			O.updateResetTimestamp(O.Utilities.timestampDaily);
		}
		if (O.Utilities.timestampWeekly.value < lastweeksresettime || isweeklyreset)
		{
			O.clearWeeklySensitiveOptions(isweeklyreset);
			O.updateResetTimestamp(O.Utilities.timestampWeekly);
		}
		
		// Update reset Date objects
		var secondstoday = T.getUNIXSeconds() - secondssincemidnight;
		var secondstomorrow = secondstoday + T.cSECONDS_IN_DAY;
		T.ResetToday = new Date(secondstoday * T.cMSECONDS_IN_SECOND);
		T.ResetTomorrow = new Date(secondstomorrow * T.cMSECONDS_IN_SECOND);
		$("#optTimestampLocalReset").text(O.Utilities.timestampDaily.value);
		$("#optTimestampServerReset").text(secondstomorrow);
	},
	
	/*
	 * Gets the index of a checked radio button within a fieldset of radio buttons.
	 * @pre Radio buttons are inside a fieldset with the same "name" attribute.
	 * @returns int 0-based index of radio button.
	 */
	getIndexOfSelectedRadioButton: function(pName)
	{
		var radiobuttons = $("fieldset[name=" + pName + "] " + "input:radio[name=" + pName + "]");
		return radiobuttons.index(radiobuttons.filter(":checked"));
	},
	
	/*
	 * Sets the HTML input tag values to the localStorage's or the defaults here.
	 * URLArguments with same Options object's keys (if available) will override both.
	 * @pre The tags are preloaded (not AJAX) and URLArguments was initialized.
	 */
	initializeOptions: function()
	{
		O.initializeLegalLocalStorageKeys();

		var optionkey;
		var inputtype;
		var inputelm;
		
		var isURLOptionLegal = function(pOptionKey)
		{
			if (U.Args[pOptionKey] !== undefined
				&& pOptionKey.lastIndexOf("int_num", 0) !== 0
				&& pOptionKey.lastIndexOf("str_", 0) !== 0)
			{
				return true;
			}
			return false;
		};
		
		// Load or initialize input options
		for (optionkey in O.Options)
		{
			inputelm = $("#" + O.cPrefixOption + optionkey);
			inputtype = inputelm.attr("type");
			
			/*
			 * Initialize legal numeric values by looking up the associated
			 * input tag.
			 */
			if (inputtype === "radio")
			{
				// Range shall be 0 to how many radio buttons there are minus one
				O.OptionRange[optionkey] = new Array(0, $("fieldset[name=" + optionkey + "] input").length - 1);
			}
			else if (inputtype === "number" || inputtype === "range")
			{
				O.OptionRange[optionkey] = new Array(inputelm.prop("min"), inputelm.prop("max"));
			}
			else if (inputtype === "checkbox")
			{
				// Custom checkbox image
				X.wrapCheckbox(inputelm);
			}
			
			/*
			 * URLArguments overrides localStorage, which overrides Options here
			 * only if such an Options variable exists. If program is embedded
			 * then URLArguments overrides Options only, and user preferences
			 * (localStorage) will not modified. Strings may not be overriden by URL.
			 */
			if (I.isProgramEmbedded)
			{
				// Use stored options if self embedded
				if (I.isProgramExternal === false)
				{
					if (localStorage[optionkey] !== undefined)
					{
						O.Options[optionkey] = O.convertLocalStorageDataType(localStorage[optionkey]);
					}
				}
				
				// URL options override localStorage, but do not overwrite
				if (isURLOptionLegal(optionkey))
				{
					O.Options[optionkey] = O.convertLocalStorageDataType(U.sanitizeURLOptionsValue(optionkey, U.Args[optionkey]));
				}
			}
			else
			{
				// Overwrite localStorage with URL's options if available
				if (isURLOptionLegal(optionkey))
				{
					localStorage[optionkey] = U.sanitizeURLOptionsValue(optionkey, U.Args[optionkey]);
				}
				
				// Assign default values to localStorage if they are empty
				if (localStorage[optionkey] === undefined)
				{
					localStorage[optionkey] = O.Options[optionkey];
				}
				// Else user set options from localStorage become the new options
				else
				{
					O.Options[optionkey] = O.convertLocalStorageDataType(localStorage[optionkey]);
				}
			}
			
			// Assign the retrieved values to the input tags
			O.setInputValue(inputelm, O.Options[optionkey]);

			/*
			 * Bind simple event handlers to each input tags that writes
			 * the value of the input to the options and localStorage.
			 * Note that the optionkey local variable was not reused here
			 * because this is the scope of the input's event! Have to use
			 * separate variables.
			 */
			if (inputtype === "radio")
			{
				/*
				 * Radio buttons are a special case because they are multiple
				 * input tags. They must be wrapped in a fieldset and all be
				 * given the same name attribute. One button shall hold the
				 * unique ID so the group will only be iterated once.
				 */
				$("fieldset[name=" + optionkey + "]").change(function()
				{
					var thisoptionkey = $(this).attr("name");
					O.Options[thisoptionkey] = O.getIndexOfSelectedRadioButton(thisoptionkey);
					localStorage[thisoptionkey] = O.Options[thisoptionkey];
				});
			}
			else
			{
				inputelm.change(function()
				{
					var thisoptionkey = $(this).attr("id").slice(O.cPrefixOption.length);
					O.Options[thisoptionkey] = O.getInputValue($(this), thisoptionkey);
					localStorage[thisoptionkey] = O.Options[thisoptionkey];
				}).click(function()
				{
					$(this).select();
				});
			}
		}
		
		// Supplementary event handlers for some inputs
		// Temporarily disabled
		/*I.isTouchEnabled = ((typeof window.ontouchstart !== "undefined")
			&& O.Options.bol_ignoreTouch === false
			&& I.ModeCurrent !== I.ModeEnum.Overlay
		);*/
		O.bindOptionsInputs();
		D.initializeLanguage();
	},
	
	/*
	 * Sets the value of an input tag.
	 * @param string pInput to read.
	 * @param polymorphic pValue.
	 */
	setInputValue: function(pInput, pValue)
	{
		var inputelm = $(pInput);
		var inputtype = inputelm.attr("type");

		// Assign the retrieved values to the cloned input
		if (inputtype === "checkbox")
		{
			inputelm.prop("checked", pValue);
		}
		else if (inputtype === "number" || inputtype === "range")
		{
			inputelm.val(pValue);
		}
		else if (inputtype === "radio")
		{
			// Check the radio button of that index (int)
			$("input:radio[name=" + inputelm.attr("name") + "]:eq(" + pValue + ")")
				.prop("checked", true);
		}
		else
		{
			inputelm.val(pValue);
		}
	},
	
	/*
	 * Gets the value of an input tag.
	 * @param string pInput to read.
	 * @param string pOptionKey name of an option for range validation.
	 */
	getInputValue: function(pInput, pOptionKey)
	{
		var inputelm = $(pInput);
		var inputtype = inputelm.attr("type");
		var value;

		if (inputtype === "checkbox")
		{
			value = inputelm.prop("checked");
		}
		else if (inputtype === "number" || inputtype === "range")
		{
			// These inputs can have custom text, so sanitize them first
			var value = inputelm.val();
			var integer = parseInt(value);
			if (isFinite(value) && integer >= O.OptionRange[pOptionKey][0]
				&& integer <= O.OptionRange[pOptionKey][1])
			{
				value = integer;
			}
			else
			{
				// Load default value if not an integer within range
				value = O.OptionRange[pOptionKey][0];
			}
			inputelm.val(value);
		}
		else if (inputtype === "text")
		{
			value = inputelm.val();
			var maxlength = inputelm.attr("maxlength");
			if (value.length > maxlength)
			{
				value = value.substring(0, maxlength);
			}
		}
		else
		{
			value = inputelm.val();
		}

		return value;
	},
	
	/*
	 * Makes an input tag behave the same as an Options input tag.
	 * @param jqobject pCloneInput input tag.
	 * @param string pOptionKey name of an option.
	 */
	mimicInput: function(pCloneInput, pOptionKey)
	{
		var inputclone = $(pCloneInput);
		// Initialize the value of the clone
		O.setInputValue(inputclone, O.Options[pOptionKey]);
		
		// If the cloned input value has changed then mimic that to the original
		var inputelm = $("#" + O.cPrefixOption + pOptionKey);
		inputclone.change(function()
		{
			var value = O.getInputValue($(this), pOptionKey);
			O.setInputValue(inputelm, value);
			inputelm.trigger("change");
		});
		// If the original input value has changed, then superficially change the cloned input
		inputelm.change(function()
		{
			O.setInputValue(inputclone, O.Options[pOptionKey]);
		});
		return inputclone;
	},
	
	/*
	 * Unchecks the time sensitive checklists and clear variables, ignoring
	 * the disabled/deleted ones by the user.
	 * @param boolean pIsDaily whether the program was running during reset.
	 */
	clearDailySensitiveOptions: function(pIsDuring)
	{
		O.isServerReset = true;
		// Notify of the reset in console
		var messagetime = 5;
		var dailymessage = pIsDuring ? "Daily Reset!" : "Expired daily checklists cleared.";
		// Update the daily object
		T.getDaily({aIsReset: true});
		
		// Chains checklist
		var i;
		var chain;
		if (O.Options.bol_clearChainChecklistOnReset)
		{
			I.greet(dailymessage, messagetime);
			for (i in C.Chains)
			{
				chain = C.Chains[i];
				$("#chnCheck_" + chain.nexus).removeClass("chnChecked");
				$("#chnBar_" + chain.nexus).removeClass("chnFaded");
				if (X.getChecklistItem(X.Checklists.Chain, chain.nexus) !== X.ChecklistEnum.Disabled)
				{
					$("#chnBar_" + chain.nexus).show();
				}
			}
			X.clearChecklist(X.Checklists.Chain, X.ChecklistJob.UncheckTheChecked);
		}
		
		// Dungeon and Personal Checklists
		if (O.Options.bol_clearPersonalChecklistOnReset)
		{
			X.clearCustomChecklistDaily();
		}
		// Daily achievements
		var resetgraceperiodms = 10000;
		if (I.isSectionLoaded_Daily)
		{
			setTimeout(function()
			{
				G.generateAndInitializeDailies();
			}, resetgraceperiodms);
		}
		// Load the audit page in a hidden iframe, which is set to close itself when the audit finishes
		if (O.Options.bol_auditAccountOnReset && U.Args[(U.KeyEnum.AutoAudit)] === undefined)
		{
			document.getElementById("jsAuditFrame").src = "./?page=Audit&" + U.KeyEnum.AutoAudit + "=true";
			I.greet("Automatic account audit started.", messagetime);
		}
		
		// Finally
		I.write("", messagetime);
	},
	clearWeeklySensitiveOptions: function(pIsDuring)
	{
		var messagetime = 5;
		var weeklymessage = pIsDuring ? "Weekly Reset!" : "Expired weekly checklists cleared.";
		if (O.Options.bol_clearPersonalChecklistOnReset)
		{
			I.greet(weeklymessage, messagetime);
			X.clearCustomChecklistWeekly();
		}
	},
	
	/*
	 * Binds custom event handlers for options that need immediate visual effect.
	 */
	bindOptionsInputs: function()
	{
		var i;
		// The Enact object has functions with the same name as the Options variables
		for (i in O.Enact)
		{
			(function(iFunction){
				var query;
				var htmlid = O.cPrefixOption + iFunction;
				var thisinputtype = $("#" + htmlid).attr("type");
				if (thisinputtype === "radio")
				{
					query = "fieldset[name=" + iFunction + "]";
				}
				else
				{
					query = "#" + htmlid;
				}
				
				$(query).change(function()
				{
					O.Enact[iFunction]();
				});
			})(i);
		}
		// POIs are created on site load
		$("#opt_bol_showWorldCompletion").change(function()
		{
			if (O.Options.bol_showWorldCompletion === true
				&& M.isMappingIconsGenerated === false)
			{
				document.location.reload();
			}
			
			$("#mapDisplayCompletion label input").not(".jsIgnore").each(function()
			{
				X.setCheckboxEnumState($(this), X.boolToChecklistEnum(O.Options.bol_showWorldCompletion));
			});
		});
		$("#opt_bol_showWorldCompletionWvW").change(function()
		{
			if (O.Options.bol_showWorldCompletionWvW === true
				&& W.isMappingIconsGenerated === false)
			{
				location.reload();
			}
			
			$("#wvwDisplayCompletion label input").each(function()
			{
				X.setCheckboxEnumState($(this), X.boolToChecklistEnum(O.Options.bol_showWorldCompletionWvW));
			});
		});
		$("#opt_bol_displayEvents").change(function()
		{
			if (O.Options.bol_displayEvents === true
				&& M.isEventIconsGenerated === false)
			{
				location.reload();
			}
			if (M.isEventIconsGenerated)
			{
				M.refreshCurrentZone();
			}
		});
		// Trigger zone in and out of current zone to toggle the icon's display
		$("#mapDisplayCompletion label input").each(function()
		{
			$(this).change(function()
			{
				if (M.isAPIRetrieved_MAPFLOOR)
				{
					M.refreshCurrentZone();
				}
			});
		});
		$("#wvwDisplayCompletion label input").each(function()
		{
			$(this).change(function()
			{
				if (W.isAPIRetrieved_MAPFLOOR)
				{
					W.refreshCurrentZone();
				}
			});
		});
		/*
		 * Run some enactors when the site loads (because this an initializer function).
		 * Will have to place it elsewhere if it requires data to be loaded first.
		 */
		O.Enact.bol_showSecondHand();
		O.Enact.int_setAlarm();
		O.Enact.bol_detectDST();
		O.Enact.bol_useSiteTag();
		O.Enact.bol_alignPanelRight(true);
		O.Enact.bol_showPanel();
		if (I.ModeCurrent !== I.ModeEnum.Simple & I.ModeCurrent !== I.ModeEnum.Tile)
		{
			O.Enact.int_setClock();
			O.Enact.int_setDimming();
		}
		
		/*
		 * Button event handlers bindings (buttons don't have stored values).
		 * ---------------------------------------------------------------------
		 */
		
		/*
		 * Clears the checklist including the deleted chain.
		 */
		$("#optRestoreAllChains").click(function()
		{
			U.interpretPage(I.PlateEnum.Chains);
			var chain;
			var display = (I.ModeCurrent === I.ModeEnum.Tile) ? "inline-block" : "block";
			for (var i in C.Chains)
			{
				chain = C.Chains[i];
				$("#chnCheck_" + chain.nexus).removeClass("chnChecked");
				$("#chnBar_" + chain.nexus).show().removeClass("chnFaded").css({display: display});
				$(".chnSlot_" + chain.nexus).each(function()
				{
					$(this).show().css({display: display}).removeClass("chnFaded")
						.find(".chnCheck").removeClass("chnChecked");
					if ($(this).hasClass("tmlIcon"))
					{
						$(this).css({display: "inline-block"});
					}
				});
			}
			X.clearChecklist(X.Checklists.Chain);
			// Also unfade the clock icons, which are the current first four bosses
			for (i = 0; i < T.cNUM_TIMEFRAMES_IN_HOUR; i++)
			{
				K.checkoffChainIcon(T.getStandardChain(i).nexus);
				var chainhardcore = T.getHardcoreChain(i);
				if (chainhardcore)
				{
					K.checkoffChainIcon(chainhardcore.nexus);
				}
			}
		});
		$("#optChainsExpand").click(function()
		{
			U.interpretPage(I.PlateEnum.Chains);
			$(".chnDetails").show();
		});
		$("#optChainsCollapse").click(function()
		{
			U.interpretPage(I.PlateEnum.Chains);
			$(".chnDetails").hide();
			I.scrollToElement("#plateChains");
		});
		
		/*
		 * Clears the browser storage.
		 */
		$("#optClearLocalStorage").click(function()
		{
			if (confirm(I.cSiteName + " Reset: This is will clear all options and everything you have written in this website. Continue?"))
			{
				localStorage.clear();
				location.reload();
			}
		});
		
		/*
		 * Prints the browser storage to HTML console.
		 */
		$("#optPrintLocalStorage").click(function()
		{
			var i;
			var keys = [];
			// Gather the keys
			for (i = 0; i < localStorage.length; i++)
			{
				var key = U.escapeHTML(localStorage.key(i));
				keys.push(key);
			}
			// Sort them alphabetically
			keys.sort();
			
			var htmlstr = "";
			var filestr = "";
			// Print the key-value pairs by the key's order
			for (i in keys)
			{
				var value = localStorage.getItem(keys[i]);
				// Convert newline to substitute
				htmlstr += keys[i] + I.cOptionsDelimiter + U.escapeHTML(value) + "<br />";
				filestr += keys[i] + I.cOptionsDelimiter + value.replace(/(?:\r\n|\r|\n)/g, "\\r\\n") + "\r\n";
			}
			
			I.print("Please click the link below to save the options file.<br />Or copy and paste all the text below to a text file.", true);
			Z.createFile(filestr, "gw2t_options.txt");
			I.print(htmlstr);
		});
		/*
		 * Imports the new-line separated options.
		 */
		Z.bindFileInput("#optImportLocalStorage", function(pString)
		{
			var counter = 0;
			var arr = pString.split(/\r\n/);
			var line, key, value, datatype;
			for (var i in arr)
			{
				line = U.toHalf(arr[i], I.cOptionsDelimiter);
				key = line[0];
				value = line[1];
				if (O.legalLocalStorageKeys[key]) // Make sure key exists
				{
					datatype = key.substring(0, O.cLengthOfPrefixes);
					if (datatype === U.TypeEnum.isString)
					{
						// Convert newline substitute to actual newline
						value = value.replace(/\\r\\n/g, "\r\n");
					}
					localStorage[key] = value;
					counter++;
				}
			}
			if (counter > 0)
			{
				I.print(counter + " options loaded. Please refresh your browser.");
			}
			else
			{
				I.print("No options loaded. Please make sure the file is properly formatted.");
			}
		});
	},
	
	/*
	 * Functions to enact the options, for which a simple variable change is
	 * not enough. Placed inside an object so they can be iterated.
	 * -------------------------------------------------------------------------
	 */
	Enact:
	{
		bol_showSecondHand: function()
		{
			$("#clkSecondHand").toggle(O.Options.bol_showSecondHand);
		},
		int_setAlarm: function()
		{
			var icon = "img/ui/placeholder.png";
			switch (O.Options.int_setAlarm)
			{
				case O.IntEnum.Alarm.Checklist: icon = "img/ui/check.png"; break;
				case O.IntEnum.Alarm.Subscription: icon = "img/ui/subscription.png"; break;
			}
			if (O.Options.int_setAlarm === O.IntEnum.Alarm.Off)
			{
				D.stopSpeech();
			}
			else
			{
				D.verifyNativeTTS();
			}
			$("#optAlarmIcon").attr("src", icon);
		},
		int_setVolume: function()
		{
			if (D.isSpeaking() === false)
			{
				D.speak(D.getWord("alarm"));
			}
		},
		bol_logNarrate: function()
		{
			if (O.Options.bol_logNarrate)
			{
				D.verifyNativeTTS();
			}
			else
			{
				D.stopSpeech();
			}
		},
		bol_hideChecked: function()
		{
			$(".chnBar").each(function()
			{
				X.hideCheckedChainBar(U.getSubintegerFromHTMLID($(this)));
			});
		},
		bol_expandWB: function()
		{
			var chains = (I.ModeCurrent === I.ModeEnum.Tile) ? C.RegularChains : C.CurrentChains;
			for (var i in chains)
			{
				if (C.isChainRegular(chains[i]))
				{
					var elm = $("#chnDetails_" + chains[i].nexus);
					if (O.Options.bol_expandWB)
					{
						elm.show("fast");
					}
					else
					{
						elm.hide("fast");
					}
				}
			}
		},
		bol_use24Hour: function()
		{
			C.initializeTimetableHTML();
			C.updateChainsTimeHTML();
			K.updateDigitalClockMinutely();
			H.updateTimelineHeader();
			H.updateTimelineSegments();
		},
		bol_detectDST: function()
		{
			T.checkDST();
		},
		int_setClock: function()
		{
			K.setClock();
		},
		int_setDimming: function()
		{
			switch (O.Options.int_setDimming)
			{
				case 1: $("#paneClockBackground").css({opacity: 1}); break;
				case 2: $("#paneClockBackground").css({opacity: 0}); break;
			}
		},
		int_setFloor: function()
		{
			M.changeFloor();
		},
		int_setFloorWvW: function()
		{
			W.changeFloor();
		},
		int_setInitialZoom: function()
		{
			M.Map.setZoom(O.Options.int_setInitialZoom);
		},
		int_setInitialZoomWvW: function()
		{
			W.Map.setZoom(O.Options.int_setInitialZoomWvW);
		},
		bol_showZoneBorders: function()
		{
			P.drawZoneBorders();
		},
		bol_showZoneGateways: function()
		{
			P.drawZoneGateways();
		},
		str_colorPersonalPath: function()
		{
			P.refreshPersonalPath();
		},
		int_opacityPersonalPath: function()
		{
			P.refreshPersonalPath();
		},
		bol_showChainPaths: function()
		{
			M.toggleLayerArray(P.LayerArray.ChainPath, O.Options.bol_showChainPaths);
		},
		bol_tourPrediction: function()
		{
			C.isTouringAuto = O.Options.bol_tourPrediction;
			if (O.Options.bol_tourPrediction)
			{
				C.isTouringManual = false;
			}
		},
		int_setFollow: function()
		{
			if (O.Options.int_setFollow !== O.IntEnum.Follow.Off)
			{
				M.GPSPreviousZoneID = "";
				P.updateCharacter(0);
			}
		},
		int_setFollowWvW: function()
		{
			if (O.Options.int_setFollowWvW !== O.IntEnum.Follow.Off)
			{
				W.GPSPreviousZoneID = "";
				P.updateCharacter(0);
			}
		},
		bol_displayCharacter: function()
		{
			if ( ! O.Options.bol_displayCharacter)
			{
				M.movePin(M.Pin.Character);
				M.movePin(M.Pin.Camera);
			}
			else
			{
				P.tickGPS();
				P.updateCharacter(0);
			}
		},
		bol_displayCharacterWvW: function()
		{
			if ( ! O.Options.bol_displayCharacterWvW)
			{
				W.movePin(W.Pin.Character);
				W.movePin(W.Pin.Camera);
			}
			else
			{
				P.tickGPS();
				P.updateCharacter(0);
			}
		},
		bol_showPanel: function()
		{
			if (I.isMapEnabled) // Only hide panel if map is visible
			{
				$("#panelApp").toggle(O.Options.bol_showPanel);
				$("#mapDisplayButton, #wvwDisplayButton, #accDisplayButton").toggle(!O.Options.bol_showPanel);
				M.refreshMap();
				if (W.isMapInitialized)
				{
					W.refreshMap();
				}
				if (A.isAccountInitialized)
				{
					A.adjustAccountPanel();
				}
			}
		},
		bol_alignPanelRight: function(pIsInitial)
		{
			if (I.isMapEnabled)
			{
				if (O.Options.bol_alignPanelRight)
				{
					// Don't realign if this function is called initially, because this is the default alignment
					if (pIsInitial !== true)
					{
						$("#panelApp").insertAfter("#panelMap");
						$(".paneApp").css({
							right: "0px",
							borderLeft: "1px solid #444",
							borderRight: "none",
							boxShadow: "-5px 0px 5px #223"
						});
						$(".mapDisplayButton").css({right: 0, left: "auto"});
						$("#itemDisplayButton").css({right: "auto", left: "auto", "margin-left": "-16px"});
						$("#prjController").css({right: "auto"});
					}
				}
				else
				{
					$("#panelApp").insertBefore("#panelMap");
					$(".paneApp").css({
						right: "auto",
						borderLeft: "none",
						borderRight: "1px solid #444",
						boxShadow: "5px 0px 5px #223"
					});
					$(".mapDisplayButton").css({right: "auto", left: 0});
					$("#itemDisplayButton").css({right: "auto", left: "auto", "margin-left": (I.cPANEL_WIDTH - 16) + "px"});
					$("#prjController").css({right: 0});
				}
			}
		},
		bol_showHUD: function()
		{
			$("#mapHUDContainer, #mapHUDContainerInner").toggle(O.Options.bol_showHUD);
		},
		bol_showHUDWvW: function()
		{
			$("#wvwHUDContainer, #wvwHUDContainerInner").toggle(O.Options.bol_showHUDWvW);
		},
		bol_showCoordinatesBar: function()
		{
			M.toggleCoordinatesBar();
		},
		bol_hideHUD: function()
		{
			if (O.Options.bol_hideHUD === false)
			{
				$("#mapHUDContainerInner").show();
			}
		},
		bol_showDashboard: function()
		{
			H.toggleDashboard();
		},
		bol_showTimeline: function()
		{
			H.toggleTimeline();
		},
		bol_opaqueTimeline: function()
		{
			H.opaqueTimeline();
		},
		bol_condenseTimelineLine: function(pIsInitial)
		{
			if (pIsInitial === undefined || (pIsInitial && O.Options.bol_condenseTimelineLine === false))
			{
				$(".tmlLineWB").show();
				I.toggleElement(".tmlLineStandard", O.Options.bol_condenseTimelineLine);
				if (O.Options.bol_condenseTimelineLine === false)
				{
					X.clearChecklist(X.Checklists.Timeline);
				}
			}
		},
		bol_condenseTimelineHeader: function(pIsInitial)
		{
			H.minutesInTimelineSpacing = (O.Options.bol_condenseTimelineHeader) ? T.cMINUTES_IN_TIMEFRAME : T.cMINUTES_IN_MINIFRAME;
			H.updateTimelineHeader();
			if (pIsInitial !== true)
			{
				H.updateTimelineSegments();
			}
		},
		bol_refreshPrices: function()
		{
			if (O.Options.bol_refreshPrices && E.isTradingCalculatorsInitialized)
			{
				E.loopRefresh();
			}
			else
			{
				E.cancelLoopRefresh();
			}
		},
		bol_useSiteTag: function()
		{
			if (O.Options.bol_useSiteTag)
			{
				I.siteTagCurrent = I.siteTagDefault;
			}
			else
			{
				I.siteTagCurrent = "";
			}
		},
		bol_showLog: function()
		{
			W.toggleLog();
		},
		bol_opaqueLog: function()
		{
			W.opaqueLog();
		},
		bol_maximizeLog: function()
		{
			W.toggleLogHeight();
		},
		bol_showLeaderboard: function()
		{
			W.toggleLeaderboard();
		},
		bol_opaqueLeaderboard: function()
		{
			W.opaqueLeaderboard();
		},
		bol_condenseLeaderboard: function()
		{
			W.toggleLeaderboardWidth(true);
		},
		bol_showSecondaries: function()
		{
			W.toggleSecondaries(true);
		},
		bol_showDestructibles: function()
		{
			W.toggleWalls(true);
		},
		bol_showObjectiveLabels: function()
		{
			W.toggleObjectiveLabels();
		}
	}
};
X = {
/* =============================================================================
 * @@Checklist management and generation
 * ========================================================================== */

	/*
	 * A checklist is a set of checkboxes that can have the usual unchecked,
	 * checked, and disabled states. These states are recorded as a single
	 * character in a string of numbers representing those states, and the index
	 * of a character is that checkbox's "ID". The Checklists object stores
	 * checklists with such a string and a key for localStorage, along with
	 * supplementary attributes.
	 */
	Checklists:
	{
		// localStorage key-value pairs (key is required)
		Directory: { key: "str_chlDirectory" },
		Chain: { key: "str_chlChain" },
		ChainSubscription: { key: "str_chlChainSubscription" },
		Timeline: { key: "str_chlTimeline" },
		JP: { key: "str_chlJP" },
		Chest: { key: "str_chlChest" },
		ResourceRich: { key: "str_chlResourceRich" },
		ResourcePermanent: { key: "str_chlResourcePermanent" },
		ResourceRegular: { key: "str_chlResourceRegular" },
		ResourceHotspot: { key: "str_chlResourceHotspot" },
		Dungeon: { key: "str_chlDungeon", money: 0 },
		Raid: { key: "str_chlRaid", money: 0 },
		CustomDaily: { key: "str_chlCustomDaily" },
		CustomWeekly: { key: "str_chlCustomWeekly" },
		// Individual calculator's settings
		TradingOverwrite: { key: "str_chlTradingOverwrite" },
		TradingNotify: { key: "str_chlTradingNotify" }
	},
	/*
	 * Collectible checklists must have the same variable name as in the map page's data.
	 * The urlkey properties must be unique from the global KeyEnum.
	 */
	Collectibles:
	{
		// Chests
		HarathiStrongboxes: { key: "str_chlHarathiStrongboxes", urlkey: "harathistrongboxes"},
		IceboundChests: { key: "str_chlIceboundChests", urlkey: "iceboundchests"},
		SkrittStashes: { key: "str_chlSkrittStashes", urlkey: "skrittstashes"},
		NoxiousPods: { key: "str_chlNoxiousPods", urlkey: "noxiouspods"},
		CrystallizedCaches: { key: "str_chlCrystallizedCaches", urlkey: "crystallizedcaches"},
		ExaltedChests: { key: "str_chlExaltedChests", urlkey: "exaltedchests"},
		AirshipCargo: { key: "str_chlAirshipCargo", urlkey: "airshipcargo"},
		BuriedChests: { key: "str_chlBuriedChests", urlkey: "chests"},
		BanditChests: { key: "str_chlBanditChests", urlkey: "banditchests"},
		MatrixCubeKey: { key: "str_chlMatrixCubeKey", urlkey: "matrixcubekey"},
		SkrittBurglar: { key: "str_chlSkrittBurglar", urlkey: "skrittburglar"},
		// Festival
		PumpkinCarving: { key: "str_chlPumpkinCarving", urlkey: "pumpkins"},
		DonationDrive: { key: "str_chlDonationDrive", urlkey: "orphans"},
		// Achievements: Heart of Thorns Living Story
		LessonsLearned: { key: "str_chlLessonsLearned", urlkey: "lessonslearned"},
		PeopleWatching: { key: "str_chlPeopleWatching", urlkey: "peoplewatching"},
		RockCollector: { key: "str_chlRockCollector", urlkey: "rockcollector"},
		CinsGoods: { key: "str_chlCinsGoods", urlkey: "cinsgoods"},
		LettersFromE: { key: "str_chlLettersFromE", urlkey: "lettersfrome"},
		CaudecusLetters: { key: "str_chlCaudecusLetters", urlkey: "caudecusletters"},
		ThoroughSampling: { key: "str_chlThoroughSampling", urlkey: "thoroughsampling"},
		MursaatTokens: { key: "str_chlMursaatTokens", urlkey: "mursaattokens"},
		MursaatTablets: { key: "str_chlMursaatTablets", urlkey: "mursaattablets"},
		CamiJournals: { key: "str_chlCamiJournals", urlkey: "camijournals"},
		RiftStabilizer: { key: "str_chlRiftStabilizer", urlkey: "riftstabilizer"},
		BloodstoneCreatures: { key: "str_chlBloodstoneCreatures", urlkey: "creatures"},
		BloodstoneSlivers: { key: "str_chlBloodstoneSlivers", urlkey: "slivers"},
		// Achievements: Heart of Thorns
		PaperScraps: { key: "str_chlPaperScraps", urlkey: "paperscraps"},
		TigerSpirit: { key: "str_chlTigerSpirit", urlkey: "tigerspirit"},
		ItzelTotems: { key: "str_chlItzelTotems", urlkey: "itzeltotems"},
		PriorySeals: { key: "str_chlPriorySeals", urlkey: "prioryseals"},
		AuricTablets: { key: "str_chlAuricTablets", urlkey: "aurictablets"},
		ExaltedMasks: { key: "str_chlExaltedMasks", urlkey: "exaltedmasks"},
		// Achievements: Pre-expansion
		LionsArchExterminator: { key: "str_chlLionsArchExterminator", urlkey: "lionsarchexterminator"},
		CoinProspect: { key: "str_chlCoinProspect", urlkey: "coinprospect"},
		CoinUplands: { key: "str_chlCoinUplands", urlkey: "coinuplands"},
		CoinChallenger: { key: "str_chlCoinChallenger", urlkey: "coinchallenger"},
		LostBadges: { key: "str_chlLostBadges", urlkey: "lostbadges"},
		GoldenLostBadges: { key: "str_chlGoldenLostBadges", urlkey: "goldenlostbadges"},
		DiveMaster: { key: "str_chlDiveMaster", urlkey: "divemaster"},
		SpeedyReader: { key: "str_chlSpeedyReader", urlkey: "speedyreader"},
		CleaningUp: { key: "str_chlCleaningUp", urlkey: "cleaningup"},
		HistoryBuff: { key: "str_chlHistoryBuff", urlkey: "historybuff"},
		// Unlocks
		HungryCats: { key: "str_chlHungryCats", urlkey: "hungrycats"},
		Strongboxes: { key: "str_chlStrongboxes", urlkey: "strongboxes"},
		MasteryInsight: { key: "str_chlMasteryInsight", urlkey: "masteryinsight"},
		HeroChallenge: { key: "str_chlHeroChallenge", urlkey: "herochallenge"},
		ImportantWaypoints: { key: "str_chlImportantWaypoints", urlkey: "importantwaypoints"},
		RangerPets: { key: "str_chlRangerPets", urlkey: "pets"}
	},
	ChecklistEnum:
	{
		// Must be 1 character long
		Unchecked: "0",
		Checked: "1",
		Disabled: "2",
		
		Unfound: "0",
		Tracked: "1",
		Found: "2"
	},
	ChecklistJob:
	{
		UncheckAll: 0,
		CheckAll: 1,
		UncheckTheChecked: 2
	},
	
	/*
	 * A textlist is a set of text inputs or textareas that user writes in.
	 * These are stored as substrings separated by "|" in a single long string.
	 * The index between the separators represent the substring's (textarea's
	 * content) ID. Other than that, its working is similar to checklists.
	 */
	Textlists:
	{
		SlotPins: { key: "str_txlSlotPins"},
		SlotPinsWvW: { key: "str_txlSlotPinsWvW"},
		SlotCompasses: { key: "str_txlSlotCompasses"},
		SlotCompassesWvW: { key: "str_txlSlotCompassesWvW"},
		CustomTextDaily: { key: "str_txlCustomTextDaily", valueDefault: [] },
		CustomTextWeekly: { key: "str_txlCustomTextWeekly", valueDefault: [] },
		NotepadText: { key: "str_txlNotepadText", valueDefault: [] },
		TradingItem: { key: "str_txlTradingItem"},
		TradingName: { key: "str_txlTradingName"},
		TradingBuy: { key: "str_txlTradingBuy"},
		TradingSell: { key: "str_txlTradingSell"},
		TradingQuantity: { key: "str_txlTradingQuantity"},
		NotifyBuyLow: { key: "str_txlNotifyBuyLow"},
		NotifyBuyHigh: { key: "str_txlNotifyBuyHigh"},
		NotifySellLow: { key: "str_txlNotifySellLow"},
		NotifySellHigh: { key: "str_txlNotifySellHigh"},
		ExchangeUnit: { key: "str_txlExchangeUnit"}
	},
	
	/*
	 * Converts a boolean to a checklist enum.
	 * @param string pBoolean to convert.
	 * @returns enum.
	 */
	boolToChecklistEnum: function(pBoolean)
	{
		if (pBoolean)
		{
			return X.ChecklistEnum.Checked;
		}
		return X.ChecklistEnum.Unchecked;
	},
	
	/*
	 * Creates a string for a checklist object with each character representing
	 * a state, and each index representing a check item. Also initializes the
	 * localStorage or load it as the checklist if already stored.
	 * @param object pChecklist to initialize.
	 * @param int pLength of the checklist string to construct.
	 * @param string pCustomList comma separated list of indexes (1-indexed) to be set as checked.
	 * @param enum pJob for clear function, optional.
	 * @param object pAssoc for custom named indexes, optional.
	 * @returns string new checklist to be assigned to a checklist variable.
	 */
	initializeChecklist: function(pChecklist, pLength, pCustomList, pJob, pAssoc)
	{
		var i;
		var indexes;
		var index;
		var storedlist = localStorage[pChecklist.key];
		pChecklist.value = "";
		pChecklist.length = pLength;
		
		if (pCustomList)
		{
			X.clearChecklist(pChecklist);
			indexes = pCustomList.split(",");
			if (pAssoc)
			{
				for (var i = 0; i < indexes.length; i++)
				{
					indexes[i] = pAssoc[(indexes[i])];
				}
			}

			for (i in indexes)
			{
				index = parseInt(indexes[i]);
				if (isFinite(index))
				{
					X.setChecklistItem(pChecklist, index - 1, X.ChecklistEnum.Checked);
				}
			}
		}
		// If no checklist exists then it create one with a string of 0s
		else if (storedlist === undefined)
		{
			X.clearChecklist(pChecklist, pJob);
		}
		// If stored list is longer than requested, then cut off the right portion
		else if (storedlist.length > pLength)
		{
			localStorage[pChecklist.key] = storedlist.substring(0, pLength);
		}
		// If stored list is shorter than requested, then concatenate it with 0s so its new length equals so
		else if (storedlist.length < pLength)
		{
			var padding = U.repeatChar(X.ChecklistEnum.Unchecked, pLength - storedlist.length);
			localStorage[pChecklist.key] = storedlist + padding;
		}
		
		// Either way, the stored list becomes the program's list
		pChecklist.value = localStorage[pChecklist.key];
	},
	
	/*
	 * Replaces a character in a checklist string and updates the localStorage.
	 * @param object pChecklist to modify.
	 * @param int pIndex of the character in the string.
	 * @param string pCharacter to replace the current.
	 */
	setChecklistItem: function(pChecklist, pIndex, pCharacter)
	{
		pIndex = parseInt(pIndex);
		var thechar = pCharacter.toString();
		// A character must be length 1 and different from the current
		if (thechar.length === 1 && pChecklist.value[pIndex] !== thechar
			&& pIndex >= 0
			&& pIndex < pChecklist.value.length)
		{
			var checklist = U.replaceCharAt(pChecklist.value, pIndex, thechar);
			localStorage[pChecklist.key] = checklist;
			pChecklist.value = checklist;
		}
	},
	
	/*
	 * Toggles a character in a checklist string and updates the localStorage
	 * between three possible states.
	 * @param object pChecklist to modify.
	 * @param int pIndex of the character in the string.
	 * @returns enum the new state.
	 */
	trackChecklistItem: function(pChecklist, pIndex)
	{
		pIndex = parseInt(pIndex);
		var thechar = pChecklist.value.charAt(pIndex);
		switch (thechar)
		{
			case X.ChecklistEnum.Unfound: thechar = X.ChecklistEnum.Tracked; break;
			case X.ChecklistEnum.Tracked: thechar = X.ChecklistEnum.Found; break;
			case X.ChecklistEnum.Found: thechar = X.ChecklistEnum.Unfound; break;
			default: thechar = X.ChecklistEnum.Unfound;
		}
		
		var checklist = U.replaceCharAt(pChecklist.value, pIndex, thechar);
		localStorage[pChecklist.key] = checklist;
		pChecklist.value = checklist;
		
		return thechar;
	},
	
	/*
	 * Gets the character in a checklist string at specified index.
	 * @param object pChecklist to extract.
	 * @param int pIndex of the character.
	 * @param string pConversion to convert that character to a type.
	 * @returns dynamic depending on conversion param.
	 */
	getChecklistItem: function(pChecklist, pIndex, pConversion)
	{
		var thechar = pChecklist.value.charAt(pIndex);
		
		if (pConversion === undefined)
		{
			return thechar;
		}
		if (pConversion === U.TypeEnum.isInteger)
		{
			return parseInt(thechar);
		}
		if (pConversion === U.TypeEnum.isBoolean)
		{
			// Returns false only if unchecked
			return U.intToBool(parseInt(thechar));
		}
		return thechar;
	},
	
	/*
	 * Tells if an element with a checkbox has checked state.
	 * @param object pChecklist to lookup.
	 * @param jqobject pEntry to extract checkbox index in checklist.
	 * @returns boolean true if checked.
	 */
	isChecked: function(pChecklist, pEntry)
	{
		var index = U.getSubintegerFromHTMLID(pEntry);
		if (X.getChecklistItem(pChecklist, index) === X.ChecklistEnum.Checked)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Gets indexes in a checklist that has its value as "checked".
	 * @param object pChecklist to extract.
	 * @param object pAssoc for custom named indexes, optional.
	 * @returns string comma separated string of index numbers (1-indexed).
	 */
	getCheckedIndexes: function(pChecklist, pAssoc)
	{
		var i;
		var indexes = "";
		var list = pChecklist.value;
		for (i = 0; i < list.length; i++)
		{
			if (list[i] === X.ChecklistEnum.Checked)
			{
				if (pAssoc)
				{
					indexes += pAssoc[i] + ",";
				}
				else
				{
					indexes += (i+1) + ",";
				}
			}
		}
		indexes = indexes.slice(0, -1); // Trim last extra comma
		return indexes;
	},
	
	/*
	 * Sets a checklist object's list a desired mass state.
	 * @param object pChecklist to clear.
	 * @param enum pJob to check or uncheck the checklist.
	 * @pre Checklist length attribute was initialized.
	 */
	clearChecklist: function(pChecklist, pJob)
	{
		var i;
		var checklist = "";
		var value = "";
		
		switch (pJob)
		{
			case X.ChecklistJob.CheckAll:
			{
				for (i = 0; i < pChecklist.length; i++)
				{
					checklist += X.ChecklistEnum.Checked;
				}
			} break;
			case X.ChecklistJob.UncheckTheChecked:
			{
				// Only sets unchecked state on checked ones
				if (localStorage[pChecklist.key])
				{
					value = localStorage[pChecklist.key];
				}
				else
				{
					value = pChecklist.value;
				}
				
				if (value && value.length)
				{
					for (i = 0; i < value.length; i++)
					{
						if (value[i] === X.ChecklistEnum.Checked)
						{
							checklist += X.ChecklistEnum.Unchecked;
						}
						else
						{
							checklist += value[i];
						}
					}
				}
			} break;
			default:
			{
				for (i = 0; i < pChecklist.length; i++)
				{
					checklist += X.ChecklistEnum.Unchecked;
				}
			}
		}
		
		pChecklist.value = checklist;
		localStorage[pChecklist.key] = checklist;
	},
	
	/*
	 * Counts the checked type in a checklist.
	 * @param object pChecklist to look in.
	 * @param enum pCheckType to look for.
	 * @returns int count.
	 */
	countChecklist: function(pChecklist, pCheckType)
	{
		return U.countOccurrence(pChecklist.value, pCheckType);
	},
	
	/*
	 * Reads a checkbox element and return its checklist enum state.
	 * @param jqobject pElement to read.
	 * @returns int checklist enum.
	 */
	getCheckboxEnumState: function(pElement)
	{
		if (pElement.prop("disabled") === true)
		{
			return X.ChecklistEnum.Disabled;
		}
		if (pElement.prop("checked") === true)
		{
			return X.ChecklistEnum.Checked;
		}
		return X.ChecklistEnum.Unchecked;
	},
	
	/*
	 * Sets an input tag checkbox checked/disabled states based on specified enum.
	 * @param jqobject pElement checkbox to change.
	 * @param int pChecklistEnum to apply.
	 */
	setCheckboxEnumState: function(pElement, pChecklistEnum)
	{
		switch (pChecklistEnum)
		{
			case X.ChecklistEnum.Disabled:
			{
				pElement.prop("disabled", true);
				pElement.prop("checked", false);
			} break;
			case X.ChecklistEnum.Checked:
			{
				pElement.prop("checked", true);
			} break;
			default: pElement.prop("checked", false);
		}
		pElement.trigger("change");
	},
	
	/*
	 * Programmatically selects an option in a fieldset input.
	 * @param string pName ID of element.
	 * @param int pOrder in the fieldset.
	 */
	setFieldsetState: function(pName, pOrder)
	{
		$("fieldset[name='" + pName + "'] input:eq(" + pOrder + ")").trigger("click");
	},
	
	/*
	 * Sets a checkbox to a desired state by reading it then manually triggering it.
	 * @param jqobject pElement checkbox to manipulate.
	 * @param int pState checkbox enum.
	 */
	triggerCheckbox: function(pElement, pState)
	{
		var checkboxstate = X.getCheckboxEnumState(pElement);
		
		if ( (pState === X.ChecklistEnum.Checked && (checkboxstate === X.ChecklistEnum.Unchecked))
			|| (pState === X.ChecklistEnum.Unchecked && (checkboxstate === X.ChecklistEnum.Checked)) )
		{
			pElement.trigger("click");
		}
		else if (pState === X.ChecklistEnum.Disabled && checkboxstate !== X.ChecklistEnum.Disabled)
		{
			pElement.trigger("dblclick");
		}
	},
	
	/*
	 * Triggers a checkbox based on associated state in a checklist.
	 * @param object pChecklist as target state.
	 * @param int pIndex of a state in checklist.
	 * @param jqobject pElement checkbox to manipulate.
	 */
	triggerCheckboxEnumState: function(pChecklist, pIndex, pElement)
	{
		var checkliststate = X.getChecklistItem(pChecklist, pIndex);
		X.triggerCheckbox(pElement, checkliststate);
	},
	
	/*
	 * Adds style classes to a label that wraps a checkbox depending on its state.
	 * @param object pChecklist to get state.
	 * @param int pIndex of state.
	 * @param jqobject pElement checkbox to style its label.
	 * @pre In format <label><input type="checkbox" />ExampleLabel</label>.
	 */
	setCheckboxStyle: function(pChecklist, pIndex, pElement)
	{
		var state = X.getChecklistItem(pChecklist, pIndex);
		var label = X.getCheckboxLabel(pElement);
		switch (state)
		{
			case X.ChecklistEnum.Disabled:
			{
				label.removeClass("chlCheckboxChecked").addClass("chlCheckboxDisabled");
			} break;
			case X.ChecklistEnum.Checked:
			{
				label.removeClass("chlCheckboxDisabled").addClass("chlCheckboxChecked");
			} break;
			default:
			{
				label.removeClass("chlCheckboxDisabled").removeClass("chlCheckboxChecked");
			}
		}
	},
	
	/*
	 * Adds custom checkbox image to a checkbox element.
	 * @param jqobject pElm
	 * @pre Checkbox is enclosed by a label tag.
	 */
	wrapCheckbox: function(pElement)
	{
		$(pElement).addClass("jsCheckbox").wrap("<span class='cssCheckbox'></span>").after("<kbd class='cssCheckboxImage'></kbd>");
	},
	rewrapCheckboxes: function()
	{
		$("input[type='checkbox']").not(".jsCheckbox").each(function()
		{
			X.wrapCheckbox($(this));
		});
	},
	getCheckboxLabel: function(pCheckbox)
	{
		return $(pCheckbox).closest("label");
	},
	
	/*
	 * Sets a checkbox's label text. Also assigns ID of checkbox to label.
	 * @param jqobject pElement
	 * @param string pHTML
	 */
	relabelCheckbox: function(pElement, pHTML)
	{
		var elm = $(pElement);
		var parent = X.getCheckboxLabel(elm).attr("id", elm.attr("id").replace(O.cPrefixOption, O.cPrefixLabel));
		parent.find(".jsCheckboxText").remove();
		parent.append("<var class='jsCheckboxText'> " + pHTML + "</var>");
	},
	
	/*
	 * Initializes the checklist for a set of checkboxes and bind their standard storage behavior.
	 * @param object pChecklist for storing state.
	 * @param jqobject pCheckboxes input to bind behavior.
	 * @param enum pJob initial checkbox state.
	 * @pre These checkboxes can only have a checked and unchecked state only.
	 */
	initializeCheckboxlist: function(pChecklist, pCheckboxes, pJob, pRestoreButton, pWantStyle)
	{
		X.initializeChecklist(pChecklist, pCheckboxes.length, null, pJob);

		pCheckboxes.each(function(iIndex)
		{
			$(this).change(function()
			{
				var state = X.getCheckboxEnumState($(this));
				X.setChecklistItem(pChecklist, iIndex, state);
				if (pWantStyle !== false)
				{
					X.setCheckboxStyle(pChecklist, iIndex, $(this));
				}
			});
			
			// Now that this checkbox is bound, trigger it as the state in checklist
			X.triggerCheckboxEnumState(pChecklist, iIndex, $(this));
			if (pWantStyle !== false)
			{
				X.setCheckboxStyle(pChecklist, iIndex, $(this));
			}
		});
		
		// Bind restore default values button
		if (pRestoreButton)
		{
			pRestoreButton.click(function()
			{
				X.clearCheckboxes(pCheckboxes);
			});
		}
	},
	clearCheckboxes: function(pCheckboxes)
	{
		pCheckboxes.each(function()
		{
			X.setCheckboxEnumState($(this), X.ChecklistEnum.Unchecked);
			$(this).trigger("change");
		});
	},
	
	/*
	 * Stores text and binds default behavior for a standard set of text fields.
	 * @param object pChecklistText for storing text in memory and storage.
	 * @param jqobject pTextFields input or textarea elements to iterate and read text,
	 * if the textlists are swappable then provide a string for fresh queries.
	 * @param string pFieldName name of the text fields for notifying of change.
	 * @param int pMaxLength of characters in a text field.
	 * @param jqobject pRestoreButton to reset all text fields, optional.
	 */
	initializeTextlist: function(pTextlist, pTextFields, pFieldName, pMaxLength, pRestoreButton)
	{
		// Initialize the pre-written text in the text fields
		pTextlist.value = [];
		$(pTextFields).each(function()
		{
			var text = $(this).val();
			pTextlist.value.push(text);
			if (pTextlist.valueDefault)
			{
				pTextlist.valueDefault.push(text);
			}
		});
		
		/*
		 * Each text fields' value will become a delimited substring in one
		 * single string to be stored in localStorage.
		 */
		var i;
		if (localStorage[pTextlist.key] === undefined)
		{
			// If localStorage value is empty, replace with original values in text field
			localStorage[pTextlist.key] = pTextlist.value.join(I.cTextDelimiterChar);
		}
		else
		{
			var storedtextarray = localStorage[pTextlist.key].split(I.cTextDelimiterChar);
			// Load the stored text and regard missing entries
			for (i = 0; i < pTextlist.value.length; i++)
			{
				if (storedtextarray[i])
				{
					pTextlist.value[i] = storedtextarray[i];
				}
				else
				{
					pTextlist.value[i] = "";
				}
			}
			localStorage[pTextlist.key] = pTextlist.value.join(I.cTextDelimiterChar);
		}
		
		var updateStoredText = function()
		{
			// Read every text fields and rewrite the string of substrings again
			$(pTextFields).each(function(iIndex)
			{
				// Do not allow delimiter in the string to be stored
				pTextlist.value[iIndex] = $(this).val().replace(I.cTextDelimiterRegex, "");
			});
			localStorage[pTextlist.key] = pTextlist.value.join(I.cTextDelimiterChar);
		};
		
		// Bind text fields behavior
		$(pTextFields).each(function(iIndex)
		{
			$(this).attr("maxlength", pMaxLength); // Set number of characters allowed in the text field
			$(this).val(pTextlist.value[iIndex]); // Load initialized text
			
			$(this).change(function()
			{
				if (pFieldName)
				{
					I.write(pFieldName + " #" + (iIndex + 1) + " updated.");
				}
				updateStoredText();
			});
		});
		
		// Bind restore default values button
		if (pRestoreButton)
		{
			pRestoreButton.click(function()
			{
				if (confirm("Reset texts to default?"))
				{
					$(pTextFields).each(function(iIndex)
					{
						$(this).val(pTextlist.valueDefault[iIndex]).trigger("change");
					});
				}
			});
		}
	},
	
	/*
	 * Binds the buttons for swapping text list items.
	 * @param jqobject pListContainer the list.
	 * @param jqobject pSwapContainer to append the swap buttons.
	 * @param boolean pWantButtons whether to append the swap buttons if haven't created, optional.
	 * @param function pSaveFunction to execute after swapping.
	 * @pre Container's list items must be sole elements in the hierarchy.
	 */
	bindTextlistSwap: function(pListContainer, pSwapContainer, pSaveFunction)
	{
		var container = $(pListContainer);
		var listitems = container.children();
		var getListItem = function(pChild)
		{
			return pChild.closest(".jsSwappable");
		};
		
		// Insert swap buttons
		var swapcontainer = (pSwapContainer) ? $(pSwapContainer) : listitems;
		swapcontainer.each(function()
		{
			$(this).append("<span class='btnSwap'><button class='btnSwapUp'></button><button class='btnSwapDown'></button></span>");
		});
		listitems.each(function()
		{
			$(this).addClass("jsSwappable");
		});
		
		// Hovering over the swap buttons highlight the input elements of the swappable row
		container.find(".btnSwap").each(function()
		{
			$(this).hover(
				function()
				{
					getListItem($(this)).find("input[type='text']").addClass("cssInputFocused");
				},
				function()
				{
					getListItem($(this)).find("input[type='text']").removeClass("cssInputFocused");
				}
			);
		});
		
		// Bind swap behavior
		container.find(".btnSwapUp, .btnSwapDown").click(function()
		{
			var listitem = getListItem($(this));
			if ($(this).hasClass("btnSwapUp"))
			{
				var prev = listitem.prev();
				if (prev.length)
				{
					listitem.insertBefore(prev);
				}
				else
				{
					listitem.insertAfter(container.find(".jsSwappable").last());
				}
			}
			else
			{
				var next = listitem.next();
				if (next.length)
				{
					listitem.insertAfter(next);
				}
				else
				{
					listitem.insertBefore(container.find(".jsSwappable").first());
				}
			}
			// Save after swapping
			if (pSaveFunction)
			{
				pSaveFunction();
			}
			else
			{
				// Assume the change event was bound for saving
				listitem.find("input").trigger("change");
			}
		});
	},
	
	/*
	 * Loads chain checklist state as recorded in localStorage, and binds
	 * clicking behavior to the div simulated checkboxes.
	 * @param object pChain to initialize.
	 * @pre Chains HTML have been initialized.
	 */
	initializeChainChecklist: function(pChain)
	{
		var bar = $("#chnBar_" + pChain.nexus);
		var check = $("#chnCheck_" + pChain.nexus);
		var time = $("#chnTime_" + pChain.nexus);

		// Set the checkbox visual state as stored
		X.reapplyChainBarState(pChain.nexus, bar, check, time);
		
		if (C.isChainRegular(pChain))
		{
			/*
			 * Bind event handler for the time clickable for subscription.
			 */
			time.click(function()
			{
				var nexus = U.getSubintegerFromHTMLID($(this));
				var slottimes = $(".chnSlot_" + nexus).find("time");

				if (X.getChecklistItem(X.Checklists.ChainSubscription, nexus) === X.ChecklistEnum.Checked)
				{
					$(this).removeClass("chnTimeSubscribed");
					slottimes.removeClass("chnTimeSubscribed");
					X.setChecklistItem(X.Checklists.ChainSubscription, nexus, X.ChecklistEnum.Unchecked);
				}
				else
				{
					$(this).addClass("chnTimeSubscribed");
					slottimes.addClass("chnTimeSubscribed");
					X.setChecklistItem(X.Checklists.ChainSubscription, nexus, X.ChecklistEnum.Checked);
					// Set the alarm mode to subscription if not already
					if (O.Options.int_setAlarm !== O.IntEnum.Alarm.Subscription)
					{
						X.setFieldsetState("int_setAlarm", O.IntEnum.Alarm.Subscription);
					}
				}
			});
		}

		/*
		 * Bind event handler for the div "checkboxes".
		 */
		check.click(function()
		{
			// The ID was named so by the chain initializer, get the chain nexus
			var nexus = U.getSubintegerFromHTMLID($(this));
			var thisbar = $("#chnBar_" + nexus);
			var theseslots = $(".chnSlot_" + nexus);
			var display = (I.ModeCurrent === I.ModeEnum.Tile) ? "inline-block" : "block";
			// State of the div is stored in the Checklist object rather in the element itself
			switch (X.getChecklistItem(X.Checklists.Chain, nexus))
			{
				case X.ChecklistEnum.Unchecked:
				{
					thisbar.addClass("chnFaded");
					if (I.ModeCurrent !== I.ModeEnum.Tile)
					{
						$("#chnDetails_" + nexus).hide("fast");
					}
					$(this).addClass("chnChecked");
					X.setChecklistItem(X.Checklists.Chain, nexus, X.ChecklistEnum.Checked);
					theseslots.addClass("chnFaded")
						.find(".chnCheck").addClass("chnChecked");
				} break;
				case X.ChecklistEnum.Checked:
				{
					thisbar.removeClass("chnFaded").show("fast").css({display: display});
					if (I.ModeCurrent !== I.ModeEnum.Tile)
					{
						$("#chnDetails_" + nexus).show("fast").css({display: display});
					}
					$(this).removeClass("chnChecked");
					X.setChecklistItem(X.Checklists.Chain, nexus, X.ChecklistEnum.Unchecked);
					theseslots.show("fast").each(function()	
					{
						$(this).css({display: display}).removeClass("chnFaded")
							.find(".chnCheck").removeClass("chnChecked");
						if ($(this).hasClass("tmlIcon"))
						{
							$(this).css({display: "inline-block"});
						}
					});
				} break;
				case X.ChecklistEnum.Disabled:
				{
					thisbar.removeClass("chnFaded").show("fast").css({display: display});
					if (I.ModeCurrent !== I.ModeEnum.Tile)
					{
						$("#chnDetails_" + nexus).show("fast").css({display: display});
					}
					$(this).removeClass("chnChecked");
					X.setChecklistItem(X.Checklists.Chain, nexus, X.ChecklistEnum.Unchecked);
					theseslots.hide().removeClass("chnFaded")
						.find(".chnCheck").removeClass("chnChecked");
				} break;
			}
			X.hideCheckedChainBar(nexus);
			// Update the icons on the clock too
			K.checkoffChainIcon(nexus);
		});

		// Bind the delete chain text button [x]
		$("#chnDelete_" + pChain.nexus).click(function()
		{
			var nexus = U.getSubintegerFromHTMLID($(this));
			$("#chnBar_" + nexus).hide("slow");
			$(".chnSlot_" + nexus).hide("slow");
			X.setChecklistItem(X.Checklists.Chain, nexus, X.ChecklistEnum.Disabled);

			// Also update the clock icon
			K.checkoffChainIcon(nexus);
		});
	},
	reapplyChainBarState: function(pIndex, pBar, pCheck, pTime)
	{
		// Chain check
		switch (X.getChecklistItem(X.Checklists.Chain, pIndex))
		{
			case X.ChecklistEnum.Unchecked:
			{
				// Bar is not checked off, so don't do anything
			} break;
			case X.ChecklistEnum.Checked:
			{
				pBar.addClass("chnFaded");
				pCheck.addClass("chnChecked");
				if (O.Options.bol_hideChecked)
				{
					pBar.hide();
				}
			} break;
			case X.ChecklistEnum.Disabled:
			{
				pBar.hide();
			} break;
		}
		
		// Chain time
		if (C.isChainRegular(C.Chains[pIndex]) &&
			X.getChecklistItem(X.Checklists.ChainSubscription, pIndex) === X.ChecklistEnum.Checked)
		{
			pTime.addClass("chnTimeSubscribed");
		}
	},
	reapplyChainIconState: function(pChain, pIcon, pWantHide)
	{
		switch (X.getChecklistItem(X.Checklists.Chain, pChain.nexus))
		{
			case X.ChecklistEnum.Unchecked:
			{
				pIcon.removeClass("chnFaded");
			} break;
			case X.ChecklistEnum.Checked:
			{
				pIcon.addClass("chnFaded");
			} break;
			case X.ChecklistEnum.Disabled:
			{
				if (pWantHide)
				{
					pIcon.hide();
				}
				else
				{
					pIcon.addClass("chnFaded");
				}
			} break;
		}
	},
	hideCheckedChainBar: function(pIndex)
	{
		var display = (I.ModeCurrent === I.ModeEnum.Tile) ? "inline-block" : "block";
		// Hide the chain bar if opted
		if (X.getChecklistItem(X.Checklists.Chain, pIndex) === X.ChecklistEnum.Checked)
		{
			if (O.Options.bol_hideChecked)
			{
				$("#chnBar_" + pIndex).hide("fast");
				$(".chnSlot_" + pIndex).hide("fast");
			}
			else
			{
				$("#chnBar_" + pIndex).show("fast").css({display: display});
				$(".chnSlot_" + pIndex).each(function()
				{
					$(this).show("fast").css({display: display});
					if ($(this).hasClass("tmlIcon"))
					{
						$(this).css({display: "inline-block"});
					}
				});
			}
		}
	},
	
	/*
	 * Gets the checklist state of a chain.
	 * @param object pChain chain to test.
	 * @returns int state (use enum).
	 */
	getChainChecklistState: function(pChain)
	{
		return X.getChecklistItem(X.Checklists.Chain, pChain.nexus);
	},
	
	/*
	 * Prepares the personal checklist presentation.
	 */
	initializePersonalChecklist: function()
	{
		/*
		 * Setting this boolean will tell the clock ticker function to call the
		 * HTML timer update function.
		 */
		T.isChecklistCountdownsStarted = true;
		T.updateChecklistCountdowns();
		
		// Initially, only show the daily checklist; user clicks the buttons to toggle the various checklists
		$("#chlDungeon, #chlCustomWeekly").hide();
		
		// Buttons to toggle view between daily and weekly checklist
		var tabs = $("#chlCustomTabs button");
		var contcust = $("#chlCustom");
		var contdung = $("#chlDungeon");
		var contraid = $("#chlRaid");
		var chldaily = $("#chlCustomDaily");
		var chlweekly = $("#chlCustomWeekly");
		var clkdaily = $("#chlCountdownToDaily").hide();
		var clkweekly = $("#chlCountdownToWeekly").hide();
		var showChecklist = function(pTab, pContainer, pChecklist, pClock)
		{
			tabs.removeClass("btnActive");
			pTab.addClass("btnActive");
			contcust.hide();
			contdung.hide();
			contraid.hide();
			chldaily.hide();
			chlweekly.hide();
			clkdaily.hide();
			clkweekly.hide();
			pClock.show();
			pContainer.show();
			pChecklist.show().css({opacity: 0.5}).animate({opacity: 1}, 400);
		};
		
		$("#chlDungeonButton").click(function()
		{
			showChecklist($(this), contdung, contdung, clkdaily);
		});
		$("#chlCustomDailyButton").click(function()
		{
			showChecklist($(this), contcust, chldaily, clkdaily);
		}).trigger("click");
		$("#chlCustomWeeklyButton").click(function()
		{
			showChecklist($(this), contcust, chlweekly, clkweekly);
		});
		$("#chlRaidButton").click(function()
		{
			showChecklist($(this), contraid, contraid, clkweekly);
		});
		
		// Initialize the checklists
		X.initializeDungeonChecklist();
		X.initializeCustomChecklist();
		X.initializeRaidChecklist();
		X.rewrapCheckboxes();
	},
	
	/*
	 * Binds dungeon checkbox storage and calculator behavior.
	 */
	initializeDungeonChecklist: function()
	{
		X.initializeChecklist(X.Checklists.Dungeon, $("#chlDungeon input").length);
		// Load icons
		$("#chlDungeon .chlDungeonBar").each(function()
		{
			$(this).prepend("<ins class='chl_dungeon chl_" + $(this).data("name").toLowerCase() + "'></ins>");
		});
		
		var updateCalculator = function()
		{
			var money = X.Checklists.Dungeon.money;
			var gold = ~~(money / E.Exchange.COPPER_IN_GOLD);
			var silver = ~~(money / E.Exchange.SILVER_IN_GOLD) % E.Exchange.COPPER_IN_SILVER;
			var copper = money % E.Exchange.COPPER_IN_SILVER;
			$("#chlDungeonCalculator_Gold").text(gold);
			$("#chlDungeonCalculator_Silver").text(silver);
			$("#chlDungeonCalculator_Copper").text(copper);
		};
		
		// Update checkbox visual and do the calculation when clicked
		$("#chlDungeon input").each(function(iIndex)
		{
			// Bind checkbox behavior
			$(this).change(function()
			{
				var state = X.getCheckboxEnumState($(this));
				X.setChecklistItem(X.Checklists.Dungeon, iIndex, state);
				X.setCheckboxStyle(X.Checklists.Dungeon, iIndex, $(this));
				
				// Sum the checkbox's path money
				var calc = $("#chlDungeonCalculator");
				var money = X.Checklists.Dungeon.money;
				var sum = $(this).data("money");
				
				switch ($(this).data("mode"))
				{
					case "E": sum += calc.data("moneyaddexp"); break;
				}
				
				switch (state)
				{
					case X.ChecklistEnum.Disabled:
					{
						X.Checklists.Dungeon.money = money - sum;
					} break;
					case X.ChecklistEnum.Checked:
					{
						X.Checklists.Dungeon.money = money + sum;
					} break;
					default:
					{
						X.Checklists.Dungeon.money = money - sum;
					}
				}
				updateCalculator();
			});
		});
		// Double click a label (which wraps an input tag) to en/disable the checkbox
		$("#chlDungeon label").each(function(iIndex)
		{
			$(this).dblclick(function()
			{
				var checkbox = $(this).find("input:first-child");

				if (checkbox.prop("disabled") === false)
				{
					/*
					 * The double click triggers the click event, which causes
					 * the calculator to count the disabled checkbox, so trigger
					 * the unchecking of it first before disabling.
					 */
					if (checkbox.prop("checked") === true)
					{
						X.triggerCheckbox(checkbox, X.ChecklistEnum.Unchecked);
					}
					checkbox.prop("disabled", true).prop("checked", false);
				}
				else
				{
					checkbox.prop("disabled", false);
				}
				X.setChecklistItem(X.Checklists.Dungeon, iIndex, X.getCheckboxEnumState(checkbox));
				X.setCheckboxStyle(X.Checklists.Dungeon, iIndex, checkbox);
			});
		});
		
		// Restore checklist state from stored by triggering the checkboxes (behaviors already bound)
		$("#chlDungeon input").each(function(iIndex)
		{
			X.triggerCheckboxEnumState(X.Checklists.Dungeon, iIndex, $(this));
		});
		
		// Bind uncheck all button
		$("#chlDungeonUncheck").click(function()
		{
			X.clearChecklist(X.Checklists.Dungeon, X.ChecklistJob.UncheckTheChecked);
			$("#chlDungeon input").each(function(iIndex)
			{
				if ($(this).prop("checked") === true)
				{
					$(this).trigger("click");
				};
				X.setCheckboxStyle(X.Checklists.Dungeon, iIndex, $(this));
			});
		});
	},
	
	/*
	 * Binds raid checkbox storage.
	 */
	initializeRaidChecklist: function()
	{
		X.initializeCheckboxlist(X.Checklists.Raid, $("#chlRaid input"), X.ChecklistJob.UncheckAll, $("#chlRaidUncheck"));
		// Load icons
		$("#chlRaid input").each(function()
		{
			$(this).before("<ins class='chl_raid chl_" + $(this).data("name") + "'></ins>");
		});
	},
	
	/*
	 * Binds checkbox and text field joined behavior.
	 */
	initializeCustomChecklist: function()
	{
		// Generate initial set of checkboxes and textboxes
		var checkitemhtml = "<li><label><input type='checkbox' />" + I.Symbol.Filler + "</label><input class='cssInputTextLine' type='text' /></li>";
		var dailylist = $("#chlCustomListDaily");
		var weeklylist = $("#chlCustomListWeekly");
		for (var i = 0; i < O.Options.int_numChecklistDaily; i++)
		{
			dailylist.append(checkitemhtml);
		}
		for (var i = 0; i < O.Options.int_numChecklistWeekly; i++)
		{
			weeklylist.append(checkitemhtml);
		}
		
		var insertSampleList = function(pList)
		{
			var samples = pList.attr("data-samples").split(I.cTextDelimiterChar);
			for (var i = 0; i < samples.length; i++)
			{
				pList.find("input[type='text']:eq(" + i + ")").val(samples[i]);
			}
		};
		insertSampleList(dailylist);
		insertSampleList(weeklylist);
		
		// Bind checkboxes and textboxes behavior
		var bindCustomChecklistBehavior = function(pChecklist, pTextlist, pListName)
		{
			var listid = "#chlCustomList" + pListName;
			var thislist = $(listid);
			var checkboxes = thislist.find("input:checkbox");
			X.initializeChecklist(pChecklist, checkboxes.length);

			checkboxes.each(function(iIndex)
			{
				$(this).change(function()
				{
					var state = X.getCheckboxEnumState($(this));

					X.setChecklistItem(pChecklist, iIndex, state);
					X.setCheckboxStyle(pChecklist, iIndex, $(this));

					var textinput = X.getCheckboxLabel($(this)).next();
					if (state === X.ChecklistEnum.Checked)
					{
						textinput.addClass("chlCustomTextChecked");
					}
					else
					{
						textinput.removeClass("chlCustomTextChecked");
					}
				});

				// Now that this checkbox is bound, trigger it as the state in checklist
				X.triggerCheckboxEnumState(pChecklist, iIndex, $(this));
			});

			// Bind uncheck all button
			$("#chlCustomUncheck" + pListName).click(function()
			{
				X.clearChecklist(pChecklist, X.ChecklistJob.UncheckTheChecked);
				thislist.find("input:checkbox").each(function(iIndex)
				{
					if ($(this).prop("checked"))
					{
						$(this).trigger("click");
					};
					X.setCheckboxStyle(pChecklist, iIndex, $(this));
				});
			});

			// Bind text fields behavior
			var restore = $("#chlCustomRestore" + pListName);
			X.initializeTextlist(pTextlist, listid + " input:text", null, 48, restore);
			X.bindTextlistSwap(thislist);
		};
		bindCustomChecklistBehavior(X.Checklists.CustomDaily, X.Textlists.CustomTextDaily, "Daily");
		bindCustomChecklistBehavior(X.Checklists.CustomWeekly, X.Textlists.CustomTextWeekly, "Weekly");
	},
	
	/*
	 * Clears the daily sensitive checklists. Called by the daily reset function.
	 */
	clearCustomChecklistDaily: function()
	{
		$("#chlCustomUncheckDaily").trigger("click");
		$("#chlDungeonUncheck").trigger("click");
		X.clearChecklist(X.Checklists.CustomDaily, X.ChecklistJob.UncheckTheChecked);
		X.clearChecklist(X.Checklists.Dungeon, X.ChecklistJob.UncheckTheChecked);
	},
	clearCustomChecklistWeekly: function()
	{
		$("#chlCustomUncheckWeekly").trigger("click");
		$("#chlRaidUncheck").trigger("click");
		X.clearChecklist(X.Checklists.CustomWeekly, X.ChecklistJob.UncheckTheChecked);
		X.clearChecklist(X.Checklists.Raid, X.ChecklistJob.UncheckTheChecked);
	},
	
	/*
	 * Binds notepad textarea behavior and button pages behavior.
	 */
	initializeNotepad: function()
	{
		// Numbered buttons' behavior
		$("#chlNotepadButtons button").each(function(iIndex)
		{
			$(this).click(function()
			{
				// Show selected number's sheet
				$("#chlNotepadSheets textarea").hide().eq(iIndex).show()
					.css({opacity: 0.5}).animate({opacity: 1}, 400);
				$("#chlNotepadButtons button").removeClass("btnActive");
				$(this).addClass("btnActive");
			});
		}).first().click(); // First sheet is default view
		
		// Bind text fields behavior
		var items = $("#chlNotepadSheets textarea");
		var restore = $("#chlNotepadRestore");
		X.initializeTextlist(X.Textlists.NotepadText, items, "Notepad sheet", 4096, restore);
		// Customize notepad according to options
		items.css("height", O.Options.int_sizeNotepadHeight);
		items.css("font-size", O.Options.int_sizeNotepadFont);
		items.first().show();
	}
};
U = {
/* =============================================================================
 * @@URL management for links and string/array/object manipulation
 * ========================================================================== */

	URL_META:
	{
		Forum: "http://forum.renaka.com/forum/368355/",
		News: "http://forum.renaka.com/topic/5500046/",
		Overlay: "http://forum.renaka.com/topic/5546166/",
		BuildNotes: "https://forum-{0}.guildwars2.com/forum/info/updates"
	},
	ScriptURLs: {}, // Associative array of script URLs, so they are not loaded again
	APIKey: null,
	APIKeyLength: 72, // The exact length of the API key in order for it to be used in the URL fragment
	ServerIDLength: 4,
	
	URL_API:
	{
		// Achievements
		Achievements: "https://api.guildwars2.com/v2/achievements",
		Daily: "https://api.guildwars2.com/v2/achievements/daily",
		Tomorrow: "https://api.guildwars2.com/v2/achievements/daily/tomorrow",
		
		// Map
		LangKey: "",
		Maps: "https://api.guildwars2.com/v1/maps",
		MapFloorTyria: "https://api.guildwars2.com/v1/map_floor.json?continent_id=1&floor=1",
		MapFloorMists: "https://api.guildwars2.com/v1/map_floor.json?continent_id=2&floor=1",
		EventDetails: "https://api.guildwars2.com/v1/event_details.json",
		
		// Exchange
		ItemListing: "https://api.guildwars2.com/v2/commerce/listings",
		ItemPrice: "https://api.guildwars2.com/v2/commerce/prices",
		ItemDetail: "https://api.guildwars2.com/v2/items",
		CoinPrice: "https://api.guildwars2.com/v2/commerce/exchange/gems?quantity=",
		GemPrice: "https://api.guildwars2.com/v2/commerce/exchange/coins?quantity=",
		
		// Guild
		Guild: "https://api.guildwars2.com/v2/guild/",
		
		// WvW
		Match: "https://api.guildwars2.com/v2/wvw/matches?world=",
		Matches: "https://api.guildwars2.com/v2/wvw/matches/",
		MatchFallback: "https://api.guildwars2.com/v1/wvw/match_details.json?match_id=",
		MatchesFallback: "https://api.guildwars2.com/v1/wvw/matches.json",
		
		// Other
		Support: "https://forum-en.guildwars2.com/forum/community/api",
		Build: "https://api.guildwars2.com/v2/build",
		Worlds: "https://api.guildwars2.com/v2/worlds",
		Prefix: "https://api.guildwars2.com/v2/",
		Prefix1: "https://api.guildwars2.com/v1/",
		TextToSpeech: "http://code.responsivevoice.org/getvoice.php?tl=",
		TextToSpeechNative: "bin/tts/mespeak.js",
		ThreeDimensional: "https://ajax.googleapis.com/ajax/libs/threejs/r76/three.min.js",
		Charts: "bin/highstock.js"
	},
	PageLimit: 200, // Number of entries per API retrieval for paginated endpoints
	IDsLimit: 200, // Max item IDs in a single fetch URL
	
	URL_IMG:
	{
		Placeholder: "img/ui/placeholder.png",
		Sector: "img/map/scope.png",
		Waypoint: "img/map/waypoint.png",
		WaypointOver: "img/map/waypoint_h.png",
		Landmark: "img/map/landmark.png",
		LandmarkOver: "img/map/landmark_h.png",
		Vista: "img/map/vista.png",
		Mastery: "img/map/mastery.png",
		Challenge: "img/map/challenge.png",
		Heart: "img/map/heart.png"
	},
	
	URL_DATA:
	{
		Maps: "cache/maps_{0}.json",
		Events: "cache/events_{0}.json",
		Account: "data/account.js",
		WvW: "data/wvw.js",
		Itinerary: "data/itinerary.js",
		Materials: "data/materials.js",
		Skins: "data/skins.js",
		Outfits: "data/outfits.js",
		Gliders: "data/gliders.js",
		Dyes: "data/dyes.js",
		Minis: "data/minis.js",
		Carriers: "data/carriers.js",
		Champions: "data/champions.js",
		Finishers: "data/finishers.js",
		Nodes: "data/nodes.js",
		Cats: "data/cats.js",
		Raids: "data/raids.js",
		Dungeons: "data/dungeons.js",
		Catalog: "data/catalog.js",
		Cleanup: "data/cleanup.js",
		Ascended: "data/ascended.js",
		Recipes: "data/recipes.js",
		SAB: "data/sab.js",
		Prices: "cache/prices.json",
		Gem:  "data/gem.js",
		Sale:  "data/sale.js",
		Museum:  "data/museum.js",
		Pact:  "data/pact.js",
		// Data to load when opening a map page section
		Unscheduled: "data/chains-add.js",
		Daily: "data/daily.js",
		DryTop: "data/drytop.js",
		Resource: "data/resource.js",
		JP: "data/jp.js",
		Collectible: "data/collectible.js",
		Guild: "data/guild.js"
	},
	
	initializeAPIURLs: function()
	{
		var lang = D.langPartiallySupported;
		U.URL_API.LangKey = "lang=" + lang;
		
		var replacekey = I.cTextReplace;
		U.URL_META.BuildNotes = U.URL_META.BuildNotes.replace(replacekey, lang);
		U.URL_DATA.Maps = U.URL_DATA.Maps.replace(replacekey, lang);
		U.URL_DATA.Events = U.URL_DATA.Events.replace(replacekey, lang);
		U.URL_API.Worlds += "?" + U.URL_API.LangKey + "&ids=";
		U.URL_API.TextToSpeech += lang + "&sv=&vn=&pitch=0.5&rate=0.4";
	},
	
	/*
	 * Analog for jQuery's getScript but with the cache option enabled.
	 * @param string pURL
	 * @param function pCallback
	 * @param boolean pWantCache
	 * @returns jqobject
	 */
	getScript: function(pURL, pCallback, pWantCache)
	{
		var wantcache = (pWantCache !== undefined) ? pWantCache : true;
		if (U.ScriptURLs[pURL] === undefined || wantcache === false)
		{
			U.ScriptURLs[pURL] = true;
			var jqxhr = $.ajax({
				dataType: "script",
				url: pURL,
				cache: wantcache,
				success: function()
				{
					if (pCallback)
					{
						pCallback();
					}
				}
			});
			return jqxhr;
		}
		else if (pCallback)
		{
			pCallback();
		}
		// Dummy jqxhr return in case of already loaded
		return {fail: function() {}};
	},
	getJSON: function(pURL, pCallback, pWantCache)
	{
		var wantcache = (pWantCache !== undefined) ? pWantCache : true;
		var jqxhr = $.ajax({
			dataType: "json",
			url: pURL,
			cache: wantcache,
			success: function(pData)
			{
				if (pCallback)
				{
					pCallback(pData);
				}
			}
		});
		return jqxhr;
	},
	
	/*
	 * Fetches all the pages of an API endpoint and combines them into a single array.
	 * @param enum pURL
	 * @objparam boolean aWantCache whether to use default caching.
	 * @objparam enum aPermission of the endpoint.
	 * @objparam function aCallback with the combined pages as parameter.
	 * @objparam function aError to execute upon failure.
	 */
	fetchPaginated: function(pURL, pSettings)
	{
		var Settings = pSettings || {};
		var scrapethreshold = 50;
		var numfetched = 0;
		var numtofetch;
		var url = pURL + "&page_size=" + U.PageLimit;
		var wantcache = (Settings.aWantCache !== undefined) ? Settings.aWantCache : false;
		var pages = [];
		var book = [];
		
		var combinePages = function()
		{
			if (numfetched !== numtofetch)
			{
				return;
			}
			pages.forEach(function(iPage)
			{
				if (iPage)
				{
					book = book.concat(iPage);
				}
			});
			// Return the result in the callback
			Settings.aCallback(book);
		};
		
		$.ajax({
			dataType: "json",
			url: url,
			cache: wantcache,
			success: function(pData, pStatus, pXHR)
			{
				// First retrieval fetches the first page, which also tells how many pages there are
				numfetched++;
				numtofetch = parseInt(pXHR.getResponseHeader("X-Page-Total"));
				if (numtofetch > scrapethreshold) // If the number of pages to fetch is too large then delegate to the scrape function
				{
					var pagenumbers = [];
					for (var i = 1; i < numtofetch; i++)
					{
						pagenumbers.push(i);
					}
					Z.scrapeAPIArray(url + "&page=", pagenumbers, {
						aIsStandard: false,
						aCooldown: 30,
						aNumRetries: 10,
						aCallback: function(pPages)
					{
						book = book.concat(pData);
						pPages.forEach(function(iPage)
						{
							book = book.concat(iPage);
						});
						Settings.aCallback(book);
					}});
				}
				else if (numtofetch > 1)
				{
					pages = new Array(numtofetch);
					pages[0] = pData;
					// Fetch the rest of the pages and insert them to the sequential array
					for (var i = 1; i < numtofetch; i++)
					{
						(function(iIndex)
						{
							$.ajax({
								dataType: "json",
								url: url + "&page=" + iIndex,
								cache: wantcache,
								success: function(pDataInner)
								{
									pages[iIndex] = pDataInner;
									numfetched++;
									combinePages();
								},
								error: function()
								{
									numtofetch--;
									combinePages();
								}
							});
						})(i);
					}
				}
				else if (numtofetch === 1)
				{
					// If only one page exists then proceed with processing
					pages[0] = pData;
					combinePages();
				}
				else // No current transactions
				{
					Settings.aCallback(null);
				}
			},
			error: function(pRequest, pStatus)
			{
				if (Settings.aError)
				{
					Settings.aError();
				}
				else if (Settings.aPermission)
				{
					A.printError(Settings.aPermission, pStatus);
				}
			}
		});
	},
	
	/*
	 * Fetches multiple URLs with IDs embedded.
	 * @param string pURL with substring "{0}" to be replaced with an ID.
	 * @param array pIDs
	 */
	fetchPattern: function(pURL, pIDs, pSettings)
	{
		var Settings = pSettings || {};
		var wantcache = (Settings.aWantCache !== undefined) ? Settings.aWantCache : true;
		var data = {};
		var datasorted = {}, idata;
		var numfetched = 0;
		var numtofetch = pIDs.length;
		var finalizeFetch = function()
		{
			A.setProgressBar(numfetched, numtofetch);
			if (numfetched === numtofetch)
			{
				// Sort according to original ID order
				for (var i in pIDs)
				{
					idata = data[(pIDs[i])];
					if (idata)
					{
						datasorted[(pIDs[i])] = idata;
					}
				}
				if (Settings.aCallback)
				{
					Settings.aCallback(datasorted, numfetched);
				}
			}
		};
		
		// Fetch all at once
		for (var i = 0; i < pIDs.length; i++)
		{
			(function(iID)
			{
				U.getJSON(pURL.replace(I.cTextReplace, U.encodeURL(iID)), function(pData)
				{
					data[iID] = pData;
					numfetched++;
					finalizeFetch();
				}, wantcache).fail(function()
				{
					numtofetch--;
					finalizeFetch();
				});
			})(pIDs[i]);
		}
	},
	
	/*
	 * Bulk fetches an API endpoint using provided IDs. May recursively queue
	 * the fetches so the IDs can fit in each single URL request.
	 * @param string pURL prefix.
	 * @param array pIDs numbers.
	 * @objparam function aCallback with array of raw API objects accumulated.
	 * @objparam boolean aWantCache use browser cache from previous fetches, optional.
	 * @objparam string aLanguage code, otherwise user's language is used, optional.
	 */
	fetchAPI: function(pURL, pIDs, pSettings)
	{
		var Settings = pSettings || {};
		var wantcache = (Settings.aWantCache !== undefined) ? Settings.aWantCache : false;
		var itemids = [];
		var retarr = [];
		var failarr = [];
		var numfetched = 0;
		var numtofetch = 0;
		
		var finishFetch = function()
		{
			// Compile IDs that the API did not return
			if (itemids.length !== retarr.length)
			{
				var retids = [];
				for (var i in retarr)
				{
					if (retarr[i].id)
					{
						retids.push(retarr[i].id);
					}
				}
				failarr = U.getDifference(itemids, retids);
			}
			
			A.fillProgressBar();
			if (Settings.aCallback)
			{
				Settings.aCallback(retarr, failarr);
			}
		};
		
		var fetchArray = function(pArray, pIsRetry)
		{
			var fetchids = pArray, remainids;
			if (fetchids.length > U.IDsLimit)
			{
				fetchids = pArray.slice(0, U.IDsLimit);
				remainids = pArray.slice(U.IDsLimit);
			}
			var continueFetch = function()
			{
				if (remainids)
				{
					numfetched += U.IDsLimit;
					A.setProgressBar(numfetched, numtofetch);
					fetchArray(remainids);
				}
				else
				{
					finishFetch();
				}
			};
			
			$.ajax({
				dataType: "json",
				url: U.getLangURL(pURL, Settings.aLanguage) + "&ids=" + fetchids.join(","),
				cache: wantcache,
				success: function(pData)
				{
					retarr = retarr.concat(pData);
					continueFetch();
				},
				error: function()
				{
					// If error then retry this batch once, else continue with remainder
					if (pIsRetry)
					{
						continueFetch();
					}
					else
					{
						fetchArray(pArray, true);
					}
				}
			});
		};
		
		// First call to recursive fetch function
		if (pIDs.length)
		{
			itemids = U.getUnique(pIDs);
			numtofetch = itemids.length;
			fetchArray(itemids);
		}
		else if (Settings.aCallback)
		{
			Settings.aCallback();
		}
	},
	
	/*
	 * Gets the appropriate query string divider for a URL.
	 * @param string pURL.
	 * @param string pLanguage code to use instead of the user's, optional.
	 * @returns string
	 */
	getDivider: function(pURL)
	{
		return (pURL.indexOf("?") !== -1) ? "&" : "?";
	},
	getLangURL: function(pURL, pLanguage)
	{
		return pURL + U.getDivider(pURL) + (pLanguage ? ("lang=" + pLanguage) : U.URL_API.LangKey);
	},
	
	/*
	 * Gets the language specific URL of a standard v2 API that requires an ID.
	 * @param string pAPI endpoint name.
	 * @param int pID for request, if provided "true" then will use "all" query.
	 * @returns string URL to request data.
	 */
	getAPI: function(pAPI, pID)
	{
		var idstr = (pID === undefined) ? "" : ((pID === true) ? "?ids=all" : "/" + pID);
		return U.getLangURL(U.URL_API.Prefix + pAPI + idstr);
	},
	getAPIURL: function(pAPI)
	{
		return U.URL_API.Prefix + pAPI.toLowerCase();
	},
	getAPIMap: function(pID)
	{
		return U.getAPI("maps", pID);
	},
	getAPIAchievement: function(pID)
	{
		return U.getAPI("achievements", pID);
	},
	getAPIItem: function(pID)
	{
		return U.getAPI("items", pID);
	},
	getAPISkin: function(pID)
	{
		return U.getAPI("skins", pID);
	},
	getAPIRecipe: function(pID)
	{
		return U.getAPI("recipes", pID);
	},
	getAPIMaterial: function(pID)
	{
		return U.getAPI("materials", pID);
	},
	getAPIMini: function(pID)
	{
		return U.getAPI("minis", pID);
	},
	getAPISkill: function(pID)
	{
		return U.getAPI("skills", pID);
	},
	getAPITrait: function(pID)
	{
		return U.getAPI("traits", pID);
	},
	getAPISpecialization: function(pID)
	{
		return U.getAPI("specializations", pID);
	},
	getAPITitle: function(pID)
	{
		return U.getAPI("titles", pID);
	},
	getAPIPrice: function(pID)
	{
		return U.URL_API.ItemPrice + "/" + pID;
	},
	getAPIListings: function(pID)
	{
		return U.URL_API.ItemListing + "/" + pID;
	},
	
	/*
	 * Gets URL to retrieve the local items database.
	 * @param string pLanguage code.
	 * @returns string.
	 */
	getDatabaseURL: function(pName, pLanguage)
	{
		return "test/" + pName + "_" + pLanguage + I.cTXT;
	},
	getItemsDatabaseURL: function(pLanguage)
	{
		return "test/items_" + pLanguage + I.cTXT;
	},
	getDataScriptURL: function(pName)
	{
		return "data/" + pName.toLowerCase() + ".js";
	},
	getCacheURL: function(pName, pLanguage)
	{
		return "cache/" + pName.toLowerCase() + "_" + (pLanguage || D.langPartiallySupported) + I.cJSON;
	},
	getRecordHeader: function(pName)
	{
		return window["GW2T_" + pName.toUpperCase() + "_HEADERS"];
	},
	getRecordMetadata: function(pName)
	{
		return window["GW2T_" + pName.toUpperCase() + "_METADATA"];
	},
	getRecordBlacklist: function(pName)
	{
		return window["GW2T_" + pName.toUpperCase() + "_BLACKLIST"];
	},
	getRecordData: function(pName)
	{
		return window["GW2T_" + pName.toUpperCase() + "_DATA"];
	},

	/*
	 * URLArguments (Args) may contain Options object's variables. In the form of:
	 * http://example.com/?ExampleKey=ExampleValue&MoreExampleKey=MoreExampleValue
	 * so http://gw2timer.com/?bol_showPanel=false will hide the side panel
	 * regardless of previous localStorage or the defaults here.
	 * Note that "bol_showPanel" matches exactly as in the Options, otherwise
	 * it would have not overridden any Options variable. Values used apart from
	 * comparison should be sanitized first.
	 */
	Args: {},
	KeyEnum:
	{
		Page: "page",
		Section: "section",
		Article: "article",
		Mode: "mode",
		Go: "go",
		Draw: "draw",
		Fragment: "fragment",
		AutoAudit: "isAutoAudit"
	},
	
	/*
	 * Data type enum.
	 */
	TypeEnum:
	{
		isObject: "obj",
		isAssoc: "asc",
		isArray: "arr",
		isString: "str",
		isEnum: "enu",
		isInteger: "int",
		isFloat: "flt",
		isBoolean: "bol"
	},
	
	/*
	 * Capitalization case style enum.
	 */
	CaseEnum:
	{
		Original: -1,
		None: 0,
		Lower: 1,
		Sentence: 2,
		Title: 3,
		Every: 4,
		Upper: 5
	},
	
	/*
	 * Tells if a string is an enum of an enum object.
	 * @param string pString to test for inclusion.
	 * @param object pEnum container of enums.
	 * @returns boolean true if within.
	 */
	isEnumWithin: function(pString, pEnum)
	{
		for (var i in pEnum)
		{
			if (pEnum[i].toLowerCase() === pString.toLowerCase())
			{
				return true;
			}
		}
		return false;
	},
	
	/*
	 * Extracts arguments from a https://en.wikipedia.org/wiki/Query_string
	 * @returns object containing the key-value pairs.
	 */
	convertQueryString: function(pString)
	{
		var urlargs = pString.substr(1).split("&"); // Skip the "?" at the beginning of the query string
		if (urlargs === "")
		{
			return {};
		}
		
		var argsobject = {};
		for (var i = 0; i < urlargs.length; ++i)
		{
			var pair = urlargs[i].split("=");
			if (pair.length !== 2)
			{
				continue;
			}
			argsobject[pair[0]] = decodeURIComponent(pair[1].replace(/\+/g, " "));
		}
		return argsobject;
	},
	getURLArguments: function()
	{
		var loc = window.location;
		var argsobject = U.convertQueryString(loc.search);
		// The URL substring after # will be assigned to the fragment key
		if (loc.hash.length)
		{
			argsobject[U.KeyEnum.Fragment] = loc.hash.substr(1);
		}
		return argsobject;
	},
	
	/*
	 * Parses and stores the URL arguments then do appropriate changes.
	 */
	enforceURLArgumentsFirst: function()
	{
		U.Args = U.getURLArguments();
		I.cSiteTitle = document.title;
		// Store article value, if exists
		I.ArticleCurrent = U.Args[U.KeyEnum.Article];
		U.Args[U.KeyEnum.Article] = null;
		// Manage special URLs
		U.enforceURLArgumentsSpecial();
		
		var i;
		// Set up program mode
		var mode = U.Args[U.KeyEnum.Mode];
		if (mode)
		{
			for (i in I.ModeEnum)
			{
				if (I.ModeEnum[i].toLowerCase() === mode.toLowerCase())
				{
					I.ModeCurrent = I.ModeEnum[i];
					break;
				}
			}
		}
		
		if (I.ModeCurrent === null)
		{
			I.ModeCurrent = I.ModeEnum.Website;
		}
	},
	
	/*
	 * Does the commands within the address bar after the site's domain name.
	 * @pre URLArguments object was initialized by extraction.
	 */
	enforceURLArgumentsLast: function()
	{
		U.interpretPage(U.Args[U.KeyEnum.Page]);
	},
	
	/*
	 * Special URL keys that override others.
	 */
	enforceURLArgumentsSpecial: function()
	{
		/*
		 * The page key could've been written by the 404 webpage, which converts
		 * forward slash (/) separated directories into query strings, with
		 * the first argument as the page value. So if a user goes to the URL
		 * http://gw2timer.com/navi they will be redirected to http://gw2timer.com/?page=Navi
		 * These special pages must have unique names from the content pages.
		 */
		var i, ii;
		var ithpage;
		var go = function(pURL)
		{
			$("body").hide();
			document.location = pURL;
		};
		var page = U.Args[U.KeyEnum.Page];
		var fragment = U.Args[U.KeyEnum.Fragment];
		// Analyze URL fragment identifier
		if (fragment)
		{
			// If fragment looks like an API key
			if (fragment.length === U.APIKeyLength)
			{
				U.APIKey = U.stripToAlphanumericDash(fragment).toUpperCase();
				if (page === undefined)
				{
					U.Args[U.KeyEnum.Page] = I.SpecialPageEnum.Account;
				}
			}
		}
		// Analyze the page query
		if (page)
		{
			page = page.toLowerCase();
			// If page is a shortcut alias for a real page
			if (page === "a")
			{
				U.Args[U.KeyEnum.Page] = I.SpecialPageEnum.Account;
			}
			else if (page === "audit")
			{
				U.Args[U.KeyEnum.Page] = I.SpecialPageEnum.Account;
				U.Args[U.KeyEnum.Section] = I.PageEnum.Account.Characters;
				I.ArticleCurrent = I.SpecialPageEnum.Audit;
			}
			// Only proceed if "page" is not an actual content page
			else if (U.isEnumWithin(page, I.PlateEnum) === false)
			{
				if (page === "forum" || page === "forums")
				{
					go(U.URL_META.Forum);
				}
				if (page === "navi" || page === "overlay")
				{
					go(U.URL_META.Overlay);
				}
				else if (page === "m" || page === "mobile")
				{
					U.Args[U.KeyEnum.Mode] = I.ModeEnum.Mobile;
				}
				else if (page === "s" || page === "simple")
				{
					U.Args[U.KeyEnum.Mode] = I.ModeEnum.Simple;
				}
				else if (page === "t" || page === "tile")
				{
					U.Args[U.KeyEnum.Mode] = I.ModeEnum.Tile;
				}
				else if (page === "draw")
				{
					localStorage["bol_showWorldCompletion"] = "true";
					U.Args[U.KeyEnum.Page] = I.PlateEnum.Map;
					U.Args[U.KeyEnum.Draw] = U.Args[U.KeyEnum.Section];
				}
				else
				{
					// Check if is a page's section
					for (i in I.PageEnum)
					{
						ithpage = I.PageEnum[i];
						for (ii in ithpage)
						{
							if (ii.toLowerCase() === page)
							{
								// Page part becomes the section, section part becomes the article
								if (U.Args[U.KeyEnum.Section] !== undefined)
								{
									I.ArticleCurrent = U.Args[U.KeyEnum.Section];
								}
								U.Args[U.KeyEnum.Page] = i;
								U.Args[U.KeyEnum.Section] = ii;
								return;
							}
						}
					}
					// Check if is a server ID
					if (isNaN(page) === false && page.length === U.ServerIDLength)
					{
						for (var i in O.OptionEnum.Server)
						{
							if (O.OptionEnum.Server[i] === page)
							{
								U.Args["enu_Server"] = page;
								U.Args[U.KeyEnum.Page] = I.SpecialPageEnum.WvW;
								return;
							}
						}
					}
				}
			}
		}
		// Remember the initial page when the site loaded
		if (U.Args[U.KeyEnum.Page] !== undefined)
		{
			I.PageInitial = U.Args[U.KeyEnum.Page].toLowerCase();
		}
		
		// Check if the special page is actually a collectible
		for (i in X.Collectibles)
		{
			ithpage = X.Collectibles[i].urlkey;
			if (ithpage === page || U.Args[ithpage] !== undefined)
			{
				U.Args[U.KeyEnum.Page] = I.PlateEnum.Map;
				U.Args[U.KeyEnum.Section] = I.PageEnum.Map.Collectible;
				// Setting the article key will tell the generate collectibles function to do so for that one
				I.ArticleCurrent = ithpage;
				return;
			}
		}
		// Check if is a zone name
		if (page)
		{
			for (i in M.Zones)
			{
				if (page.indexOf(i) !== -1)
				{
					U.Args[U.KeyEnum.Go] = i;
					return;
				}
			}
		}
	},
	
	/*
	 * Tells if the current article variable matches the requesting initialization
	 * function before "opening" parts of the section automatically.
	 * @param string pArticle.
	 * @returns boolean.
	 */
	verifyArticle: function(pArticle, pCallback)
	{
		if (I.ArticleCurrent && I.ArticleCurrent.toLowerCase() === pArticle.toLowerCase())
		{
			I.ArticleCurrent = null;
			if (pCallback)
			{
				pCallback();
			}
			return true;
		}
		return false;
	},
	nullifyArticle: function()
	{
		I.ArticleCurrent = null;
	},
	
	/*
	 * Triggers the button or header associated with the requested page and section,
	 * which will cause that section to expand/show. This is to be called after
	 * a page has been AJAX loaded and bindings completed.
	 * @objparam string aPrefix HTML ID prefix of the button to trigger, optional.
	 * @objparam string aSection name to override URL's, optional.
	 * @objparam string aInitialSection to open initially, optional.
	 * @objparam string aButton HTML ID of the button to trigger, optional.
	 */
	openSectionFromURL: function(pSettings)
	{
		var Settings = $.extend({
			aPrefix: I.cHeaderPrefix + I.PageCurrent + "_",
			aSection: null,
			aInitialSection: null,
			aButton: null
		}, pSettings);
		
		/*
		 * Enclosed in setTimeout because without it the scroll to element
		 * animation function is glitchy (the function is called when the header
		 * is clicked so the page automatically scrolls to the header).
		 */
		setTimeout(function()
		{
			var section = (U.Args[U.KeyEnum.Section]) ? (U.Args[U.KeyEnum.Section]).toString() : null;
			// If section was specified in the URL arguments
			if (section)
			{
				U.Args[U.KeyEnum.Section] = null; // Use once only
				section = U.stripToAlphanumeric(section);
				var elm = $(null);
				if (typeof Settings.aButton === "string")
				{
					if (Settings.aSection !== undefined
						&& Settings.aSection.toLowerCase() === section.toLowerCase())
					{
						elm = $(Settings.aButton);
					}
				}
				else
				{
					// Try going to a section name in sentence letter case
					elm = $(Settings.aPrefix + U.toFirstUpperCase(section));
					if ( ! elm.length)
					{
						// Else try going to a section name in all caps
						elm = $(Settings.aPrefix + section.toUpperCase());
					}
					if (I.PageCurrent === I.PlateEnum.Chains)
					{
						// Click the chains header to hide it because it's shown by default
						$("#headerChains_Scheduled").trigger("click");
					}
				}
				elm.trigger("click");
			}
			// If section was specified by the function call
			else if (typeof Settings.aInitialSection === "string")
			{
				$(Settings.aPrefix + Settings.aInitialSection).trigger("click");
			}
		}, 0);
	},
	
	/*
	 * Automatically opens a "page" for the user, whether the content is generated or not.
	 * @param enum pPage
	 */
	interpretPage: function(pPage)
	{
		if (typeof pPage !== "string")
		{
			return;
		}
		var page = U.toFirstUpperCase(pPage);
		var pagecaps = pPage.toUpperCase();
		var pagebutton;
		var isaccountvisible = $("#panelAccount").is(":visible");
		var iswvwvisible = P.MapSwitchWebsite === P.MapEnum.Mists;
		var viewMap = function()
		{
			// Close the account panel in order to see the map
			if (isaccountvisible)
			{
				I.toggleAccount();
			}
			// Switch to PvE map if viewing WvW
			if (iswvwvisible)
			{
				I.switchMap();
			}
		};
		var viewWvW = function()
		{
			// Close the account panel in order to see the map
			if (isaccountvisible)
			{
				I.toggleAccount();
			}
			// Switch to WvW map if viewing PvE
			if (iswvwvisible === false)
			{
				I.switchMap(page);
			}
		};
		var viewAccount = function(page)
		{
			pagebutton = $("#accMenu_" + page);
			if (pagebutton.length)
			{
				if (isaccountvisible === false)
				{
					I.toggleAccount();
				}
				pagebutton.trigger("click");
			}
			else
			{
				I.toggleAccount();
				I.loadAccountPanel(page);
			}
		};
		
		// PLATE
		if (I.PlateEnum[page])
		{
			$(I.cPlateMenuPrefix + page).trigger("click");
			if (page === I.PlateEnum.Chains || page === I.PlateEnum.Map)
			{
				viewMap();
			}
		}
		// PLATE SECTION: Map
		else if (I.PageEnum.Map[page] || I.PageEnum.Map[pagecaps])
		{
			page = (I.PageEnum.Map[pagecaps]) ? pagecaps : page;
			if (I.Directory.Map[page])
			{
				viewMap();
			}
			// View the map section if already loaded, otherwise load then view
			pagebutton = $("#plateBeamIcon_" + page);
			if (pagebutton.length)
			{
				$(I.cPlateMenuPrefix + I.PlateEnum.Map).trigger("click");
				pagebutton.trigger("click");
			}
			else
			{
				I.loadMapPlate(page);
			}
		}
		// PLATE SECTION: Chains
		else if (I.PageEnum.Chains[page] || I.PageEnum.Chains[pagecaps])
		{
			page = (I.PageEnum.Chains[pagecaps]) ? pagecaps : page;
			viewMap();
			$(I.cPlateMenuPrefix + I.PlateEnum.Chains).trigger("click");
			I.openChainsSection(page);
		}
		// ACCOUNT SECTION
		else if (I.PageEnum.Account[page] || I.PageEnum.Account[pagecaps] || page === I.SpecialPageEnum.Account)
		{
			page = (I.PageEnum.Account[pagecaps]) ? pagecaps : page;
			viewAccount(page);
		}
		// SPECIAL PAGE: Audit
		else if (page === I.SpecialPageEnum.Audit)
		{
			if ($("#audExecute").is(":visible"))
			{
				$("#audExecute").trigger("click");
			}
			else
			{
				I.ArticleCurrent = I.SpecialPageEnum.Audit;
				viewAccount(I.PageEnum.Account.Characters);
			}
		}
		// SPECIAL PAGE: WvW
		else if (page === U.toFirstUpperCase(I.SpecialPageEnum.WvW))
		{
			viewWvW();
		}
		// SPECIAL PAGE: Leaderboard
		else if (page === I.SpecialPageEnum.Leaderboard)
		{
			// Switch to WvW map if viewing PvE
			if (iswvwvisible)
			{
				$("#lboRegion").trigger("click");
			}
			viewWvW();
		}
		// MODE
		else if (I.ModeEnum[page])
		{
			document.location = "./?mode=" + page;
		}
	},
	
	/*
	 * Sanitizes URLArguments value part before overriding. For example:
	 * http://gw2timer.com/?bol_showPanel=falsse "falsse" defaults to "true"
	 * @param string pKey of an option.
	 * @param string pValue of that option.
	 * @returns string sanitized value.
	 * @pre The key-value pair matches the Options object's, and numeric values
	 * have the OptionRange object initialized for legal numbers.
	 */
	sanitizeURLOptionsValue: function(pKey, pValue)
	{
		var datatype = pKey.substring(0, O.cLengthOfPrefixes);
		var s = pValue.toLowerCase();
		switch (datatype)
		{
			case U.TypeEnum.isBoolean:
			{
				if (s === "true" || s === "false")
				{
					return s;
				}
				return O.Options[pKey].toString(); // Default boolean
			} break;
			case U.TypeEnum.isInteger:
			{
				if (isFinite(s)) // Is a number
				{
					var theinteger = parseInt(s);
					if (theinteger >= O.OptionRange[pKey][0] && theinteger <= O.OptionRange[pKey][1])
					{
						return theinteger.toString();
					}
				}
				return O.Options[pKey].toString(); // Default number
			} break;
			case U.TypeEnum.isFloat:
			{
				if (isFinite(s)) // Is a number
				{
					var thefloat = parseFloat(s);
					if (thefloat >= O.OptionRange[pKey][0] && thefloat <= O.OptionRange[pKey][1])
					{
						return thefloat.toString();
					}
				}
				return O.Options[pKey].toString(); // Default number
			} break;
			case U.TypeEnum.isEnum:
			{
				return O.validateEnum(pKey, pValue);
			} break;
			case U.TypeEnum.isString:
			{
				return U.escapeHTML(pValue);
			} break;
		}
		return "null";
	},
	
	/*
	 * Sorts an array of objects by the provided key name, or language name if not.
	 * @param array pObjects.
	 * @objparam string aKeyName to key of each property to sort by.
	 * @objparam boolean aIsDescending order, optional. Ascending is default order.
	 * @objparam boolean aIsNumbers whether to interpret the keys as integers.
	 */
	sortObjects: function(pObjects, pSettings)
	{
		var Settings = pSettings || {};
		var key = (Settings.aKeyName) ? Settings.aKeyName : D.getNameKey();
		if (Settings.aIsDescending)
		{
			pObjects.sort(function(a, b)
			{
				var valA = (Settings.aIsNumbers && typeof a[key] === "string") ? U.stripToNumbers(a[key]) : a[key];
				var valB = (Settings.aIsNumbers && typeof b[key] === "string") ? U.stripToNumbers(b[key]) : b[key];
				if (valA < valB)
				{
					return 1;
				}
				if (valA > valB)
				{
					return -1;
				}
				return 0;
			});
		}
		else
		{
			pObjects.sort(function(a, b)
			{
				var valA = (Settings.aIsNumbers && typeof a[key] === "string") ? U.stripToNumbers(a[key]) : a[key];
				var valB = (Settings.aIsNumbers && typeof b[key] === "string") ? U.stripToNumbers(b[key]) : b[key];
				if (valA > valB)
				{
					return 1;
				}
				if (valA < valB)
				{
					return -1;
				}
				return 0;
			});
		}
	},
	
	/*
	 * Sorts an array of integers.
	 * @param array pArray.
	 */
	sortAscending: function(pArray)
	{
		pArray.sort(function(a, b) {
			return a - b;
		});
	},
	sortDescending: function(pArray)
	{
		pArray.sort(function(a, b) {
			return b - a;
		});
	},
	
	/*
	 * Converts an array of objects into an associative array accessible by
	 * one of their property acting as the key name.
	 * @param array pArray.
	 * @param string pKeyName to find in each object.
	 * @returns object.
	 * @pre Array has no duplicates sharing the same key.
	 */
	convertArrayToAssoc: function(pArray, pKeyName)
	{
		var assoc = {};
		var keyname = pKeyName || "id";
		var obj;
		for (var i = 0; i < pArray.length; i++)
		{
			obj = pArray[i];
			assoc[obj[keyname]] = obj;
		}
		return assoc;
	},
	convertAssocToArray: function(pAssoc, pKeyName)
	{
		var arr = [];
		if (pKeyName)
		{
			// An array of objects, with key assigned as a property of each object
			for (var i in pAssoc)
			{
				(pAssoc[i])[pKeyName] = i;
				arr.push(pAssoc[i]);
			}
		}
		else
		{
			// An array of keys
			for (var i in pAssoc)
			{
				arr.push(i);
			}
		}
		return arr;
	},
	convertAssocToInts: function(pAssoc)
	{
		var arr = [];
		for (var i in pAssoc)
		{
			arr.push(parseInt(i));
		}
		return arr;
	},
	
	/*
	 * Converts an array of keys into an existence associative array.
	 * @param array pArray
	 * @param object pFilterAssoc to filter in matching keys, optional
	 * @returns object
	 */
	getExistAssoc: function(pArray, pFilterAssoc)
	{
		// Element itself is the key
		var assoc = {};
		var entry;
		for (var i = 0; i < pArray.length; i++)
		{
			entry = pArray[i];
			if (pFilterAssoc === undefined || (pFilterAssoc && pFilterAssoc[entry]))
			{
				assoc[entry] = true;
			}
		}
		return assoc;
	},
	
	/*
	 * Gets elements that array A and B do not share.
	 * @param array pArrayA.
	 * @param array pArrayB.
	 * @returns array of difference.
	 */
	getDifference: function(pArrayA, pArrayB)
	{
		return pArrayA.concat(pArrayB).filter(function(iElm, iIndex, iArr){
			return iArr.indexOf(iElm) === iArr.lastIndexOf(iElm);
		});
	},
	getUnique: function(pArray)
	{
		return pArray.filter(function(iElm, iIndex)
		{
			return pArray.indexOf(iElm) === iIndex;
		});
	},
	getUnion: function(pArrayA, pArrayB)
	{
		return U.getUnique(pArrayA.concat(pArrayB));
	},
	getRandomElement: function(pArray)
	{
		if (pArray.length)
		{
			var randind = T.getRandomIntRange(0, pArray.length - 1);
			return pArray[randind];
		}
		return null;
	},
	
	/*
	 * Gets the length of a uniform associative array object.
	 * @param object pObject to count.
	 * @returns int number of subobjects in object.
	 */
	getObjectLength: function(pObject)
	{
		var count = 0;
		for (var i in pObject)
		{
			count++;
		}
		return count;
	},
	
	/*
	 * Converts an integer to boolean.
	 * @param int pInteger to convert.
	 * @returns boolean true only if integer is greater than 0.
	 */
	intToBool: function(pInteger)
	{
		if (pInteger > 0)
		{
			return true;
		}
		return false;
	},
	boolToInt: function(pBoolean)
	{
		if (pBoolean)
		{
			return 1;
		}
		return 0;
	},
	stringToBool: function(pString)
	{
		if (pString.toLowerCase() === "true")
		{
			return true;
		}
		return false;
	},
	boolToString: function(pBoolean)
	{
		if (pBoolean)
		{
			return "true";
		}
		return "false";
	},
	randomBool: function()
	{
		return (Math.random() > 0.5) ? true : false;
	},
	isInteger: function(pValue)
	{
		return !isNaN(pValue) && (function(x) { return (x | 0) === x; })(parseFloat(pValue));
	},
	isObject: function(pValue)
	{
		if (pValue && Object.prototype.toString.call(pValue) === "[object Object]")
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Returns false if object is undefined or null or falsy, otherwise true.
	 * @param object pObject to test.
	 * @returns boolean whether object exists.
	 */
	objToBool: function(pObject)
	{
		if (pObject)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Converts an RGB array to a CSS hex code.
	 * @param intarray pRGB.
	 * @returns string hexadecimal color.
	 */
	convertRGBToHex: function(pRGB)
	{
		var str = "", num;
		for (var i = 0; i < pRGB.length; i++)
		{
			num = parseInt(pRGB[i]);
			str += ((num < T.cBASE_16) ? "0" : "") + num.toString(T.cBASE_16);
		}
		return "#" + str;
	},
	getRGBToHex: function(pString)
	{
		var numbers = pString.split(",");
		return U.convertRGBToHex([U.stripToNumbers(numbers[0]), U.stripToNumbers(numbers[1]), U.stripToNumbers(numbers[2])]);
	},
	convertHexToRGB: function(pHex)
	{
		// Source: http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
		var hex = (typeof pHex === "string" && pHex.charAt(0) === "#") ? pHex.substring(1, pHex.length) : pHex;
		var bigint = parseInt(hex, 16);
		var r = (bigint >> 16) & 255;
		var g = (bigint >> 8) & 255;
		var b = bigint & 255;
		return [r, g, b];
	},
	getHexToRGB: function(pString)
	{
		var rgba = U.convertHexToRGB(pString);
		return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", 1)";
	},
	
	/*
	 * Converts an RGB array to Hue Saturation Lightness array.
	 * @param intarray pRGB.
	 * @returns array.
	 * Source: http://stackoverflow.com/questions/11923659/javascript-sort-rgb-values
	 */
	convertRGBToHSL: function(pRGB)
	{
		var r = pRGB[0]/255, g = pRGB[1]/255, b = pRGB[2]/255;
		var max = Math.max(r, g, b), min = Math.min(r, g, b);
		var h, s, l = (max + min) / 2;

		if (max === min)
		{
			h = s = 0; // achromatic
		}
		else
		{
			var d = max - min;
			s = (l > 0.5) ? (d / (2 - max - min)) : (d / (max + min));
			switch(max)
			{
				case r: h = (g - b) / d + ((g < b) ? 6 : 0); break;
				case g: h = (b - r) / d + 2; break;
				case b: h = (r - g) / d + 4; break;
			}
			h /= 6;
		}
		return [h * 360, s * 100, l * 100];
	},
	sortRGBs: function(pRGBs)
	{
		var indexes = [];
		var sortedindexes = [];
		var hslArr = [];
		for (var i = 0; i < pRGBs.length; i++)
		{
			hslArr[i] = [U.convertRGBToHSL(pRGBs[i]), i]; 
			indexes.push(i);
		}
		
		var sortedHslArr = [];
		for (var i = 0; i < hslArr.length; i++)
		{
			var continueouter = false;
			for (var j = 0; j < sortedHslArr.length; j++)
			{
				if (sortedHslArr[j][0][0] > hslArr[i][0][0])
				{
					sortedHslArr.splice(j, 0, hslArr[i]);
					sortedindexes.splice(j, 0, i);
					continueouter = true;
					break;
				}
			}
			if (continueouter)
			{
				continue;
			}
			sortedHslArr.push(hslArr[i]);
			sortedindexes.push(i);
		}
		
		var sortedRgbArr = [];
		for (var i = 0; i < sortedHslArr.length; i++)
		{
			sortedRgbArr[i] = pRGBs[sortedHslArr[i][1]];
		}
		return {
			oRGBs: sortedRgbArr,
			oIndexes: sortedindexes
		};
	},
	
	/*
	 * Converts a decimal number into a decimal-less percentage.
	 * @param float pNumber to convert.
	 * @param int pPlaces decimal to keep.
	 * @returns string.
	 */
	convertRatioToPercent: function(pDecimal, pPlaces)
	{
		if (pDecimal === undefined || isFinite(pDecimal) === false)
		{
			return "0%";
		}
		if (pPlaces === undefined)
		{
			pPlaces = 0;
		}
		
		var sign = (pDecimal < 0) ? I.Symbol.Negative : "";
		return sign + Math.abs(pDecimal * 100).toFixed(pPlaces) + "%";
	},
	
	/*
	 * Formats a percentage number. Example: 1250.538 becomes 1,250.53%
	 * @param float pPercentage to convert.
	 * @param int pPlacesMax decimals to keep.
	 * @param int pPlacesMin decimals to keep if number has no decimal values.
	 * @returns string.
	 */
	formatPercentage: function(pPercentage, pPlacesMax, pPlacesMin)
	{
		if (pPercentage === parseInt(pPercentage)) // The percentage has no decimal points, then don't include them
		{
			if (pPlacesMin !== undefined)
			{
				return pPercentage.toFixed(pPlacesMin).toLocaleString() + "%";
			}
			return pPercentage.toLocaleString() + "%";
		}
		return pPercentage.toFixed((pPlacesMax === undefined) ? 2 : pPlacesMax).toLocaleString() + "%";
	},
	
	/*
	 * Gets string representation of JSON object, with default parameters.
	 * @param object pObject.
	 * @returns string.
	 */
	formatJSON: function(pObject)
	{
		var str = "failedstringify";
		try
		{
			str = JSON.stringify(pObject, null, "\t");
		}
		catch (e) {}
		return str;
	},
	escapeJSON: function(pObject)
	{
		return U.escapeHTML(U.formatJSON(pObject));
	},
	lineJSON: function(pObject, pWantQuotes)
	{
		// Returns the stringified JSON as a single line separated with spaces.
		var str = JSON.stringify(pObject, null, 1);
		if (pWantQuotes === false)
		{
			str = U.stripJSONQuotations(str);
		}
		return str
			.replace(/[\r\n]/g, "")
			.replace(/  +/g, " ")
			.replace(/ }/g, "}")
			.replace(/{ /g, "{")
			.replace(/ \]/g, "]")
			.replace(/\[ /g, "[");
	},
	compressToJS: function(pObject)
	{
		return U.stripJSONQuotations(JSON.stringify(pObject));
	},
	
	/*
	 * Strips all non-alphabet and non-numbers from a string using regex.
	 * @param string pString to strip.
	 * @returns string stripped.
	 */
	stripToAlphanumeric: function(pString)
	{
		return pString.replace(/\W/g, "");
	},
	stripToAlphanumericDash: function(pString)
	{
		return pString.replace(/[^a-zA-Z0-9\-]/g, "");
	},
	stripToNumbers: function(pString)
	{
		return parseInt(pString.replace(/[^0-9]/g, ""));
	},
	stripToColorString: function(pString)
	{
		// Allow only alphanumeric and number sign (color word or a hexadecimal color)
		return pString.replace(/[^a-zA-Z0-9#]/g, "");
	},
	stripToVariable: function(pString)
	{
		// Disallow spaces and ranges of programming characters !/:@[^`{~
		return pString.replace(/ /g, "_").replace(/[0-9\u0021-\u002f\u003a-\u0040\u005b-\u005e\u0060\u007b-\u007e]/g, "");
	},
	stripJSONQuotations: function(pString)
	{
		// Removes quotation marks from JSON stringified object properties
		return pString.replace(/\"([^(\")"]+)\":/g,"$1:");
	},
	
	/*
	 * Strips to alphanumeric and allow spaces and some punctuation marks.
	 * @param string pString to strip.
	 * @returns string stripped.
	 */
	stripToSentence: function(pString)
	{
		return pString.replace(/[^\w\s\'\"\:\,]/gi, "");
	},
	
	/*
	 * Allows only numbers, arithmetic operators, and parantheses.
	 * @param string pString arithmetic expression.
	 * @returns string stripped.
	 */
	stripToCalculation: function(pString)
	{
		return pString.replace(/[^0-9.()\-+/*]/gi, "");
	},
	
	/*
	 * Converts a string to be all lower case except the first letter which is capitalized.
	 * @param string pString to convert.
	 * @returns string converted.
	 */
	toFirstUpperCase: function(pString)
	{
		return pString.charAt(0).toUpperCase() + pString.slice(1).toLowerCase();
	},
	
	/*
	 * Changes letter case of a word or sentence.
	 * @param string pString to change.
	 * @returns string changed.
	 * @pre String is a readable text that starts with a letter.
	 */
	toCase: function(pString, pCase)
	{
		var i;
		var str = [];
		
		if (pCase === undefined || pCase === U.CaseEnum.None)
		{
			return pString;
		}
		if (pCase === U.CaseEnum.Title || pCase === U.CaseEnum.Every)
		{
			str = pString.split(" ");
		}
		
		switch (pCase)
		{
			case U.CaseEnum.Lower: return pString.toLowerCase();
			case U.CaseEnum.Sentence: return U.toFirstUpperCase(pString);
			case U.CaseEnum.Title:
			{
				// Capitalize the first word and the rest, but don't capitalize 2-letter words
				if (str.length > 1)
				{
					str[0] = U.toFirstUpperCase(str[0]);
					for (i = 1; i < str.length; i++)
					{
						if (str[i].length !== 2)
						{
							str[i] = U.toFirstUpperCase(str[i]);
						}
					}
					return str.join(" ");
				}
				else
				{
					return U.toFirstUpperCase(pString);
				}
			}
			case U.CaseEnum.Every:
			{
				if (str.length > 1)
				{
					for (i in str)
					{
						str[i] = U.toFirstUpperCase(str[i]);
					}
					return str.join(" ");
				}
				else
				{
					return U.toFirstUpperCase(pString);
				}
			}
			case U.CaseEnum.Upper: return pString.toUpperCase();
		}
		return pString;
	},
	
	/*
	 * Converts an HTML string to plain text.
	 * @param string pHTML
	 * @returns string
	 */
	toText: function(pHTML)
	{
		return $("<div>" + pHTML + "</div>").text();
	},
	
	/*
	 * Splits a string in half.
	 * @param string pString
	 * @param string pDelimiter
	 * @returns array
	 */
	toHalf: function(pString, pDelimiter)
	{
		var divind = pString.indexOf(pDelimiter);
		if (divind !== -1)
		{
			return [pString.substr(0, divind), pString.substr(divind + pDelimiter.length, pString.length)];
		}
		return [pString, ""];
	},
	
	/*
	 * Shortens a title/name string based on limit, and add ellipses.
	 * @param string pString.
	 * @returns string truncated if it's too long.
	 */
	truncateString: function(pString, pLimit, pSuffix)
	{
		pSuffix = pSuffix || "";
		if (pString.length > pLimit)
		{
			return pString.substring(0, pLimit) + pSuffix;
		}
		return pString;
	},
	
	/*
	 * Wraps a substring (or multiple substrings if separated by spaces) with a
	 * tag if the substring is found in the main string.
	 * @param string pString to search in.
	 * @param string pSubstring to wrap.
	 * @param string pTag HTML tag, optional.
	 * @returns string with substring wrapped with tag.
	 */
	highlightSubstring: function(pString, pSubstrings, pTag)
	{
		var tag = pTag || "u";
		var str = pString.replace(/{{|}}/g, ""); // Disallow the highlight markup alias
		var subs = pSubstrings.split(" ");
		var sub;
		for (var i = 0; i < subs.length; i++)
		{
			// Wrap the matches in the alias so that the wrapper itself isn't matched
			sub = subs[i];
			if (sub.length)
			{
				str = str.replace(new RegExp(U.escapeRegEx(sub), "gi"), "{{$&}}"); // $& is the original match, to maintain letter case
			}
		}
		// Replace the wrapper alias with the proper tag now that the matching is done
		str = str.replace(/{{/g, "<" + tag + ">");
		str = str.replace(/}}/g, "</" + tag + ">");
		return str;
	},
	
	/*
	 * Strips a string of HTML special characters for use in printing.
	 * @param string pString to escape.
	 * @returns string replaced string.
	 */
	escapeHTML: function(pString)
	{
		if (typeof pString === "string")
		{
			return pString
				.replace(/&/g, "&amp;")
				.replace(/</g, "&lt;")
				.replace(/>/g, "&gt;")
				.replace(/"/g, "&quot;")
				.replace(/'/g, "&apos;");
		}
		if (pString === undefined)
		{
			return "undefined";
		}
		return "null";
	},
	escapeRegEx: function(pString)
	{
		return pString.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
	},
	
	/*
	 * Replaces a character in a string with a specified character.
	 * @param string pString to manipulate.
	 * @param int pIndex of the target character.
	 * @param string pCharacter the replacement.
	 * @returns string with a character at index replaced.
	 */
	replaceCharAt: function(pString, pIndex, pCharacter)
	{
		return pString.substr(0, pIndex) + pCharacter + pString.substr(pIndex + pCharacter.length);
	},
	
	/*
	 * Creates a string of specified length containing only the specified character.
	 * @param string pChar to write.
	 * @param int pLength of returned string.
	 * @returns string of repeated character.
	 */
	repeatChar: function(pChar, pLength)
	{
		return Array(pLength + 1).join(pChar);
	},
	
	/*
	 * Counts the occurences of a string within a string.
	 * @param string pString to look in.
	 * @param string pMatch to look for.
	 * @returns int count.
	 */
	countOccurrence: function(pString, pMatch)
	{
		return pString.split(pMatch).length - 1;
	},
	
	/*
	 * Updates the address bar with the given string affixed to the site base URL.
	 * This should be the only place the "history" global variable is used.
	 * @param string pString URL query string.
	 */
	updateAddressBar: function(pString)
	{
		history.replaceState("", null, pString);
		// Workaround Firefox SVG url bug
		K.reapplyFilters();
	},
	
	/*
	 * Rewrites the URL in the address bar to show the current page and section.
	 * Does not actually load anything and is only a visual effect; however, if
	 * the user presses enter with that URL (go to such a link), a separate
	 * function will load that page (content plate) and expand that section.
	 * @param string pParamOptions additional query string options.
	 */
	updateQueryString: function(pParamOptions)
	{
		if (I.PageCurrent !== "")
		{
			var section = I.SectionCurrent[I.PageCurrent];
			var article = I.ArticleCurrent;
			var go = U.Args[U.KeyEnum.Go];

			var pagestring = "?" + U.KeyEnum.Page + "=" + I.PageCurrent;
			var sectionstring = "";
			var articlestring = "";
			var gostring = "";
			var modestring = "";
			pParamOptions = (pParamOptions === undefined) ? "" : "&" + pParamOptions;
			
			var title = I.PageCurrent;
			
			if (I.ModeCurrent !== I.ModeEnum.Website)
			{
				modestring = "&mode=" + I.getMode();
			}

			if (section)
			{
				sectionstring = "&" + U.KeyEnum.Section + "=" + section;
				title = section;
			}
			else if (I.ModeCurrent === I.ModeEnum.Website && I.PageCurrent === I.PlateEnum.Directory)
			{
				pagestring = "."; // Chains is the default and level top URL, so don't include it
				title = null;
			}
			if (article)
			{
				articlestring = "&" + U.KeyEnum.Article + "=" + article;
			}
			if (go)
			{
				gostring = "&" + U.KeyEnum.Go + "=" + go;
			}
			U.updateAddressBar(pagestring + sectionstring + articlestring + gostring + modestring + pParamOptions);
			U.updateTitle(title);
			U.updateLanguageLinks(pagestring + sectionstring + modestring);
		}
	},
	updateTitle: function(pTitle)
	{
		document.title = (pTitle) ? I.cSiteName + "/" + pTitle : I.cSiteTitle;
	},
	
	/*
	 * Updates the href attribute of the language links for the user to change
	 * language, while also keeping the current URL path.
	 * @param string pString prefix query string.
	 */
	updateLanguageLinks: function(pString)
	{
		$(".linkLanguage").each(function()
		{
			var lang = $(this).attr("data-lang");
			var suffixes = "";
			if (pString === undefined || pString === ".")
			{
				// This should be assigned when the website loads for the first time
				suffixes = (I.ModeCurrent === I.ModeEnum.Website) ? ("?enu_Language=" + lang) : ("?enu_Language=" + lang + "&mode=" + I.getMode());
			}
			else
			{
				// This should be assigned when the user changes to a different page
				suffixes = pString + "&enu_Language=" + lang;
			}
			$(this).attr("href", "./" + suffixes);
		});
	},
	initializeLanguageButton: function()
	{
		$("#itemLanguageButton").html(O.Options.enu_Language.toUpperCase());
		$("#itemLanguagePopup").click(function(pEvent)
		{
			pEvent.stopPropagation();
		});
	},
	
	/*
	 * Binds pseudolinks that has the "data-page" attribute pointing to pages.
	 * @param string pSelector
	 */
	convertInternalLink: function(pSelector)
	{
		$(pSelector).each(function()
		{
			var page = $(this).attr(I.cPageAttribute);
			if (page)
			{
				$(this).removeAttr(I.cPageAttribute).click(function()
				{
					U.interpretPage(page);
				});
			}
		});
	},
	
	/*
	 * Makes links open a new tab on an HTML page with analytics to record
	 * what link the user clicked on, then almost instantly redirect them to
	 * the proper address of the link.
	 * @param string pSelector to find tags to convert.
	 */
	convertExternalLink: function(pSelector)
	{
		$(pSelector).each(function()
		{
			var url = $(this).attr("href");
			if (!url)
			{
				return;
			}
			if (url.indexOf("./") === 0)
			{
				// Don't convert relative links
				return;
			}
			if (url.indexOf(I.cSiteExternal) === 0)
			{
				// Don't convert already converted links
				return;
			}
			if (I.ModeCurrent === I.ModeEnum.Overlay && url.indexOf(I.cSiteURL + "?") !== -1)
			{
				// For overlay, self-linking URLs should not new open window and must contain the mode
				$(this).attr("href", url + U.getDivider(url) + "mode=" + I.getMode());
			}
			else
			{
				$(this).attr("href", I.cSiteExternal + U.encodeURL(url)).attr("target", "_blank");
			}
		});
	},
	convertExternalURL: function(pURL)
	{
		// Prefixes the outgoing page to the URL
		return I.cSiteExternal + U.encodeURL(pURL);
	},
	convertExternalAnchor: function(pURL)
	{
		// This is to be placed within the property of an <a> tag
		return " href='" + I.cSiteExternal + U.encodeURL(pURL) + "' target='_blank' ";
	},
	convertPrivateAnchor: function(pURL)
	{
		// This is to be placed within the property of an <a> tag
		return " href='" + pURL + "' target='_blank' ";
	},
	
	/*
	 * Replaces href attributes in a raw HTML string and replace them with
	 * external prefixes.
	 * @param string pHTML.
	 * @returns string.
	 */
	convertExternalString: function(pHTML)
	{
		return pHTML.replace(/href='/g, "target='_blank' href='" + I.cSiteExternal);
	},
	
	/*
	 * Converts an internal URL to have the currently used mode query string.
	 * @param string pSelector
	 */
	convertModeLink: function(pSelector)
	{
		if (I.ModeCurrent !== I.ModeEnum.Website)
		{
			$(pSelector).each(function()
			{
				var url = $(this).attr("href");
				if (url && url.indexOf(I.cSiteExternal) !== 0
					&& (url.indexOf(I.cSiteURL) === 0 || url.indexOf("./") === 0))
				{
					$(this).attr("href", url + U.getDivider(url) + "mode=" + I.getMode());
				}
			});
		}
	},
	
	/*
	 * Opens a new browser tab with the requested URL.
	 * @param string pURL to go to.
	 */
	openExternalURL: function(pURL)
	{
		window.open(I.cSiteExternal + U.encodeURL(pURL), "_blank");
	},
	openPrivateURL: function(pURL)
	{
		window.open(pURL, "_blank");
	},
	
	/*
	 * Extracts the name part from a variable, as in "bol_showPanel" returns "showPanel".
	 * @param string pVariable full name.
	 * @returns string option name.
	 * @pre Variable name has exactly one underscore character.
	 */
	getVariableSuffix: function(pVariable)
	{
		var index = pVariable.indexOf("_");
		return pVariable.substring(index + 1, pVariable.length);
	},
	getVariablePrefix: function(pVariable)
	{
		var index = pVariable.indexOf("_");
		return pVariable.substring(0, index);
	},
	
	/*
	 * Extracts the "identifier" part of an HTML element's ID. Most iterable
	 * elements' IDs were manually named as [prefix]_[Index].
	 * @param jqobject pElement to extract.
	 * @returns string identifier of the element's ID.
	 */
	getSubstringFromHTMLID: function(pElement)
	{
		return U.getVariableSuffix(pElement.attr("id"));
	},
	/*
	 * Integer version of the ID extraction function.
	 * @param jqobject pElement to extract.
	 * @returns int identifier of the element's ID.
	 */
	getSubintegerFromHTMLID: function(pElement)
	{
		return parseInt(U.getVariableSuffix(pElement.attr("id")));
	},
	
	/*
	 * Gets the URL directory of the HTML source file
	 * @param string pPage name.
	 * @returns string path.
	 */
	getPageSrc: function(pPage)
	{
		return "page/" + pPage.toLowerCase() + ".html";
	},
	
	/*
	 * Encodes a string for URL usage with regards to "'" character (apostrophe).
	 * @param string pString to encode.
	 * @returns string encoded.
	 */
	encodeURL: function(pString)
	{
		return encodeURI(pString).replace(/'/g, "%27");
	},
	
	/*
	 * Converts a search query to GW2 wiki URL.
	 * @param string pString search entry.
	 * @returns string wiki link.
	 */
	getWikiLinkDefault: function(pString)
	{
		pString = pString.replace(/ /g, "_"); // Replace spaces with underscores
		return "http://wiki.guildwars2.com/wiki/" + U.encodeURL(pString);
	},
	getWikiLinkLanguage: function(pString)
	{
		pString = pString.replace(/ /g, "_");
		return "http://wiki-" + D.langFullySupported + ".guildwars2.com/wiki/" + U.encodeURL(pString);
	},
	getWikiLinkObject: function(pObject)
	{
		return D.isLanguageFullySupported ? U.getWikiLinkLanguage(D.getObjectName(pObject)) : U.getWikiLinkDefault(D.getObjectDefaultName(pObject));
	},
	getWikiLinkCode: function(pID, pName)
	{
		var chatlink = U.getChatlinkFromPoiID(pID);
		var name = (pName) ? ("&name=" + pName.replace(/ /g, "_")) : "";
		return "https://wiki.guildwars2.com/index.php?search=" + encodeURIComponent(chatlink) + name;
	},
	getWikiSearchDefault: function(pString)
	{
		pString = pString.replace(/ /g, "+"); // Replace spaces with plus sign
		return "https://wiki.guildwars2.com/index.php?search=" + U.encodeURL(pString);
	},
	getWikiSearchLanguage: function(pString)
	{
		pString = pString.replace(/ /g, "_");
		return "http://wiki-" + D.langFullySupported + ".guildwars2.com/index.php?search=" + U.encodeURL(pString);
	},
	getWikiItemDefault: function(pItem)
	{
		// This always return the English wiki. Non-English queries use item ID search rather than direct name
		if (D.isLanguageFullySupported && D.isLanguageDefault === false)
		{
			return U.getWikiSearchDefault((pItem.id).toString());
		}
		return U.getWikiLinkDefault(pItem.name);
	},
	
	/*
	 * Generates a link to news article at the GuildWars2.com site.
	 * @param string pString suffix.
	 * @returns string URL.
	 */
	getGW2OfficialLink: function(pString)
	{
		return "https://www.guildwars2.com/" + D.langFullySupported + "/" + pString;
	},
	
	/*
	 * Converts a search query to YouTube http link.
	 * @param string pString search entry.
	 * @returns string youtube link.
	 */
	getYouTubeLink: function(pString)
	{
		return "http://www.youtube.com/results?search_query=" + U.encodeURL(pString + " " + I.cGameNick);
	},
	
	/*
	 * Converts a search query to Trading Post http link.
	 * @param string pString search entry.
	 * @returns string search link.
	 */
	getTradingSearchLink: function(pString)
	{
		return "https://www.gw2tp.com/search?name=" + U.encodeURL(pString);
	},
	
	/*
	 * Gets a URL to an item page from an item's ID.
	 * @param string pID of the item.
	 * @param string pName of the item.
	 * @returns string item page link.
	 */
	getTradingItemLink: function(pID, pName)
	{
		return "http://www.gw2spidy.com/item/" + U.encodeURL(pID) + "?name=" + U.stripToSentence(pName).replace(/ /g, "_");
	},
	
	/*
	 * Gets an image URL from a third party provider for a guild banner.
	 * @param string pName of the guild.
	 * @returns string URL.
	 */
	getGuildBannerURL: function(pName)
	{
		if (pName)
		{
			var name = U.escapeHTML((pName.split(" ").join("-")).toLowerCase());
			return "http://guilds.gw2w2w.com/guilds/" + name + "/128.svg";
		}
		return "img/ui/placeholder.png";
	},
	
	/*
	 * Gets an API image URL from the cached emblem array. These emblems are
	 * uncolorized and unbackgrounded. Used as a backup or workaround when the
	 * default banner renderer is offline.
	 * @param object pGuild
	 * @returns string
	 * @pre Account page data was loaded, since the emblem data is inside it.
	 */
	getGuildBannerRaw: function(pGuild)
	{
		try { return U.getAPIImage(GW2T_EMBLEM_DATA.foreground[pGuild.emblem.foreground.id]); }
		catch (e) {}
		return "img/ui/unavailable.png";
	},
	getAPIImage: function(pSubstring)
	{
		return "https://render.guildwars2.com/file/" + pSubstring + ".png";
	},
	
	/*
	 * Converts a poi_id number from maps_floor.json to a valid chatlink.
	 * Code from http://virtus-gilde.de/gw2map
	 * @param int pID of the poi.
	 * @returns string chatlink.
	 */
	getChatlinkFromPoiID: function(pID)
	{
		var chatlink = String.fromCharCode(4);
		// Create unicode characters from the id
		for (var i = 0; i < 4; i++)
		{
			chatlink += String.fromCharCode((pID >> (i * 8)) & 255);
		}
		// Return base64 string with chat code tags
		return I.cChatcodePrefix + btoa(chatlink) + I.cChatcodeSuffix;
	},
	
	/*
	 * Converts an item id from items.json to a valid chatlink.
	 * Code from http://redd.it/zy8gb
	 * @param int pID of the item.
	 * @returns string chatlink.
	 */ 
	getChatlinkFromItemID: function(pID)
	{
		var str = "";
		try // To ignore "Failed to execute 'btoa' on 'Window'" exception
		{
			str = I.cChatcodePrefix + btoa(String.fromCharCode(2) + String.fromCharCode(1)
			+ String.fromCharCode(pID % 256) + String.fromCharCode(Math.floor(pID / 256))
			+ String.fromCharCode(0) + String.fromCharCode(0)) + I.cChatcodeSuffix;
		} catch (e) {};
		return str;
	},

	/*
	 * Converts a chatlink to a plain number ID.
	 * @param string pChatlink.
	 * @param boolean pWantType if to return the type of the ID also, optional.
	 * @returns int number or null if invalid.
	 * Code from http://wiki.guildwars2.com/wiki/MediaWiki:ChatLinkSearch.js
	 */
	getGameIDFromChatlink: function(pChatlink, pWantType)
	{
		var decodeChatLink = function(pCode)
		{
			var binary = window.atob(pCode);
			var octets = new Array(binary.length);
			for (var i = 0; i < binary.length; i++)
			{
				octets[i] = binary.charCodeAt(i);
			}
			return octets;
		};
		
		var id = null;
		// Extract the code portion of the chatlink [&CODE]
		if (typeof pChatlink === "string" && pChatlink.indexOf(I.cChatcodePrefix) === 0 && pChatlink.indexOf(I.cChatcodeSuffix === pChatlink.length - 1))
		{
			pChatlink = pChatlink.substring(2, pChatlink.length - 1);
		}
		
		try
		{
			var data = decodeChatLink(pChatlink);
			var id = data[2] << 8 | data[1];
			var type = null;
			switch (data[0])
			{
				case 2: {
					type = "item";
					id = data[3] << 8 | data[2];
					id = (data.length > 4 ? data[4] << 16 : 0) | id;
				} break;
				case 4: type = "location"; break;
				case 6: type = "skill"; break;
				case 8: type = "trait"; break;
				case 9: type = "recipe"; break;
				case 10: type = "skin"; break;
				case 11: type = "outfit"; break;
			}
		}
		catch (e)
		{
			I.write("Invalid chatlink to decode.");
		}
		
		if (pWantType)
		{
			var idtype = id + " (" + type + ")";
			I.print("<input class='cssInputText' type='text' value='" + id + "'></input>&nbsp;<span>" + idtype + "</span>");
			I.bindConsoleInput();
		}
		return id;
	}
};
Z = {
/* =============================================================================
 * @@Z Console commands and server-like maintenance and file functions
 * ========================================================================== */

	cCommandPrefix: "/",
	APICacheFiles: [], // Stores the URLs to generated blob files
	APICacheArrayOfIDs: null, // Array of ID numbers for any particular v2 API endpoint
	APICacheArrayOfObjects: null, // Array of objects downloaded from the IDs pointing there
	APICacheConsole: null, // JSON text entered by the user
	DatabaseCache: {}, // To be loaded with various API databases, access order: database name > language code > item ID
	DatabaseLanguages: ["en", "de", "es", "fr", "zh"],
	
	/*
	 * Loads an object from local storage into a variable for testing or console usage.
	 * @returns boolean true if successfully loaded into variable, else false.
	 */
	loadAPICache: function()
	{
		var cache = localStorage[O.Utilities.APICache.key];
		if (cache)
		{
			try {
				Z.APICacheConsole = JSON.parse(cache);
				return true;
			}
			catch (e) {
				I.print("Error loading API cache object.");
			}
		}
		return false;
	},
	saveAPICache: function()
	{
		if (Z.APICacheConsole)
		{
			localStorage[O.Utilities.APICache.key] = JSON.stringify(Z.APICacheConsole);
			return true;
		}
		else
		{
			I.print("Error saving cache object.");
		}
		return false;
	},
	
	/*
	 * Interprets and executes a command string, which may be a console command
	 * or a map data string.
	 * @param string pString command.
	 * @param object pMapObject which map to execute.
	 * @param enum pZoom level, optional.
	 */
	interpretCommand: function(pString, pMapObject, pZoom, pPin)
	{
		if (pString.indexOf(Z.cCommandPrefix) === 0)
		{
			// If input starts with a console command
			Z.parseCommand(pString, pMapObject);
		}
		else if (pString.indexOf(I.cChatencodedPrefix) !== -1)
		{
			try
			{
				var chatcode = decodeURIComponent(decodeURIComponent(pString));
				U.getGameIDFromChatlink(chatcode.substring(chatcode.indexOf("["), chatcode.indexOf("]")), true);
			}
			catch (e) {}
		}
		else if (pString.indexOf(I.cChatcodePrefix) === 0)
		{
			// If input is a chatcode
			U.getGameIDFromChatlink(pString, true);
		}
		else if (pMapObject.parsePersonalPath(pString) === false)
		{
			// If input looks like a 2D array of coordinates, then create pins from them
			pMapObject.goToArguments(pString, pZoom, pPin);
		}
	},
	
	/*
	 * Executes a console command.
	 * @param string pString command.
	 * @param object pMapObject which map the command was executed from.
	 */
	parseCommand: function(pString, pMapObject)
	{
		var that = pMapObject || M;
		var args = pString.substring(1, pString.length).split(" "); // Trim the command prefix character
		var argstr = pString.substring(pString.indexOf(" ") + 1, pString.length);
		var command = args[0].toLowerCase();
		
		var Commands = {
			clear: {usage: "Clears the console screen. Or just press the Esc key.", f: function()
			{
				I.clear();
			}},
			speak: {usage: "Speaks the given text. <em>Parameters: str_text</em>", f: function()
			{
				D.speak(argstr);
			}},
			gps: {usage: "Prints GPS location information (overlay only).", f: function()
			{
				I.print("Position: " + U.formatJSON(GPSPositionArray) + "<br />"
					+ "Direction: " + U.formatJSON(GPSDirectionArray) + "<br />"
					+ "Perspective: " + U.formatJSON(GPSPerspectiveArray) + "<br />"
					+ "Camera: " + U.formatJSON(GPSCameraArray)
				);
			}},
			identity: {usage: "Prints GPS general information (overlay only).", f: function()
			{
				I.prettyJSON(GPSIdentityJSON);
			}},
			trace: {usage: "Prints GPS information continuously by toggle (overlay only).", f: function()
			{
				P.isGPSPrinting = !P.isGPSPrinting;
				if (P.isGPSPrinting)
				{
					I.print("Trace started.");
				}
				else
				{
					I.print("Trace stopped.");
				}
			}},
			agent: {usage: "Prints browser's navigator object.", f: function()
			{
				var str = "", obj, desc;
				for (var i in window.navigator)
				{
					obj = window.navigator[i];
					desc = (typeof obj === "string" || typeof obj === "number") ? obj : U.formatJSON(obj);
					str += U.escapeHTML(i + ": " + desc) + "<br />";
				}
				I.print(str);
			}},
			cal: {usage: "Prints a HTML calendar input element.", f: function()
			{
				I.print("<br /><input id='cslCalendar' type='date' /><br />");
				$("#cslCalendar")[0].valueAsDate = new Date();
			}},
			floor: {usage: "Sets the map floor. <em>Parameters: int_floornumber</em>", f: function()
			{
				that.changeFloor(parseInt(args[1]));
			}}, 
			lock: {usage: "Map cannot be moved.", f: function()
			{
				that.Map.dragging.disable(); that.Map.scrollWheelZoom.disable(); I.write("Map locked.");
			}},
			unlock: {usage: "Map can be moved.", f: function()
			{
				that.Map.dragging.enable(); that.Map.scrollWheelZoom.enable(); I.write("Map unlocked.");
			}},
			nct: {usage: "Disables the map's context menu.", f: function()
			{
				that.Map.off("contextmenu"); I.write("Map context menu disabled.");
			}},
			link: {usage: "Prints a coordinates URL of the current map view.", f: function()
			{
				I.paste(I.cSiteURL + that.convertLCtoGC(that.Map.getCenter()), true);
			}},
			dart: {usage: "Draws personal pins at random map coordinates. <em>Parameters: int_quantity</em>", f: function()
			{
				that.drawRandom(args[1]);
			}},
			nodes: {usage: "Sorts and prints a list coordinates. <em>Parameters: arr_coordinates</em>", f: function()
			{
				P.printNodes(P.sortCoordinates(M.parseCoordinatesMulti(args[1])));
			}},
			needles: {usage: "Numbers and prints a list of coordinates. <em>Parameters: arr_coordinates</em>", f: function()
			{
				P.printNodes(M.parseCoordinatesMulti(args[1]), true);
			}},
			latlngs: {usage: "Converts an array of LatLng's to standard coordinates. <em>Parameters: arr_latlngs</em>", f: function()
			{
				that.convertLatLngs(JSON.parse(argstr));
			}},
			jsonparse: {usage: "Converts a JSON string into an object for testing. <em>Parameters: str_json</em>", f: function()
			{
				try { Z.APICacheConsole = JSON.parse(argstr); I.print("Parse JSON successful."); }
				catch (e) { I.print("Parse JSON failed."); }
			}},
			url: {usage: "Prints the result of a URL. <em>Parameters: str_url</em>", f: function()
			{
				U.getJSON(argstr, function(pData)
				{
					if (pData)
					{
						I.prettyJSON(pData);
					}
				}).fail(function()
				{
					I.print("No results from URL.");
				});
			}},
			api: {usage: "Prints the output of an API URL &quot;" + U.URL_API.Prefix + "&quot;. <em>Parameters: str_apiurlsuffix, str_querystring (optional)</em>", f: function()
			{
				if (args[1])
				{
					Z.printAPI(args[1], args[2], args[3]);
				}
				else
				{
					U.openExternalURL("https://api.guildwars2.com/v2");
				}
			}},
			apicache: {usage: "Prints the cache of the previous console API call as an associative array. <em>Parameters: bol_wantoutputasfile (optional)</em>", f: function()
			{
				Z.printAPICache(U.TypeEnum.isAssoc, {aFileName: (args[1] === "true")});
			}},
			apicachearray: {usage: "...as an array.", f: function()
			{
				Z.printAPICache(U.TypeEnum.isArray, false);
			}},
			apicacheobject: {usage: "...as an object.", f: function()
			{
				Z.printAPICache(U.TypeEnum.isObject, false);
			}},
			apicacheids: {usage: "...as IDs.", f: function()
			{
				Z.printAPICache(U.TypeEnum.isInteger, false);
			}},
			apilang: {usage: "Prints all languages of an API data point. <em>Parameters: str_endpoint, int_id</em>", f: function()
			{
				Z.printAPIMultilingual(args[1], args[2]);
			}},
			acc: {usage: "Prints the output of an account API URL &quot;"
				+ U.URL_API.Prefix + "&quot;. Token must be initialized from the account page. <em>Parameters: str_apiurlsuffix</em>. "
				+ "Type &quot;acc&quot; alone to see list of URL suffixes. Please replace spaces in character's name with &quot;%20&quot;", f: function()
			{
				A.printAccount(args[1]);
			}},
			daily: {usage: "Prints today's and tomorrow's daily achievements.", f: function()
			{
				Z.printDaily();
			}},
			item: {usage: "Prints an item's information. <em>Parameters: int_itemid</em>", f: function()
			{
				Z.scrapeAPIArrayMultilingual("items", parseInt(args[1]), function(pDatabase)
				{
					I.clear();
					for (var i in pDatabase)
					{
						for (var ii in pDatabase[i])
						{
							Q.printItemInfo((pDatabase[i])[ii]);
						}
					}
				});
			}},
			items: {usage: "Prints the highest numbered item IDs in the API. <em>Parameters: int_offset</em>", f: function()
			{
				Z.printItemsAPI(args[1]);
			}},
			sortitems: {usage: "Sorts an array of item IDs by item type. <em>Parameters: arr_itemids</em>", f: function()
			{
				try
				{
					Q.sortItems(JSON.parse(args[1]), function(pItems, pIDs)
					{
						I.paste(U.lineJSON(pIDs));
					});
				}
				catch (e) {}
			}},
			events: {usage: "Prints the event names of the current zone, dynamic events option must be enabled.", f: function()
			{
				P.printZoneEvents();
			}},
			lower: {usage: "Converts a string to all lower case. <em>Parameters: str_string</em>", f: function()
			{
				if (args[1])
				{
					I.paste(U.toCase(argstr, U.CaseEnum.Lower));
				}
			}},
			upper: {usage: "Converts a string to all upper case. <em>Parameters: str_string</em>", f: function()
			{
				if (args[1])
				{
					I.paste(U.toCase(argstr, U.CaseEnum.Upper));
				}
			}},
			rgba: {usage: "Converts a hex color to RGBA format. <em>Parameters: str_hex</em>", f: function()
			{
				I.paste(U.getHexToRGB(argstr));
			}},
			hex: {usage: "Converts an RGBA color to hex format. <em>Parameters: str_rgba</em>", f: function()
			{
				I.paste(U.getRGBToHex(argstr));
			}},
			help: {usage: "Prints this help message.", f: function()
			{
				I.write("Available console commands:<br />");
				var s = "";
				for (var i in Commands)
				{
					s += "<b>" + i + "</b> - " + Commands[i].usage + "<br />";
				}
				s += "<br />The console also accepts: coordinates, array of coordinates, zone names, and chatcodes.<br />";
				I.print(s);
			}},
			wiki: {usage: "Search the game wiki. <em>Parameters: str_keywords</em>", f: function()
			{
				U.openExternalURL(U.getWikiSearchLanguage(argstr));
			}},
			test: {usage: "Test function for debugging.", f: function()
			{
				
			}},
			updatedb: {usage: "Prints an updated database of items. <em>Parameters: bol_wantrebuild (optional).", f: function()
			{
				Z.collateDatabase("items", args[1] === "true");
			}},
			subdb: {usage: "Prints a subset database of items used by an account page's section. <em>Parameters: str_section</em>", f: function()
			{
				if (args[1])
				{
					Z.updateItemsSubdatabase(args[1]);
				}
			}},
			collate: {usage: "Executes a function to update and categorize an unlockables record. <em>Parameters: str_section</em>", f: function()
			{
				Z.executeCollate(args[1], args[2]);
			}}
		};
		// Execute the command by finding it in the object
		if (Commands[command] !== undefined)
		{
			(Commands[command].f)();
		}
	},
	
	/*
	 * Creates a blob file with the provided text.
	 * @param string pString source text.
	 * @returns string URL to download the generated file.
	 */
	createFile: function(pString, pFileName)
	{
		var data = new Blob([pString], {type: "text/plain;charset=UTF-8"});
		var fileurl = window.URL.createObjectURL(data);
		Z.APICacheFiles.push(fileurl);
		
		var wantfilename = typeof pFileName === "string";
		var filename = (wantfilename) ? pFileName : "";
		var filenameoutput = (wantfilename) ? "<input class='cslFilename cssInputText' type='text' value='" + pFileName + "' /> " : "";
		I.print(filenameoutput + "<a href='" + fileurl + "' download='" + filename + "'>" + fileurl + "</a>");
		return fileurl;
	},
	
	/*
	 * Converts a text file into a string.
	 * @param object pFile
	 * @param function pCallback with string.
	 */
	openTextFile: function(pFile, pCallback)
	{
		var reader = new FileReader();
		reader.readAsText(pFile);
		reader.onload = function()
		{
			pCallback(reader.result);
		};
	},
	
	/*
	 * Binds a file input button for returning string.
	 * @param jqobject pInput
	 * @param function pCallback with the string if successful.
	 */
	bindFileInput: function(pInput, pCallback)
	{
		var input = $(pInput);
		input.change(function()
		{
			try
			{
				Z.openTextFile($(this)[0].files[0], function(pString)
				{
					pCallback(pString);
				});
			}
			catch (e)
			{
				I.write("Error loading file.");
			}
		});
	},
	
	/*
	 * Clears the array that stores URLs pointing to generated files, to clear
	 * up browser memory after the files have been used.
	 */
	freeFiles: function()
	{
		for (var i = 0; i < Z.APICacheFiles.length; i++)
		{
			if (Z.APICacheFiles[i])
			{
				window.URL.revokeObjectURL(Z.APICacheFiles[i]);
			}
		}
		Z.APICacheFiles = null;
		Z.APICacheFiles = [];
	},
	
	/*
	 * Prints a v2 API endpoint by querying each element in the array it
	 * returned, or just the object.
	 * @param string pString of API
	 * @param string pQueryStr arguments for the API url, or an array of IDs, optional.
	 */
	printAPI: function(pString, pQueryStr, pArray)
	{
		I.print("Gathering elements...");
		var versionprefix = "v1";
		var providedarray = null;
		var querystr = (pQueryStr === undefined) ? "" : pQueryStr;
		var url = U.URL_API.Prefix + pString;
		try
		{
			providedarray = JSON.parse(pArray || pQueryStr);
		}
		catch (e) {}
		
		var printResult = function()
		{
			I.clear();
			// Sort the objects by their IDs
			if (Z.APICacheArrayOfObjects.length > 0 && Z.APICacheArrayOfObjects[0].id)
			{
				U.sortObjects(Z.APICacheArrayOfObjects, {aKeyName: "id", aIsNumbers: true});
			}
			Z.printAPICache(U.TypeEnum.isArray);
		};
		var printIcon = function(pData)
		{
			var data = (typeof pData === "string") ? JSON.parse(pData) : pData;
			if (data.icon)
			{
				I.print("<img class='cssRight' src='" + U.escapeHTML(data.icon) + "' />");
			}
		};
		// Function to print retrieved data, or fetch more data if the original data is an array
		var iterateData = function(pData)
		{
			if (Array.isArray(pData))
			{
				var queryobj = U.convertQueryString(querystr);
				U.fetchAPI(url, pData, {
					aLanguage: (queryobj.lang) ? queryobj.lang : null,
					aCallback: function(pDataInner)
				{
					Z.APICacheArrayOfIDs = pData;
					Z.APICacheArrayOfObjects = pDataInner;
					printResult();
				}});
			}
			else
			{
				printIcon(pData);
				I.prettyJSON(pData);
			}
		};
		
		// If requesting v1 API by entering it in the first parameter
		if (pString === versionprefix)
		{
			url = U.URL_API.Prefix1 + pQueryStr;
			querystr = pArray || "";
		}
		
		// Fetch if did not provide an array in the parameter
		if (providedarray && Array.isArray(providedarray))
		{
			iterateData(providedarray);
		}
		else
		{
			$.get(url + querystr, function(pData)
			{
				iterateData(pData);
			}).fail(function()
			{
				I.warn(U.escapeHTML(url), true);
			});
		}
	},
	printAPIMultilingual: function(pSuffix, pID)
	{
		Z.scrapeAPIArrayMultilingual(pSuffix, parseInt(pID), function(pDatabase)
		{
			for (var i in pDatabase)
			{
				for (var ii in pDatabase[i])
				{
					Q.printItemInfo((pDatabase[i])[ii]);
				}
			}
		});
	},
	
	/*
	 * Prints the cached API arrays and objects.
	 * @param enum pType data type to output.
	 * @objparam object aCustomCache to use instead of the global.
	 * @objparam string aFileName of the file if want to output to file.
	 * @objparam boolean aWantQuotes whether to wrap key names in quotes (for JSON files).
	 */
	printAPICache: function(pType, pSettings)
	{
		var Settings = pSettings || {};
		var output = "";
		var obj;
		var wantfile = (Settings.aFileName !== undefined && Settings.aFileName !== false);
		var wantquotes = (Settings.aWantQuotes === undefined) ? wantfile : Settings.aWantQuotes;
		var cache = Settings.aCustomCache || Z.APICacheArrayOfObjects;
		var req = pType;
		
		// Compile the output
		if (req === undefined || req === U.TypeEnum.isAssoc || req === U.TypeEnum.isArray)
		{
			if (cache)
			{
				var length = cache.length;
				var brk = (wantfile) ? "\r\n" : "<br />";
				var quo = (wantfile) ? "\"" : "&quot;";
				var icon;
				output += ((req === U.TypeEnum.isAssoc) ? "{" : "[") + brk;
				for (var i = 0; i < length; i++)
				{
					obj = cache[i];
					icon = (obj.icon && !wantfile) ? "<img src='" + obj.icon + "' />" : "";
					output += icon + ((req === U.TypeEnum.isAssoc) ? (quo + obj.id + quo + ": ") : "")
						+ U.lineJSON(obj, wantquotes)
					+ ((i === length - 1) ? "" : ",") + brk;
				}
				output += ((req === U.TypeEnum.isAssoc) ? "}" : "]");
			}
			else
			{
				output = "API Objects Array is empty.";
			}
		}
		else if (req === U.TypeEnum.isObject)
		{
			output = (cache) ?
				((wantfile) ? U.lineJSON(cache) : U.escapeJSON(cache)) : "API Objects Array is empty.";
		}
		else if (req === U.TypeEnum.isInteger)
		{
			output = (Z.APICacheArrayOfIDs) ?
			((wantfile) ? U.lineJSON(Z.APICacheArrayOfIDs) : U.escapeJSON(Z.APICacheArrayOfIDs)) : "API IDs Array is empty.";
		}
		
		// Print or generate the output
		if (wantfile)
		{
			Z.createFile(output, (typeof Settings.aFileName === "string") ? Settings.aFileName : "apicache");
		}
		else
		{
			I.print(output);
		}
	},
	
	/*
	 * Creates a file from a regenerated unlockables record.
	 * @param object pRecord.
	 * @param boolean pIsFlat whether the record is just an array of numbers
	 * @param string pFilename or if "true" then will print to console.
	 * rather than objects.
	 */
	printUnlockables: function(pRecord, pIsFlat, pFilename)
	{
		var output = "";
		var catarr, arrlength;
		var objlength = U.getObjectLength(pRecord);
		var objlengthcounter = 0;
		for (var i in pRecord)
		{
			catarr = pRecord[i];
			arrlength = catarr.length;
			var keyq = (isNaN(i.charAt(0)) === false) ? "\"" : "";
			if (pIsFlat)
			{
				output += keyq + i + keyq + ": [" + catarr.toString() + "]";
			}
			else
			{
				output += keyq + i + keyq + ": [\r\n";
				for (var ii = 0; ii < arrlength; ii++)
				{
					output += "\t" + U.lineJSON(catarr[ii], false)
						+ ((ii === arrlength - 1) ? "" : ",") + "\r\n";
				}
				output += "]";
			}
			output += ((objlengthcounter === objlength - 1) ? "" : ",") + "\r\n";
			objlengthcounter++;
		}
		if (pFilename === true)
		{
			I.paste(output);
		}
		Z.createFile(output, pFilename);
	},
	
	/*
	 * Gets the latest items that was added to the API item database.
	 * @param int pSmartIndex if positive, will list that many latest items;
	 * if negative, will list the item at that index, from end of the array.
	 * @returns string of item details.
	 */
	printItemsAPI: function(pSmartIndex)
	{
		if (U.isInteger(pSmartIndex) === false)
		{
			I.write("Invalid reverse index.");
			return;
		}
		else
		{
			I.write("Retrieving items...");
			pSmartIndex = parseInt(pSmartIndex);
		}
		
		if (E.ItemsArray.length === 0)
		{
			$.get(U.URL_API.ItemDetail, function(pData)
			{
				E.ItemsArray = pData;
			}).done(function()
			{
				Z.printItemsAPI(pSmartIndex);
			}).fail(function()
			{
				I.warn("items database");
			});
		}
		else
		{
			var requesteditem = 0;
			var index = 0;
			if (pSmartIndex <= 0)
			{
				index = E.ItemsArray.length + pSmartIndex - 1;
				requesteditem = E.ItemsArray[index];
				Q.getItem(requesteditem, function(pData)
				{
					I.print("<img class='cssLeft' src='" + pData.icon + "' />" + U.escapeJSON(pData));
				}).fail(function()
				{
					I.warn("item: " + index);
				});
			}
			else
			{
				I.clear();
				for (var i = 0; i < pSmartIndex; i++)
				{
					index = E.ItemsArray.length - pSmartIndex - 1 - i;
					requesteditem = E.ItemsArray[index];
					Q.getItem(requesteditem, function(pData)
					{
						I.print("<img class='cssLeft' src='" + pData.icon + "' />" + U.escapeJSON(pData));
					}).fail(function()
					{
						I.warn("item: " + index);
					});
				}
			}
			
		}
	},
	
	/*
	 * Takes an array of API endpoint ID numbers, downloads every object they
	 * point to, and amasses them into an array of objects.
	 * @param string pSuffix of API endpoint.
	 * @param intarray pArray downloaded from API.
	 * @objparam string aQueryStr arguments for the API url.
	 * @objparam boolean aIsStandard whether to format the URL in standard v2 API format with a "/" preceding the ID.
	 * @objparam boolean aWantSort whether to sort the retrieved objects by their ID after, on by default.
	 * @objparam function aIterator to execute for every fetched data.
	 * @objparam function aCallback to execute after finishing scraping.
	 * @objparam int aCooldown seconds between cooldown.
	 * @objparam int aNumRetries number of retries.
	 * @objparam int aRetryCount used internally for recursive retrieval of failed IDs.
	 * @objparam array aCacheArray from previous scrape.
	 */
	scrapeAPIArray: function(pSuffix, pArray, pSettings)
	{
		var Settings = pSettings || {};
		var querystr = Settings.aQueryStr || "";
		var indexsep = (Settings.aIsStandard === false) ? "" : "/";
		var prefix = (Settings.aIsStandard === false) ? "" : U.URL_API.Prefix;
		var idsarray = [];
		var failedids = [];
		var failedindexes = [];
		var reqindex = 0;
		var numretries = (Settings.aNumRetries || 3);
		var reqlimit = 500;
		var reqcooldownms = (Settings.aCooldown || 30) * T.cMSECONDS_IN_SECOND;
		var numfetched = 0;
		var numtofetch = 0;
		var cachearr = Settings.aCacheArray || new Array(pArray.length);
		if (pArray.length === 0)
		{
			Settings.aCallback(null, null);
			return;
		}
		
		var finalizeScrape = function()
		{
			A.setProgressBar(numfetched, numtofetch);
			if (numfetched === numtofetch)
			{
				if (failedids.length > 0)
				{
					I.print("WARNING - Failed to retrieve some IDs: " + failedids);
				}
				else
				{
					I.print("All IDs successfully retrieved.");
				}
				// Recurse the function to retrieved fail IDs and append them to the current cache, will stop recursion if retry number exceeds
				if (Settings.aRetryCount !== 0 && failedids.length > 0)
				{
					var retrycount = (Settings.aRetryCount || numretries) - 1;
					I.print("Retrying " + retrycount + " times to fetch failed IDs...");
					Z.scrapeAPIArray(pSuffix, failedids, {
						aNumRetries: numretries,
						aRetryCount: retrycount,
						aCacheArray: cachearr,
						aFailedIndexes: failedindexes,
						aIsStandard: Settings.aIsStandard,
						aWantSort: Settings.aWantSort,
						aCooldown: Settings.aCooldown,
						aIterator: Settings.aIterator,
						aCallback: Settings.aCallback
					});
				}
				else
				{
					// Sort the objects by their IDs
					if (cachearr.length > 0 && cachearr[0].id && Settings.aWantSort !== false)
					{
						U.sortObjects(cachearr, {aKeyName: "id", aIsNumbers: true});
					}
					Z.APICacheArrayOfObjects = cachearr;
					// Execute callback if provided
					if (Settings.aCallback)
					{
						Settings.aCallback(cachearr, failedids);
					}
					else
					{
						I.print("Scrape completed. Enter /apicache to print the results.");
					}
				}
			}
		};
		
		var iterateIDs = function()
		{
			var reqcounter = 0;
			for (var i = reqindex; i < idsarray.length; i++)
			{
				if (reqcounter === reqlimit)
				{
					waitCooldown();
					return;
				}
				else
				{
					retrieveObject(idsarray[i], ((Settings.aFailedIndexes) ? Settings.aFailedIndexes[reqindex] : reqindex));
				}
				reqindex++;
				reqcounter++;
			}
		};
		
		var retrieveObject = function(pID, pIndex)
		{
			$.getJSON(prefix + pSuffix + indexsep + pID + querystr, function(pData)
			{
				cachearr[pIndex] = pData;
				// Execute iterator with data if requested
				if (Settings.aIterator)
				{
					Settings.aIterator(pData);
				}
				// Check for completion
				numfetched++;
				finalizeScrape();
			}).fail(function()
			{
				failedids.push(pID);
				failedindexes.push(pIndex);
				// Check for completion
				numtofetch--;
				finalizeScrape();
			});
		};
		
		var waitCooldown = function()
		{
			var percentcomplete = U.convertRatioToPercent(reqindex / idsarray.length);
			var secremaining = Math.ceil((idsarray.length - reqindex) / reqlimit) * ~~(reqcooldownms / T.cMSECONDS_IN_SECOND);
			I.print(D.getWordCapital("cooldown") + "... " + reqindex + " / " + idsarray.length
				+ " (" + percentcomplete + ")" + " " + T.formatTimeLetter(secremaining, true) + " " + D.getWord("remaining") + ".");
			setTimeout(function()
			{
				iterateIDs();
			}, reqcooldownms);
		};
		
		// Start the process
		if (Settings.aRetryCount === undefined)
		{
			Z.APICacheArrayOfIDs = pArray;
			Z.APICacheArrayOfObjects = [];
		}
		idsarray = pArray;
		numtofetch = idsarray.length;
		iterateIDs();
	},
	scrapeAPIArrayMultilingual: function(pSuffix, pArray, pCallback, pSettings)
	{
		var Settings = pSettings || {};
		Z.DatabaseCache[pSuffix] = {};
		var array;
		var multidb = Z.DatabaseCache[pSuffix]; 
		var counter = 0;
		var retrieveData = function()
		{
			if (counter < Z.DatabaseLanguages.length)
			{
				(function(iLang)
				{
					Settings.aQueryStr = "?lang=" + iLang;
					Settings.aCallback = function(pData)
					{
						multidb[iLang] = {};
						pData.forEach(function(iObj)
						{
							(multidb[iLang])[iObj.id] = iObj;
						});
						retrieveData();
					};
					Z.scrapeAPIArray(pSuffix, array, Settings);
				})(Z.DatabaseLanguages[counter]);
				counter++;
			}
			else
			{
				// Returns with a multilingual database, accessed first by the language code, then the object ID
				pCallback(multidb);
			}
		};
		if (Array.isArray(pArray))
		{
			array = pArray;
			retrieveData();
		}
		else if (typeof pArray === "number")
		{
			array = [pArray];
			retrieveData();
		}
		else
		{
			// If not provided an array of IDs then retrieve it from the API
			$.getJSON(U.getAPI(pSuffix), function(pData)
			{
				array = pData;
				retrieveData();
			});
		}
	},
	
	/*
	 * Fetches an API endpoint in all available languages.
	 * @param string pURL to fetch.
	 * @param function pCallback to execute after.
	 */
	fetchAPIMultilingual: function(pURL, pCallback)
	{
		var multidb = {};
		var numfetched = 0;
		var numtofetch = Z.DatabaseLanguages.length;
		var retrieveData = function()
		{
			if (numfetched < numtofetch)
			{
				(function(iLang)
				{
					var url = pURL + U.getDivider(pURL) + "lang=" + iLang;
					$.getJSON(url, function(pData)
					{
						multidb[iLang] = pData;
						retrieveData();
						A.setProgressBar(numfetched, numtofetch);
					}).fail(function()
					{
						I.print("Error retrieving " + U.escapeHTML(url) + ". Fetch aborted.");
					});
				})(Z.DatabaseLanguages[numfetched]);
				numfetched++;
			}
			else
			{
				// Returns with a multilingual database, accessed first by the language code, then the object ID
				pCallback(multidb);
			}
		};
		retrieveData();
	},
	
	/*
	 * Creates a processed object from a color API object, to be stored in the
	 * custom dyes database for use in account bank.
	 * @param object pColor.
	 * @returns object.
	 * @pre Items database for all languages were loaded.
	 */
	processDye: function(pColor, pColorDB)
	{
		var itemdb = (Z.DatabaseCache["items"])[O.OptionEnum.Language.Default];
		var item = itemdb[pColor.item];
		// Create CSS colors from the RGB values
		var materials = ["cloth", "leather", "metal"];
		var matarr = [];
		for (var i = 0; i < materials.length; i++)
		{
			var ithmat = materials[i];
			matarr.push(U.convertRGBToHex((pColor[ithmat]).rgb));
		}
		
		// Format of the object with properties in this order
		var obj = {};
		obj.u = pColor.id;
		if (pColor.item) // If the color has an associated item to unlock it
		{
			obj.i = pColor.item;
			obj.n = item.name;
		}
		else
		{
			obj.n = pColor.name;
		}
		obj.c = matarr;
		obj.h = pColor.categories[0];
		obj.m = pColor.categories[1];
		obj.l = item.chat_link;
		// Add translated names, with the property key as the language code
		Z.DatabaseLanguages.forEach(function(iLang)
		{
			obj[iLang] = (pColorDB[iLang])[pColor.id].name;
		});
		
		return obj;
	},
	
	/*
	 * Prints the current daily achievements.
	 * @param boolean pWantTomorrow whether to get tomorrow's instead of today's.
	 */
	printDaily: function(pWantTomorrow)
	{
		var numfetched = 0;
		var numtofetch = 0;
		var dailyobj = {};
		var finalizeDaily = function()
		{
			if (numtofetch === numfetched)
			{
				if (pWantTomorrow === undefined)
				{
					I.print("TODAY'S DAILIES");
				}
				for (var i in dailyobj)
				{
					I.print(i);
					for (var ii in dailyobj[i])
					{
						var ach = (dailyobj[i])[ii];
						I.prettyJSON(ach);
					}
				}
				// Also recursively print tomorrow's
				if (pWantTomorrow === undefined)
				{
					I.print("<br />");
					I.print("TOMORROW'S DAILIES");
					Z.printDaily(true);
				}
			}
		};
		
		var url = (pWantTomorrow) ? U.URL_API.Tomorrow : U.URL_API.Daily;
		$.getJSON(U.getLangURL(url), function(pData)
		{
			for (var i in pData)
			{
				numtofetch += (pData[i]).length;
			}
			for (var i in pData)
			{
				dailyobj[i] = [];
				for (var ii in pData[i])
				{
					var ach = (pData[i])[ii];
					(function(iAchArray, iAch)
					{
						$.getJSON(U.getAPIAchievement(iAch.id), function(iData)
						{
							iData.level = iAch.level; // Append the level from the daily object to the actual achievement
							iAchArray.push(iData);
						}).always(function()
						{
							numfetched++;
							finalizeDaily();
						});
					})(dailyobj[i], ach);
				}
			}
		});
	},
	
	/*
	 * Loads a database in all available languages.
	 * @param string pName of database to look for file.
	 * @param function pCallback to execute after loaded.
	 */
	loadMultilingualDatabase: function(pName, pCallback)
	{
		var dbname = pName.toLowerCase();
		var database = {};
		// Use loaded database if available
		var isdbloaded = true;
		Z.DatabaseLanguages.forEach(function(iLang)
		{
			if (Z.DatabaseCache[iLang] === undefined)
			{
				isdbloaded = false;
			}
		});
		if (isdbloaded)
		{
			pCallback(Z.DatabaseCache[dbname]);
			return;
		}
		
		// Check to see if all language versions of the database are loaded
		var finalize = function()
		{
			var isallloaded = true;
			Z.DatabaseLanguages.forEach(function(iLang)
			{
				if (database[iLang] === undefined)
				{
					isallloaded = false;
				}
			});
			if (isallloaded)
			{
				Z.DatabaseCache[dbname] = database;
				pCallback(Z.DatabaseCache[dbname]);
			}
		};
		
		// Retrieve the database
		Z.DatabaseLanguages.forEach(function(iLang)
		{
			$.getJSON(U.getItemsDatabaseURL(iLang), function(pData)
			{
				database[iLang] = pData;
				finalize();
			});
		});
	},
	
	/*
	 * Loads the items database in the default language.
	 * @param function pCallback to execute after loaded.
	 */
	getItemsDatabase: function(pCallback)
	{
		var lang = O.OptionEnum.Language.Default;
		var db = Z.DatabaseCache["items"];
		if (db && db[lang])
		{
			pCallback(db[lang]);
		}
		else
		{
			$.getJSON(U.getItemsDatabaseURL(lang), function(pData)
			{
				if (Z.DatabaseCache["items"] === undefined)
				{
					Z.DatabaseCache["items"] = {};
				}
				(Z.DatabaseCache["items"])[lang] = pData;
				pCallback(pData);
			});
		}
	},
	
	/*
	 * Loads the items database in all available languages.
	 * @param function pCallback to execute after loaded.
	 */
	loadItemsDatabase: function(pCallback)
	{
		Z.loadMultilingualDatabase("items", pCallback);
	},
	
	/*
	 * Creates JSON files containing an associative array of item details, for
	 * use by a specific Account page section.
	 * @param string pType section.
	 * @param intarray IDs to include instead of using the section record, optional.
	 */
	updateItemsSubdatabase: function(pType, pIDs)
	{
		var scripturl = U.getDataScriptURL(pType.toLowerCase());
		var dblang;
		var itemids = [];
		var createSubdatabase = function()
		{
			itemids = U.getUnique(itemids);
			for (var i in dblang)
			{
				// Reinitialize for ith language
				Z.APICacheArrayOfObjects = null;
				Z.APICacheArrayOfObjects = [];
				var db = dblang[i];
				var ithid;
				for (var ii = 0; ii < itemids.length; ii++)
				{
					ithid = itemids[ii];
					if (db[ithid])
					{
						Z.APICacheArrayOfObjects.push(db[ithid]);
					}
					else if (isNaN(ithid) === false)
					{
						I.print("Error looking up item: " + ithid);
					}
				}
				U.sortObjects(Z.APICacheArrayOfObjects, {aKeyName: "id"});
				var filename = pType.toLowerCase() + "_" + i + I.cJSON;
				Z.printAPICache(U.TypeEnum.isAssoc, {aWantQuotes: true, aFileName: filename});
			}
		};
		
		I.print("Loading items database...");
		Z.loadItemsDatabase(function(pDatabase)
		{
			dblang = pDatabase;
			if (pIDs)
			{
				itemids = pIDs;
				createSubdatabase();
			}
			else
			{
				I.print("Loading section record...");
				U.getScript(scripturl, function()
				{
					Z.freeFiles();
					var record = U.getRecordData(pType);
					for (var i in record)
					{
						var catarr = record[i];
						for (var ii = 0; ii < catarr.length; ii++)
						{
							if (catarr[ii].i)
							{
								itemids.push(catarr[ii].i);
							}
							else if (typeof catarr[ii] === "number")
							{
								itemids.push(catarr[ii]);
							}
						}
					}
					createSubdatabase();
				}).fail(function()
				{
					I.print("Error retrieving script: " + scripturl);
				});
			}
		});
	},
	
	/*
	 * Loads an unlockables record, downloads the current API array, compares
	 * for new IDs, and retrieves the new entries.
	 * @param string pSection name of account section and record.
	 * @param string pEndpoint name of API URL suffix, or an array of item IDs for comparison.
	 * @param function pCallback to execute after loaded.
	 */
	getNewAPIEntries: function(pSection, pEndpoint, pCallback)
	{
		var section = pSection;
		var sectionlower = pSection.toLowerCase();
		var endpoint;
		var record, blacklist, apiids;
		var iscustomids = Array.isArray(pEndpoint);
		
		var fetchNewEntries = function()
		{
			// Combine the record's categories into one associative array
			var catarr, entry, storedids = [];
			for (var i in record)
			{
				catarr = record[i];
				for (var ii = 0; ii < catarr.length; ii++)
				{
					entry = catarr[ii];
					if (iscustomids)
					{
						storedids.push(entry.i);
					}
					else
					{
						storedids.push(entry.u);
					}
				}
			}
			// Reformat the API IDs into an array of integers if it is objects
			apiids = A.flattenUnlocks(apiids);
			// Compile IDs to fetch by filtering: new IDs, not in blacklist
			var newids = U.getDifference(apiids, storedids);
			var filteredids = (blacklist === undefined) ? newids : (newids.filter(function(iID)
			{
				if (blacklist[iID] === undefined)
				{
					return iID;
				}
			}));
			
			if (filteredids.length === 0)
			{
				I.print("No difference found between stored " + sectionlower + " record and post-blacklisted API array.");
				return;
			}
			// Execute callback with filtered list in object
			if (iscustomids)
			{
				pCallback({
					oRecord: record,
					oBlacklist: blacklist,
					oEntries: filteredids,
					oNewIDs: filteredids
				});
			}
			else
			{
				// Fetch new entries
				U.fetchAPI(U.URL_API.Prefix + endpoint, filteredids, {aCallback: function(pData)
				{
					pCallback({
						oRecord: record,
						oBlacklist: blacklist,
						oEntries: pData,
						oNewIDs: filteredids
					});
				}});
			}
		};
		
		U.getScript(U.getDataScriptURL(section), function()
		{
			record = U.getRecordData(section);
			blacklist = U.getRecordBlacklist(section);
			if (iscustomids)
			{
				apiids = pEndpoint;
				fetchNewEntries();
			}
			else
			{
				endpoint = pEndpoint.toLowerCase();
				$.getJSON(U.getAPI(endpoint), function(pData)
				{
					apiids = pData;
					fetchNewEntries();
				});
			}
		});
	},
	
	/*
	 * Prints a new unlockables record entry to the console.
	 * @param array pEntries item details objects.
	 * @objparam string aItemIDsKey name of property for getting the associated item ID.
	 * @objparam object aItemDB for looking up items.
	 */
	printRecordEntry: function(pEntries, pSettings)
	{
		I.print("");
		if (pEntries.length)
		{
			I.print("New items added:");
		}
		else
		{
			I.print("No new items added. Record is up-to-date.");
			return;
		}
		
		var Settings = pSettings || {};
		var ithentry, entryobj, entrystr, blackliststr = "", entrystrs = [], itemidsproperty, itemids, itemid, name;
		var icon, entryelm, itemselm, inputselm, unlockid;
		for (var i in pEntries)
		{
			ithentry = pEntries[i];
			icon = (ithentry.icon) ? "<img src='" + ithentry.icon + "' />" : "";
			entryelm = $("<div style='margin-bottom:24px'><span>" + icon + U.escapeHTML(U.lineJSON(ithentry))
				+ "</span></div>").appendTo(I.getConsole());
			itemselm = $("<div></div>").appendTo(entryelm);
			
			unlockid = ithentry["unlock_items"];
			itemidsproperty = (unlockid) ? (unlockid || unlockid[0]) : ithentry[Settings.aItemIDsKey];
			if (itemidsproperty)
			{
				itemids = (Array.isArray(itemidsproperty)) ? itemidsproperty : [itemidsproperty];
				for (var ii = 0; ii < itemids.length; ii++)
				{
					itemid = itemids[ii];
					name = (Settings.aItemDB) ? Settings.aItemDB[itemid].name : ithentry.name;
					entryobj = ithentry.oRecordEntry || {
						u: ithentry.id,
						i: itemid,
						n: name,
						p: {gem: null}
					};
					if (entryobj.u === entryobj.i)
					{
						delete entryobj["u"];
					}
					entrystr = U.lineJSON(entryobj, false) + ",";
					inputselm = $("<aside>&nbsp;<a" + U.convertExternalAnchor(U.getWikiLinkDefault(name)) + ">" + name + "</a></aside>").appendTo(itemselm);
					$("<input class='cssInputText' type='text' />").prependTo(inputselm).val(entrystr);
					$("<input class='cssInputText' type='text' />").prependTo(inputselm).val(itemid);
					entrystrs.push(entrystr);
					blackliststr += "&quot;" + ithentry.id + "&quot;" + ": " + "&quot;<a"
						+ U.convertExternalAnchor(U.getWikiLinkDefault(name)) + "'>" + name + "</a>&quot;,<br />";
				}
			}
			I.bindInputSelect(entryelm.find(".cssInputText"));
		}
		I.print(blackliststr);
		I.print(entrystrs.join("<br />"));
		I.bindConsoleInput();
	},
	
	/*
	 * Executes a collate function.
	 * @param string pName of the function.
	 */
	executeCollate: function(pName, pExtra)
	{
		var prefix = "collate", name;
		var printFunctions = function()
		{
			I.print("Collate function not found, available functions:");
			for (var i in Z)
			{
				if (i.indexOf(prefix) !== -1)
				{
					name = i.substring(i.indexOf(prefix) + prefix.length, i.length).toLowerCase();
					I.print(name);
				}
			}
		};
		
		if (pName)
		{
			var functionname = prefix + U.toFirstUpperCase(pName);
			if (Z[functionname])
			{
				(Z[functionname])(pExtra);
			}
			else
			{
				printFunctions();
			}
		}
		else
		{
			printFunctions();
		}
	},
	
	/*
	 * Downloads API entries that are missing from the current version of the
	 * database for every available API languages.
	 * @param string pType of database, such as items or achievements.
	 * @boolean pIsRebuild whether to redownload all entries.
	 */
	collateDatabase: function(pType, pIsRebuild)
	{
		var type = pType.toLowerCase();
		var typeupper = U.toFirstUpperCase(type);
		var wantrebuild = (pIsRebuild === true);
		var counter = 0;
		var newitemslist, newitems, newitemids;
		var isitemsdb = (type === "items") ? true : false;
		
		var updateDBLang = function()
		{
			// Stopping condition for this recursive function
			if (counter >= Z.DatabaseLanguages.length)
			{
				I.print(typeupper + " database of all languages updated.");
				if (newitems && !wantrebuild)
				{
					if (isitemsdb)
					{
						Q.sortItems(newitemids, function(pSortedItems, pSortedIDs)
						{
							Z.printRecordEntry(pSortedItems, {aItemIDsKey: "id"});
							Z.collateMuseum(pSortedIDs);
						});
					}
					else
					{
						Z.printRecordEntry(newitems, {aItemIDsKey: "id"});
					}
				}
				return;
			}
			var lang = Z.DatabaseLanguages[counter];
			var dburl = (isitemsdb) ? U.getItemsDatabaseURL(lang) : U.getCacheURL(type, lang);
			$.getJSON(dburl, function(pData)
			{
				var dbarray = [];
				var currentitemids = [];
				// Convert the associative array into an array for later sorting
				for (var ithitemid in pData)
				{
					if (!wantrebuild)
					{
						dbarray.push(pData[ithitemid]);
					}
					currentitemids.push(parseInt(ithitemid));
				}
				// Find what item IDs are missing by comparing the API's current list with the one here
				newitemids = (wantrebuild) ? currentitemids : ((newitemids === undefined) ? U.getDifference(newitemslist, currentitemids) : newitemids);
				if (newitemids.length)
				{
					U.fetchAPI(U.getAPIURL(type), newitemids, {
						aLanguage: lang,
						aCallback: function(pNewItems)
					{
						for (var i = 0; i < pNewItems.length; i++)
						{
							dbarray.push(pNewItems[i]);
						}
						if (lang === O.OptionEnum.Language.Default)
						{
							newitems = pNewItems;
						}
						U.sortObjects(dbarray, {aKeyName: "id"});
						Z.APICacheArrayOfObjects = dbarray;
						// Force unicode encoding on English
						var firstitem = Z.APICacheArrayOfObjects[0];
						if (lang === O.OptionEnum.Language.English && firstitem.name.indexOf(I.Symbol.Unicode) === -1)
						{
							firstitem.name += I.Symbol.Unicode;
						}
						Z.printAPICache(U.TypeEnum.isAssoc, {
							aWantQuotes: true,
							aFileName: type + "_" + lang + ((isitemsdb) ? I.cTXT : I.cJSON)
						});
						counter++;
						updateDBLang();
					}});
				}
				else
				{
					I.print(typeupper + " database is up-to-date. No difference found in IDs list.");
				}
			});
		};
		
		// Initial call
		I.print("Retrieving " + type + " indexes...");
		$.getJSON(U.getAPIURL(type), function(pData)
		{
			I.print("Looking for difference...");
			newitemslist = pData;
			updateDBLang();
		});
	},
	
	/*
	 * Decomposes the items database into a lightweight array for searching by name.
	 * Sample structure: [[69984,"bo"],[31283,"bow"],[70936,"keg"]...]
	 * @pre Items database files are up to date.
	 */
	collateSearch: function()
	{
		I.print("Loading items database...");
		Z.loadItemsDatabase(function()
		{
			I.print("Generating language search files...");
			Z.DatabaseLanguages.forEach(function(iLang)
			{
				var db = [];
				var sortabledb = [];
				var item;
				var ithdb = (Z.DatabaseCache["items"])[iLang];
				
				// Convert the assoc array into an array
				for (var ii in ithdb)
				{
					item = ithdb[ii];
					if (item.name)
					{
						sortabledb.push({
							i: item.id,
							n: item.name.toLowerCase(),
							l: item.name.length
						});
					}
				}
				// Sort the database by the item's name length, rather than ID number as it currently is
				U.sortObjects(sortabledb, {aKeyName: "l"});
				for (var ii = 0; ii < sortabledb.length; ii++)
				{
					item = sortabledb[ii];
					db.push([item.i, item.n]);
				}
				var dbstr = U.compressToJS(db);
				Z.createFile(dbstr, "search_" + iLang + I.cJSON);
			});
		});
	},
	
	/*
	 * Outputs the materials categories in the unlockables record format.
	 */
	collateMaterials: function()
	{
		var section = "Materials";
		U.getScript(U.getDataScriptURL(section), function()
		{
			var record = {};
			var headers = U.getRecordHeader(section);
			var assoc = U.getRecordMetadata(section).CategoryAssoc;
			var catname, catarr;
			for (var i in headers)
			{
				record[i] = [];
			}
			$.getJSON(U.getAPIMaterial(), function(pMatCategoryIDs)
			{
				Z.scrapeAPIArray(section.toLowerCase(), pMatCategoryIDs, {aCallback: function(pMatCategories)
				{
					for (var i in pMatCategories)
					{
						catarr = pMatCategories[i];
						catname = assoc[catarr.id];
						record[catname] = catarr.items;
					}
					Z.printUnlockables(record, true, true);
				}});
			});
		});
	},
	
	/*
	 * Updates the skins unlockables record by looking for new skin IDs, then
	 * downloads, categorizes, and associates the skins to their unlocking items.
	 * @pre Items database is up to date.
	 */
	collateSkins: function()
	{
		var section = "Skins";
		var itemdb, record, blacklist;
		var newentries, newskins, categorizedskins = {};
		
		// Updates an added skin entry in the record
		var updateSkinEntry = function(pEntry, pItem)
		{
			pEntry.i = pItem.id;
			// Add to the list of items associated with this skin, this will not be included in the result
			if (newskins[pEntry.u].oAssocItems === undefined)
			{
				newskins[pEntry.u].oAssocItems = [];
			}
			newskins[pEntry.u].oAssocItems.push(pItem.id);
			// Update skin entry properties
			if (Q.isTradeable(pItem))
			{
				// IDs of items that unlock the skin
				if (pEntry.b === undefined)
				{
					pEntry.b = [];
				}
				pEntry.b.push(pItem.id);
			}
			else
			{
				// If not tradeable then a custom payment property must be later manually assigned
				pEntry.p = {gem: null};
			}
		};
		
		// Scans through the item database once, modifying the skin entry in the record if the item has a matching skin ID
		var associateNewSkins = function()
		{
			var item, skinid, skinids;
			for (var i in itemdb)
			{
				item = itemdb[i];
				skinid = null;
				if (item.default_skin)
				{
					skinid = item.default_skin;
				}
				else if (item.details && item.details.skins)
				{
					skinid = item.details.skins;
				}
				// Get the matching skin entry and update its associated item ID property
				if (skinid)
				{
					skinids = (Array.isArray(skinid)) ? skinid : [skinid];
					for (var ii = 0; ii < skinids.length; ii++)
					{
						if (categorizedskins[skinids[ii]])
						{
							updateSkinEntry(categorizedskins[skinids[ii]], item);
						}
					}
				}
			}
			// Final output
			Z.printUnlockables(record, null, true);
			Z.printRecordEntry(newentries, {
				aItemDB: itemdb,
				aItemIDsKey: "oAssocItems"
			});
		};
		
		// Find new API entries
		Z.getNewAPIEntries(section, section, function(pReturn)
		{
			record = pReturn.oRecord;
			blacklist = pReturn.oBlacklist;
			newentries = pReturn.oEntries;
			
			var isnewblacklist = false;
			var catname;
			var ithskin;
			newskins = {};
			for (var i = 0; i < newentries.length; i++)
			{
				ithskin = newentries[i];
				newskins[ithskin.id] = ithskin;
				if (ithskin.name === "" || ithskin.type === undefined)
				{
					// Create a new blacklist by looking for mismatch or improper skins
					isnewblacklist = true;
					blacklist[ithskin.id] = ithskin.name;
				}
				else
				{
					// Categorize skin
					catname = "";
					if (ithskin.type === "Armor" && ithskin.details && ithskin.details.type && ithskin.details.weight_class)
					{
						catname = ithskin.type + "_" + ithskin.details.weight_class + "_" + ithskin.details.type;
					}
					else if (ithskin.type === "Weapon" && ithskin.details && ithskin.details.type)
					{
						catname = ithskin.type + "_" + ithskin.details.type;
					}
					else if (ithskin.type === "Back")
					{
						catname = ithskin.type;
					}
					// Create initial entry in the record, to be assigned with associated item ID later
					var entry = {
						u: ithskin.id,
						i: null,
						n: ithskin.name
					};
					if (record[catname])
					{
						record[catname].push(entry);
						categorizedskins[ithskin.id] = entry;
					}
					else
					{
						I.print("Warning uncategorizable skin:");
						I.prettyJSON(ithskin);
					}
				}
			}
			// Print the blacklist if there are new items to blacklist
			if (isnewblacklist)
			{
				I.prettyJSON(blacklist);
			}
			// Categorize
			Z.getItemsDatabase(function(pDatabase)
			{
				itemdb = pDatabase;
				associateNewSkins();
			});
		});
	},
	
	/*
	 * Finds and prints unlockables from the API not already in the unlockables record.
	 */
	collateUnlockables: function(pSection, pEndpoint)
	{
		var section = pSection;
		Z.getNewAPIEntries(section, pEndpoint || section, function(pReturn)
		{
			Z.printRecordEntry(pReturn.oEntries, {
				aItemIDsKey: "item_id"
			});
		});
	},
	collateOutfits: function()
	{
		Z.collateUnlockables("Outfits");
	},
	collateGliders: function()
	{
		Z.collateUnlockables("Gliders");
	},
	collateMinis: function()
	{
		Z.collateUnlockables("Minis");
	},
	collateCarriers: function()
	{
		Z.collateUnlockables("Carriers", "mailcarriers");
	},
	collateFinishers: function()
	{
		Z.collateUnlockables("Finishers");
	},
	
	/*
	 * Sorts the dyes database according to set, hue, then lightness.
	 */
	collateDyes: function()
	{
		var section = "Dyes";
		var record, newentries;
		I.print("Loading items database...");
		Z.getItemsDatabase(function()
		{
			I.print("Looking for difference...");
			Z.getNewAPIEntries(section, "colors", function(pReturn)
			{
				record = pReturn.oRecord;
				newentries = pReturn.oEntries;
				I.print("Downloading color translations...");
				Z.scrapeAPIArrayMultilingual("colors", pReturn.oNewIDs, function(pDataColor)
				{
					I.clear();
					newentries.forEach(function(iEntry)
					{
						var color = Z.processDye(iEntry, pDataColor);
						I.print(U.lineJSON(color, false) + ",");
					});
				});
			});
		});
	},
	
	/*
	 * Reads the item database for some collectionesque items. Other items such
	 * as toys will have to be manually added.
	 */
	collateCatalog: function()
	{
		var section = "Catalog";
		
		// Returns the category name of an item, if fitting
		var categorizeItem = function(pItem)
		{
			var name = pItem.name.toLowerCase();
			var desc = (pItem.description) ? pItem.description.toLowerCase() : "";
			if (desc.indexOf("to transform") !== -1 || desc.indexOf("to become") !== -1)
			{
				if (pItem.type === Q.ItemEnum.Gizmo)
				{
					return "TonicEndless";
				}
				if (pItem.type === Q.ItemEnum.Consumable)
				{
					return "TonicConsumable";
				}
			}
			if (pItem.type === Q.ItemEnum.Gathering && pItem.rarity === Q.RarityEnum.Exotic)
			{
				return "Gathering";
			}
			if (pItem.type === Q.ItemEnum.UpgradeComponent && name.indexOf("infusion") !== -1)
			{
				return "Aura";
			}
			if (pItem.rarity === Q.RarityEnum.Legendary && pItem.type === Q.ItemEnum.Weapon)
			{
				return "Legendary";
			}
			if (pItem.details && pItem.details.unlock_type)
			{
				var unlock = pItem.details.unlock_type;
				if (unlock === "Content" && name.indexOf("mail") !== -1)
				{
					return "Carrier";
				}
			}
			return null;
		};
		
		I.print("Loading items database...");
		Z.getItemsDatabase(function(pDatabase)
		{
			I.print("Loading " + section);
			U.getScript(U.getDataScriptURL(section), function()
			{
				var item, catname;
				var newitems = [];
				var record = U.getRecordData(section);
				var assoc = A.flattenRecord(record);
				var blacklist = U.getRecordBlacklist(section);
				for (var i in pDatabase)
				{
					item = pDatabase[i];
					// Exclude blacklisted
					if (blacklist[item.id])
					{
						continue;
					}
					catname = categorizeItem(item);
					// Add the item if matched
					if (catname && assoc[item.id] === undefined)
					{
						newitems.push(item);
						record[catname].push({
							i: item.id,
							n: item.name,
							p: {gem: null}
						});
					}
				}
				Z.printUnlockables(record);
				Z.printRecordEntry(newitems, {
					aItemIDsKey: "id"
				});
			});
		});
	},
	
	/*
	 * Reads the item database for container items and "useless" items.
	 */
	collateCleanup: function()
	{
		var section = "Cleanup";
		var record = {};
		var db;
		
		var doCollate = function()
		{
			// Initialize the record's arrays
			var headers = U.getRecordHeader(section);
			for (var i in headers)
			{
				record[i] = [];
			}
			// Use the main catalog as the blacklist
			var blacklist = {};
			var catarr, itemid;
			var catalog = U.getRecordData("Catalog");
			for (var i in catalog)
			{
				catarr = catalog[i];
				for (var ii = 0; ii < catarr.length; ii++)
				{
					itemid = catarr[ii].i;
					blacklist[itemid] = true;
				}
			}
			// Exclude items from material storage
			var materials = U.getRecordData("Materials");
			for (var i in materials)
			{
				var matcat = materials[i];
				for (var ii = 0; ii < matcat.length; ii++)
				{
					blacklist[(matcat[ii])] = true;
				}
			}
			
			// Categorize the whitelist
			var item, catname;
			for (var i in db)
			{
				item = db[i];
				// Exclude blacklisted
				if (blacklist[item.id])
				{
					continue;
				}
				catname = Q.categorizeCleanableItem(item);
				// Add the item if matched
				if (catname)
				{
					record[catname].push(item.id);
				}
			}
			Z.printUnlockables(record, true, true);

			// Also print junk items prices
			var junkvalue = {};
			for (var i in db)
			{
				var item = db[i];
				if (item.rarity === Q.RarityEnum.Junk && item.vendor_value > 0)
				{
					junkvalue[item.id] = item.vendor_value;
				}
			}
			I.paste(U.lineJSON(junkvalue));
		};
		
		// Retrieve data first
		U.getScript(U.getDataScriptURL(section), function()
		{
			U.getScript(U.getDataScriptURL("Catalog"), function()
			{
				U.getScript(U.getDataScriptURL("Materials"), function()
				{
					Z.getItemsDatabase(function(pDatabase)
					{
						db = pDatabase;
						doCollate();
					});
				});
			});
		});
	},
	
	/*
	 * Updates the unlockables record of ascended items.
	 */
	collateAscended: function()
	{
		var categorizeItem = function(pItem)
		{
			var name = pItem.name.toLowerCase();
			if (pItem.type === Q.ItemEnum.Container && name.indexOf("recipe") === -1)
			{
				if (name.indexOf("weapon") !== -1)
				{
					return "ContainerWeapon";
				}
				if (name.indexOf("armor") !== -1)
				{
					return "ContainerArmor";
				}
			}
			else if (pItem.type === Q.ItemEnum.Weapon || pItem.type === Q.ItemEnum.Trinket)
			{
				return pItem.details.type;
			}
			else if (pItem.type === Q.ItemEnum.Armor)
			{
				return pItem.details.weight_class + pItem.details.type;
			}
			else if (pItem.type === Q.ItemEnum.Back)
			{
				return pItem.type;
			}
			return null;
		};
		
		var ascendedids = [];
		Z.getItemsDatabase(function(pDatabase)
		{
			var item, name, type, category;
			// Compile a list of desired ascended items from the database
			for (var i in pDatabase)
			{
				item = pDatabase[i];
				type = item.type;
				if (item.rarity === Q.RarityEnum.Ascended)
				{
					if (categorizeItem(item))
					{
						ascendedids.push(item.id);
					}
				}
			}
			// Filter against current list of ascendeds and print the new items
			Z.getNewAPIEntries("ascended", ascendedids, function(pReturn)
			{
				var newitems = [];
				for (var i in pReturn.oEntries)
				{
					item = pDatabase[(pReturn.oEntries[i])];
					name = U.escapeHTML(item.name);
					// Add the categorizable items to the record and output as file
					category = categorizeItem(item);
					if (category)
					{
						pReturn.oRecord[category].push({
							i: item.id,
							n: item.name,
							p: {coin: -1}
						});
						newitems.push(item);
					}
				}
				Z.printUnlockables(pReturn.oRecord, null, true);
				Z.printRecordEntry(newitems, {
					aItemIDsKey: "id"
				});
			});
		});
	},
	
	/*
	 * Reads the database of recipes and creates an unlockables record with the
	 * disciplines as categories.
	 * @pre Recipes database from API is up to date and precached.
	 */
	collateRecipes: function()
	{
		var db, record = {}, item, entry, entries;
		var sheets = {};
		var sheetstradeable = {};
		var doCollate = function(pReturn)
		{
			record = pReturn.oRecord;
			entries = pReturn.oEntries;
			// Create a list of recipe sheets
			for (var i in db)
			{
				item = db[i];
				if (item.details && item.details.unlock_type === "CraftingRecipe")
				{
					if (Q.isTradeable(item))
					{
						sheetstradeable[(item.details.recipe_id)] = item.id;
					}
					sheets[(item.details.recipe_id)] = item.id;
				}
			};

			var recipe, catname, discipline, ingredients, type, itemid, newitems = [];
			for (var i in entries)
			{
				recipe = entries[i];
				type = recipe.type;
				itemid = recipe.output_item_id;
				for (var ii = 0; ii < recipe.disciplines.length; ii++)
				{
					discipline = recipe.disciplines[ii];
					catname = discipline + "_" + recipe.type;
					// Merge some smaller categories into a bigger category
					if (recipe.type === "RefinementObsidian" || recipe.type === "RefinementEctoplasm")
					{
						catname = discipline + "_" + "Refinement";
					}
					if (db[itemid] && record[catname])
					{
						ingredients = [];
						recipe.ingredients.forEach(function(iIngredient)
						{
							ingredients.push([iIngredient.item_id, iIngredient.count]);
						});
						entry = {
							u: recipe.id,
							i: itemid,
							n: db[itemid].name,
							r: ingredients
						};
						if (sheets[recipe.id])
						{
							entry.s = sheets[recipe.id];
						}
						if (sheetstradeable[recipe.id])
						{
							entry.b = sheetstradeable[recipe.id];
						}
						record[catname].push(entry);
						newitems.push(db[itemid]);
					}
				}
			}
			// Discard the empty array categories
			var newrecord = {};
			for (var i in record)
			{
				if (record[i].length)
				{
					newrecord[i] = record[i];
				}
			}
			Z.printUnlockables(newrecord);
			Z.printRecordEntry(newitems);
		};
		
		I.print("Loading items database...");
		Z.getItemsDatabase(function(pDatabase)
		{
			I.print("Looking for difference...");
			Z.getNewAPIEntries("Recipes", "Recipes", function(pReturn)
			{
				db = pDatabase;
				doCollate(pReturn);
			});
		});
	},
	
	/*
	 * Updates the achievements database for all languages.
	 */
	collateAchievements: function()
	{
		Z.collateDatabase("achievements");
	},
	
	/*
	 * Creates a cache file of Trading Post prices to be used by the account audit function.
	 */
	collatePrices: function()
	{
		// Should only include records that have tradeable items
		var recordnames = ["materials", "skins", "dyes", "minis", "carriers", "champions", "finishers", "nodes", "recipes"];
		var recordnamescounter = 0;
		var db, record, catarr;
		var idstocache = {};
		var numcached = 0;
		var numcaches = recordnames.length;
		
		var fetchPrices = function(pPriceDB)
		{
			// Scan the entire item database for untradeable items
			var blacklist = pPriceDB["blacklist"];
			for (var i in db)
			{
				if (Q.isTradeable(db[i]) === false && blacklist[i] === undefined)
				{
					blacklist[i] = 1;
				}
			}
			// Include ingredients of composite items
			var compositeingr = U.getRecordMetadata("ascended").CompositeIngredients;
			var ingrid;
			for (var i in compositeingr)
			{
				for (var ii = 0; ii < compositeingr[i].length; ii++)
				{
					ingrid = ((compositeingr[i])[ii])[0];
					if (blacklist[ingrid] === undefined)
					{
						idstocache[ingrid] = true;
					}
				}
			}
			// Convert associative array into array before fetching
			var arr = [];
			for (var i in idstocache)
			{
				if (blacklist[i] === undefined)
				{
					arr.push(parseInt(i));
				}
			}
			
			I.print("Fetching prices...");
			E.getPrices(arr, function(pData, pUntradeableIDs)
			{
				// Add to the untradeable list any items that got past the tradeable check
				/*for (var i in pUntradeableIDs)
				{
					blacklist[(pUntradeableIDs[i])] = 1;
				}*/
				// Extract retrieved prices and create database of prices
				var pricecache = {};
				var priceobj;
				for (var i in pData)
				{
					priceobj = pData[i];
					pricecache[i] = [priceobj.oPriceBuy, priceobj.oPriceSell];
				}
				var str = "{\r\n"
					+ "\"data\":" + U.lineJSON(pricecache).replace(/ /g, "") + ",\r\n"
					+ "\"blacklist\":" + U.lineJSON(blacklist).replace(/ /g, "") + "\r\n"
					+ "}";
				Z.createFile(str, "prices.json");
			});
		};
		
		// Load composite ingredient IDs and the previous ID blacklist
		var loadMetadata = function()
		{
			I.print("Loading prices data...");
			U.getScript(U.URL_DATA.Ascended, function()
			{
				$.getJSON(U.URL_DATA.Prices, function(pData)
				{
					fetchPrices(pData);
				});
			});
		};
		
		// Macro function to iterate over an unlockables record
		var iterateRecord = function(pIteration)
		{
			var name = recordnames[recordnamescounter];
			recordnamescounter++;
			U.getScript(U.getDataScriptURL(name), function()
			{
				record = U.getRecordData(name);
				for (var i in record)
				{
					catarr = record[i];
					catarr.forEach(function(iEntry)
					{
						pIteration(iEntry);
					});
				}
				numcached++;
				if (numcached === numcaches)
				{
					loadMetadata();
				}
			});
		};
		
		/*
		 * Load cacheable records and add unlockables' associated tradeable items'
		 * ID to the associative array. Executions must be in the same order as
		 * the record names array.
		 */
		I.print("Loading items database...");
		Z.getItemsDatabase(function(pDatabase)
		{
			db = pDatabase;
			
			// Include specific items that are tradeable
			iterateRecord(function(iID) // Materials
			{
				if (Q.isTradeable(db[iID]))
				{
					idstocache[iID] = true;
				}
			});
			iterateRecord(function(iEntry) // Skins
			{
				if (iEntry.p === undefined && Q.isTradeable(db[iEntry.i]))
				{
					idstocache[iEntry.i] = true;
				}
			});
			iterateRecord(function(iEntry) // Dyes
			{
				if (Q.isTradeable(db[iEntry.i]))
				{
					idstocache[iEntry.i] = true;
				}
			});
			iterateRecord(function(iEntry) // Minis
			{
				if (Q.isTradeable(db[iEntry.i]))
				{
					idstocache[iEntry.i] = true;
				}
			});
			iterateRecord(function(iEntry) // Carriers
			{
				if (Q.isTradeable(db[iEntry.i]))
				{
					idstocache[iEntry.i] = true;
				}
			});
			iterateRecord(function(iEntry) // Champions
			{
				if (Q.isTradeable(db[iEntry.i]))
				{
					idstocache[iEntry.i] = true;
				}
			});
			iterateRecord(function(iEntry) // Finishers
			{
				if (Q.isTradeable(db[iEntry.i]))
				{
					idstocache[iEntry.i] = true;
				}
			});
			iterateRecord(function(iEntry) // Nodes
			{
				if (Q.isTradeable(db[iEntry.i]))
				{
					idstocache[iEntry.i] = true;
				}
			});
			iterateRecord(function(iEntry) // Recipes
			{
				if (iEntry.b)
				{
					idstocache[iEntry.b] = true;
				}
			});
		});
	},
	
	/*
	 * Updates the record of new API items.
	 * @param array pIDs from the update database function.
	 */
	collateMuseum: function(pIDs)
	{
		var datestr = (((new Date()).toISOString()).split("T")[0]).split("-");
		var timestamp = datestr[0] + "-" + datestr[1];
		var ids;
		U.getScript(U.URL_DATA.Museum, function()
		{
			var record = U.getRecordData("museum");
			var trimmedrecord = {};
			if (record[timestamp])
			{
				ids = U.getUnion(record[timestamp], pIDs);
			}
			else
			{
				ids = pIDs;
			}
			Q.sortItems(ids, function(pSortedItems, pSortedIDs)
			{
				record[timestamp] = pSortedIDs;
				trimmedrecord[timestamp] = pSortedIDs;
				Z.printUnlockables(trimmedrecord, true, true);
				Z.printUnlockables(record, true, true);
			});
		}, false);
	},
	
	/*
	 * Prints subdatabase of Pact recipes and produced items.
	 */
	collatePact: function()
	{
		var ids = [];
		for (var i in H.Pact.Products)
		{
			ids.push(i);
			ids.push(H.Pact.Products[i]);
		}
		Z.updateItemsSubdatabase("Pact", ids);
	},
	
	/*
	 * Gets and trims the current map floor details.
	 */
	collateMaps: function()
	{
		var printFile = function(pData, pLanguage)
		{
			for (var i in pData.regions)
			{
				var region = pData.regions[i];
				for (var ii in region.maps)
				{
					// Only keep the prelisted zones
					if (M.isZoneValid(ii) === false)
					{
						delete region.maps[ii];
					}
				}
			}
			Z.createFile(U.lineJSON(pData), "maps_" + pLanguage + I.cJSON);
		};
		Z.fetchAPIMultilingual(U.URL_API.MapFloorTyria, function(pData)
		{
			for (var i in pData)
			{
				printFile(pData[i], i);
			}
		});
	},
	
	/*
	 * Updates the map dynamic events list.
	 */
	collateEvents: function()
	{
		var printFile = function(pData, pLanguage)
		{
			var formatteddata = [];
			for (var i in pData.events)
			{
				// Make the events accessible with its ID
				pData.events[i].id = i;
				formatteddata.push(pData.events[i]);
			}
			Z.printAPICache(U.TypeEnum.isAssoc, {aCustomCache: formatteddata, aFileName: "events_" + pLanguage + I.cJSON});
		};
		Z.fetchAPIMultilingual(U.URL_API.EventDetails, function(pData)
		{
			for (var i in pData)
			{
				printFile(pData[i], i);
			}
		});
	}
};
A = {
/* =============================================================================
 * @@Account panel, API key management, and audit
 * ========================================================================== */

	TokenCurrent: null,
	CharIndexCurrent: null,
	isAccountInitialized: false,
	isChartsInitialized: false,
	isAuditReady: false,
	isCharactersCached: false, // For force redownloading of characters data rather than use cached
	Metadata: {}, // Prewritten data loaded along with account page
	Currency: {}, // Currency data
	Equipment: {}, // Character equipment slots information
	Attribute: {}, // Character attribute points
	Data: { // Cache for retrieved API data objects and arrays
		Account: {},
		Characters: [],
		CharacterAssoc: {},
		CharacterNames: null,
		Vaults: null,
		Wallet: null,
		Titles: null
	},
	Possessions: null, // Associative array of actual items from the user's bank, inventory, equipment slots, shared slots, and bag slots
	Tally: null, // Number of filled slots and capacity of banks and collections, used in auditing
	URL: { // Account data type and URL substring
		Account: "account",
		Bank: "account/bank",
		Materials: "account/materials",
		Skins: "account/skins",
		Outfits: "account/outfits",
		Gliders: "account/gliders",
		Dyes: "account/dyes",
		Minis: "account/minis",
		Carriers: "account/mailcarriers",
		Champions: "account/pvp/heroes",
		Finishers: "account/finishers",
		Nodes: "account/home/nodes",
		Cats: "account/home/cats",
		Achievements: "account/achievements",
		Masteries: "account/masteries",
		Raids: "account/raids",
		Dungeons: "account/dungeons",
		Characters: "characters",
		Shared: "account/inventory", // Shared inventory slots
		Wallet: "account/wallet",
		Titles: "account/titles",
		Recipes: "account/recipes",
		CharactersSAB: "characters/{0}/sab",
		Transactions: "commerce/transactions",
		CurrentBuys: "commerce/transactions/current/buys",
		CurrentSells: "commerce/transactions/current/sells",
		HistoryBuys: "commerce/transactions/history/buys",
		HistorySells: "commerce/transactions/history/sells",
		Stats: "pvp/stats",
		Games: "pvp/games",
		Standings: "pvp/standings",
		TokenInfo: "tokeninfo",
		GuildLog: "log",
		GuildMembers: "guild/{0}/members",
		GuildPermission: "guild/{0}/permission",
		GuildRanks: "guild/{0}/ranks",
		GuildStash: "guild/{0}/stash",
		GuildTeams: "guild/{0}/teams",
		GuildTreasury: "guild/{0}/treasury",
		GuildUpgrades: "guild/{0}/upgrades"
	},
	Permissions: {}, // Corresponds to tokeninfo.json permissions array
	PermissionEnum: {
		Account: "account", // Your account display name, ID, home world, and list of guilds. Required permission.
		Builds: "builds", // Your currently equipped specializations, traits, skills, and equipment for all game modes.
		Characters: "characters", // Basic information about your characters.
		Guilds: "guilds", // Guilds' rosters, history, and MOTDs for all guilds you are a member of.
		Inventories: "inventories", // Your account bank, material storage, recipe unlocks, and character inventories.
		Progression: "progression", // Your achievements, dungeon unlock status, mastery point assignments, and general PvE progress.
		PvP: "pvp", // Your PvP stats, match history, reward track progression, and custom arena details.
		TradingPost: "tradingpost", // Your Trading Post transactions.
		Wallet: "wallet", // Your account's wallet.
		Unlocks: "unlocks" // Your wardrobe unlocks—skins, dyes, minipets, finishers, etc.—and currently equipped skins.
	},
	DishCurrent: null, // The account section currently displayed
	
	/*
	 * Gets an authenticated API URL to retrieve account data.
	 * @param enum pSuffix type of account data.
	 * @returns string.
	 * @pre Token for use (API key) variable was initialized.
	 */
	getURL: function(pSuffix)
	{
		return "https://api.guildwars2.com/v2/" + pSuffix + U.getDivider(pSuffix) + "access_token=" + A.TokenCurrent;
	},
	getURLAll: function(pSuffix)
	{
		return A.getURL(pSuffix + "?ids=all");
	},
	
	/*
	 * Fetches a transactions.
	 * @param enum pURL type of transactions.
	 * @param object pSettings for the used fetch paginated function.
	 */
	getTransactions: function(pURL, pSettings)
	{
		var Settings = pSettings || {};
		Settings.aPermission = A.PermissionEnum.TradingPost;
		U.fetchPaginated(A.getURL(pURL), Settings);
	},
	
	/*
	 * Advances the global account page progress bar by given values, or clears
	 * the bar if completed progress.
	 * @param int pNumFetched dividend.
	 * @param int pNumToFetch divisor.
	 */
	setProgressBar: function(pNumFetched, pNumToFetch)
	{
		var progressbar = document.getElementById("accProgress");
		var progresscount = document.getElementById("accProgressCount");
		if (progressbar)
		{
			progressbar.style.width = (pNumFetched / pNumToFetch) * T.cPERCENT_100 + "%";
			progresscount.innerHTML = pNumFetched + " / " + pNumToFetch;
			if (pNumFetched === pNumToFetch)
			{
				A.resetProgressBar();
			}
		}
	},
	fillProgressBar: function()
	{
		A.setProgressBar(1, 1);
	},
	
	/*
	 * Fades and clears the progress bar.
	 */
	resetProgressBar: function(pWantAnimation)
	{
		var progress = $("#accProgress");
		var count = $("#accProgressCount");
		if (pWantAnimation || pWantAnimation === undefined)
		{
			progress.css({opacity: 1}).animate({opacity: 0}, 800, function()
			{
				$(this).css({width: "0px", opacity: 1});
			});
		}
		else
		{
			progress.css({width: "0px", opacity: 1});
		}
		count.empty();
	},
	
	/*
	 * Initializes common UI for the account panel.
	 */
	initializeAccount: function(pPage)
	{
		// Add new words to the dictionary
		D.addDictionary(GW2T_ACCOUNT_DICTIONARY);
		A.Metadata = GW2T_ACCOUNT_METADATA;
		A.Currency = GW2T_CURRENCY_DATA;
		A.Equipment = GW2T_EQUIPMENT_DATA;
		A.Attribute = GW2T_ATTRIBUTE_DATA;
		var ispageprovided = (typeof pPage === "string" && I.PageEnum.Account[pPage] !== undefined);
		// Add faux items
		Q.initializeFaux();
		
		// Initialize scaffolding HTML
		var scaffold = $("#accContent");
		scaffold.find("section").addClass("accPlatter");
		scaffold.find("article").addClass("accDishContainer jsScrollable").each(function()
		{
			var sectionname = $(this).attr("data-section");
			if ($(this).is(":empty"))
			{
				$(this).html("<div class='accDishPadding'></div>"
					+ "<div id='accDish_" + sectionname + "' class='accDish cntComposition'></div>");
			}
			else
			{
				$(this).wrapInner("<div id='accDish_" + sectionname + "' class='accDish cntComposition'></div>");
				$(this).prepend("<div class='accDishPadding'></div>");
			}
			I.bindScrollbar($(this));
		});
		$("#accContent").show();
		
		// Initialize common UI
		U.convertExternalLink($("#accHelp").find(".jsExternal").find("a"));
		A.generateMenu(ispageprovided);
		
		// Bind the window buttons
		$("#accToggle").click(function()
		{
			$("#accMenu").slideToggle("fast", function()
			{
				A.adjustAccountPanel();
			});
		});
		$("#accExpand").click(function()
		{
			$("#opt_bol_showPanel").trigger("click");
		});
		$("#accClose").click(function()
		{
			$("#mapAccountButton").trigger("click");
		});
		$("#accDisplayButton").toggle(!O.Options.bol_showPanel).click(function()
		{
			$("#opt_bol_showPanel").trigger("click");
		});
		
		// Initialize API keys
		A.initializeTokens();
		
		// Initialize tooltips and translate
		I.qTip.init($("#panelAccount").find("a, label, button, kbd, img"));
		D.translateElements();
		
		// Initialize the console, which is the same as the map's coordinates bar
		var consoleinput = $("#accConsole").onEnterKey(function()
		{
			var val = $(this).val();
			var str = (val.charAt(0) === Z.cCommandPrefix) ? val : Z.cCommandPrefix + val;
			Z.parseCommand(str, M);
		});
		I.bindInputBarText(consoleinput, "Enter \"help\" for commands...");
		Q.bindItemSearch("#accSearch", {
			aCallback: function(pItem)
			{
				Q.printItemInfo(pItem, true);
			}}
		);
		
		// Initialize context menu for bank and inventory slots
		Q.initializeItemContextMenu();
		
		// Translate directory
		if (D.isLanguageDefault === false)
		{
			$("#accDirectory var").each(function()
			{
				var word = $(this).text().toLowerCase();
				$(this).html(D.getWordCapital(word));
			});
		}
		U.convertExternalLink("#accDirectory .linkExternal");
		U.convertInternalLink("#accDirectory a");
	
		// Finally
		setTimeout(function()
		{
			A.adjustAccountPanel();
		}, 1000);
		A.isAccountInitialized = true;
		
		// Print messages if available
		H.getUrgent(H.Announcement.UrgentAccount);
		
		// Open a section if initially requested
		if (ispageprovided)
		{
			$("#accMenu_" + pPage).trigger("click");
		}
	},
	
	/*
	 * Binds functionality of the account page menu bar.
	 */
	generateMenu: function(pPage)
	{
		var menu = $("#accMenu");
		$("#accContent").find(".accDishMain").each(function()
		{
			var sectionname = $(this).attr("data-section");
			var sectionnamelow = sectionname.toLowerCase();
			var menutab = $("<aside id='accMenu_" + sectionname + "' class='accMenuTab accMenuClick curClick'>"
				+ "<span>"
					+ "<ins class='accMenuIcon accMenuIconMain mnu mnu_" + sectionnamelow + "' "
						+ "title='<dfn>" + D.getWordCapital(sectionnamelow) + "</dfn>'></ins>"
					+ "<var class='accMenuTitle'>" + D.getPhraseOriginal(sectionname) + "</var>"
				+ "</span>"
				+ "<span class='accMenuSubtab' style='display:none;'></span>"
			+ "</aside>");
			menu.append(menutab);
			(function(iTab, iSectionName)
			{
				var section = $("#accPlatter" + iSectionName);
				A.createDishMenu(iSectionName);
				/*
				 * Clicking on a menu tab shows the associated section, and
				 * clicking on a menu icon inside the tab shows the subsection
				 * of that section. The tab also acts as a menu icon if the user
				 * clicks on the tab instead of the icons the tab holds.
				 */
				iTab.click(function()
				{
					// Reset tab styles
					$(".accMenuTab").find(".accMenuIcon").removeClass("accMenuButtonFocused");
					$(".accPlatter").hide();
					// If previously viewing a non-main subsection of this section, then open that subsection
					if ($(this).data("iscurrentaccounttab") && $(this).hasClass("accMenuTabFocused") === false)
					{
						section.show();
						$(this).find(".accMenuCurrent").trigger("click");
					}
					else
					{
						// Else view the main subsection
						$(this).data("iscurrentaccounttab", null);
						A.DishCurrent = $("#accDish_" + iSectionName);
						// Show dish menu
						$(".accDishMenu").hide();
						$("#accDishMenu_" + iSectionName).show();
						// Show the main subsection
						section.find(".accDishContainer").hide();
						section.find(".accDishMain").show();
						$(this).find(".accMenuIconMain").addClass("accMenuButtonFocused");
						section.fadeIn(400);
						A.adjustAccountPanel();
						// Update address
						I.PageCurrent = I.SpecialPageEnum.Account;
						I.SectionCurrent[I.SpecialPageEnum.Account] =
							(iSectionName === I.PageEnum.Account.Manager) ? "" : iSectionName;
						U.updateQueryString();
						A.generateDish(iSectionName);
					}
					// Highlight the clicked tab
					$(".accMenuTab").removeClass("accMenuTabFocused").find(".accMenuSubtab").hide();
					$(this).addClass("accMenuTabFocused").find(".accMenuSubtab").show();
					// Clear the global progress bar, in case it froze
					A.resetProgressBar(false);
				});
				
				// A section (platter) may have multiple subsections (dishes)
				var subsections = section.find(".accDishContainer");
				if (subsections.length)
				{
					var subbuttons = iTab.find(".accMenuSubtab");
					subbuttons.append("<img src='img/ui/view.png' />");
					subsections.each(function()
					{
						if ($(this).hasClass("accDishMain") === false)
						{
							var subsectionname = $(this).attr("data-section");
							var subsectionnamelow = subsectionname.toLowerCase();
							var subbutton = $("<ins id='accMenu_" + subsectionname + "' class='accMenuButton accMenuIcon accMenuClick mnu mnu_" + subsectionnamelow + "' "
								+ "title='<dfn>" + D.getWordCapital(subsectionnamelow) + "</dfn>'></ins>");
							subbuttons.append(subbutton);
							A.createDishMenu(subsectionname);
							if ($(this).hasClass("accCharDependent"))
							{
								subbutton.addClass("accCharDependentMenu");
							}
							// Create a divider if this button is the beginning of a subtab group
							if ($(this).attr("data-islead"))
							{
								$("<span class='accMenuTabDivider'></span>").insertBefore(subbutton);
							}
							(function(iSubbutton, iSubsection)
							{
								iSubbutton.click(function(pEvent)
								{
									// Reset tab styles
									$(".accMenuTab").find(".accMenuIcon").removeClass("accMenuButtonFocused");
									$(".accPlatter").hide();
									$(".accMenuTab").removeClass("accMenuTabFocused").find(".accMenuSubtab").hide();
									section.show();
									var menutab = $(this).closest(".accMenuTab").data("iscurrentaccounttab", subsectionname);
									menutab.find(".accMenuCurrent").removeClass("accMenuCurrent");
									$(this).addClass("accMenuCurrent");
									A.DishCurrent = $("#accDish_" + subsectionname);
									// For the case that the subsection was opened programmatically, style the parent tab
									if (menutab.hasClass("accMenuTabFocused") === false)
									{
										menutab.addClass("accMenuTabFocused").find(".accMenuSubtab").show();
									}
									// Show dish menu menu
									$(".accDishMenu").hide();
									$("#accDishMenu_" + subsectionname).show();
									// Show the subsection
									pEvent.stopPropagation();
									iSubsection.parent().find(".accDishContainer").hide();
									iSubsection.fadeIn(200);
									A.adjustAccountPanel();
									// Highlight the button
									iTab.find(".accMenuIcon").removeClass("accMenuButtonFocused");
									$(this).addClass("accMenuButtonFocused");
									// Update address
									I.PageCurrent = I.SpecialPageEnum.Account;
									I.SectionCurrent[I.SpecialPageEnum.Account] = subsectionname;
									U.updateQueryString();
									A.generateDish(subsectionname);
								});
							})(subbutton, $(this));
						}
					});
				}
			})(menutab, sectionname);
		});
		I.qTip.init(".accMenuIcon");
		
		// Open the section if specified in the URL
		if (pPage !== true)
		{
			$("#accPlatterManager").show();
			U.openSectionFromURL({aPrefix: "#accMenu_", aInitialSection: I.PageEnum.Account.Manager});
		}
	},
	resetMenu: function()
	{
		// Clear menu tabs and icons state
		$(".accMenuTab").each(function()
		{
			$(this).data("iscurrentaccounttab", null).removeClass("accMenuTabFocused").find(".accMenuSubtab").hide();
			$(this).find(".accMenuIcon").removeClass("accMenuButtonFocused");
		});
		// Go to default dish
		$("#accMenu_Manager").trigger("click");
	},
	
	/*
	 * Adjusts the content portion of the account panel.
	 */
	adjustAccountPanel: function()
	{
		// Workaround for Firefox positioning, if not compensated then the account page will be invisible with height 0
		if (I.BrowserCurrent === I.BrowserEnum.Firefox)
		{
			$("#panelAccount").css({
				position: (O.Options.bol_showPanel) ? "relative" : "static",
				height: (O.Options.bol_showPanel) ? "100%" : $(window).height() + "px"
			});
		}
		// Resize the width of the menu bar based on the size of the content window
		var menualign = (O.Options.bol_alignPanelRight) ? {left: "0px", right: "auto"} : {left: "auto", right: "0px"};
		$("#accOverhead").css({width: ($("#accContent").width() - 8) + "px"}).css(menualign);
		// Put padding between the menu bar and the content
		if (A.DishCurrent)
		{
			A.DishCurrent.parent().find(".accDishPadding").css({height: A.getOverheadHeight() + "px"});
			A.adjustAccountScrollbar();
		}
	},
	getOverheadHeight: function()
	{
		return $("#accOverhead").height();
	},
	
	/*
	 * Updates the scroll bar of the currently viewed account section.
	 */
	adjustAccountScrollbar: function()
	{
		I.updateScrollbar(A.DishCurrent.parent());
	},
	
	/*
	 * Initializes the API keys manager and their storage.
	 */
	initializeTokens: function()
	{
		var tokenslimit = 64;
		var tokensarr = localStorage[O.Utilities.APITokens.key];
		var token;
		try
		{
			tokensarr = JSON.parse(tokensarr);
		}
		catch (e) {}
		if (tokensarr === undefined)
		{
			tokensarr = [];
			tokensarr.push(A.createToken("Example Key Name", "EXAMPLE-API-KEY-PLEASE-REPLACE-WITH-YOUR-OWN-HERE"));
		}
		// Create the token UI inputs
		var wantnewurlapikey = true;
		if (U.APIKey)
		{
			for (var i = 0; i < tokensarr.length; i++)
			{
				token = tokensarr[i];
				if (U.APIKey === token.key) // If the URL API key already exists in the manager, use it
				{
					token.isUsed = true;
					wantnewurlapikey = false;
				}
				else
				{
					delete token["isUsed"];
				}
			}
		}
		else
		{
			wantnewurlapikey = false;
		}
		if (U.APIKey && wantnewurlapikey) // Create a new token with the URL API key if doesn't exist
		{
			tokensarr.push(A.createToken("URL API Key", U.APIKey, true));
		}
		// Create the token UI inputs
		for (var i = 0; i < tokensarr.length; i++)
		{
			token = tokensarr[i];
			A.insertTokenRow(token.name, token.key, token.isUsed);
		}
		// Swap tokens behavior
		X.bindTextlistSwap("#accTokenList", "#accTokenList .accTokenButtons", A.saveTokens);
		A.saveTokens();
		A.loadToken();
		
		// Bind button to print the tokens
		$("#accManagerPrint").click(function()
		{
			var tokens = localStorage[O.Utilities.APITokens.key];
			try
			{
				tokens = JSON.parse(tokens);
				I.prettyJSON(tokens);
			}
			catch (e) {}
		});
		$("#accManagerHide").click(function()
		{
			$("#accManager").toggle();
		});
		
		// Bind button to add another token/row
		$("#accTokenNew").attr("title", "<dfn>" + D.getWordCapital("add") + "</dfn> " + D.getPhrase("key slot") + ".");
		$("#accTokenNew").click(function()
		{
			if (O.Utilities.APITokens.value.length < tokenslimit)
			{
				A.insertTokenRow("", "");
				A.saveTokens();
				I.qTip.init($("#accManager").find("button"));
			}
			else
			{
				I.write("API tokens limit reached.");
			}
		});
		
		// Finally
		D.translateElements();
		I.qTip.init($("#accManager").find("button"));
	},
	
	/*
	 * Inserts a token (row) into the API key manager.
	 * @param string pName.
	 * @param string pAPIKey.
	 */
	insertTokenRow: function(pName, pAPIKey, pIsUsed)
	{
		var token = $("<div class='accToken'></div>").appendTo("#accTokenList");
		var link = $("<img class='accTokenLink curClick' src='img/ui/link.png' title='Get private <dfn>shareable link</dfn>.' />").appendTo(token);
		var key = $("<input class='accTokenKey' type='text' value='" + pAPIKey + "' maxlength='128' />").appendTo(token);
		var name = $("<input class='accTokenName' type='text' value='" + pName + "' maxlength='64' />").appendTo(token);
		var buttons = $("<div class='accTokenButtons'></div>").appendTo(token);
		var use = $("<button class='accTokenUse' title='<dfn>" + D.getWordCapital("use") + "</dfn> "
			+ D.getPhrase("this key") + ".<br />" + D.getPhraseOriginal("Double click to audit") + ".'><img src='img/ui/adjust_use.png' /></button>").appendTo(buttons);
		var del = $("<button class='accTokenDelete' title='<dfn>" + D.getWordCapital("delete") + "</dfn> "
			+ D.getPhrase("this key") + ".'><img src='img/ui/adjust_del.png' /></button>").appendTo(buttons);
		var updateLink = function()
		{
			I.updateClipboard(link[0], "http://gw2timer.com#" + U.escapeHTML(U.stripToAlphanumericDash(key.val())));
		};
		
		// Use the token if specified
		if (pIsUsed === true)
		{
			A.TokenCurrent = U.stripToAlphanumericDash(pAPIKey);
			name.addClass("cssInputActive");
			use.addClass("btnActive");
		}
		
		// Button to use this token's API key
		use.click(function()
		{
			var str = key.val();
			if (str.length > 0)
			{
				$(".accTokenName").removeClass("cssInputActive");
				$(".accTokenUse").removeClass("btnActive");
				name.addClass("cssInputActive");
				use.addClass("btnActive").find("img");
				A.TokenCurrent = U.stripToAlphanumericDash(str);
				A.loadToken();
				A.saveTokens();
			}
			else
			{
				I.write("Please enter a valid API key.");
			}
		}).dblclick(function()
		{
			U.interpretPage(I.SpecialPageEnum.Audit);
		});
		// Entering a new key in the input box triggers the use button
		key.change(function()
		{
			use.trigger("click");
			updateLink();
		});
		// Clicking the link icon gets a shareable URL
		I.bindClipboard(link);
		updateLink();
		// Button to delete this token
		del.click(function()
		{
			var str = key.val();
			if (O.Utilities.APITokens.value.length > 1)
			{
				// Ask for confirmation if key is not empty
				if (str.length > 0)
				{
					if (confirm("Delete this API token?\nNote: Audit history must be manually deleted at gw2timer.com/audit"))
					{
						token.remove();
						A.saveTokens();
					}
				}
				else
				{
					token.remove();
					A.saveTokens();
				}
				I.qTip.hide();
			}
			else
			{
				I.write("Must have at least one API token.");
			}
		});
		// Autoselect the input boxes on click and save on change
		$([name, key]).each(function()
		{
			$(this).click(function()
			{
				$(this).select();
			}).change(function()
			{
				A.saveTokens();
			});
		});
		// Highlight the row when hovered on a button
		$([link, buttons]).each(function()
		{
			$(this).hover(
				function()
				{
					name.addClass("cssInputFocused");
					key.addClass("cssInputFocused");
				},
				function()
				{
					name.removeClass("cssInputFocused");
					key.removeClass("cssInputFocused");
				}
			);
		});
	},
	
	/*
	 * Creates a token object which contains a token's name and the API key string.
	 * @param string pName.
	 * @param string pAPIKey.
	 * @param boolean pIsUsed optional.
	 * @returns object.
	 */
	createToken: function(pName, pAPIKey, pIsUsed)
	{
		var token = {
			name: pName,
			key: pAPIKey
		};
		if (pIsUsed)
		{
			token.isUsed = true;
		}
		return token;
	},
	
	/*
	 * Reads text from the token inputs then serialize and store them.
	 */
	saveTokens: function()
	{
		var tokens = [];
		$(".accToken").each(function()
		{
			var name = U.escapeHTML($(this).find(".accTokenName").val());
			var key = U.stripToAlphanumericDash($(this).find(".accTokenKey").val());
			var token = A.createToken(name, key, $(this).find(".accTokenUse").hasClass("btnActive"));
			tokens.push(token);
		});
		var obj = O.Utilities.APITokens;
		obj.value = tokens;
		localStorage[obj.key] = JSON.stringify(obj.value);
	},
	
	/*
	 * Readies the account panel for the current API key.
	 */
	loadToken: function()
	{
		if (A.TokenCurrent === null)
		{
			return;
		}
		
		// Reset variables so the sections will reload the account data
		for (var i in A.Permissions)
		{
			A.Permissions[i] = null;
		}
		A.Data.CharacterNames = null;
		A.Data.Vaults = null;
		A.isAuditReady = false;
		// Prevent skipping loading the characters section first
		$("#accMenu_Characters").data("iscurrentaccounttab", null);
		$(".accDishMenu").empty();
		A.wipeDish("Characters");
		
		// Initialize permissions
		$.getJSON(A.getURL(A.URL.TokenInfo), function(pData)
		{
			for (var i in pData.permissions)
			{
				var permission = pData.permissions[i];
				A.Permissions[permission] = true;
			}
		}).fail(function(pRequest, pStatus)
		{
			A.printError(A.PermissionEnum.Account, pStatus, false);
		});
	},
	
	/*
	 * Prints standard API key error message to the console.
	 * @param string pRequestType the permission requested.
	 * @param string pStatus from AJAX.
	 * @param boolean pWantRedirect to return user to the manager section.
	 */
	printError: function(pPermission, pStatus, pWantRedirect)
	{
		if (A.TokenCurrent === null)
		{
			I.write("Please enter an API key first.");
		}
		else
		{
			if (pStatus === "error")
			{
				I.write("Unable to retrieve response. " + I.cErrorAPI);
			}
			else
			{
				I.write("Unable to access data for this key from ArenaNet API server.");
			}
			I.write(A.TokenCurrent);
		}
		if (pPermission)
		{
			// If missing permission then go to the Manager section for the user to update their key
			I.write("Requested permission: " + pPermission, 10);
			if (pWantRedirect || pWantRedirect === undefined)
			{
				$("#accMenu_Manager").trigger("click");
			}
		}
		U.nullifyArticle();
	},
	
	/*
	 * Checks if permission exists, else prints error.
	 * @returns boolean success.
	 */
	checkPermission: function(pPermission)
	{
		if (A.Permissions[pPermission])
		{
			return true;
		}
		A.printError(pPermission);
		return false;
	},
	
	/*
	 * Prints data from an account API.
	 * @param string pURLSuffix.
	 */
	printAccount: function(pURLSuffix)
	{
		if (pURLSuffix)
		{
			I.print("Loading " + pURLSuffix + "...");
			$.ajax({
				dataType: "json",
				url: A.getURL(pURLSuffix),
				cache: false,
				success: function(pData, pStatus, pRequest)
				{
					I.prettyJSON(pData);
				},
				error: function(pRequest, pStatus)
				{
					A.printError(null, pStatus);
				}
			});
		}
		else
		{
			I.print("Available account API URL suffixes:");
			for (var i in A.URL)
			{
				I.print(A.URL[i]);
			}
		}
	},
	
	/*
	 * Gets the current user selected character.
	 * @returns object character.
	 */
	getCurrentCharacter: function()
	{
		try
		{
			return A.Data.Characters[A.CharIndexCurrent];
		}
		catch (e) {}
		return null;
	},
	getCharacterByName: function(pName)
	{
		var charindex = A.Data.CharacterAssoc[pName];
		return A.Data.Characters[charindex];
	},
	
	/*
	 * Gets the name of the account section an element resides in.
	 * @param jqobject pElement.
	 * @returns string.
	 */
	getDishName: function(pElement)
	{
		return $(pElement).closest(".accDishContainer").attr("data-section");
	},
	
	/*
	 * Tells if a section has the current account's content generated, else wipe.
	 * @param jqobject pDish to check.
	 * @param boolean pIsForce to proceed without checks.
	 * @returns boolean.
	 */
	reinitializeDish: function(pDish, pIsForce)
	{
		if (!pIsForce && pDish.is(":empty") === false && pDish.data("token") === A.TokenCurrent)
		{
			return false;
		}
		var dishname = U.getSubstringFromHTMLID(pDish);
		
		// Wipe dish
		pDish.empty().data("token", A.TokenCurrent);
		// Wipe dish menu
		$("#accDishMenu_" + dishname).empty();
		
		if (pIsForce)
		{
			pDish.removeClass("accDishWipeable");
		}
		else
		{
			pDish.addClass("accDishWipeable");
			I.updateScrollbar(pDish);
		}
		return true;
	},
	
	/*
	 * Wipes all applicable dishes to relieve browser rendering, to be called
	 * when account panel is no longer used.
	 */
	reinitializePanel: function()
	{
		$(".accDishWipeable").each(function()
		{
			A.reinitializeDish($(this), true);
		});
		// Reset account viewed page
		A.resetMenu();
	},
	
	/*
	 * Executes the serve function which generates content for an account section.
	 * @param string pDish section name.
	 */
	generateDish: function(pDish)
	{
		var functionname = "serve" + pDish; // Special generate functions start with this word
		if (V[functionname])
		{
			(V[functionname])();
		}
	},
	
	/*
	 * Wipes a section's content and reexecutes the serve function.
	 * @param string pDish.
	 */
	regenerateDish: function(pDish)
	{
		A.wipeDish(pDish);
		A.generateDish(pDish);
	},
	wipeDish: function(pDish)
	{
		$("#accDish_" + pDish).empty().data("isloaded", false);
		$("#accDishMenu_" + pDish).empty();
	},
	
	/*
	 * Creates a container to insert items into a section-specific menu.
	 * @param string pSection name.
	 * @returns jqobject.
	 */
	createDishMenu: function(pDish)
	{
		$("<aside id='accDishMenu_" + pDish + "' class='accDishMenu'></aside>").appendTo("#accDishMenuContainer");
	},
	getDishMenu: function(pDish)
	{
		return $("#accDishMenu_" + pDish);
	},
	
	/*
	 * Creates fixed menu that scrolls to an associated character's element when
	 * clicked on its icon from the selection bar.
	 * @param objarray pCharacters
	 * @param string pSection
	 * @objparam function aClick custom scrolling action, with provided character index, optional.
	 * @objparam string aElementPrefix HTML ID for element to scroll to, to be suffixed by character index.
	 * @objparam int aOffset scroll from the element.
	 */
	createCharacterScroller: function(pCharacters, pSection, pSettings)
	{
		var Settings = pSettings || {};
		var dishmenu = A.getDishMenu(pSection);
		var container = $("<div class='eqpSelectContainer'></div>").appendTo(dishmenu);
		pCharacters.forEach(function(iChar)
		{
			var select = $("<span class='eqpSelect curClick' title='" + iChar.oCharName + " (" + iChar.level + ")' style='border-left: 2px solid " + iChar.oCharColor + "'>"
				+ "<img class='eqpSelectPortrait' src='" + iChar.oCharPortrait + "' />"
				+ "<img class='eqpSelectProfession' src='img/account/classes/" + iChar.oCharElite + ".png' />"
			+ "</span>").appendTo(container);
			if (iChar.oCharIsLowLevel)
			{
				select.addClass("accTrivial");
			}
			
			(function(iIndex)
			{
				select.click(function()
				{
					if (Settings.aClick)
					{
						Settings.aClick(iIndex);
					}
					else
					{
						var elm = $("#" + Settings.aElementPrefix + iIndex);
						if (elm && elm.length)
						{
							I.scrollToElement(elm, {
								aOffset: Settings.aOffset,
								aSpeed: "fast"
							});
						}
					}
					A.adjustAccountScrollbar();
				});
			})(iChar.oCharIndex);
		});
		I.qTip.init(container.find(".eqpSelect"));
		// Readjust because the newly created bar takes space up top
		A.adjustAccountPanel();
	},
	
	/*
	 * Creates a page wide banner with a character's name and portrait.
	 * @param object pCharacter
	 * @param jqobject pContainer
	 * @param string pPrefix for creating banner HTML ID.
	 */
	createCharacterBanner: function(pContainer, pCharacter, pPrefix)
	{
		var idstr = (pPrefix) ? "id='" + pPrefix + pCharacter.oCharIndex + "'" : "";
		$("<div " + idstr + " class='eqpCharSeparator'><img class='eqpCharPortrait' src='" + pCharacter.oCharPortrait + "' />"
			+ "<img class='eqpCharProfession' src='img/account/classes/" + pCharacter.oCharElite + ".png' />"
			+ "<span class='eqpCharName'>" + pCharacter.oCharName + "</span>"
		+ "</div>").prependTo(pContainer);
	},
	
	/*
	 * Embeds a website into an account section. Because the account page occupies
	 * the map container, embedding the site itself allows the map to be displayed.
	 * @param jqobject pContainer to insert iframe.
	 * @param string pURL source.
	 */
	embedFrame: function(pContainer, pURL)
	{
		var container = $(pContainer);
		if (!container.find(".accEmbedContainer").length)
		{
			var frameouter = $("<div class='accEmbedContainer'></div>").appendTo(container);
			var frame = $("<iframe class='accEmbedFrame'></iframe>").appendTo(frameouter);
			frame[0].src = pURL;
		}
	},
	
	/*
	 * Assigns a gem store account upgrade.
	 * @param string pUpgrade key name.
	 * @param int pOwned for example the total number of tabs in a bank tab.
	 */
	assignAccountUpgrades: function(pUpgrade, pOwned)
	{
		var upgobj = A.Currency.AuditUpgrades[pUpgrade];
		upgobj.purchased = pOwned - upgobj.starting;
		upgobj.totalgem = upgobj.gem * upgobj.purchased;
		upgobj.totalowned = upgobj.starting + upgobj.purchased;
	},
	initializeAccountUpgrades: function()
	{
		var upgs = A.Currency.AuditUpgrades;
		for (var i in upgs)
		{
			upgs[i].purchased = 0;
			upgs[i].totalgem = 0;
			upgs[i].totalowned = upgs[i].starting;
		}
	},
	getAccountUpgradesGem: function()
	{
		var upgs = A.Currency.AuditUpgrades;
		var gemsum = 0;
		for (var i in upgs)
		{
			gemsum += upgs[i].totalgem;
		}
		return gemsum;
	},
	
	/*
	 * Caches guild details objects for the current account if haven't already.
	 * @param array pGuilds containing guild IDs.
	 * @param function pCallback to execute after.
	 */
	initializeGuilds: function(pCallback)
	{
		var guildids = A.Data.Account.guilds;
		if (guildids === undefined || guildids === null || guildids.length <= 0)
		{
			pCallback();
			return;
		}
		Q.getGuilds(guildids, function()
		{
			pCallback();
		});
	},
	
	/*
	 * Downloads guild bank data for all of the account's guilds, if permitting.
	 * @param function pCallback to execute after.
	 * @pre Account guilds data were downloaded.
	 */
	initializeVault: function(pCallback)
	{
		A.initializeGuilds(function()
		{
			U.fetchPattern(A.getURL(A.URL.GuildStash), A.Data.Account.guilds, {aCallback: function(pData, pLength)
			{
				if (pLength)
				{
					A.Data.Vaults = pData;
				}
				else
				{
					A.Data.Vaults = null;
					I.print("Unable to access any guild bank for this account.<br />Requires API key from account of guild leader.");
				}
				pCallback(A.Data.Vaults);
			}});
		});
	},
	
	/*
	 * Iterates through an "inventory" style array whose objects may have these properties:
	 * id, upgrades, infusions, skin. Then return their item and skin IDs for prefetching.
	 * @param array pArray
	 * @param function pIterator
	 * @returns object
	 */
	iterateInventory: function(pArray, pIterator)
	{
		var slot, upgs, infs, skin;
		var itemids = [];
		var skins = [];
		for (var i in pArray)
		{
			slot = pArray[i];
			if (slot)
			{
				itemids.push(slot.id); // The ID of the item itself
				upgs = slot.upgrades;
				infs = slot.infusions;
				skin = slot.skin;
				if (upgs && upgs.length)
				{
					upgs.forEach(function(iUpg)
					{
						itemids.push(iUpg);
					});
				}
				if (infs && infs.length)
				{
					infs.forEach(function(iInf)
					{
						itemids.push(iInf);
					});
				}
				if (skin)
				{
					skins.push(skin);
				}
				if (pIterator)
				{
					pIterator(slot);
				}
			}
		}
		return {
			oItemIDs: itemids,
			oSkinIDs: skins
		};
	},
	
	/*
	 * Initializes the associative array accessed by item IDs that holds the
	 * count of each items, based on the account's bank, inventory, shared slots,
	 * equipment, and materials. Also initializes the tally and gem store upgrades
	 * objects for use in auditing.
	 * @param function pCallback to execute after.
	 * @param boolean pWantVault whether to include guild banks too.
	 * @pre Characters data were downloaded by the Characters page.
	 */
	initializePossessions: function(pCallback, pWantVault)
	{
		// Continue with callback if already initialized
		if ((A.Possessions && !pWantVault) || (A.Possessions && pWantVault && A.Data.Vaults))
		{
			pCallback();
			return;
		}
		A.Possessions = {};
		
		// Adds an item to the possessions database
		var addItem = function(pItemID, pLocation, pCount, pIsBound)
		{
			// Create entry if doesn't exist
			if (A.Possessions[pItemID] === undefined)
			{
				A.Possessions[pItemID] = {
					oCount: 0,
					oAudit: {} // Will contain length 2 arrays: index 0 is unbound found, index 1 is total found
				};
			}
			var auditobj = A.Possessions[pItemID].oAudit;
			// Initializes the audit object in an audit location if doesn't exist, and adds its count
			var updateAuditObj = function(pAuditLocation)
			{
				if (auditobj[pAuditLocation] === undefined)
				{
					auditobj[pAuditLocation] = [0, 0];
				}
				if ( ! pIsBound)
				{
					(auditobj[pAuditLocation])[0] += pCount;
				}
				(auditobj[pAuditLocation])[1] += pCount;
			};
			
			// Update total item found count
			A.Possessions[pItemID].oCount += pCount;
			
			// Assign discrete category counts; the Characters location combines inventory, equipment
			var locationkey = (isNaN(pLocation) === false) ? "Characters" : U.toFirstUpperCase(pLocation);
			updateAuditObj(locationkey);
			// Per character audit entries
			if (isNaN(pLocation) === false)
			{
				updateAuditObj(pLocation);
			}
		};
		
		// Adds a slotted upgrade from an item such as a weapon or armor piece
		var addUpgrades = function(pSlot, pLocation)
		{
			if (pSlot.upgrades)
			{
				pSlot.upgrades.forEach(function(iID)
				{
					addItem(iID, pLocation, 1, true); // Upgrades must be salvaged, so consider it account bound
				});
			}
			if (pSlot.infusions)
			{
				pSlot.infusions.forEach(function(iID) // Infusions can be easily extracted with a coin bought item
				{
					addItem(iID, pLocation, 1);
				});
			}
		};
		
		// Search the account for items
		var compilePossessions = function(pSharedData, pBankData, pMaterialsData, pVaultData)
		{
			// Hold filled and capacity numbers
			A.Tally = {
				Characters: [0, 0],
				Shared: [0, 0],
				Bank: [0, 0],
				Materials: [0, 0],
				Vault: [0, 0]
			};
			var bagsupgobj = A.Currency.AuditUpgrades.BagSlot;
			var bagspurchased = 0;
			var craftsupgobj = A.Currency.AuditUpgrades.CraftingLicense;
			var craftspurchased = 0;
			
			// Compile character possessions
			A.Data.Characters.forEach(function(iChar)
			{
				// Add character's equipped items (equipment) and their slotted upgrades or infusions
				if (iChar.equipment)
				{
					iChar.equipment.forEach(function(iSlot)
					{
						addItem(iSlot.id, iChar.oCharIndex, 1, true);
						addUpgrades(iSlot, iChar.oCharIndex);
					});
				}
				// Add character's inventories
				if (iChar.bags)
				{
					bagspurchased += iChar.bags.length - A.Currency.AuditUpgrades.BagSlot.starting;
					iChar.bags.forEach(function(iBag)
					{
						if (iBag)
						{
							A.Tally.Characters[1] += iBag.size;
							addItem(iBag.id, iChar.oCharIndex, 1); // Add the bag itself which is an item
							iBag.inventory.forEach(function(iSlot)
							{
								if (iSlot)
								{
									A.Tally.Characters[0] += 1;
									addItem(iSlot.id, iChar.oCharIndex, iSlot.count, iSlot.binding);
									addUpgrades(iSlot, iChar.oCharIndex);
								}
							});
						}
					});
				}
				// Count the highest number of active crafting disciplines
				if (iChar.crafting)
				{
					var activecrafts = 0;
					iChar.crafting.forEach(function(iCraft)
					{
						if (iCraft.active)
						{
							activecrafts++;
						}
					});
					if (activecrafts > (craftspurchased + craftsupgobj.starting))
					{
						craftspurchased++;
					}
				}
			});
			A.assignAccountUpgrades("CraftingLicense", craftspurchased + craftsupgobj.starting);
			// Bag slot upgrades are counted manually instead of by the macro function
			bagsupgobj.purchased = bagspurchased;
			bagsupgobj.totalgem = bagsupgobj.gem * bagspurchased;
			bagsupgobj.totalowned = (A.Data.Characters.length * bagsupgobj.starting) + bagspurchased;
			
			// Add shared inventory slot items
			A.assignAccountUpgrades("SharedSlot", pSharedData.length);
			A.Tally.Shared[1] = pSharedData.length;
			pSharedData.forEach(function(iSlot)
			{
				if (iSlot)
				{
					A.Tally.Shared[0] += 1;
					addItem(iSlot.id, "Shared", iSlot.count, iSlot.binding);
				}
			});
			
			// Add bank contents
			A.assignAccountUpgrades("BankTab", ~~(pBankData.length / A.Metadata.Bank.NumSlotsPerTab));
			A.Tally.Bank[1] = pBankData.length;
			pBankData.forEach(function(iSlot)
			{
				if (iSlot)
				{
					A.Tally.Bank[0] += 1;
					addItem(iSlot.id, "Bank", iSlot.count, iSlot.binding);
					addUpgrades(iSlot, "Bank");
				}
			});
			
			// Add materials deposits
			var materialcountlargest = 0;
			A.Tally.Materials[1] = pMaterialsData.length;
			pMaterialsData.forEach(function(iSlot)
			{
				if (iSlot && iSlot.count > 0)
				{
					A.Tally.Materials[0] += 1;
					addItem(iSlot.id, "Materials", iSlot.count);
					if (iSlot.count > materialcountlargest)
					{
						materialcountlargest = iSlot.count;
					}
				}
			});
			A.assignAccountUpgrades("StorageExpander", Math.ceil(materialcountlargest / Q.GameLimit.StackSize));
			
			// Add vault contents for all guilds if requested and permitted
			if (pVaultData)
			{
				for (var i in pVaultData)
				{
					pVaultData[i].forEach(function(iSubvault)
					{
						iSubvault.inventory.forEach(function(iSlot)
						{
							if (iSlot)
							{
								A.Tally.Vault[0] += 1;
								addItem(iSlot.id, "Vault", iSlot.count);
							}
						});
						A.Tally.Vault[1] += iSubvault.size;
					});
				}
			}
			
			// Execute callback after finishing compilation
			pCallback();
		};
		
		// Download additional API data containing the account's items
		$.getJSON(A.getURL(A.URL.Shared), function(pSharedData)
		{
			$.getJSON(A.getURL(A.URL.Bank), function(pBankData)
			{
				$.getJSON(A.getURL(A.URL.Materials), function(pMaterialsData)
				{
					if (pWantVault)
					{
						A.initializeVault(function(pVaultData)
						{
							compilePossessions(pSharedData, pBankData, pMaterialsData, pVaultData);
						});
					}
					else
					{
						compilePossessions(pSharedData, pBankData, pMaterialsData);
					}
				});
			});
		}).fail(function(pRequest, pStatus)
		{
			A.printError(A.PermissionEnum.Inventories, pStatus);
		});
	},
	
	/*
	 * Gets a list of locations an item of a type is located in the account.
	 * @param object pLocations from possessions object.
	 * @returns string.
	 */
	formatPossessionLocations: function(pPossessionEntry)
	{
		var str = "";
		var locations = pPossessionEntry.oAudit;
		for (var i in locations)
		{
			// Show the character names rather than the combined characters location, ignore empty locations
			if (i !== "Characters" && ((locations[i])[0] > 0 || (locations[i])[1] > 0))
			{
				if (isNaN(i))
				{
					str += D.getWordCapital(i.toLowerCase());
				}
				else
				{
					if (A.Data.Characters[i])
					{
						str += A.Data.Characters[i].oCharName;
					}
				}
				str += " (" + (locations[i])[1] + ")" + ", "; // Write the count next to the location name
			}
		}
		str = str.substring(0, str.length - 2); // Trim the trailing comma
		return str;
	},
	getFoundString: function(pPossessionEntry)
	{
		return "<var class='itmColor_reminder'>" + D.getPhrase("found in", U.CaseEnum.Sentence)
			+ ": " + A.formatPossessionLocations(pPossessionEntry) + "</var>";
	},
	
	/*
	 * Iterates a function over an unlockables record.
	 * @param object pRecord.
	 * @param function pIteration with parameters entry and entry's category name.
	 */
	iterateRecord: function(pRecord, pIteration)
	{
		var catarr, entry;
		for (var i in pRecord)
		{
			catarr = pRecord[i];
			for (var ii = 0; ii < catarr.length; ii++)
			{
				entry = catarr[ii];
				pIteration(entry, i);
			}
		}
	},
	flattenRecord: function(pRecord)
	{
		var newrec = {}; // Returns a record as a single associative array instead of one 
		A.iterateRecord(pRecord, function(pEntry)
		{
			newrec[pEntry.i] = pEntry;
		});
		return newrec;
	},
	
	/*
	 * An account's unlocks API may return an array of unlock IDs (if an ID is in
	 * the array, that unlockable is unlocked), or an array of objects with more
	 * information. This function flattens to the IDs format if it is objects.
	 * @param array pUnlocks from any account unlock API.
	 * @returns array of integers.
	 */
	flattenUnlocks: function(pUnlocks)
	{
		var arr = [];
		if (pUnlocks.length && pUnlocks[0].id !== undefined)
		{
			pUnlocks.forEach(function(iUnlock)
			{
				if (iUnlock.id && iUnlock.permanent !== false)
				{
					arr.push(iUnlock.id);
				}
			});
			pUnlocks = arr;
			return arr;
		}
		return pUnlocks;
	},
	
	/*
	 * Loads the charts script and initialize it if haven't already.
	 * @param function pCallback
	 */
	initializeCharts: function(pCallback)
	{
		U.getScript(U.URL_API.Charts, function()
		{
			if (A.isChartsInitialized === false)
			{
				Highcharts.setOptions(
				{
					global: {useUTC: false}
				});
				A.isChartsInitialized = true;
			}
			pCallback();
		});
	},
	getChartsTimeFormat: function()
	{
		if (O.Options.bol_use24Hour)
		{
			return {
				second: "%H:%M:%S",
				minute: "%H:%M",
				hour: "%H:%M"
			};
		}
		return {
			second: "%l:%M:%S %p",
			minute: "%l:%M %p",
			hour: "%l:%M %p"
		};
	},
	
	/*
	 * Macro function to be used in chart tooltip property.
	 * @param object pPoints
	 * @param object pColors to colorize the lines and format values.
	 * @returns string html.
	 */
	getChartsCurrencyFormat: function(pPoints, pColors)
	{
		var html = (T.formatWeektime(pPoints[0].x, true)) + "<table>";
		for (var i = 0; i < pPoints.length; i++)
		{
			var ipoint = pPoints[i];
			var series = ipoint.series;
			var name = series.name;
			var currencystr = "";
			if (pColors && pColors[name].currency)
			{
				switch (pColors[name].currency)
				{
					case "gem": { currencystr = E.formatGemString(ipoint.y, true); } break;
					case "karma": { currencystr = E.formatKarmaString(ipoint.y, true); } break;
				}
			}
			else
			{
				currencystr = E.formatCoinStringColored(ipoint.y); 
			}
			
			html += "<tr>"
				+ "<td style='color:" + series.color + "'>" + D.getWordCapital(name.toLowerCase()) + "</td>"
				+ "<td><b>" + currencystr + "</b></td>"
			+ "</tr>";
		};
		html += "</table>";
		return html;
	},
	
	/*
	 * Generates the account audit subsection into the Characters page.
	 * The inner functions are executed from bottom to top.
	 */
	generateAudit: function()
	{
		var sampleconversionamount = 100;
		var button = $("#audExecute");
		var buttonalt = $("#audExecuteAlternate").hide();
		I.suspendElement(button);
		var container = $("#accAudit").empty();
		var auditpayments = A.Currency.AuditPayments; // Auditable payment objects
		var cachedprices; // Will contain payment or TP prices, accessible by item ID
		var untradeabledb;
		E.Paylist = {}; // Holds payment object or processed TP price, items whose ID is not in this will have no value
		var priceids = {}; // Tradeable item IDs to fetch, an associative array so no duplicate
		var ascendeddata, ascendedheader, ingredients, ascendedingr, compositeingr, auditmetadata;
		var currentbuysdata, currentsellsdata;
		var categoriesview = {}; // Holds categories which holds item IDs and totaled payments of possession or unlocks, for the bank view
		var recordsdata = {
			Ascended: {},
			Catalog: {},
			Skins: {},
			Outfits: {},
			Gliders: {},
			Dyes: {},
			Minis: {},
			Carriers: {},
			Champions: {},
			Finishers: {},
			Nodes: {},
			Recipes: {}
		};
		var unlocksdata = { // Account's unlocked IDs retrieved from API
			Skins: {},
			Outfits: {},
			Gliders: {},
			Dyes: {},
			Minis: {},
			Carriers: {},
			Champions: {},
			Finishers: {},
			Nodes: {}
		};
		
		var finalizeAutoAudit = function()
		{
			// If ran from an embed then assume this was automated, so close the webpage after the audit finishes
			if (I.isProgramEmbedded && U.Args[(U.KeyEnum.AutoAudit)])
			{
				window.location.href = "about:blank";
			}
		};
		
		// Resets the auditing process in case it failed to let the user restart it
		var dealError = function()
		{
			I.suspendElement(button, false);
			buttonalt.show();
			finalizeAutoAudit();
		};
		
		// Creates a standard object of payments to be displayed for an audit category
		var createAuditPayments = function(pInitialAmount)
		{
			var paymentsobj = {};
			var amount = (pInitialAmount === undefined) ? 0 : pInitialAmount;
			for (var i in auditpayments)
			{
				paymentsobj[i] = amount;
			}
			return paymentsobj;
		};
		var initializeAuditCategories = function()
		{
			for (var i in A.Currency.AuditCategories)
			{
				A.Currency.AuditCategories[i] = createAuditPayments();
				A.Currency.AuditHistory[i] = null; // Also initializes audit history
			}
			A.Currency.AuditCategoriesCharacters = {};
		};
		
		// Adds a payment or price object to an audit category
		var addPaymentToCategory = function(pCategory, pPayment, pCount, pIsBound, pItemID)
		{
			var auditcat = A.Currency.AuditCategories[pCategory];
			if (isNaN(pCategory) === false) // If auditing an individual character
			{
				if (A.Currency.AuditCategoriesCharacters[pCategory] === undefined)
				{
					A.Currency.AuditCategoriesCharacters[pCategory] = createAuditPayments();
				}
				auditcat = A.Currency.AuditCategoriesCharacters[pCategory];
			}
			var count = (pCount === undefined) ? 1 : pCount;
			if (E.isPriceObject(pPayment))
			{
				if (pIsBound === true)
				{
					// Bound items cannot be liquidated for cash, so only have appraised values
					auditcat.coin_appraisedbuy += pPayment.oPriceBuy * count;
					auditcat.coin_appraisedsell += pPayment.oPriceSell * count;
				}
				else
				{
					auditcat.coin_liquidbuy += pPayment.oPriceBuyTaxed * count;
					auditcat.coin_liquidsell += pPayment.oPriceSellTaxed * count;
					auditcat.coin_appraisedbuy += pPayment.oPriceBuy * count;
					auditcat.coin_appraisedsell += pPayment.oPriceSell * count;
				}
			}
			else
			{
				for (var i in pPayment)
				{
					if (auditcat[i] !== undefined && pPayment[i] > 0)
					{
						auditcat[i] += pPayment[i] * count;
					}
				}
			}
			// Update the category view object that totals the items and appraised sell coin of that category
			if (pItemID)
			{
				var itemid = parseInt(pItemID);
				if (categoriesview[pCategory] === undefined)
				{
					categoriesview[pCategory] = {};
				}
				var catview = categoriesview[pCategory];
				if (catview[itemid] === undefined)
				{
					catview[itemid] = [0, 0];
					if (E.isPriceObject(pPayment))
					{
						(catview[itemid])[1] = convertCurrencyToCoin("coin_appraisedsell", pPayment.oPriceSell);
					}
					else
					{
						for (var i in pPayment)
						{
							if (auditcat[i] !== undefined && pPayment[i] > 0)
							{
								(catview[itemid])[1] = convertCurrencyToCoin(i, pPayment[i]);
							}
						}
					}
				}
				// Update the count of the item in that category
				(catview[itemid])[0] += count;
			}
		};
		
		// Evaluates the wallet audit category
		var auditWallet = function()
		{
			var quantity, paymentobj;
			for (var i in A.Data.Wallet)
			{
				quantity = A.Data.Wallet[i];
				if (i === "1") // If the currency is coin
				{
					addPaymentToCategory("Wallet", E.createPricePlain(quantity), 1);
				}
				else if (A.Currency.AuditWallet[i]) // Audit applicable currencies
				{
					paymentobj = {};
					paymentobj[(A.Currency.AuditWallet[i]).payment] = quantity;
					addPaymentToCategory("Wallet", paymentobj, 1, true);
				}
			}
		};
		
		// Evaluates the bank, characters, and materials audit categories
		var auditPossessions = function()
		{
			var legendaryinclusion = auditmetadata.LegendaryInclusion;
			var payment, auditcat, auditobj, count;
			A.Tally.Legendary = {
				count: 0,
				price: E.createPrice()
			};
			for (var i in A.Possessions)
			{
				payment = E.Paylist[i];
				if (payment)
				{
					for (var ii in A.Possessions[i].oAudit)
					{
						auditcat = A.Currency.AuditCategories[ii];
						auditobj = A.Possessions[i].oAudit[ii];
						if (isNaN(ii) === false) // If auditing an individual character
						{
							if (A.Currency.AuditCategoriesCharacters[ii] === undefined)
							{
								A.Currency.AuditCategoriesCharacters[ii] = createAuditPayments();
							}
							auditcat = A.Currency.AuditCategoriesCharacters[ii];
						}
						if (auditcat) // Add payment if it is of a valid audit category or is a character audit
						{
							if (E.isPriceObject(payment))
							{
								/*
								 * Index [0] is the count of unbound (tradeable, liquid and appraised).
								 * Index [1] is the count of all items (mixed).
								 * [1] - [0] = the count of bound items (untradeable, appraised only).
								 */
								if (auditobj[1] === auditobj[0]) // If there is no bound item
								{
									addPaymentToCategory(ii, payment, auditobj[1], false, i);
								}
								else // If there at least one bound item, then add bound and unbound items separately
								{
									addPaymentToCategory(ii, payment, auditobj[0], false, i);
									addPaymentToCategory(ii, payment, (auditobj[1] - auditobj[0]), true, i);
								}
							}
							else
							{
								addPaymentToCategory(ii, payment, auditobj[1], false, i);
							}
						}
					}
					// Tally the legendary gear possessed
					if (legendaryinclusion[i])
					{
						count = A.Possessions[i].oCount;
						A.Tally.Legendary.count += count;
						A.Tally.Legendary.price = E.addPrice(A.Tally.Legendary.price, E.recountPrice(payment, count));
					}
				}
			}
		};
		
		// Evaluates an unlocks audit category
		var auditUnlocks = function(pName, pWantPossessions)
		{
			var payment;
			var unlockedids; // An associative array of unlock IDs
			var itemkey = "i";
			// Special case for recipes because the unlocks is stored within the characters data instead of an API flat array
			if (pName === "Recipes")
			{
				// Initialize the recipes unlocks array
				unlocksdata.Recipes = [];
				unlockedids = {};
				itemkey = "b"; // The item ID of tradeable recipes is stored in the recipes record under this object key
				A.Data.Characters.forEach(function(iChar)
				{
					if (iChar.recipes)
					{
						// Compile recipe unlocks by combining each characters' learned recipes
						for (var i = 0; i < iChar.recipes.length; i++)
						{
							if (unlockedids[(iChar.recipes[i])] === undefined)
							{
								unlocksdata.Recipes.push(iChar.recipes[i]); // This is for the tally
								unlockedids[(iChar.recipes[i])] = true;
							}
						}
					}
				});
				// Add the bound recipe payments
				var recipesdata = U.getRecordData("recipes");
				var recipepayment;
				A.iterateRecord(recipesdata, function(pEntry)
				{
					if (unlockedids[pEntry.u] && unlockedids[pEntry.u] !== 1 && pEntry.p)
					{
						unlockedids[pEntry.u] = 1; // Only audit the recipe once
						for (var ii in pEntry.p)
						{
							payment = {};
							payment[ii] = pEntry.p[ii];
							recipepayment = ((ii === "coin") ? E.createPriceBound(pEntry.p[ii]) : payment);
							addPaymentToCategory(pName, recipepayment, 1, true, pEntry.s);
						}
					}
				});
			}
			
			// Audit by adding the payment value once for each unlock (which has an associated item that has a payment)
			unlocksdata[pName] = A.flattenUnlocks(unlocksdata[pName]);
			A.Tally[pName] = [(unlocksdata[pName]).length, 0];
			if (unlockedids === undefined)
			{
				unlockedids = U.getExistAssoc(unlocksdata[pName]);
				// Special case for skins, nullify some from auditing
				if (pName === "Skins")
				{
					for (var i in auditmetadata.SkinsExclusion)
					{
						unlockedids[i] = false;
					}
				}
				// Consider the backpack skin and ignore the glider, for those from gem store combo
				if (pName === "Gliders")
				{
					var gliderscombo = GW2T_GLIDERS_DATA["Combo"];
					for (var i in gliderscombo)
					{
						unlockedids[(gliderscombo[i].u)] = false;
					}
				}
			}
			var associtems = {};
			var associtemid;
			A.iterateRecord(recordsdata[pName], function(pEntry)
			{
				(A.Tally[pName])[1] += 1;
				associtemid = pEntry[itemkey];
				if (associtemid)
				{
					payment = E.Paylist[associtemid];
					/*
					 * Audit if payment exists, the unlock is unlocked, and the associated
					 * item has not been audited for this record and is not in possession.
					 */
					if (payment
						&& unlockedids[pEntry.u] && unlockedids[pEntry.u] !== 1
						&& associtems[associtemid] === undefined
						&& ((pWantPossessions === false && A.Possessions[associtemid] === undefined) || (pWantPossessions !== false)))
					{
						unlockedids[pEntry.u] = 1; // Only audit the unlock once
						addPaymentToCategory(pName, payment, 1, true, associtemid);
						associtems[pEntry.i] = true;
					}
				}
			});
		};
		
		// Evaluates transactions of coin in buy orders or items in sell listings
		var auditTransactions = function()
		{
			var payment;
			if (currentbuysdata)
			{
				A.Tally.Buying = [currentbuysdata.length, currentbuysdata.length];
				currentbuysdata.forEach(function(iTransaction)
				{
					addPaymentToCategory("Buying", E.createPricePlain(iTransaction.price), iTransaction.quantity, false, iTransaction.item_id);
				});
			}
			if (currentsellsdata)
			{
				A.Tally.Selling = [currentsellsdata.length, currentsellsdata.length];
				currentsellsdata.forEach(function(iTransaction)
				{
					payment = E.Paylist[iTransaction.item_id];
					if (payment)
					{
						addPaymentToCategory("Selling", payment, iTransaction.quantity, false, iTransaction.item_id);
					}
				});
			}
		};
		
		// Adds two audit categories' payments and returns a sum audit category
		var sumAuditCategories = function(pCategoryA, pCategoryB)
		{
			var auditcat = {};
			for (var i in pCategoryA)
			{
				auditcat[i] = pCategoryA[i] + pCategoryB[i];
			}
			return auditcat;
		};
		
		// Appraises a non-coin currency into a coin amount; the exchange ratios must have been initialized
		var convertCurrencyToCoin = function(pCurrencyName, pAmount, pPriceType)
		{
			var name = pCurrencyName;
			var pricetype = pPriceType || "oPriceSell";
			if (name.indexOf("coin") !== -1) // Coin cases
			{
				return pAmount;
			}
			if (name === "gem") // Gem case
			{
				return E.convertGemToCoin(pAmount);
			}
			
			var conversion = auditpayments[name].conversion;
			if (conversion === 0) // Unconvertible case
			{
				return 0;
			}
			if (isNaN(conversion) === false) // Normal case
			{
				return pAmount * conversion;
			}
			if (Array.isArray(conversion)) // Item dependent case
			{
				var barteramount = conversion[0];
				var barteritem = conversion[1];
				var payment = E.Paylist[barteritem];
				if (payment && payment[pricetype])
				{
					return Math.floor(pAmount * (payment[pricetype] / barteramount));
				}
			}
			return 0;
		};
		
		// Creates an audit page separator and title
		var createTitle = function(pTitle)
		{
			return $("<div class='audTitleContainer'><aside class='audTitle'>" + pTitle + "</aside></div>");
		};
		
		// Creates an audit presentation table
		var createTable = function(pTitle)
		{
			var table = $("<div class='audTable'></div>").appendTo(container);
			createTitle(pTitle).insertBefore(table);
			return table;
		};
		
		// Inserts a headered but empty column into a table
		var insertColumn = function(pTable, pHeader, pCategory)
		{
			var tally = A.Tally[pCategory], tallystr = "";
			if (tally)
			{
				tallystr = "<span class='audTableTally'>" + tally[0] + " / " + tally[1]
					+ " (" + U.convertRatioToPercent(tally[0] / tally[1]) + ")</span>";
			}
			var auditcolumn = $("<div class='audTableColumn'></div>").appendTo(pTable);
			var columnheader = $("<div class='audTableCell audTableHeaderHorizontal'>" + pHeader + tallystr + "</div>").appendTo(auditcolumn);
			// Bind category view function on category header
			if (pCategory && pCategory !== "Wallet")
			{
				columnheader.click(function()
				{
					createCategoryView(pCategory);
				}).addClass("audTableHeaderView curZoom").attr("id", "audViewHeader_" + pCategory);
			}
			return auditcolumn;
		};
		
		// Inserts a leading column of currency names into a table
		var insertTableCurrencyHeader = function(pTable, pWantHidden)
		{
			// Write the first column which acts as headers for the rows of currencies
			var paymentobj, currency, headerwords;
			var currencyheaders = $("<div class='audTableHeaderVertical audTableColumn'></div>").appendTo(pTable);
			for (var i in auditpayments)
			{
				if (!pWantHidden && auditpayments[i].ishidden)
				{
					continue;
				}
				paymentobj = auditpayments[i];
				currency = A.Currency.AuditWallet[paymentobj.id];
				headerwords = (paymentobj.id === 1) ? D.getPhraseOriginal(paymentobj.header) : D.getObjectName(currency);
				currencyheaders.append("<div class='audTableCell'>"
					+ headerwords + "&nbsp;<ins class='acc_wallet acc_wallet_" + paymentobj.id + "'></ins></div>");
			}
			// Padding cell at the top left corner of the table
			currencyheaders.prepend("<div class='audTableCell audTableHeaderCorner'></div>");
		};
		
		// Creates an audit category containing the max amount found from multiple categories, for creating mini bar charts
		var createCurrencyMaxes = function(pCategories)
		{
			var ithcat;
			var maxcat = createAuditPayments(Number.NEGATIVE_INFINITY);
			for (var i in pCategories)
			{
				ithcat = pCategories[i];
				for (var ii in ithcat)
				{
					if (ithcat[ii] > maxcat[ii])
					{
						maxcat[ii] = ithcat[ii];
					}
				}
			}
			return maxcat;
		};
		
		// Fills a table column with currencies
		var fillCurrencyColumn = function(pColumn, pCategory, pIsConversion, pMaxCategory, pWantHidden)
		{
			var amount, paymentkey, barstr, prefix;
			for (var i in pCategory)
			{
				if (!pWantHidden && auditpayments[i].ishidden)
				{
					continue;
				}
				amount = pCategory[i];
				paymentkey = (i.indexOf("coin") !== -1 || pIsConversion) ? "coin" : i;
				barstr = "";
				if (pMaxCategory)
				{
					barstr = "<samp class='audTableCellBar'>"
						+ "<s style='background:url(img/background/bargraph.png), linear-gradient(to right, black 0%, " + auditpayments[i].color + " 100%);"
						+ "width:" + ((pMaxCategory[i] > 0) ? ((amount / pMaxCategory[i]) * T.cPERCENT_100) : 0) + "%'></s>"
					+ "</samp>";
				}
				prefix = (pIsConversion) ? ("<span class='cssLeft'>" + ((auditpayments[i].isappraised) ? I.Symbol.Approx : I.Symbol.ArrowRight) + "</span>") : "";
				pColumn.append("<div class='audTableCell'>" + prefix + E.PaymentFormat[paymentkey](amount) + barstr + "</div>");
			}
		};
		// Same as original function but shows the hidden payment rows
		var fillCurrencyColumnFull = function(pColumn, pCategory, pIsConversion, pMaxCategory)
		{
			fillCurrencyColumn(pColumn, pCategory, pIsConversion, pMaxCategory, true);
		};
		
		// Fills a table column with the rows' currency converted to coin
		var fillConversionColumn = function(pColumn, pCategory)
		{
			var convertedpayments = createAuditPayments();
			for (var i in pCategory)
			{
				convertedpayments[i] = convertCurrencyToCoin(i, pCategory[i]);
			}
			fillCurrencyColumnFull(pColumn, convertedpayments, true);
		};
		
		// Generates a "bank" of audited items in a category with their payment preconverted to appraised sell coin
		var createCategoryView = function(pCategory)
		{
			var audview = $("#audView").empty();
			var viewcontainer = B.createBank(audview);
			var viewbank = B.getTabsContainer(viewcontainer);
			var tabtitle = (isNaN(pCategory) === false) ? A.Data.Characters[pCategory].oCharPreface : D.getWordCapital(pCategory);
			var viewtab = B.createBankTab(viewbank, {aTitle: tabtitle});
			var viewslotscontainer = B.getSlotsContainer(viewtab);
			var itemids = [];
			for (var i in categoriesview[pCategory])
			{
				itemids.push(i);
			}
			
			// Fill the "bank" with item slots
			Q.getPricedItems(itemids, function()
			{
				for (var i in categoriesview[pCategory])
				{
					(function(iSlot, iItemID, iView)
					{
						Q.getItem(iItemID, function(iItem)
						{
							B.styleBankSlot(iSlot, {aItem: iItem, aPrice: iView[1], aSlotMeta: {count: iView[0]}});
							var payment = E.Paylist[iItemID];
							if (payment && E.isPriceObject(payment) === false)
							{
								B.updateSlotPayment(iSlot, payment, iView[0], "bnkSlotPriceSell");
							}
						});
					})(B.createBankSlot(viewslotscontainer), i, (categoriesview[pCategory])[i]);
				}
				B.tallyBank(viewcontainer);
				B.createBankMenu(viewbank, {aWantClear: true, aReloadElement: $("#audViewHeader_" + pCategory)});
				I.scrollToElement("#audViewTitle", {aSpeed: "fast"});
			});
		};
		
		// Reformats a history object for chart display
		var formatAuditHistory = function(pHistory)
		{
			var lines = [], histcat;
			var histstamp = pHistory["Timestamps"];
			for (var i in pHistory)
			{
				if (i !== "Timestamps")
				{
					var ithline = {
						name: i,
						data: [],
						color: A.Currency.AuditColor[i].color
					};
					histcat = pHistory[i];
					for (var ii = 0; ii < histcat.length; ii++)
					{
						ithline.data.push([
							new Date(histstamp[ii]).getTime(),
							histcat[ii]
						]);
					}
					lines.push(ithline);
				}
			}
			return lines;
		};
		
		/*
		 * Writes HTML to display the audit results.
		 */
		var generateResults = function()
		{
			// Clear the console of load messages
			I.clear();
			var tablecategory = createTable(D.getPhraseOriginal("Audit Categories"));
			var tablesum = createTable(D.getPhraseOriginal("Sum &amp; Conversion"));
			var tablechar = createTable(D.getPhraseOriginal("Audit Characters"));
			
			// TABLE: Audit categories
			insertTableCurrencyHeader(tablecategory);
			// Write a column for each audit category
			var auditcolumn;
			var auditcats = A.Currency.AuditCategories;
			var auditcatsmax = createCurrencyMaxes(auditcats);
			for (var i in auditcats)
			{
				if ((i === "Vault" && A.Data.Vaults === null)
					|| (i === "Buying" && currentbuysdata === undefined)
					|| (i === "Selling" && currentsellsdata === undefined))
				{
					// Don't show the transaction columns if did not opt to audit them
					continue;
				}
				auditcolumn = insertColumn(tablecategory, D.getWordCapital(i.toLowerCase()), i);
				fillCurrencyColumn(auditcolumn, auditcats[i], false, auditcatsmax);
			}
			
			// TABLE: Sum and conversions
			insertTableCurrencyHeader(tablesum, true);
			// Sum columns
			var sumcolumn = insertColumn(tablesum, D.getPhraseOriginal("Account Sum"));
			var convertedsumcolumn = insertColumn(tablesum, D.getPhraseOriginal("Account Sum"));
			var sumcat = createAuditPayments();
			for (var i in auditcats)
			{
				// Add all audit categories' payments into one "sum" category
				sumcat = sumAuditCategories(sumcat, auditcats[i]);
			}
			fillCurrencyColumnFull(sumcolumn, sumcat);
			fillConversionColumn(convertedsumcolumn, sumcat);
			// Wallet columns
			var walletcat = auditcats["Wallet"];
			var walletcolumn = insertColumn(tablesum, D.getPhraseOriginal("Wallet"));
			var convertedwalletcolumn = insertColumn(tablesum, D.getPhraseOriginal("Wallet"));
			fillCurrencyColumnFull(walletcolumn, walletcat);
			fillConversionColumn(convertedwalletcolumn, walletcat);
			// Sample columns
			var samplecat = createAuditPayments(sampleconversionamount);
			var samplecolumn = insertColumn(tablesum, D.getPhraseOriginal("Conversion"));
			var convertedsamplecolumn = insertColumn(tablesum, D.getPhraseOriginal("Conversion"));
			fillCurrencyColumnFull(samplecolumn, samplecat);
			fillConversionColumn(convertedsamplecolumn, samplecat);
			
			// TABLE: Characters
			insertTableCurrencyHeader(tablechar);
			var charcolumn;
			var charcats = A.Currency.AuditCategoriesCharacters;
			var charcatsmax = createCurrencyMaxes(charcats);
			for (var i in charcats)
			{
				charcolumn = insertColumn(tablechar, A.Data.Characters[i].oCharIcons, i);
				fillCurrencyColumn(charcolumn, charcats[i], false, charcatsmax);
			}
			tablechar.addClass("audTableHorizontal");
			I.bindScrollbar(tablechar, true);
			I.qTip.init(tablechar.find(".chrPreface"));
			
			// VIEW
			createTitle("View Audit").attr("id", "audViewTitle").appendTo(container);
			$("<div id='audView'></div>").appendTo(container);
			
			// GEM STORE UPGRADES
			var summaryupgrades = $("<div id='audUpgrades'></div>").appendTo(container);
			var upggems = A.getAccountUpgradesGem();
			var upgcontainer = B.createBank(summaryupgrades);
			var upgbank = B.getTabsContainer(upgcontainer);
			var upgtab = B.createBankTab(upgbank, {aTitle: D.getPhraseTitle("Account Upgrades")});
			var upgslotscontainer = B.getSlotsContainer(upgtab);
			// Fill the "bank" with pseudo item slots
			for (var i in A.Currency.AuditUpgrades)
			{
				(function(iSlot, iUpg)
				{
					Q.getItem(iUpg.id, function(iItem)
					{
						B.styleBankSlot(iSlot, {aItem: iItem, aGem: iUpg.gem, aSlotMeta: {count: iUpg.purchased}});
					});
				})(B.createBankSlot(upgslotscontainer), A.Currency.AuditUpgrades[i]);
			}
			
			// SUMMARY
			E.getCoinFromGem(walletcat["gem"], function(pCoin)
			{
				// Appraised sell plus all non-coin payments converted to coin
				var totalappraisedbuy = sumcat["coin_appraisedbuy"];
				var totalappraisedsell = sumcat["coin_appraisedsell"];
				var totalappraisedbuynogems = sumcat["coin_appraisedbuy"];
				var totalappraisedsellnogems = sumcat["coin_appraisedsell"];
				// Liquid sell plus gem converted to coin plus all non-coin payments converted to coin
				var totalliquidbuy = sumcat["coin_liquidbuy"] + pCoin;
				var totalliquidsell = sumcat["coin_liquidsell"] + pCoin;
				var totalliquidbuynogems = sumcat["coin_liquidbuy"];
				var totalliquidsellnogems = sumcat["coin_liquidsell"];
				for (var i in auditpayments)
				{
					if (i.indexOf("coin") === -1)
					{
						totalappraisedbuy += convertCurrencyToCoin(i, sumcat[i], "oPriceBuy");
						totalappraisedsell += convertCurrencyToCoin(i, sumcat[i], "oPriceSell");
						if (i.indexOf("gem") === -1)
						{
							totalappraisedbuynogems += convertCurrencyToCoin(i, sumcat[i], "oPriceBuy");
							totalappraisedsellnogems += convertCurrencyToCoin(i, sumcat[i], "oPriceSell");
						}
					}
					if (auditpayments[i].isliquid)
					{
						totalliquidbuy += convertCurrencyToCoin(i, walletcat[i], "oPriceBuyTaxed");
						totalliquidsell += convertCurrencyToCoin(i, walletcat[i], "oPriceSellTaxed");
					}
				}
				// Add gems spent from account upgrades to appraisal
				var sumgems = sumcat["gem"];
				var totalgems = sumgems + upggems;
				var upggemstocoin = convertCurrencyToCoin("gem", upggems);
				totalappraisedbuy += upggemstocoin;
				totalappraisedsell += upggemstocoin;
				
				// For each audit category, convert their payments to coin and remember their sum
				var convertcat = {};
				for (var i in auditcats)
				{
					convertcat[i] = 0;
					for (var ii in auditcats[i])
					{
						// The desired coin payment is "coin_appraisedsell", so avoid these duplicates
						if (ii !== "coin_liquidbuy"
							&& ii !== "coin_liquidsell"
							&& ii !== "coin_appraisedbuy")
						{
							convertcat[i] += convertCurrencyToCoin(ii, (auditcats[i])[ii], "oPriceSell");
						}
					}
				}
				
				var summarycontainer = $("<div id='audSummaryContainer'></div>").prependTo(container);
				var summary = $("<div id='audSummary'></div>").appendTo(summarycontainer).hide();
				var historycontainer = $("<div id='audHistoryContainer'></div>").appendTo(summarycontainer).hide();
				var historychart = $("<div id='audHistory'></div>").appendTo(historycontainer);
				summary.append("<div id='audSummaryName'><var id='audAccountName'>" + U.escapeHTML(A.Data.Account.name) + "</var></div>");
				summary.append("<div id='audSummaryValues'>"
					+ "<div class='audSummarySubtitle'>― " + D.getWordCapital("appraised") + " ―</div>"
					+ "<div id='audSummaryAppraised' class='audSummaryCoin curHelp'>" + E.formatCoinString(0, {aWantBig: true}) + "</div>"
					+ "<div class='audSummaryMoney'>" + I.Symbol.Approx + " " + E.formatGemToMoney(totalgems + E.convertCoinToGem(totalappraisedsellnogems)) + "</div>"
					+ "<div class='audSummarySubtitle'>― " + D.getWordCapital("liquid") + " ―</div>"
					+ "<div id='audSummaryLiquid' class='audSummaryCoin curHelp'>" + E.formatCoinString(0, {aWantBig: true}) + "</div>"
					+ "<div class='audSummaryMoney'>" + I.Symbol.Approx + " " + E.formatGemToMoney(walletcat["gem"] + E.convertCoinToGem(totalliquidsellnogems)) + "</div>"
				+ "</div>");
				
				// Tooltip over the coin value to show both and buy and sell
				var appraisedtip = "<dfn>" + D.getPhraseOriginal("Appraised Summary") + ":</dfn> <br />"
					+ D.getPhraseOriginal("Appraised Sell") + ": " + E.formatCoinStringColored(totalappraisedsell) + "<br />"
					+ D.getPhraseOriginal("Appraised Buy") + ": " + E.formatCoinStringColored(totalappraisedbuy) + "<br />"
					+ "<br />"
					+ "<dfn>" + D.getPhraseOriginal("Appraised Summary Exclude Gems") + ":</dfn> <br />"
					+ D.getPhraseOriginal("Appraised Sell") + ": " + E.formatCoinStringColored(totalappraisedsellnogems) + "<br />"
					+ D.getPhraseOriginal("Appraised Buy") + ": " + E.formatCoinStringColored(totalappraisedbuynogems) + "<br />"
					+ "<br />"
					+ "<dfn>" + D.getWordCapital("Info") + ":</dfn> <br />"
					+ D.getPhraseOriginal("Legendary Equipment") + ": " + E.formatCoinStringColored(A.Tally.Legendary.price.oPriceSell)
						+ " (" + A.Tally.Legendary.count + " " + D.getWord("legendary") + ")<br />"
					+ D.getPhraseOriginal("Ascended Equipment") + ": " + E.formatCoinStringColored(A.Tally.Ascended.price.oPriceSell)
						+ " (" + A.Tally.Ascended.armorcount + " " + D.getWord("armor") + ", " + A.Tally.Ascended.weaponcount + " " + D.getWord("weapons") + ")<br />"
					+ D.getPhraseOriginal("Gem Categories Sum") + ": " + E.formatGemToMoney(sumgems)
						+ " " + I.Symbol.ArrowRight + " " +  E.formatGemString(sumgems, true)
						+ " " + I.Symbol.ArrowLeft + " " + E.formatGemToCoin(sumcat["gem"]) + "<br />"
					+ D.getPhraseOriginal("Gem Account Upgrades") + ": " + E.formatGemToMoney(upggems)
						+ " " + I.Symbol.ArrowRight + " " + E.formatGemString(upggems, true)
						+ " " + I.Symbol.ArrowLeft + " " + E.formatCoinStringColored(upggemstocoin) + "<br />";
				var liquidtip = "<dfn>" + D.getPhraseOriginal("Liquid Summary") + ":</dfn> <br />"
					+ D.getPhraseOriginal("Liquid Sell") + ": " + E.formatCoinStringColored(totalliquidsell) + "<br />"
					+ D.getPhraseOriginal("Liquid Buy") + ": " + E.formatCoinStringColored(totalliquidbuy) + "<br />"
					+ "<br />"
					+ "<dfn>" + D.getPhraseOriginal("Liquid Summary Exclude Gems") + ":</dfn> <br />"
					+ D.getPhraseOriginal("Liquid Sell") + ": " + E.formatCoinStringColored(totalliquidsellnogems) + "<br />"
					+ D.getPhraseOriginal("Liquid Buy") + ": " + E.formatCoinStringColored(totalliquidbuynogems) + "<br />";
				var appraisedelm = $("#audSummaryAppraised").click(function(pEvent)
				{
					if (pEvent.which === I.ClickEnum.Left)
					{
						I.print(appraisedtip);
					}
				});
				var liquidelm = $("#audSummaryLiquid").click(function(pEvent)
				{
					if (pEvent.which === I.ClickEnum.Left)
					{
						I.print(liquidtip);
					}
				});
				
				// Show the summary box animated
				var animationspeed = 3000;
				summary.show("slow", function()
				{
					I.animateNumber(totalappraisedsell, function(pValue)
					{
						appraisedelm[0].innerHTML = E.formatCoinString(pValue, {aWantBig: true});
					}, animationspeed, "easeInOutQuart");
					I.animateNumber(totalliquidsell, function(pValue)
					{
						liquidelm[0].innerHTML = E.formatCoinString(pValue, {aWantBig: true});
					}, animationspeed, "easeInOutQuart");
					historycontainer.show();
					// Bind tooltip after the animation
					setTimeout(function()
					{
						I.qTip.init(appraisedelm.attr("title", appraisedtip));
						I.qTip.init(liquidelm.attr("title", liquidtip));
					}, animationspeed);
				});
				
				/*
				 * Load audit history and generate chart.
				 */
				var now = new Date();
				var histbook = O.loadCompressedObject(O.Utilities.AuditHistory.key) || {};
				var accname = A.Data.Account.oAccName;
				if (U.isObject(histbook[accname]) === false)
				{
					histbook[accname] = {};
				}
				var hist = {}; // New object so the variable order follows the template
				// Verify the account's audit history object
				for (var i in A.Currency.AuditHistory)
				{
					var histrow = (histbook[accname])[i];
					hist[i] = (histrow === undefined || Array.isArray(histrow) === false) ? [] : histrow;
				}
				// Each array's nth element are associated with a timestamp, so all arrays must be of the same length
				var audstamps = hist["Timestamps"];
				var historylength = audstamps.length;
				for (var i in hist)
				{
					if (hist[i].length < historylength)
					{
						var padarray = new Array(historylength - hist[i].length).fill(0);
						hist[i] = hist[i].concat(padarray);
					}
					// Shave the history if larger than limit
					if (historylength >= O.Options.int_numAuditReports)
					{
						hist[i] = hist[i].slice(1, O.Options.int_numAuditReports);
					}
					else if (hist[i].length > historylength)
					{
						hist[i] = hist[i].slice(0, historylength);
					}
				}
				// Append the new audit data to the history
				hist["Timestamps"].push(T.formatISO(now));
				hist["WalletCoin"].push(walletcat["coin_liquidsell"]);
				hist["WalletKarma"].push(walletcat["karma"]);
				hist["WalletGem"].push(walletcat["gem"]);
				hist["TotalGems"].push(totalgems);
				hist["TotalAppraisedSellNoGems"].push(totalappraisedsellnogems);
				hist["TotalLiquidSellNoGems"].push(totalliquidsellnogems);
				
				// Record only the coin currency of audit categories, or their converted sum if opted
				if (O.Options.bol_auditHistoryConverted)
				{
					for (var i in auditcats)
					{
						hist[i].push(convertcat[i]);
					}
				}
				else
				{
					for (var i in auditcats)
					{
						hist[i].push((auditcats[i])["coin_appraisedsell"]);
					}
				}
				// Save the audit history object
				histbook[accname] = hist;
				O.saveCompressedObject(O.Utilities.AuditHistory.key, histbook);
				
				// Draw the history chart
				A.initializeCharts(function()
				{
					historychart.highcharts("StockChart", {
						chart: {width: 720, height: 445},
						series: formatAuditHistory(hist),
						credits: {enabled: false},
						xAxis:
						{
							type: "datetime",
							ordinal: false,
							dateTimeLabelFormats: A.getChartsTimeFormat()
						},
						yAxis:
						{
							startOnTick: false,
							endOnTick: false,
							labels:
							{
								useHTML: true,
								formatter: function()
								{
									return E.formatCoinStringColored(this.value);
								}
							}
						},
						tooltip:
						{
							useHTML: true,
							formatter: function()
							{
								return A.getChartsCurrencyFormat(this.points, A.Currency.AuditColor);
							}
						}
					});
					var historybuttons = $("<div id='audHistoryButtons'></div>").appendTo(historycontainer);
					// Button to print this account's history
					$("<button class='accButton'>" + D.getPhraseOriginal("Print History") + "</button>").appendTo(historybuttons).click(function()
					{
						I.prettyJSON(hist);
					});
					// Button to print the entire history object
					$("<button class='accButton'>" + D.getPhraseOriginal("Print Storage") + "</button>").appendTo(historybuttons).click(function()
					{
						var history = O.loadCompressedObject(O.Utilities.AuditHistory.key);
						if (history)
						{
							try
							{
								I.prettyJSON(history);
							}
							catch (e) {}
						}
					});
					// Button to reformat the history to have unique dates only
					$("<button class='accButton'>" + D.getPhraseOriginal("Trim History") + "</button>").appendTo(historybuttons).click(function()
					{
						var audstamps = hist["Timestamps"];
						var historylength = audstamps.length;
						if (historylength > 1 && confirm("This will delete some of your history so there is one entry max per day. Continue?"))
						{
							var histnew = {}, uniquedates = {}, ithstamp;
							for (var i in A.Currency.AuditHistory)
							{
								histnew[i] = [];
							}
							for (var index = historylength - 1; index >= 0; index--) // Iterate backward so only the latest entry is saved
							{
								ithstamp = audstamps[index].split("T")[0]; // Get the date portion of the ISO time string
								if (ithstamp && uniquedates[ithstamp] === undefined)
								{
									uniquedates[ithstamp] = true;
									for (var i in A.Currency.AuditHistory)
									{
										histnew[i].unshift((hist[i])[index]);
									}
								}
							}
							hist = histnew;
							histbook[accname] = hist;
							O.saveCompressedObject(O.Utilities.AuditHistory.key, histbook);
						}
					});
					// Selection to delete an account in the history
					var searchdb = [];
					for (var i in histbook)
					{
						searchdb.push({name: i});
					}
					I.createSearchBar(historybuttons, {
						aIsSelect: true,
						aIsInline: true,
						aFillerText: D.getPhraseOriginal("Delete Storage"),
						aDatabase: searchdb,
						aCallback: function(pElm)
						{
							var acctodelete = pElm.name;
							if (confirm("Delete account " + acctodelete + " from audit storage?"))
							{
								if (histbook[acctodelete])
								{
									delete histbook[acctodelete];
									O.saveCompressedObject(O.Utilities.AuditHistory.key, histbook);
									I.write(acctodelete + " was deleted from the storage.");
								}
								else
								{
									I.write(acctodelete + " was already deleted or not found in history.");
								}
							}
						}
					});
					
					finalizeAutoAudit();
				});
			});
			
			// Debug buttons at the bottom
			var debug = $("<div id='audDebug'></div>").appendTo(container);
			$("<button class='accButton'>Print Possessions</button>").appendTo(debug).click(function()
			{
				I.prettyJSON(A.Possessions);
			});
			$("<button class='accButton'>Print Paylist</button>").appendTo(debug).click(function()
			{
				I.prettyJSON(E.Paylist);
			});
			$("<button class='accButton'>Print View</button>").appendTo(debug).click(function()
			{
				I.prettyJSON(categoriesview);
			});
			
			// Finalize elements
			I.scrollToElement("#accAuditCenter", {aSpeed: "fast"});
			I.suspendElement(button, false);
			buttonalt.show();
		};
		
		/*
		 * Audits the banks and unlocks after prices have been assigned.
		 */
		var executeAudit = function()
		{
			initializeAuditCategories();
			auditWallet();
			auditPossessions();
			auditUnlocks("Skins", false);
			auditUnlocks("Outfits");
			auditUnlocks("Gliders");
			auditUnlocks("Dyes");
			auditUnlocks("Minis");
			auditUnlocks("Carriers");
			auditUnlocks("Champions");
			auditUnlocks("Finishers");
			auditUnlocks("Nodes");
			auditUnlocks("Recipes");
			auditTransactions();
			generateResults();
		};
		
		// Sums the coin price of an item's ingredients to get the appraised value of the untradeable item
		var sumIngredients = function(pIngredients)
		{
			var sum = E.createPrice(), ingrprice;
			pIngredients.forEach(function(iIngr)
			{
				// Sum the ingredients' prices
				if (iIngr)
				{
					ingrprice = E.Paylist[iIngr[0]];
					if (ingrprice && E.isPriceObject(ingrprice))
					{
						sum = E.addPrice(sum, E.recountPrice(ingrprice, iIngr[1]));
					}
				}
			});
			return E.createPriceBound(sum);
		};
		
		// Updates the payment database with the appraised value of untradeable items
		var appraiseCraftable = function()
		{
			ascendedheader = U.getRecordHeader("ascended");
			ascendeddata = U.getRecordData("ascended");
			ascendedingr = auditmetadata.AscendedIngredients;
			compositeingr = auditmetadata.CompositeIngredients;
			
			// Ascended items
			var appraisal = {}, ascendedtype;
			for (var i in ascendedheader)
			{
				// If armor or weapon then append the ingredients for insignia or inscription
				ascendedtype = ascendedheader[i].type;
				ingredients = (ascendedtype === "Armor" || ascendedtype === "Weapon")
					? ascendedingr[i].concat(ascendedingr[ascendedtype]) : ascendedingr[i];
				appraisal[i] = sumIngredients(ingredients);
			}
			A.Tally.Ascended = {
				armorcount: 0,
				weaponcount: 0,
				price: E.createPrice()
			};
			// Items of an ascended category gets the same appraised value, except trinkets
			var count;
			A.iterateRecord(ascendeddata, function(pEntry, pCategory)
			{
				ascendedtype = ascendedheader[pCategory].type;
				if (ascendedtype !== "Trinket")
				{
					E.Paylist[pEntry.i] = appraisal[pCategory];
					// Also count the number of ascended armor and weapons pieces
					if (A.Possessions[pEntry.i])
					{
						count = A.Possessions[pEntry.i].oCount;
						if (ascendedtype === "Armor")
						{
							A.Tally.Ascended.armorcount += count;
						}
						else if (ascendedtype === "Weapon")
						{
							A.Tally.Ascended.weaponcount += count;
						}
						// Sum the prices of all non-trinket ascended items
						A.Tally.Ascended.price = E.addPrice(A.Tally.Ascended.price, E.recountPrice(appraisal[pCategory], count));
					}
				}
			});
			
			// Crafted, forged, or combined items from other ingredient items
			for (var i in compositeingr)
			{
				E.Paylist[i] = sumIngredients(compositeingr[i]);
			}
		};
		
		// Scans an unlockables record and updates the payment database with applicable payments
		var insertPaymentsFromRecord = function(pName, pIsPossessions)
		{
			var record = recordsdata[pName];
			A.iterateRecord(record, function(pEntry)
			{
				if (pEntry.p)
				{
					for (var i in pEntry.p)
					{
						// Update payment database item if the payment type is applicable
						if (auditpayments[i] || pEntry.p.coin)
						{
							E.Paylist[pEntry.i] = (pEntry.p.coin) ? E.createPriceBound(pEntry.p.coin) : pEntry.p;
						}
					}
				}
				else if (pIsPossessions)
				{
					// For possessions, bound items that came from a tradeable container item will have this property, so copy the price
					if (pEntry.u && E.Paylist[pEntry.u])
					{
						E.Paylist[pEntry.i] = E.createPriceBound(E.Paylist[pEntry.u]);
					}
				}
			});
		};
		
		/*
		 * Begins downloading of numerous uncached prices and defines the payment
		 * database, the order of insertion will affect override of item payments.
		 */
		var fetchPrices = function()
		{
			I.print(D.getPhraseOriginal("Loading trading price") + "...");
			E.getPrices(U.convertAssocToArray(priceids), function(pPriceDB)
			{
				// Insert cached Trading Post prices
				var boundpayments = auditmetadata.BoundPayments;
				for (var i in cachedprices)
				{
					E.Paylist[i] = E.processPrice(cachedprices[i]);
				}
				// Insert fresh Trading Post prices
				if (pPriceDB)
				{
					for (var i in pPriceDB)
					{
						E.Paylist[i] = pPriceDB[i];
					}
				}
				// Insert audit metadata untradeable item prices
				for (var i in boundpayments)
				{
					if (boundpayments[i].coin)
					{
						E.Paylist[i] = E.createPricePlain(boundpayments[i].coin);
					}
					else
					{
						for (var ii in boundpayments[i])
						{
							E.Paylist[i] = {};
							(E.Paylist[i])[ii] = (boundpayments[i])[ii];
						}
					}
				}
				
				// Insert junk rarity item prices
				for (var i in auditmetadata.JunkValue)
				{
					E.Paylist[i] = E.createPricePlain(auditmetadata.JunkValue[i]);
				}
				// Insert ascended payments
				insertPaymentsFromRecord("Ascended", true);
				// Insert untradeable crafted or forged item prices
				appraiseCraftable();
				// Insert untradeable catalog item payments
				insertPaymentsFromRecord("Catalog", true);
				// Insert armors, weapons, backpacks item payments
				insertPaymentsFromRecord("Skins");
				// Insert outfits item payments
				insertPaymentsFromRecord("Outfits");
				// Insert gliders item payments
				insertPaymentsFromRecord("Gliders");
				// Insert minis item payments
				insertPaymentsFromRecord("Minis");
				// Insert mail carriers item payments
				insertPaymentsFromRecord("Carriers");
				// Insert mists champions item payments
				insertPaymentsFromRecord("Champions");
				// Insert finisher item payments
				insertPaymentsFromRecord("Finishers");
				// Insert home instance node item payments
				insertPaymentsFromRecord("Nodes");
				// Begin auditing
				executeAudit();
			});
		};
		
		/*
		 * Readies the IDs of possessions and priority items to retrieve live TP prices.
		 */
		var initializePrices = function()
		{
			// Load the cached prices
			I.print(D.getPhraseOriginal("Loading info price") + "...");
			$.getJSON(U.URL_DATA.Prices, function(pPriceDB)
			{
				cachedprices = pPriceDB["data"];
				untradeabledb = pPriceDB["blacklist"];
				// Include owned items in the list of prices to fetch, if it is not already cached and is tradeable
				for (var i in A.Possessions)
				{
					if (cachedprices[i] === undefined && untradeabledb[i] === undefined)
					{
						priceids[i] = true;
					}
				}
				// Include barter items for currencies conversion into coin
				var conversion;
				for (var i in auditpayments)
				{
					conversion = auditpayments[i].conversion;
					if (Array.isArray(conversion) && auditpayments[i].isbound !== true)
					{
						priceids[(conversion[1])] = true;
					}
				}
				// Include items that require fresh uncached prices
				auditmetadata = U.getRecordMetadata("ascended");
				auditmetadata.PriorityTradeable.forEach(function(iID)
				{
					priceids[iID] = true;
				});
				// Load unbought and unsold items in the account's Trading Post
				if (O.Options.bol_auditTransactions === false)
				{
					fetchPrices();
					return;
				}
				I.print(D.getPhraseOriginal("Loading buying transactions") + "...");
				A.getTransactions(A.URL.CurrentBuys, {
					aCallback: function(pDataBuys)
					{
						I.print(D.getPhraseOriginal("Loading selling transactions") + "...");
						A.getTransactions(A.URL.CurrentSells, {
							aCallback: function(pDataSells)
							{
								// Include existing TP items in the price list
								if (pDataBuys && pDataBuys.length)
								{
									currentbuysdata = pDataBuys;
									pDataBuys.forEach(function(iTransaction)
									{
										priceids[iTransaction.item_id] = true;
									});
								}
								if (pDataSells && pDataSells.length)
								{
									currentsellsdata = pDataSells;
									pDataSells.forEach(function(iTransaction)
									{
										priceids[iTransaction.item_id] = true;
									});
								}
								fetchPrices();
							},
							aError: function()
							{
								fetchPrices();
							}
						});
					},
					aError: function()
					{
						fetchPrices();
					}
				});
			});
		};
		
		/*
		 * Loads all the unlockables record files to get their item payments.
		 */
		var loadRecords = function()
		{
			var numfetched = 0;
			var numtofetch = U.getObjectLength(recordsdata);
			for (var i in recordsdata)
			{
				I.print(D.getPhraseOriginal("Loading info " + i.toLowerCase()) + "...");
				(function(iName)
				{
					U.getScript(U.URL_DATA[iName], function()
					{
						recordsdata[iName] = U.getRecordData(iName);
						numfetched++;
						if (numfetched === numtofetch)
						{
							initializePrices();
						}
					}).fail(function()
					{
						I.print("Failed to load " + iName + " record file. Auditing aborted.");
						dealError();
					});
				})(i);
			}
		};
		
		/*
		 * Retrieves account unlocks.
		 */
		var fetchUnlocks = function()
		{
			var numfetched = 0;
			var numtofetch = U.getObjectLength(unlocksdata);
			for (var i in unlocksdata)
			{
				I.print(D.getPhraseOriginal("Loading account " + i.toLowerCase()) + "...");
				(function(iName)
				{
					$.getJSON(A.getURL(A.URL[iName]), function(pData)
					{
						unlocksdata[iName] = pData;
					}).done(function()
					{
						numfetched++;
						if (numfetched === numtofetch)
						{
							loadRecords();
						}
					}).fail(function()
					{
						I.print("Failed to retrieve " + iName + " account unlocks. Auditing aborted.<br />Please check account permissions.");
						dealError();
					});
				})(i);
			}
		};
		
		// Load the bank, inventory, equipment, materials, vaults
		I.clear();
		I.print(D.getPhraseOriginal("Loading account bank materials inventory") + "...");
		A.initializePossessions(function()
		{
			fetchUnlocks();
		}, O.Options.bol_auditVault);
	}
};
V = {
/* =============================================================================
 * @@View and generate account character and bank sections
 * ========================================================================== */
	
	/*
	 * Rearranges all the characters columns based on one column's data values.
	 * @param string pClassifier class names of data containing cells.
	 * @param boolean pOrder descending if true, ascending if false.
	 */
	sortCharacters: function(pClassifier, pOrder)
	{
		var sortable = [];
		$("." + pClassifier).each(function()
		{
			sortable.push({
				// Get the index from the list item containing the value
				index: U.getSubintegerFromHTMLID($(this).parent()),
				value: parseInt($(this).attr("data-value"))
			});
		});
		U.sortObjects(sortable, {aKeyName: "value", aIsDescending: pOrder});
		
		// Sort all the rows using the new order
		for (var i = 0; i < sortable.length; i++)
		{
			var index = sortable[i].index;
			$("#chrSelection_" + index).appendTo("#chrSelection");
			$("#chrUsage_" + index).appendTo("#chrUsage");
			$("#chrSeniority_" + index).appendTo("#chrSeniority");
		}
	},
	
	/*
	 * Initializes the account audit subsection of the characters page.
	 */
	serveAudit: function()
	{
		$("#accAuditContainer").show("fast");
		// Audit option
		$("#accAuditTop").append(
			"<label><input id='audWantTransactions' type='checkbox' /> " + D.getPhraseOriginal("Include current trading transactions") + ".</label><br />"
			+ "<label><input id='audWantVaults' type='checkbox' /> " + D.getPhraseOriginal("Include guilds vault") + ".</label><br />"
			+ "<label><input id='audWantAutomatic' type='checkbox' /> " + D.getPhraseOriginal("Automatic daily audit") + ".</label><br />"
			+ "<label><input id='audWantConverted' type='checkbox' /> " + D.getPhraseOriginal("Convert currencies in history") + ".</label>"
		);
		O.mimicInput("#audWantTransactions", "bol_auditTransactions");
		O.mimicInput("#audWantVaults", "bol_auditVault");
		O.mimicInput("#audWantAutomatic", "bol_auditAccountOnReset");
		O.mimicInput("#audWantConverted", "bol_auditHistoryConverted");
		X.rewrapCheckboxes();
		// Audit buttons
		var buttoncontainer = $("#accAuditCenter");
		var executebtn = $("<button id='audExecute'>" + D.getPhraseOriginal("Audit Account") + "</button>")
			.appendTo(buttoncontainer).click(function()
		{
			A.generateAudit();
		});
		$("<button id='audHelp'>" + D.getWordCapital("help") + "</button>")
			.appendTo(buttoncontainer).click(function()
		{
			if (I.isConsoleShown() === false)
			{
				I.help($("#accHelpAudit").html());
			}
		});
		// Alternate button up top
		var executebtnalt = $("<button id='audExecuteAlternate' title='<dfn>Audit</dfn> account.<br />gw2timer.com/audit'> "
			+ "<img src='img/ui/stats.png' /></button>").insertAfter("#chrAccountReload").click(function()
		{
			$(this).hide();
			executebtn.trigger("click");
		});
		I.qTip.init("#audExecuteAlternate");
		
		// Scroll to execute button if requested by URL
		A.isAuditReady = true;
		V.attemptAudit();
	},
	attemptAudit: function()
	{
		if (A.isAuditReady)
		{
			U.verifyArticle(I.SpecialPageEnum.Audit, function()
			{
				$("#audExecute").trigger("click");
			}, true);
		}
		U.nullifyArticle();
	},
	
	/*
	 * Initializes the characters subpage.
	 * @param string pSection to open after finishing loading characters.
	 */
	serveCharacters: function(pSection)
	{
		// Don't retrieve if already did
		var dish = $("#accDish_Characters");
		if (A.reinitializeDish(dish) === false)
		{
			V.attemptAudit();
			return;
		}
		var chardependentmenu = $(".accCharDependentMenu");
		
		A.Possessions = null;
		dish.html("<div id='chrSummary'></div>"
		+ "<div id='chrStatistics' class='cssStats'>"
			+ "<ul id='chrSelection'></ul>"
			+ "<ul id='chrUsage' class='chrStats'></ul>"
			+ "<ul id='chrSeniority' class='chrStats'></ul>"
			+ "<ul id='chrGuilds' class='chrStats'></ul>"
		+ "</div>"
		+ "<div id='accAuditContainer'>"
			+ "<div id='audSeparatorTop' class='accSeparator'></div>"
			+ "<div id='accAuditTop' class='accComposition'></div>"
			+ "<div id='accAuditCenter'></div>"
			+ "<div id='accAudit'></div>"
		+ "</div>");
		$(".chrWallet").remove();
		$(".chrStats").hide();
		I.suspendElement(chardependentmenu);
		dish.prepend(I.cThrobber);
		
		// Retrieve characters data
		U.getJSON(A.getURLAll(A.URL.Characters), function(pData)
		{
			A.wipeDish("Hero");
			I.removeThrobber(dish);
			A.adjustAccountScrollbar();
			A.isCharactersCached = true;
			
			// Reset variables
			var numcharacters = pData.length;
			A.initializeAccountUpgrades();
			A.assignAccountUpgrades("CharacterSlot", numcharacters);
			A.Data.CharacterNames = [];
			A.CharIndexCurrent = null;
			A.Data.Characters = null;
			A.Data.Characters = new Array(numcharacters);
			A.Data.CharacterAssoc = {};
			var charindex = 0;
			pData.forEach(function(iCharData)
			{
				A.Data.CharacterNames.push(iCharData.name);
				$("#chrSelection").append("<li id='chrSelection_" + charindex + "' class='chrSelection curClick'></li>");
				$("#chrUsage").append("<li id='chrUsage_" + charindex + "'></li>");
				$("#chrSeniority").append("<li id='chrSeniority_" + charindex + "'></li>");
				// Add extra or preformatted properties 
				A.Data.Characters[charindex] = iCharData;
				A.Data.Characters[charindex].oCharIndex = charindex;
				A.Data.Characters[charindex].oCharName = U.escapeHTML(iCharData.name);
				A.Data.CharacterAssoc[iCharData.name] = charindex;
				V.generateCharactersSelection(iCharData);
				charindex++;
			});
			I.suspendElement(chardependentmenu, false);
			V.generateCharactersStatistics();
			if (pSection)
			{
				$("#accMenu_" + pSection).trigger("click");
			}
		}, A.isCharactersCached).fail(function(pRequest, pStatus)
		{
			I.removeThrobber(dish);
			A.printError(A.PermissionEnum.Characters, pStatus);
		});
	},
	
	/*
	 * Generates a row in the first column showing common information about a character.
	 * @param object pCharacter characters data.
	 */
	generateCharactersSelection: function(pCharacter)
	{
		// Initializes common character values to reused later
		var icon = (pCharacter.profession).toLowerCase();
		pCharacter.oCharElite = icon;
		pCharacter.oCharProfession = icon;
		pCharacter.oCharColor = A.Metadata.Profession[icon].color;
		pCharacter.oCharIsLowLevel = (pCharacter.level < Q.GameLimit.LevelMax);
		if (pCharacter.specializations && pCharacter.specializations.pve)
		{
			var specs = pCharacter.specializations.pve;
			for (var i = 0; i < specs.length; i++)
			{
				if (specs[i])
				{
					// If one of the character's specs is found to be in the elite spec
					var specid = specs[i].id;
					if (A.Metadata.ProfElite[specid] !== undefined)
					{
						icon = A.Metadata.ProfElite[specid];
						pCharacter.oCharElite = icon; // Remember the icon
						break;
					}
				}
			}
		}
		
		// Get active crafting disciplines
		var craftused = "";
		var crafttooltip = "";
		if (pCharacter.crafting && pCharacter.crafting.length > 0)
		{
			pCharacter.oCharCraft = {};
			pCharacter.crafting.forEach(function(iCraft)
			{
				var trivial = (iCraft.rating >= A.Metadata.CraftingRank.Master) ? "" : "accTrivial";
				var craftstr = "<b class='" + trivial + "'><ins class='acc_craft acc_craft_" + (iCraft.discipline).toLowerCase() + "'></ins>"
					+ "<sup class='chrCraftingRating'>" + iCraft.rating + "</sup></b> ";
				if (iCraft.active)
				{
					craftused += craftstr;
					pCharacter.oCharCraft[iCraft.discipline] = iCraft.rating;
				}
				crafttooltip += craftstr + " ";
			});
		}
		
		// SELECTION COLUMN (left)
		var charvalue = A.Metadata.Race[(pCharacter.race).toLowerCase() + "_" + (pCharacter.gender).toLowerCase()] || 1;
		var professionvalue = (A.Metadata.Profession[(pCharacter.profession).toLowerCase()]).weight;
		var trivial = (pCharacter.oCharIsLowLevel) ? "accTrivial" : "";
		// Remember character portrait
		pCharacter.oCharPortrait = "img/account/characters/" + (pCharacter.race).toLowerCase() + "_" + (pCharacter.gender).toLowerCase() + I.cPNG;
		// Create character name row that leads to its hero page
		$("#chrSelection_" + pCharacter.oCharIndex).append(
			"<img id='chrPortrait_" + pCharacter.oCharIndex + "' class='chrPortrait' src='" + pCharacter.oCharPortrait + "' />"
			+ "<var id='chrName_" + pCharacter.oCharIndex + "' class='chrName' data-value='" + charvalue + "'>" + pCharacter.oCharName + "</var>"
			+ "<span class='chrCommitment' data-value='" + professionvalue + "'>"
				+ "<var class='chrProfession " + trivial + "'>"
					+ "<ins class='chrProfessionIcon acc_prof acc_prof_" + icon + "'></ins><sup>" + pCharacter.level + "</sup></var>"
				+ "<var class='chrCrafting'>" + craftused + "</var>"
			+ "</span>"
			+ "<img class='chrProceed' src='img/ui/view.png' />")
		.click(function()
		{
			var charindex = U.getSubintegerFromHTMLID($(this));
			if (A.CharIndexCurrent === charindex)
			{
				A.CharIndexCurrent = null;
				$(this).find(".chrProceed").animate({rotation: 0}, {duration: 200, queue: false});
				$(this).removeClass("chrSelected");
			}
			else
			{
				A.CharIndexCurrent = charindex;
				$(".chrProceed").animate({rotation: 0}, {duration: 200, queue: false});
				$(this).find(".chrProceed").animate({rotation: T.cCIRCLE_RIGHT_DEGREE}, {duration: 200, queue: false});
				$(".chrSelection").removeClass("chrSelected");
				$(this).addClass("chrSelected");
				$("#accMenu_Hero").trigger("click");
				A.adjustAccountScrollbar();
			}
		});
		// Mini portrait can be clicked to print raw data
		$("#chrPortrait_" + pCharacter.oCharIndex).click(function(pEvent)
		{
			pEvent.stopPropagation();
			var charindex = U.getSubintegerFromHTMLID($(this));
			I.prettyJSON(A.Data.Characters[charindex]);
		});
		// Remember HTML containing the character's portrait, profession icon, and name, to be used in bank tab headers
		var prefacecontent = "<img class='chrPrefaceIcon' src='" + pCharacter.oCharPortrait + "' />"
			+ "<ins class='acc_prof acc_prof_" + pCharacter.oCharElite + " " + trivial + "'></ins>";
		pCharacter.oCharPreface = "<span class='chrPreface'>" + prefacecontent + pCharacter.oCharName + "</span>";
		pCharacter.oCharIcons = "<span class='chrPreface' title='" + pCharacter.oCharName + "'>" + prefacecontent + "</span>";
		// Additional information as tooltip
		I.qTip.init($("#chrSelection_" + pCharacter.oCharIndex).find(".chrCommitment").attr("title", crafttooltip));
	},
	
	/*
	 * Generates the columns for presenting the character's data values.
	 */
	generateCharactersStatistics: function()
	{
		var now = new Date();
		var nowmsec = now.getTime();
		var hourstr = D.getWord("h");
		var daystr = D.getWord("d");
		var yearstr = D.getWord("y");
		var highestage = 0;
		var highestdeaths = 0;
		var highestlifetime = 0;
		var totalage = 0;
		var totaldeaths = 0;
		
		var getWvWTitle = function(pRank)
		{
			var rankobj = A.Metadata.WvWRank;
			var ranks = rankobj.Ranks;
			var wvwtitle = "", wvwtitletip = "", wvwtitlenext = "";
			var titleindex, modifierindex;
			var length = ranks.length;
			for (var i = 0; i < length; i++)
			{
				if (ranks[i] > pRank)
				{
					// Current rank
					titleindex = (i-1) % rankobj.RanksPerModifier;
					modifierindex = ~~((i-1) / rankobj.RanksPerModifier);
					wvwtitle = D.orderModifier(
						D.getObjectTranslation(rankobj.Titles[titleindex]),
						D.getObjectTranslation(rankobj.Modifiers[modifierindex])
					);
					// Next rank
					if (i < length)
					{
						titleindex = i % rankobj.RanksPerModifier;
						modifierindex = ~~(i / rankobj.RanksPerModifier);
						wvwtitlenext = D.orderModifier(
							D.getObjectTranslation(rankobj.Titles[titleindex]),
							D.getObjectTranslation(rankobj.Modifiers[modifierindex])
						);
						wvwtitletip = pRank + " + " + (ranks[i] - pRank) + "<img src=\"img/account/summary/worldabilitypoint.png\" />" + " = " + wvwtitlenext;
					}
					break;
				}
			}
			// Max rank case
			if (pRank >= ranks[length - 1])
			{
				wvwtitle = D.orderModifier(
					D.getObjectTranslation(rankobj.Titles[rankobj.Titles.length - 1]),
					D.getObjectTranslation(rankobj.Modifiers[rankobj.Modifiers.length - 1])
				);
			}
			return "<var id='chrAccountWvWRank' title='" + wvwtitletip + "'>" + wvwtitle + "</var>";
		};
		
		// First loop to find max values for age and deaths
		A.Data.Characters.forEach(function(iChar)
		{
			if (highestage < iChar.age)
			{
				highestage = iChar.age;
			}
			if (highestdeaths < iChar.deaths)
			{
				highestdeaths = iChar.deaths;
			}
			iChar.oCharLifetime = ~~((nowmsec - (new Date(iChar.created)).getTime()) / T.cMSECONDS_IN_SECOND);
			if (highestlifetime < iChar.oCharLifetime)
			{
				highestlifetime = iChar.oCharLifetime;
			}
		});
		// Write a row for each character
		A.Data.Characters.forEach(function(iChar)
		{
			var name = "<abbr>" + iChar.oCharName + "</abbr>";
			// USAGE COLUMN (middle)
			totalage += iChar.age; // Seconds
			totaldeaths += iChar.deaths;
			var age = Math.round(iChar.age / T.cSECONDS_IN_HOUR);
			var agepercent = (iChar.age / highestage) * T.cPERCENT_100;
			var deathpercent = (iChar.deaths / highestdeaths) * T.cPERCENT_100;
			var usage = "<var class='chrAge' title='" + T.formatTimeLetter(iChar.age) + "' data-value='" + age + "'>" + age + hourstr + "</var>"
				+ "<span class='chrHoverName'>" + name + I.getBar(agepercent, true) + I.getBar(deathpercent) + "</span>"
				+ "<var class='chrDeaths' title='" + T.parseRatio(iChar.deaths / age, 2) + "x / " + "1" + hourstr + "' data-value='" + iChar.deaths + "'>" + iChar.deaths + "x</var>";
			$("#chrUsage_" + iChar.oCharIndex).append(usage);
			// SENIORITY COLUMN (right)
			var birthdate = (new Date(iChar.created)).toLocaleString();
			var birthdays = ~~(iChar.oCharLifetime / T.cSECONDS_IN_YEAR);
			var lifetime = ~~(iChar.oCharLifetime / T.cSECONDS_IN_DAY);
			var lifetimepercent = (iChar.oCharLifetime / highestlifetime) * T.cPERCENT_100;
			var birthdaysince = ~~((iChar.oCharLifetime % T.cSECONDS_IN_YEAR) / T.cSECONDS_IN_DAY);
			var birthdaytill = T.cDAYS_IN_YEAR - birthdaysince;
			var birthdaypercent = (birthdaysince / T.cDAYS_IN_YEAR) * T.cPERCENT_100;
			var seniority = "<var class='chrLifetime' title='" + T.formatTimeLetter(iChar.oCharLifetime) + "' data-value='" + iChar.oCharLifetime + "'>"
					+ lifetime + daystr + " (" + birthdays + yearstr + ")</var>"
				+ "<span class='chrHoverName'>" + name + I.getBar(lifetimepercent, true) + I.getBar(birthdaypercent) + "</span>"
				+ "<var class='chrBirthday' title='" + T.formatTimeLetter(birthdaytill * T.cSECONDS_IN_DAY) + "' data-value='" + birthdaysince + "'>" + birthdaytill + daystr + "</var>"
				+ "<var class='chrBirthdate'>" + birthdate + "</var>";
			$("#chrSeniority_" + iChar.oCharIndex).append(seniority);
		});
		// Highlight the character's name when hovered over a statistics row
		$(".chrStats li").hover(
			function() { $("#chrSelection_" + U.getSubstringFromHTMLID($(this))).css({outline: "1px solid red"}); },
			function() { $("#chrSelection_" + U.getSubstringFromHTMLID($(this))).css({outline: "none"}); }
		);
		// Insert header above the columns
		var sym = " <b class='jsSortableHeaderSymbol'>" + I.Symbol.TriDown + "</b>";
		$("#chrSelection").prepend("<li class='chrHeader'><var class='chrHeaderLeft curClick' data-classifier='chrName'>"
			+ A.Data.Characters.length + " "
			+ D.getWordCapital("characters") + sym + "</var><var class='chrHeaderRight curClick' data-classifier='chrCommitment'>"
			+ D.getWordCapital("profession") + sym + "</var></li>");
		$("#chrUsage").prepend("<li class='chrHeader'><var class='chrHeaderLeft curClick' data-classifier='chrAge'>"
			+ D.getWordCapital("age") + sym + "</var><var class='chrHeaderRight curClick' data-classifier='chrDeaths'>"
			+ D.getWordCapital("deaths") + sym + "</var></li>");
		$("#chrSeniority").prepend("<li class='chrHeader'><var class='chrHeaderLeft curClick' data-classifier='chrLifetime'>"
			+ D.getWordCapital("lifetime") + sym + "</var><var class='chrHeaderRight curClick' data-classifier='chrBirthday'>"
			+ D.getWordCapital("birthday") + sym + "</var></li>");
		// Header click to sort the columns
		$(".chrHeaderLeft, .chrHeaderRight").click(function()
		{
			I.toggleSortableHeader($(this));
			V.sortCharacters($(this).attr("data-classifier"), $(this).data("isdescending"));
		});
		// SUMMARY MARQUEE (top)
		$.getJSON(A.getURL(A.URL.Account), function(pData)
		{
			A.Data.Account = pData;
			A.Data.Account.oAccName = U.escapeHTML(pData.name);
			A.Data.Account.oAccNick = A.Data.Account.oAccName.split(".")[0]; // Omit the identifier number from the account name
			var forumlink = U.convertPrivateAnchor("https://forum-en.guildwars2.com/members/" + pData.name.replace(/[\s\.]/g, "-") + "/showposts");
			var totalagehour = Math.round(totalage / T.cSECONDS_IN_HOUR);
			var accountbirthdate = new Date(pData.created);
			var accountlifetime = ~~((nowmsec - accountbirthdate.getTime()) / T.cMSECONDS_IN_SECOND);
			var accountbirthdaysince = T.formatTimeLetter(accountlifetime).trim();
			var hoursperday = T.parseRatio((totalage / accountlifetime) * T.cHOURS_IN_DAY, 2);
			var commandership = (pData.commander) ? "" : "accTrivial";
			var wvwtitle = (pData.wvw_rank) ? (" " + getWvWTitle(pData.wvw_rank)) : "";
			var access = (pData.access) ? "" : "accTrivial";
			var accountadditional = "<span id='chrAccountMisc'>"
				+ "<dfn><a id='chrAccountLink' title='" + U.escapeHTML(pData.id) + "'" + forumlink + ">" + U.escapeHTML(pData.name) + "</a></dfn><br />" + accountbirthdate.toLocaleString() + "<br />"
				+ "<img class='" + commandership +  "' src='img/account/summary/commander.png' />"
				+ "<img class='" + access +  "' src='img/account/summary/access_hot.png' /> "
				+ "<img src='img/account/summary/fractal.png' />" + (pData.fractal_level || "?") + " "
				+ "<img src='img/account/summary/worldabilitypoint.png' />" + (pData.wvw_rank || "?") + " "
				+ "<img src='img/account/summary/daily.png' />" + (pData.daily_ap || "?") + " "
				+ "<img src='img/account/summary/monthly.png' />" + (pData.monthly_ap || "?")
			+ "</span><br />";
			var summary = "<var id='chrAccountName'>" + A.Data.Account.oAccNick + "</var>"
				+ accountadditional
				+ "<var id='chrAccountServer'></var>" + wvwtitle + "<br />"
				+ "<var id='chrAccountAge' title='" + hoursperday + hourstr + " / " + T.cHOURS_IN_DAY + hourstr + "<br />"
						+ T.formatTimeLetter(totalage) + " / " + accountbirthdaysince + "'>" + totalagehour + hourstr + "</var> / "
					+ "<var id='chrAccountDeaths' title='" + T.parseRatio(totaldeaths / totalagehour, 2) + "x / " + "1" + hourstr + "'>" + totaldeaths + "x</var> &nbsp; "
					+ "<var id='chrAccountLifetime'>" + accountbirthdaysince +  "</var>"
					+ " &nbsp; <span id='chrAccountTitles'></span> &nbsp; "
					+ "<button id='chrAccountReload' title='<dfn>Reload</dfn> characters data (statistics, equipment, inventory).'><img src='img/ui/refresh.png' /></button>";
			$("#chrSummary").append(summary);
			I.qTip.init("#chrSummary var, #chrAccountReload");
			// Account reload button
			$("#chrAccountReload").click(function()
			{
				// Wipe previous sections that use characters data
				A.isCharactersCached = false;
				$(".accCharDependent").each(function()
				{
					A.wipeDish($(this).attr("data-section"));
				});
				I.qTip.hide();
				A.regenerateDish("Characters");
			});
			// Insert server name
			$.getJSON(U.URL_API.Worlds + pData.world, function(pDataInner)
			{
				if (Array.isArray(pDataInner) && pDataInner.length > 0)
				{
					$("#chrAccountServer").text(pDataInner[0].name);
				}
			});
			// Retrieve and insert guilds
			A.initializeGuilds(function()
			{
				// Guild tag next to each character's name
				var guildids = pData.guilds;
				A.Data.Characters.forEach(function(iChar)
				{
					if (iChar.guild)
					{
						var guild = Q.getCachedGuild(iChar.guild);
						if (guild)
						{
							$("#chrName_" + iChar.oCharIndex).append("<sup class='chrTag'>[" + guild.tag + "]" + "</sup>");
						}
					}
				});

				var guildheader = "<li class='chrHeader'><var class='chrHeaderLeft'>" + D.getWordCapital("guilds") + "</var></li>";
				$("#chrGuilds").append(guildheader);
				for (var i in guildids)
				{
					var guild = Q.getCachedGuild(guildids[i]);
					if (guild)
					{
						(function(iGuild)
						{
							var banner = U.getGuildBannerRaw(iGuild);
							var guildrow = $("<li class='chrGuild'><span class='chrGuildHover'><img class='chrGuildBanner' src='" + banner + "' />"
									+ "<img class='chrGuildBanner chrGuildBannerLarge' src='" + banner + "' /></span>"
								+ "<var class='chrGuildName'>" + iGuild.name + " " + iGuild.oTag + "</var></li>").click(function()
								{
									I.prettyJSON(iGuild);
								});
							$("#chrGuilds").append(guildrow);
						})(guild);
					}
				}
			});
			V.initializeWallet();
			V.initializeTitles();
			
			// Finally show the summary
			$("#chrSummary").show("fast");
		});
		
		// Finally
		I.qTip.init("#accPlatterCharacters var");
		$(".chrStats").show("fast");
	},
	
	/*
	 * Initializes the wallet object and generate columns (categorized wallets) for currencies.
	 */
	initializeWallet: function()
	{
		var generateWallet = function(pWallet, pName)
		{
			// Prepare HTML
			var wallet = $("<ul id='chrWallet_" + pName + "' class='chrStats chrWallet'></ul>").insertBefore("#chrGuilds");
			var header = "";
			switch (pName)
			{
				case "General": header = D.getModifiedWord("currencies", "general", U.CaseEnum.Every); break;
				case "Dungeon": header = D.getModifiedWord("tokens", "dungeon", U.CaseEnum.Every); break;
				case "Map": header = D.getModifiedWord("tokens", "map", U.CaseEnum.Every); break;
			}
			wallet.append("<li class='chrHeader'><var class='chrHeaderLeft curClick'>" + header + "</var></li>");
			I.bindSortableTable(wallet, {aIsList: true});
			
			// First loop to find max value of the wallet
			var currency, value, amount, coef, amountstr;
			for (var i = 0; i < pWallet.length; i++)
			{
				currency = pWallet[i];
				amount = A.Data.Wallet[currency.id];
				amount = (amount === undefined || amount === null) ? 0 : amount;
				coef = currency.coefficient;
				
				// Adjust the value so the currencies can be compared
				currency.value = (coef === "gem") ? E.convertGemToCoin(amount)
					: ((coef === undefined) ? amount : (amount * coef));
				
				// Insert wallet currency into accessible associative array
				if (currency.payment)
				{
					A.Currency.AuditWallet[currency.id] = currency;
				}
			}
			var max = T.getMinMax(pWallet, "value").oMax;
			
			// Generate the currencies for this wallet
			for (var i = 0; i < pWallet.length; i++)
			{
				currency = pWallet[i];
				amount = A.Data.Wallet[currency.id];
				amount = (amount === undefined || amount === null) ? 0 : amount;
				amountstr = amount.toLocaleString();
				value = currency.value;
				switch (currency.id)
				{
					case 1: amountstr = E.formatCoinStringColored(amount); break;
					case 2: amountstr = E.formatKarmaString(amount, true); break;
					case 3: amountstr = E.formatLaurelString(amount, true); break;
					case 4: amountstr = E.formatGemString(amount, true); break;
				}

				var percent = (value / max) * T.cPERCENT_100;
				var link = U.getWikiLinkDefault(D.getObjectDefaultName(currency));
				wallet.append("<li data-value='" + value + "'>"
					+ "<var class='chrWalletAmount'>" + amountstr + "</var>"
					+ "<ins class='acc_wallet acc_wallet_" + currency.id + "'></ins>"
					+ "<var class='chrWalletCurrency'><a class='chrWalletLink'" + U.convertExternalAnchor(link) + ">" + D.getObjectName(currency) + "</a></var>"
					+ I.getBar(percent)
				+ "</li>");
			}
		};
		
		$.getJSON(A.getURL(A.URL.Wallet), function(pData)
		{
			E.updateExchangeRatios(function() // For the gem conversion
			{
				A.Data.Wallet = null;
				A.Data.Wallet = {};
				// Convert the API array of currency objects into an associative array of currency IDs and values
				for (var i = 0; i < pData.length; i++)
				{
					var currency = pData[i];
					A.Data.Wallet[currency.id] = parseInt(currency.value);
				}

				var wallets = A.Currency.Wallet;
				for (var i in wallets)
				{
					generateWallet(wallets[i], i);
				}
				// Show the audit button now that wallet is loaded
				V.serveAudit();
			});
		}).fail(function()
		{
			// Cannot audit without wallet
			U.nullifyArticle();
		});
	},
	
	/*
	 * Retrieves account's acquired titles and assign them to each character.
	 */
	initializeTitles: function()
	{
		var generateTitles = function()
		{
			// Add a title as a tooltip for each character's selection line
			var usedtitles = {};
			A.Data.Characters.forEach(function(iChar)
			{
				var titleid = iChar.title;
				if (titleid)
				{
					if (usedtitles[titleid] === undefined)
					{
						usedtitles[titleid] = 0;
					}
					usedtitles[titleid] += 1;
					var title = Q.getBoxedTitle(titleid).oData;
					I.qTip.init($("#chrSelection_" + iChar.oCharIndex).attr("title", "&quot;<dfn>" + title.name + "</dfn>&quot;"));
				}
			});
			
			// List all unlocked titles as a dropdown menu
			var searchdb = [];
			for (var i in A.Data.Titles)
			{
				var box = Q.getBoxedTitle(i);
				if (box)
				{
					var title = box.oData;
					// Also append a count next to used titles
					var count = ((usedtitles[title.id]) ? "(" + usedtitles[title.id] + ") " : "");
					searchdb.push({
						name: count + title.name,
						wiki: U.getWikiLinkLanguage(title.name)
					});
				}
			}
			I.createSearchBar("#chrAccountTitles", {
				aIsSelect: true,
				aIsInline: true,
				aFillerText: searchdb.length + " " + D.getPhraseOriginal("Titles Unlocked"),
				aDatabase: searchdb,
				aCallback: function(aTitle)
				{
					U.openExternalURL(aTitle.wiki);
				}
			});
		};
		
		// Get account title unlocks
		$.getJSON(A.getURL(A.URL.Titles), function(pData)
		{
			A.Data.Titles = null;
			A.Data.Titles = U.getExistAssoc(pData);
			// Get title data
			Q.getTitles(pData, function()
			{
				generateTitles();
			});
		});
	},
	
	/*
	 * Requires characters data to be loaded first before loading other subsections.
	 * @param string pSection to open after characters data are loaded.
	 * @returns boolean true if characters data is required.
	 */
	requireCharacters: function(pSection)
	{
		if ($("#accDish_Characters").is(":empty"))
		{
			V.serveCharacters(pSection);
			$("#accMenu_Characters").trigger("click");
			return true;
		}
		return false;
	},
	
	/*
	 * Shows or hides a character or all characters hero overview window, and
	 * generates them if haven't already.
	 * @pre Characters array was loaded by AJAX.
	 */
	serveHero: function()
	{
		if (V.requireCharacters("Hero"))
		{
			return;
		}
		else if ( ! A.Data.Characters[0].equipment)
		{
			A.printError(A.PermissionEnum.Builds);
			return;
		}
		var dish = $("#accDish_Hero");
		var equipcur = $("#eqpContainer_" + A.CharIndexCurrent);
		var equipall = $(".eqpContainer");
		var doGenerate = function()
		{
			// Generate all characters
			I.removeThrobber(dish);
			A.Data.Characters.forEach(function(iChar)
			{
				V.generateHero(iChar);
			});
			equipall.show();
			
			// Create the quick scroller since multiple characters are shown
			A.createCharacterScroller(A.Data.Characters, "Hero", {
				aElementPrefix: "eqpContainer_",
				aOffset: -120
			});
		};
		
		// Generate for single character if user chosen, else all characters
		if (A.CharIndexCurrent !== null)
		{
			V.generateHero();
			equipall.hide();
			equipcur.show();
		}
		else
		{
			if (A.reinitializeDish(dish) === false)
			{
				equipall.show();
			}
			else
			{
				// Prefetch equipped items, and their transmuted skins, upgrades, and infusions
				dish.prepend(I.cThrobber);
				var itemstofetch = [];
				var skinstofetch = [];
				A.Data.Characters.forEach(function(iChar)
				{
					var result = A.iterateInventory(iChar.equipment);
					itemstofetch = itemstofetch.concat(result.oItemIDs);
					skinstofetch = skinstofetch.concat(result.oSkinIDs);
				});
				Q.getItems(itemstofetch, function()
				{
					Q.getSkins(skinstofetch, function()
					{
						doGenerate();
					});
				});
			}
		}
	},
	
	/*
	 * Generates the equipment subsection of the characters page.
	 * @param object pCharacter characters data.
	 */
	generateHero: function(pCharacter)
	{
		var char = pCharacter || A.getCurrentCharacter();
		if (char === undefined || char === null || Array.isArray(char.equipment) === false || $("#eqpContainer_" + char.oCharIndex).length)
		{
			return;
		}
		// Initialize variables
		var dish = $("#accDish_Hero");
		var container = $("<div id='eqpContainer_" + char.oCharIndex + "' class='eqpContainer'></div>").appendTo(dish);
		// Title and separator
		A.createCharacterBanner(container, char);
		// Equipment icons and brief glance information
		var subcontainer = $("<div class='eqpSubcontainer eqpSubcontainer_" + char.profession + "'></div>").appendTo(container);
		var subconleft = $("<div class='eqpLeft eqpColumn'></div>").appendTo(subcontainer);
		var subconright = $("<div class='eqpRight eqpColumn'></div>").appendTo(subcontainer);
		var subconbuild = $("<div class='eqpBuild eqpColumn'></div>").appendTo(subcontainer);
		var eqp = A.Equipment;
		var equipleft = eqp.ColumnLeft;
		var equipright = eqp.ColumnRight;
		var equiprightbrief = eqp.BriefRight;
		var equiptoggle = eqp.ToggleableSlots;
		var attrwindow = $("<div class='eqpAttrWindow'><aside class='eqpAttrHeader'><span class='eqpAttrTitle'>"
			+ D.getWordCapital("attributes") + "</span></aside><aside class='eqpAttrContent'></aside></div>").appendTo(subconbuild);
		// Object containing attribute points to be added by the retrieved items
		var attrobj = new A.Attribute.Base();
		var numtofetch = char.equipment.length;
		var numfetched = 0;
		
		/*
		 * Macro HTML writing functions.
		 */
		var formatEquipmentSlotLeft = function(pEquipment)
		{
			return "<aside class='eqpRow eqp" + pEquipment + "'>"
				+ "<span class='eqpSlotOuter'><span class='eqpSlot eqpSlot_" + pEquipment
					+ "' style='background-image:url(\"img/account/equipment/" + pEquipment.toLowerCase() + ".png\")'></span></span>"
				+ "<span class='eqpBrief eqpBrief_" + pEquipment + "'></span>"
			+ "</aside>";
		};
		var formatEquipmentSlotRight = function(pEquipment)
		{
			return "<aside class='eqpCell eqp" + pEquipment + "'>"
				+ "<span class='eqpSlot eqpSlot_" + pEquipment
					+ "' style='background-image:url(\"img/account/equipment/" + pEquipment.toLowerCase() + ".png\")'></span>"
			+ "</aside>";
		};
		var formatItemBrief = function(pBox)
		{
			var str = "";
			var levelstr = (pBox.oData.level < Q.GameLimit.LevelMax) ? (" (" + pBox.oData.level + ")") : "";
			str = "<span class='eqpBriefName " + Q.getRarityClass(pBox.oData.rarity) + "'>" + pBox.oData.name + levelstr + "</span><br />";
			pBox.oInfusions.forEach(function(iInfusion)
			{
				str += "<span class='" + Q.getRarityClass(iInfusion.rarity) + "'><img src='" + iInfusion.icon + "' /> " + iInfusion.name + "</span><br />";
			});
			pBox.oUpgrades.forEach(function(iUpgrade)
			{
				str += "<span class='" + Q.getRarityClass(iUpgrade.rarity) + "'><img src='" + iUpgrade.icon + "' /> " + iUpgrade.name + "</span><br />";
			});
			return str;
		};
		
		/*
		 * Windows to generate after equipments are fully loaded.
		 */
		var formatAttributesWindow = function()
		{
			// BUILD COLUMN: Attributes
			var attrcontent = attrwindow.find(".eqpAttrContent");
			var attrstrobj = Q.calculateAttributes(attrobj, char);
			for (var i in attrstrobj)
			{
				attrcontent.append("<span class='eqpAttrBlock eqpAttr_" + i + "' title='<dfn>" + D.getString(i) + "</dfn>'>"
					+ "<img src='img/account/attributes/" + i.toLowerCase() + ".png' />"
					+ "<var class='eqpAttrSum'>" + attrstrobj[i] + "</var><var class='eqpAttrBonus'>+" + attrobj[i] + "</var>"
				+ "</span>");
			}
			// Insert profession-specific attribute
			attrcontent.find(".eqpAttr_Power").after("<span class='eqpAttrBlock eqpAttr_Profession'>"
				+ "<img src='img/account/attributes/" + char.oCharElite.toLowerCase() + ".png' /><var>0%</var></span>");
			I.qTip.init(attrcontent.find("span"));
		};
		var formatTraitsWindow = function()
		{
			// BUILD COLUMN: Specializations
			var spec = char.specializations;
			var skills = char.skills;
			if (spec === undefined)
			{
				return;
			}
			var traitwindow = $("<div class='spzWindow'>"
				+ "<aside class='spzSwitchContainer'><span class='spzSwitchWrapper'>"
					+ "<img class='spzBuildIcon' src='img/ui/menu/build.png' />"
					+ "<img src='img/ui/view.png' />"
					+ "<img class='spzSwitch curClick' data-assoc='PVE' src='img/ui/menu/map.png' />"
					+ "<img class='spzSwitch curClick' data-assoc='WVW' src='img/ui/menu/wvw.png' />"
					+ "<img class='spzSwitch curClick' data-assoc='PVP' src='img/ui/menu/pvp.png' />"
				+ "</span></aside>"
				+ "<div class='spzContainer'>"
					+ "<div class='spzPanel spzPanel_PVE'></div>"
					+ "<div class='spzPanel spzPanel_WVW'></div>"
					+ "<div class='spzPanel spzPanel_PVP'></div>"
				+ "</div>"
				+ "<div class='sklContainer'>"
					+ "<div class='sklPanel sklPanel_PVE'></div>"
					+ "<div class='sklPanel sklPanel_WVW'></div>"
					+ "<div class='sklPanel sklPanel_PVP'></div>"
				+ "</div>"
			+ "</div>").appendTo(subconbuild);
			// Bind game mode buttons to switch to appropriate specializations panel
			traitwindow.find(".spzSwitch").each(function()
			{
				$(this).click(function()
				{
					traitwindow.find(".spzSwitch").removeClass("spzSwitchFocused");
					$(this).addClass("spzSwitchFocused");
					var buildmode = $(this).attr("data-assoc");
					var buildmodelower = buildmode.toLowerCase();
					var specpanel = traitwindow.find(".spzPanel_" + buildmode);
					var skillpanel = traitwindow.find(".sklPanel_" + buildmode);
					traitwindow.find(".spzPanel").hide();
					traitwindow.find(".sklPanel").hide();
					specpanel.show();
					skillpanel.show();
					// Generate the traits and skills panels if have not already
					V.generateTraits(spec[buildmodelower], specpanel);
					V.generateSkills(skills[buildmodelower], skillpanel);
				});
			});
			// Automatically opens the PVE traits window first
			traitwindow.find(".spzSwitch:first").trigger("click");
		};
		
		/*
		 * Function to execute after every single item and subitems have been retrieved.
		 */
		var finalizeEquipment = function()
		{
			A.setProgressBar(numfetched, numtofetch);
			if (numtofetch === numfetched)
			{
				formatAttributesWindow();
				formatTraitsWindow();
			}
		};
		
		// LEFT COLUMN armor and weapon
		equipleft.forEach(function(iEquip)
		{
			subconleft.append(formatEquipmentSlotLeft(iEquip));
		});
		// Add swap weapon ornamental icon
		subconleft.find(".eqpWeaponA2").after("<aside class='eqpSwap'><img class='eqpSwapIcon' src='img/account/equipment/swap.png' /></aside>");
		subconleft.find(".eqpWeaponA1").after("<span class='eqpSwapOuter eqpSwapA'><img class='eqpSwapIcon' src='img/account/equipment/swapa.png' /></span>");
		subconleft.find(".eqpWeaponB1").after("<span class='eqpSwapOuter eqpSwapB'><img class='eqpSwapIcon' src='img/account/equipment/swapb.png' /></span>");
		// RIGHT COLUMN trinket and underwater
		equipright.forEach(function(iEquip)
		{
			subconright.append(formatEquipmentSlotRight(iEquip));
		});
		subconright.prepend("<aside class='eqpSepTrinket'></aside>");
		var briefcontainer = $("<aside class='eqpBriefRight'></aside>").prependTo(subconright);
		equiprightbrief.forEach(function(iEquip)
		{
			briefcontainer.append("<span class='eqpBrief eqpBrief_" + iEquip + "' style='display:none;'></span>");
		});
		// Add padding separators
		subconright.find(".eqpRing2").after("<aside class='eqpSepGathering'><span class='eqpSepInner'></span></aside>");
		subconright.find(".eqpPick").after("<aside class='eqpSepUnderwater'><span class='eqpSepInner'></span></aside>");
		// Add swap weapon ornamental icon
		subconright.find(".eqpWeaponAquaticA").after("<aside class='eqpSwapAquatic eqpCell'><img class='eqpSwapIcon' src='img/account/equipment/swap.png' /></aside>");
		subconright.find(".eqpWeaponAquaticA").after("<span class='eqpSwapAquaticOuter eqpSwapAquaticA'><img class='eqpSwapIcon' src='img/account/equipment/swapaquatica.png' /></span>");
		subconright.find(".eqpWeaponAquaticB").after("<span class='eqpSwapAquaticOuter eqpSwapAquaticB'><img class='eqpSwapIcon' src='img/account/equipment/swapaquaticb.png' /></span>");
		// Add aquatic weapon background
		subconright.append("<img class='eqpAquaticBackground' src='img/account/equipment/aquatic.png' />");
		
		// Retrieve and slot the equipment
		var runesets = Q.countRuneSets(char);
		var itemids = [];
		for (var i in char.equipment)
		{
			itemids.push(char.equipment[i].id);
		}
		Q.getItems(itemids, function()
		{
			for (var i in char.equipment)
			{
				(function(iEquipment)
				{
					Q.getItem(iEquipment.id, function(iItem)
					{
						var ithcontainer = $("#eqpContainer_" + char.oCharIndex);
						var slot = ithcontainer.find(".eqpSlot_" + iEquipment.slot);
						var slotimg = (iEquipment.skin) ? "img/ui/placeholder.png" : iItem.icon;
						var sloticon = $("<img class='eqpIcon' src='" + slotimg + "' />").appendTo(slot);
						Q.scanItem(iItem, {
							aElement: slot,
							aItemMeta: iEquipment,
							aRuneSets: runesets,
							aWantAttr: true,
							aCallback: function(iBox)
							{
								// Set the slot icon as the transmuted skin icon
								ithcontainer.find(".eqpBrief_" + iEquipment.slot).append(formatItemBrief(iBox)).show();
								var skinname = null;
								if (iBox.oSkin)
								{
									skinname = iBox.oSkin.name;
									sloticon.attr("src", iBox.oSkin.icon);
								}
								// If the item is slotted in an attributable slot, (armor, primary weapons, trinkets, not underwater), then tally the attribute points
								if (A.Equipment.AttributableSlots[iEquipment.slot])
								{
									Q.sumAttributeObject(attrobj, iBox.oAttr);
								}
								// Add simulated checkboxes for toggleable armor slots
								if (equiptoggle[iEquipment.slot])
								{
									subcontainer.find(".eqpSlot_" + iEquipment.slot).prepend("<img class='eqpCheckbox' src='img/ui/checkbox.png' />");
								}
								// Add charges number over gathering tools
								if (iItem.type === "Gathering" && iEquipment.charges)
								{
									sloticon.attr("src", iBox.oData.icon);
									subcontainer.find(".eqpSlot_" + iEquipment.slot).prepend("<span class='eqpCharges'>" + iEquipment.charges + "</span>");
								}
								// Bind click behavior for the icon
								Q.bindItemSlotBehavior(sloticon, {
									aItem: iBox.oData,
									aSearch: skinname,
									aWantClick: true
								});
								numfetched++;
								finalizeEquipment();
							}
						});
					});
				})(char.equipment[i]);
			}
		});
		
		// In case the character is wearing nothing, the finalize callback would not have happened
		if (char.equipment.length === 0)
		{
			finalizeEquipment();
		}

		// Hide secondary weapon slots for professions that can't swap weapons
		if ((A.Metadata.Profession[char.oCharProfession]).isswappable === false)
		{
			var elmstoconceal = [".eqpSwap", ".eqpSwapB", ".eqpWeaponB1", ".eqpWeaponB2"];
			var elmstohide = [".eqpSwapAquatic", ".eqpSwapAquaticB", ".eqpWeaponAquaticB"];
			elmstoconceal.forEach(function(iSelector)
			{
				// Set visibility instead of hide so their width and height presence remains
				subcontainer.find(iSelector).css({visibility: "hidden"});
			});
			elmstohide.forEach(function(iSelector)
			{
				subcontainer.find(iSelector).hide();
			});
			subconright.find(".eqpAquaticBackground").addClass("eqpAquaticBackgroundSingle");
			subconright.find(".eqpHelmAquatic").addClass("eqpHelmAquaticSingle");
		}
	},
	
	/*
	 * Generates a specializations panel for a profession.
	 * @param array pTraitLines from character API under "specializations" property.
	 * Example structure: [{"id": 1, "traits": [701, 1889, 704]}, ...]
	 * @param jqobject pContainer to place the trait panel.
	 */
	generateTraits: function(pTraitLines, pContainer)
	{
		if (pTraitLines === undefined || pContainer.is(":empty") === false)
		{
			return;
		}
		
		var traitassoc = {};
		var insertSpecialization = function(pSpecID, pTraits)
		{
			var specline = $("<aside class='spzLine'>"
				+ "<span class='spzLineBackground'></span>"
				+ "<span class='spzLineForeground'></span>"
				+ "<span class='spzLineContent'>"
					+ "<span class='spzSpecSide'><var class='spzSpecSideIcon'></var></span>"
					+ "<span class='spzSpecColumn'><var class='spzSpecName'></var></span>"
					+ "<span class='spzColumn'>"
						+ "<var class='spzMinor spzMinor_10' data-tier='0'><em class='spzCon_01'></em></var>"
					+ "</span>"
					+ "<span class='spzColumn'>"
						+ "<var class='spzMajor_10'><em class='spzCon_10L'></em><em class='spzCon_10R'></em></var><br />"
						+ "<var class='spzMajor_11'><em class='spzCon_11L'></em><em class='spzCon_11R'></em></var><br />"
						+ "<var class='spzMajor_12'><em class='spzCon_12L'></em><em class='spzCon_12R'></em></var><br />"
					+ "</span>"
					+ "<span class='spzColumn'>"
						+ "<var class='spzMinor spzMinor_20' data-tier='1'></var>"
						+ "</var>"
					+ "</span>"
					+ "<span class='spzColumn'>"
						+ "<var class='spzMajor_20'><em class='spzCon_20L'></em><em class='spzCon_20R'></em></var><br />"
						+ "<var class='spzMajor_21'><em class='spzCon_21L'></em><em class='spzCon_21R'></em></var><br />"
						+ "<var class='spzMajor_22'><em class='spzCon_22L'></em><em class='spzCon_22R'></em></var><br />"
					+ "</span>"
					+ "<span class='spzColumn'>"
						+ "<var class='spzMinor spzMinor_30' data-tier='2'></var>"
					+ "</span>"
					+ "<span class='spzColumn'>"
						+ "<var class='spzMajor_30'><em class='spzCon_30L'></em></var><br />"
						+ "<var class='spzMajor_31'><em class='spzCon_31L'></em></var><br />"
						+ "<var class='spzMajor_32'><em class='spzCon_32L'></em></var><br />"
					+ "</span>"
				+ "</span>"
			+ "</aside>").appendTo(pContainer);
			specline.find("img").attr("src", "img/ui/placeholder.png");
			
			var formatTraitIcon = function(pTraitID)
			{
				var trait = Q.getBoxedTrait(pTraitID).oData;
				var traitelm = specline.find(".spz" + trait.slot + "_" + trait.tier + trait.order);
				traitelm.css({backgroundImage: "url(" + trait.icon + ")"});
				var traithighlight = "";
				var traitname = "";
				var tier = traitelm.attr("data-tier");
				if (traitassoc[pTraitID] // If the trait present in the character's traits array
					|| pTraits[tier]) // If the traits array is filled up at least to that "tier" (index)
				{
					traitelm.find("em").show(); // Show the connecting line between trait icons
					traithighlight = "spzActive"; // Brighten the active trait icon
					if (trait.slot === "Major")
					{
						traitname = "<span class='spzMajorName'>" + trait.name + "</span>";
					}
				}
				traitelm.append(traitname + "<mark class='" + traithighlight + "'>" + I.Symbol.Filler + "</mark>");
				// Generate tooltip for trait
				Q.analyzeTrait(trait, {aElement: traitelm});
			};
			var formatSpecLine = function()
			{
				var spec = Q.getBoxedSpecialization(pSpecID).oData;
				specline.css({backgroundImage: "url(" + spec.background + ")"});
				specline.find(".spzSpecName").text(spec.name);
				if (spec.elite)
				{
					specline.find(".spzLineBackground").addClass("spzLineBackgroundElite");
				}
				
				var traitids = spec.minor_traits.concat(spec.major_traits);
				traitids.forEach(function(iTraitID)
				{
					formatTraitIcon(iTraitID);
				});
			};
			
			// Generate
			formatSpecLine();
		};
		
		// Prefetch all of this character's specializations and traits
		var specstofetch = [];
		var traitstofetch = [];
		pTraitLines.forEach(function(iLine)
		{
			if (iLine)
			{
				specstofetch.push(iLine.id);
				if (iLine.traits)
				{
					iLine.traits.forEach(function(iTrait)
					{
						if (iTrait)
						{
							traitstofetch.push(iTrait);
							// Convert the traits array into an associative array for highlighting active traits
							traitassoc[iTrait] = true;
						}
					});
				}
			}
		});
		Q.getSpecializations(specstofetch, function()
		{
			// API only shows IDs of active major, so also manually include all the IDs of a spec line
			for (var i in specstofetch)
			{
				var spec = Q.getBoxedSpecialization(specstofetch[i]).oData;
				traitstofetch = traitstofetch.concat(spec.minor_traits.concat(spec.major_traits));
			}
			Q.getTraits(traitstofetch, function()
			{
				// Insert specialization lines to the panel of specific game mode
				pTraitLines.forEach(function(iLine)
				{
					if (iLine)
					{
						// Insert that line of traits into the panel
						insertSpecialization(iLine.id, iLine.traits);
					}
				});
			});
		});
		
	},
	
	/*
	 * Generates a skills bar for a profession.
	 * @param array pSkills from character API under "skills" property.
	 * Example structure: { "heal": 10548, "utilities": [10622, 10606, 10612], "elite": 10646 }
	 * @param jqobject pContainer to place the skills bar.
	 */
	generateSkills: function(pSkills, pContainer)
	{
		if (pSkills === undefined || pContainer.is(":empty") === false)
		{
			return;
		}
		
		var bar = $("<div class='sklBar'></div>").appendTo(pContainer);
		var insertSkill = function(pSkillID, pSlot)
		{
			if (pSkillID)
			{
				var skill = Q.getBoxedSkill(pSkillID).oData;
				pSlot.find(".sklSlotIcon").css({backgroundImage: "url(" + skill.icon + ")"});
				// Include ground targeting icon if skill is so
				for (var i = 0; i < skill.flags.length; i++)
				{
					if (skill.flags[i] === "GroundTargeted")
					{
						pSlot.append("<span class='sklSlotTarget'></span>");
						break;
					}
				}
				// Generate tooltip for trait
				Q.analyzeSkill(skill, {aElement: pSlot});
			}
			else
			{
				// Don't show the select bar over skill slots if the skill is locked
				pSlot.find(".sklSlotSelect, .sklSlotForeground").hide();
			}
		};
		var createSlot = function(pSlotType, pHotkey)
		{
			return $("<aside class='sklSlot sklSlot_" + pSlotType + "'>"
				+ "<span class='sklSlotSelect'></span>"
				+ "<span class='sklSlotLocked'></span>"
				+ "<span class='sklSlotIcon'></span>"
				+ "<span class='sklSlotForeground'></span>"
				+ "<span class='sklSlotHotkey'>" + pHotkey + "</span>"
			+ "</aside>").appendTo(bar);
		};
		
		// First create empty slots
		var heal = createSlot("heal", "6");
		createSlot("utilities0", "7");
		createSlot("utilities1", "8");
		createSlot("utilities2", "9");
		var elite = createSlot("elite", "0");
		
		// Prefetch skills
		var idstofetch = [];
		for (var i in pSkills)
		{
			var ithskill = pSkills[i];
			if (ithskill)
			{
				if (isNaN(ithskill) === false)
				{
					idstofetch.push(ithskill);
				}
				else
				{
					for (var ii in ithskill)
					{
						idstofetch.push(ithskill[ii]);
					}
				}
			}
		}
		
		// Fill the slots by additionally retrieving skill data
		Q.getSkills(idstofetch, function()
		{
			insertSkill(pSkills.heal, heal);
			for (var i = 0; i < pSkills.utilities.length; i++)
			{
				insertSkill(pSkills.utilities[i], bar.find(".sklSlot_utilities" + i));
			}
			insertSkill(pSkills.elite, elite);
		});
	},
	
	/*
	 * Generates inventory of all characters as bank tabs.
	 */
	serveInventory: function()
	{
		if (V.requireCharacters("Inventory"))
		{
			return;
		}
		else if ( ! A.Data.Characters[0].bags)
		{
			A.printError(A.PermissionEnum.Inventories);
			return;
		}
		
		var dish = $("#accDish_Inventory");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		var container = B.createBank(dish);
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var slotdata;
		var tab, slotscontainer, slot;
		var char, bagdata;
		var tabfill = 0;
		var tabcapacity = 0;
		var tabcount = 0;
		var bankfill = 0;
		var bankcapacity = 0;
		var bankcount = 0;
		
		// Fills a tab, which is one character's inventory
		var fillInventory = function(pTab, pCharacter)
		{
			var itemids = [];
			var numfetched = 0;
			var numtofetch = 0;
			slotscontainer = B.getSlotsContainer(pTab.append(I.cThrobber));
			// First count items to fetch
			for (var ii = 0; ii < pCharacter.bags.length; ii++)
			{
				bagdata = pCharacter.bags[ii];
				if (bagdata)
				{
					for (var iii = 0; iii < bagdata.inventory.length; iii++)
					{
						slotdata = bagdata.inventory[iii];
						if (slotdata)
						{
							itemids.push(slotdata.id);
							numtofetch++;
						}
					}
				}
			}
			// Fetch the items and fill slots
			Q.getPricedItems(itemids, function()
			{
				I.removeThrobber(pTab);
				for (var ii = 0; ii < pCharacter.bags.length; ii++)
				{
					bagdata = pCharacter.bags[ii];
					if (bagdata)
					{
						for (var iii = 0; iii < bagdata.inventory.length; iii++)
						{
							slot = B.createBankSlot(slotscontainer);
							slotdata = bagdata.inventory[iii];
							if (slotdata)
							{
								slot.data("count", slotdata.count);
								(function(iSlot, iSlotData)
								{
									Q.getItem(iSlotData.id, function(iItem)
									{
										B.styleBankSlot(iSlot, {aItem: iItem, aSlotMeta: iSlotData, aCallback: function()
										{
											numfetched++;
											A.setProgressBar(numfetched, numtofetch);
										}});
									});
								})(slot, slotdata);
							}
							else
							{
								// For empty inventory slots
								B.styleBankSlot(slot);
							}
						}
					}
				}
			});
		};
		
		$.getJSON(A.getURL(A.URL.Shared), function(pData)
		{
			bank.empty();
			var sharedtab = B.createBankTab(bank, {aTitle: D.getPhraseOriginal("Shared Inventory")});
			tabfill = 0;
			tabcapacity = pData.length;
			bankcapacity = pData.length;
			tabcount = 0;
			// Generate a first tab for the shared inventory slots
			for (var i = 0; i < pData.length; i++)
			{
				slot = B.createBankSlot(B.getSlotsContainer(sharedtab), "bnkSlotShared");
				slotdata = pData[i];
				if (slotdata)
				{
					slot.data("count", slotdata.count);
					tabfill++;
					bankfill++;
					tabcount += slotdata.count;
					bankcount += slotdata.count;
					(function(iSlot, iSlotData)
					{
						Q.getItem(iSlotData.id, function(iItem)
						{
							B.styleBankSlot(iSlot, {aItem: iItem, aSlotMeta: iSlotData});
						});
					})(slot, slotdata);
				}
			}
			B.updateTabTally(sharedtab, tabfill, tabcapacity, tabcount);
			
			// Generate the tabs for each character that fills their inventory after clicking to expand
			for (var i = 0; i < A.Data.Characters.length; i++)
			{
				tabfill = 0;
				tabcapacity = 0;
				tabcount = 0;
				char = A.Data.Characters[i];
				// Bank tab separator for each character
				tab = B.createBankTab(bank, {aTitle: char.oCharPreface, aIsCollapsed: true});
				B.createInventorySidebar(tab, char.bags);
				(function(iTab, iChar)
				{
					iTab.one("click", function()
					{
						fillInventory(iTab, iChar);
					});
				})(tab, char);
				
				// Calculate inventory sizes and stack count
				for (var ii = 0; ii < char.bags.length; ii++)
				{
					bagdata = char.bags[ii];
					if (bagdata)
					{
						for (var iii = 0; iii < bagdata.inventory.length; iii++)
						{
							slotdata = bagdata.inventory[iii];
							if (slotdata)
							{
								tabfill++;
								bankfill++;
								if (slotdata.count)
								{
									tabcount += slotdata.count;
									bankcount += slotdata.count;
								}
							}
						}
						tabcapacity += bagdata.inventory.length;
						bankcapacity += bagdata.inventory.length;
					}
				}
				B.updateTabTally(tab, tabfill, tabcapacity, tabcount);
			}
			B.updateBankTally(container, bankfill, bankcapacity, bankcount);
			B.createBankMenu(bank);
		});
	},
	
	/*
	 * Generates the account's possessions as single item slots in bank tabs.
	 */
	servePossessions: function()
	{
		if (V.requireCharacters("Possessions"))
		{
			return;
		}
		else if ( ! A.Data.Characters[0].bags)
		{
			A.printError(A.PermissionEnum.Inventories);
			return;
		}
		
		var dish = $("#accDish_Possessions");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		var container = B.createBank(dish);
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var slotscontainers = {};
		var tab, slotscontainer, slot;
		
		var generatePossessions = function()
		{
			bank.empty();
			// Bank tab for each item type
			for (var i in Q.ItemEnum)
			{
				tab = B.createBankTab(bank, {aTitle: D.getString(i)});
				slotscontainers[i] = B.getSlotsContainer(tab);
			}
			// Insert item slots into proper type tab
			for (var i in A.Possessions)
			{
				(function(iItemID, iPossession)
				{
					Q.getItem(iItemID, function(iItem)
					{
						slotscontainer = slotscontainers[iItem.type];
						if (slotscontainer)
						{
							slot = B.createBankSlot(slotscontainer);
							B.styleBankSlot(slot,
							{
								aItem: iItem,
								aSlotMeta: {count: iPossession.oCount},
								aComment: A.getFoundString(iPossession)
							});
						}
					});
				})(i, A.Possessions[i]);
			}
			B.createBankMenu(bank);
			B.tallyBank(container);
		};
		
		A.initializePossessions(function()
		{
			Q.getPricedItems(U.convertAssocToArray(A.Possessions), function()
			{
				generatePossessions();
			});
		});
	},
	
	/*
	 * Generates the items catalog bank window.
	 */
	serveCatalog: function()
	{
		B.generateCatalog("Catalog", {
			aIsCustomCatalog: true
		});
	},
	
	/*
	 * Generates the ascended equipment catalog bank window.
	 */
	serveCleanup: function()
	{
		B.generateCatalog("Cleanup", {
			aIsCollection: false,
			aIsLookup: true,
			aWantItems: true,
			aWantGem: false,
			aWantDefaultHelp: false
		});
	},
	
	/*
	 * Generates the ascended equipment catalog bank window.
	 */
	serveAscended: function()
	{
		B.generateCatalog("Ascended", {
			aWantPrices: false,
			aWantGem: false,
			aWantDefaultHelp: false
		});
	},
	
	/*
	 * Generates the learned recipes as a bank categorized by crafting disciplines.
	 */
	serveRecipes: function()
	{
		var section = "Recipes";
		if (V.requireCharacters(section))
		{
			return;
		}
		else if ( ! A.Data.Characters[0].recipes)
		{
			A.printError(A.PermissionEnum.Inventories);
			return;
		}
		
		var dish = $("#accDish_Recipes");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		var container = B.createBank(dish, {
			aIsCollection: true,
			aWantGem: false
		});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		
		// Retrieve data before generating
		U.getScript(U.URL_DATA.Recipes, function()
		{
			var headers = {};
			var metadata = GW2T_RECIPES_METADATA;
			var record = GW2T_RECIPES_DATA;
			
			// Merge the record arrays into one lookup table
			var recipelookup = {}; // Will be used to find a character's unlocked recipe
			var itemlookup = {}; // Will be used to find a character's unlocked recipe by searching with the item
			var searchsubset = {};
			var discname, entry, recipeid, itemid;
			for (var i in record)
			{
				discname = i.split("_")[0];
				for (var ii = 0; ii < record[i].length; ii++)
				{
					entry = (record[i])[ii];
					searchsubset[entry.i] = i;
					if (recipelookup[entry.u] === undefined)
					{
						recipelookup[entry.u] = {
							oItemID: entry.i, // Item ID of crafted product
							oDisciplines: [discname] // Disciplines that can craft this recipe
						};
					}
					else
					{
						recipelookup[entry.u].oDisciplines.push(discname);
					}
				}
			}
			
			// Merge all characters' unlocked recipes array into one
			var unlockeds = [];
			A.Data.Characters.forEach(function(iChar)
			{
				unlockeds = U.getUnion(unlockeds, iChar.recipes);
				// Create a list of items with the characters' names who can craft it
				for (var ii = 0; ii < iChar.recipes.length; ii++)
				{
					recipeid = iChar.recipes[ii];
					if (recipelookup[recipeid])
					{
						itemid = recipelookup[recipeid].oItemID;
						var discnames = recipelookup[recipeid].oDisciplines;
						var discicons = "";
						for (var iii = 0; iii < discnames.length; iii++)
						{
							discname = discnames[iii];
							if (iChar.oCharCraft && iChar.oCharCraft[discname])
							{
								discicons += "<ins class='acc_craft acc_craft_" + discname.toLowerCase() + "'></ins>";
							}
						}
						if (discicons.length)
						{
							if (itemlookup[itemid] === undefined)
							{
								itemlookup[itemid] = [];
							}
							itemlookup[itemid].push(iChar.oCharName + discicons);
						}
					}
				}
			});
			// Add the characters' names to the record so later the style slot function can write them in item tooltips
			var craftstr = D.getPhrase("crafted by", U.CaseEnum.Sentence) + ": ";
			for (var i in record)
			{
				for (var ii = 0; ii < record[i].length; ii++)
				{
					var entry = (record[i])[ii];
					if (itemlookup[entry.i])
					{
						entry.t = "<var class='itmColor_reminder'>" + craftstr + (itemlookup[entry.i]).join(", ") + "</var>";
					}
					else
					{
						delete entry.t;
					}
				}
			}
			
			// Construct tab headers from crafting disciplines and recipe types
			var lang = D.langFullySupported;
			var catname;
			for (var i in metadata.Disciplines)
			{
				for (var ii in metadata.Types)
				{
					catname = i + "_" + ii;
					headers[catname] = {};
					(headers[catname])["name_" + lang] = (metadata.Disciplines[i])[lang] + " " + (metadata.Types[ii])[lang];
				}
			}
			
			// Get the account wide unlocked recipes
			$.getJSON(A.getURL(A.URL.Recipes), function(pData)
			{
				unlockeds = U.getUnion(unlockeds, pData);
				// Generate the bank
				B.generateUnlockables(bank, {
					aHeaders: headers,
					aRecord: record,
					aUnlockeds: unlockeds,
					aIsCollapsed: true,
					aTabIterator: function(pCatName)
					{
						var discipline = pCatName.split("_")[0];
						var catname = D.getObjectName(headers[pCatName]);
						var caticon = "<ins class='bnkTabIcon acc_craft acc_craft_" + discipline.toLowerCase() + "'></ins>"
							+ "<ins class='bnkTabIcon acc_recipes acc_recipes_" + pCatName.toLowerCase() + "'></ins>";
						var tab = B.createBankTab(bank, {
							aID: "rcpTab_" + pCatName,
							aTitle: catname,
							aIcon: caticon,
							aIsCollapsed: true
						});
						return tab;
					}
				});

				/*
				 * Piggyback on the bank search bar (created by the generate unlockables
				 * function) and make it print the characters who have unlocked the
				 * recipe to create that searched item.
				 */
				var searchbar = B.getBankSearch(section);
				Q.bindItemSearch(searchbar, {
					aSubset: searchsubset,
					aFillerText: null,
					aCallback: function(pItem)
					{
						var itemname = "&quot;<a" + U.convertExternalAnchor(U.getWikiLinkLanguage(pItem.name)) + ">" + pItem.name + "</a>&quot;";
						if (itemlookup[pItem.id])
						{
							var charnames = (itemlookup[pItem.id]).join(", ");
							I.write(itemname + " was learned and can be crafted by:<br /><br />" + charnames);
						}
						else
						{
							I.write("None of your characters have learned how to craft " + itemname);
						}
						// Show the tab the item is in
						B.scrollToBankTab("#rcpTab_" + searchsubset[pItem.id]);
					}
				});
			});
		});
	},
	
	/*
	 * Generates Super Adventure Box per-character unlocks.
	 */
	serveSAB: function()
	{
		var section = "SAB";
		if (V.requireCharacters(section))
		{
			return;
		}
		
		var dish = $("#accDish_SAB");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var record, headers;
		var elmprefix = "sabProgressionBanner_";
		var createBank = function(pUnlockAssoc, pCharacter)
		{
			var container = B.createBank(dish, {
				aIsCollection: true,
				aWantGem: false,
				aWantCoin: false
			});
			A.createCharacterBanner(container, pCharacter, elmprefix);
			var bank = B.getTabsContainer(container);
			var tab, slotscontainer, slot, unlock;
			
			for (var i in record)
			{
				tab = B.createBankTab(bank, {aTitle: D.getObjectName(headers[i])});
				slotscontainer = B.getSlotsContainer(tab);
				for (var ii in record[i])
				{
					unlock = (record[i])[ii];
					slot = B.createPseudoSlot(slotscontainer, {
						aName: unlock.n,
						aTooltip: unlock.t || unlock.n,
						aIcon: "img/account/sab/" + unlock.i + I.cPNG,
						aIsUnlocked: pUnlockAssoc[unlock.u],
						aLabel: unlock.l
					});
				}
			}
			B.tallyBank(container);
			B.createBankDivider(container);
		};
		
		// Turns the API's multiple arrays into one associative array
		var flattenUnlocks = function(pData)
		{
			var unlockassoc = {};
			for (var i in pData)
			{
				for (var ii in pData[i])
				{
					var newid = i + "_" + (pData[i])[ii].id; // This is the ID as it appears in the custom record
					unlockassoc[newid] = true;
				}
			}
			return unlockassoc;
		};
		
		// Retrieve data and unlocks
		dish.prepend(I.cThrobber);
		U.getScript(U.URL_DATA.SAB, function()
		{
			headers = U.getRecordHeader(section);
			record = U.getRecordData(section);
			U.fetchPattern(A.getURL(A.URL.CharactersSAB), A.Data.CharacterNames, {aCallback: function(pData, pLength)
			{
				I.removeThrobber(dish);
				if (pLength)
				{
					var validcharacters = [];
					for (var i in pData)
					{
						// Only create a bank for a character if it has any unlocks
						var idata = pData[i];
						if (idata.zones && idata.unlocks && idata.songs &&
							(idata.zones.length || idata.unlocks.length || idata.songs.length))
						{
							var ichar = A.getCharacterByName(i);
							validcharacters.push(ichar);
							createBank(flattenUnlocks(pData[i]), ichar);
						}
					}
					// Create characters bar after generating banks
					if (validcharacters.length > 1)
					{
						A.createCharacterScroller(validcharacters, section, {
							aElementPrefix: elmprefix,
							aOffset: -120 // Consider the character banner
						});
					}
				}
				else
				{
					A.printError(A.PermissionEnum.Progression);
				}
			}});
		});
	},
	
	/*
	 * Generates the items bank window.
	 */
	serveBank: function()
	{
		var dish = $("#accDish_Bank");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var container = B.createBank(dish);
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var slotdata;
		var tab, slotscontainer, slot;
		var nexti;
		var numitems = 0;
		var numfetched = 0;
		var numtofetch = 0;
		var doGenerate = function(pData)
		{
			// First generate empty bank slots, then fill them up asynchronously by item details retrieval
			bank.empty();
			for (var i = 0; i < pData.length; i++)
			{
				// Bank tab separator every so slots
				if ((i === 0 || nexti % A.Metadata.Bank.NumSlotsPerTab === 0) && nexti !== pData.length)
				{
					tab = B.createBankTab(bank);
					slotscontainer = B.getSlotsContainer(tab);
				}
				nexti = i+1;

				slot = B.createBankSlot(slotscontainer);
				slotdata = pData[i];
				// Line breaks (new rows) are automatically rendered by the constant width of the bank's container
				if (slotdata)
				{
					slot.data("count", slotdata.count);
					numitems += slotdata.count;
					(function(iSlot, iSlotData)
					{
						Q.getItem(iSlotData.id, function(iItem)
						{
							B.styleBankSlot(iSlot, {aItem: iItem, aSlotMeta: iSlotData, aCallback: function()
							{
								numfetched++;
								A.setProgressBar(numfetched, numtofetch);
							}});
						});
					})(slot, slotdata);
				}
				else
				{
					// For empty inventory slots
					B.styleBankSlot(slot);
				}
			}
			// Update tallies
			B.tallyBank(container);
			// Ornamental bank tab separator at the bottom
			bank.append("<div class='bnkTabSeparator'><var class='bnkTabLocked'>" + I.Symbol.Filler + "</var></div>");
			// Create search bar
			B.createBankMenu(bank);
		};
		
		// Get bank information and prefetch item data
		$.getJSON(A.getURL(A.URL.Bank), function(pData)
		{
			// Count the number of items in the bank first, because empty slots are written as "null" in the API
			var result = A.iterateInventory(pData, function()
			{
				numtofetch++;
			});
			
			Q.getPricedItems(result.oItemIDs, function()
			{
				Q.getSkins(result.oSkinIDs, function()
				{
					doGenerate(pData);
				});
			});
		}).fail(function(pRequest, pStatus)
		{
			A.printError(A.PermissionEnum.Inventories, pStatus);
			dish.empty();
		});
	},
	
	/*
	 * Generates the guild bank window for all permitting guilds.
	 */
	serveVault: function()
	{
		var dish = $("#accDish_Vault");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		var container = B.createBank(dish);
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var guild;
		var tab, slotscontainer, slot;
		var sortedvaults = [], vault, subvault;
		var subbankname = {
			"0": D.getString("GuildStash"),
			"1": D.getString("TreasureTrove"),
			"2": D.getString("DeepCave")
		};
		
		var generateVault = function()
		{
			var itemids = [];
			var numitems = 0;
			var numfetched = 0;
			var numtofetch = 0;
			// First order the vaults by the number of unique items they have
			for (var i in A.Data.Vaults)
			{
				vault = A.Data.Vaults[i];
				var uniqueitems = {};
				var uniquecount = 0;
				vault.forEach(function(iSubvault)
				{
					iSubvault.inventory.forEach(function(iSlotData)
					{
						if (iSlotData)
						{
							numtofetch++;
							if (uniqueitems[iSlotData.id] === undefined)
							{
								uniqueitems[iSlotData.id] = true;
								uniquecount++;
								itemids.push(iSlotData.id);
							}
						}
					});
				});
				vault.oGuildID = i;
				vault.oUniqueCount = uniquecount;
				sortedvaults.push(vault);
			}
			U.sortObjects(sortedvaults, {aKeyName: "oUniqueCount", aIsDescending: true});
			
			Q.getPricedItems(itemids, function()
			{
				bank.empty();
				// Fill the vaults
				for (var i in sortedvaults)
				{
					vault = sortedvaults[i];
					guild = Q.getCachedGuild(vault.oGuildID);
					if (!guild)
					{
						continue;
					}
					for (var ii = 0; ii < vault.length; ii++)
					{
						subvault = vault[ii];
						tab = B.createBankTab(bank, {aTitle: guild.oTag + " " + subbankname[ii]});
						slotscontainer = B.getSlotsContainer(tab);
						subvault.inventory.forEach(function(iSlotData)
						{
							slot = B.createBankSlot(slotscontainer);
							// Line breaks (new rows) are automatically rendered by the constant width of the bank's container
							if (iSlotData)
							{
								slot.data("count", iSlotData.count);
								numitems += iSlotData.count;
								(function(iSlot, iSlotData)
								{
									Q.getItem(iSlotData.id, function(iItem)
									{
										B.styleBankSlot(iSlot, {aItem: iItem, aSlotMeta: iSlotData, aCallback: function()
										{
											numfetched++;
											A.setProgressBar(numfetched, numtofetch);
										}});
									});
								})(slot, iSlotData);
							}
							else
							{
								// For empty inventory slots
								B.styleBankSlot(slot);
							}
						});
					}
				}
				// Update tallies
				B.tallyBank(container);
				// Create search bar
				B.createBankMenu(bank);
			});
		};
		
		// Retrieve guilds and guild data
		$.getJSON(A.getURL(A.URL.Account), function(pData)
		{
			A.Data.Account = pData;
			A.initializeVault(function(pData)
			{
				if (pData)
				{
					generateVault();
				}
				else
				{
					bank.empty();
				}
			});
		}).fail(function(pRequest, pStatus)
		{
			bank.empty();
			A.printError(A.PermissionEnum.Account, pStatus);
		});
	},
	
	/*
	 * Generates the crafting materials window.
	 */
	serveMaterials: function()
	{
		var section = "Materials";
		var dish = $("#accDish_" + section);
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var container = B.createBank(dish, {
			aIsCollection: false,
			aWantGem: false
		});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var doGenerate = function(pUnlockeds)
		{
			var entry;
			var unlockeds = {};
			// Reformat the unlockeds array from API
			for (var i in pUnlockeds)
			{
				entry = pUnlockeds[i];
				if (entry.count > 0)
				{
					unlockeds[entry.id] = {
						oCount: entry.count
					};
				}
			}
			B.generateUnlockables(bank, {
				aHeaders: U.getRecordHeader(section),
				aRecord: U.getRecordData(section),
				aUnlockeds: unlockeds,
				aWantSearchHighlight: false,
				aWantDefaultHelp: false
			});
		};
		
		U.getScript(U.URL_DATA.Materials, function()
		{
			$.getJSON(A.getURL(A.URL.Materials), function(pData)
			{
				Q.loadItemsSubdatabase(section.toLowerCase(), function()
				{
					doGenerate(pData);
				});
			}).fail(function(pRequest, pStatus)
			{
				A.printError(A.PermissionEnum.Inventories, pStatus);
				dish.empty();
			});
		});
	},
	
	/*
	 * Generates the skin wardrobe window.
	 */
	serveWardrobe: function()
	{
		var dish = $("#accDish_Wardrobe");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var section = "Wardrobe";
		var headers, galleries, record;
		var galleryword = D.getWordCapital("gallery");
		// Macro function to add link to gallery buttons next to the tab separators
		var createGalleryLinks = function(pTab, pCategory)
		{
			var galkey = headers[pCategory].set || pCategory;
			var link = galleries[galkey];
			var hoverelm = $("<aside class='bnkTabHover'></aside>").prependTo(pTab.find(".bnkTabSeparator"));
			if (typeof link === "string")
			{
				$("<button class='bnkTabHoverButton'>" + galleryword + "</button>").click(function(pEvent)
				{
					pEvent.stopPropagation();
					U.openExternalURL(link);
				}).appendTo(hoverelm);
			}
			else
			{
				var counter = 0;
				for (var i in link)
				{
					counter++;
					(function(iLink)
					{
						$("<button class='bnkTabHoverButton'><img src='img/account/characters/" + i.toLowerCase() + ".png' /></button>").click(function(pEvent)
						{
							pEvent.stopPropagation();
							U.openExternalURL(iLink);
						}).appendTo(hoverelm);
					})(link[i]);
					if (counter % 2 === 0)
					{
						hoverelm.append("<br />");
					}
				}
			}
		};
		
		var container = B.createBank(dish, {aIsCollection: true});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var generateWardrobe = function(pUnlockeds)
		{
			galleries = GW2T_SKINS_GALLERIES;
			headers = GW2T_SKINS_HEADERS;
			record = GW2T_SKINS_DATA;
			
			B.generateUnlockables(bank, {
				aHeaders: headers,
				aRecord: record,
				aUnlockeds: pUnlockeds,
				aIsCollapsed: true,
				aTabIterator: function(pCatName)
				{
					var catname = D.getObjectName(headers[pCatName]);
					var caticon = "<ins class='bnkTabIcon acc_wardrobe acc_wardrobe_" + pCatName.toLowerCase() + "'></ins>";
					var tab = B.createBankTab(bank, {
						aID: "wrdTab_" + pCatName,
						aTitle: catname,
						aIcon: caticon,
						aIsCollapsed: true
					});
					createGalleryLinks(tab, pCatName);
					return tab;
				}
			});
			
			// Piggyback on the bank search bar with custom search for skin items
			var searchsubset = {};
			A.iterateRecord(record, function(pEntry, pCatName)
			{
				searchsubset[pEntry.i] = pCatName;
			});

			Q.bindItemSearch(B.getBankSearch(section), {
				aSubset: searchsubset,
				aFillerText: null,
				aCallback: function(pItem)
				{
					// Show the tab the item is in
					B.scrollToBankTab("#wrdTab_" + searchsubset[pItem.id]);
				}
			});
		};
		
		// Retrieve data before generating
		U.getScript(U.URL_DATA.Skins, function()
		{
			$.getJSON(A.getURL(A.URL.Skins), function(pData)
			{
				generateWardrobe(pData);
			}).fail(function(pRequest, pStatus)
			{
				A.printError(A.PermissionEnum.Unlocks, pStatus);
				dish.empty();
			});
		});
	},
	
	/*
	 * Generates a standard unlockables collection window without extra features.
	 * @param string pSection
	 * @objparam boolean aWantPrices to prefetch TP prices for all items, optional.
	 * @objparam boolean aWantGem whether to display the gem tally, optional.
	 * @objparam enum aPermission required for those unlockables, optional.
	 * @objparam function aCallback to execute after generate.
	 */
	serveUnlockables: function(pSection, pSettings)
	{
		var section = pSection;
		var dish = $("#accDish_" + section);
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		var Settings = pSettings || {};
		
		var container = B.createBank(dish, {
			aIsCollection: true,
			aWantGem: Settings.aWantGem
		});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var doGenerate = function(pUnlockeds)
		{
			B.generateUnlockables(bank, {
				aHeaders: U.getRecordHeader(section),
				aRecord: U.getRecordData(section),
				aUnlockeds: pUnlockeds,
				aWantPrices: (Settings.aWantPrices !== false) ? true : false,
				aCallback: Settings.aCallback
			});
		};
		
		U.getScript(U.URL_DATA[section], function()
		{
			$.getJSON(A.getURL(A.URL[section]), function(pData)
			{
				Q.loadItemsSubdatabase(section.toLowerCase(), function()
				{
					doGenerate(pData);
				});
			}).fail(function(pRequest, pStatus)
			{
				A.printError(Settings.aPermission || A.PermissionEnum.Unlocks, pStatus);
				dish.empty();
			});
		});
	},
	serveOutfits: function()
	{
		V.serveUnlockables("Outfits", {aWantPrices: false});
	},
	serveGliders: function()
	{
		V.serveUnlockables("Gliders", {aWantPrices: false});
	},
	serveMinis: function()
	{
		V.serveUnlockables("Minis");
	},
	serveCarriers: function()
	{
		V.serveUnlockables("Carriers");
	},
	serveChampions: function()
	{
		V.serveUnlockables("Champions");
	},
	serveFinishers: function()
	{
		V.serveUnlockables("Finishers");
	},
	serveNodes: function()
	{
		V.serveUnlockables("Nodes");
	},
	serveCats: function()
	{
		V.serveUnlockables("Cats", {aPermission: A.PermissionEnum.Progression, aWantGem: false, aCallback: function(pReturn)
		{
			A.embedFrame("#accDish_Cats", G.getCollectibleURL(X.Collectibles.HungryCats, pReturn.aUnlockAssoc));
		}});
	},
	serveRaids: function()
	{
		V.serveUnlockables("Raids", {aPermission: A.PermissionEnum.Progression, aWantPrices: false, aWantGem: false, aCallback: function()
		{
			T.isChecklistCountdownsStarted = true;
			$("#accDish_Raids").prepend("<div class='accCountdown jsCountdownToWeekly'></div>");
		}});
	},
	serveDungeons: function()
	{
		V.serveUnlockables("Dungeons", {aPermission: A.PermissionEnum.Progression, aWantPrices: false, aWantGem: false, aCallback: function()
		{
			T.isChecklistCountdownsStarted = true;
			$("#accDish_Dungeons").prepend("<div class='accCountdown jsCountdownToDaily'></div>");
		}});
	},
	
	/*
	 * Generates the dye color collection window.
	 */
	serveDyes: function()
	{
		var dish = $("#accDish_Dyes");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var container = B.createBank(dish, {
			aClass: "bnkBankDyes",
			aIsPseudo: true
		});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		U.getScript(U.URL_DATA.Dyes, function()
		{
			$.getJSON(A.getURL(A.URL.Dyes), function(pData)
			{
				B.generateUnlockables(bank, {
					aHeaders: GW2T_DYES_HEADERS,
					aRecord: GW2T_DYES_DATA,
					aUnlockeds: pData,
					aWantDefaultHelp: false,
					aWantSearchHighlight: false,
					aIsDyes: true
				});
			}).fail(function(pRequest, pStatus)
			{
				A.printError(A.PermissionEnum.Unlocks, pStatus);
				dish.empty();
			});
		});
	},
	
	/*
	 * Generates and tallies achievement points.
	 */
	serveAchievements: function()
	{
		var dish = $("#accDish_Achievements");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var section = "Achievements";
		var unlocks = {};
		var searchdb = [];
		var generateBank = function(pData)
		{
			I.removeThrobber(dish);
			var container = B.createBank(dish, {
				aIsPseudo: true
			});
			var bank = B.getTabsContainer(container);
			var tab, slot;
			var categorizedach = {};
			var categories = {}, cat, achid, box, ithach, ithunlock, processedach;
			
			var createTab = function(pCategory)
			{
				tab = B.createBankTab(bank, {
					aID: "achTab_" + pCategory.id,
					aTitle: pCategory.name,
					aIcon: "<img class='bnkTabIcon' src='" + pCategory.icon + "' />"
				});
				
				// Compute all achievements for showing on the bank and tab tallies
				for (var ii = 0; ii < pCategory.achievements.length; ii++)
				{
					achid = pCategory.achievements[ii];
					box = Q.getBoxedAchievement(achid);
					if (box)
					{
						categorizedach[achid] = true;
						ithach = box.oData;
						ithunlock = unlocks[achid];
						processedach = Q.processAchievement(ithach, ithunlock);
						
						B.updateSlotPrice(tab, {
							aIsTab: true,
							aCount: (ithunlock && ithunlock.done) ? 1 : 0,
							aPrice: processedach.oAPPointCurrent,
							aPossible: processedach.oAPPointPossible,
							aPaymentEnum: "achievement"
						});
						// Create search database
						if (ithach.icon === undefined)
						{
							ithach.icon = pCategory.icon;
						}
						ithach.oCategoryName = pCategory.name;
						ithach.oCategoryID = pCategory.id;
						ithach.keywords = ithach.name.toLowerCase() + " " + pCategory.name.toLowerCase();
						searchdb.push(ithach);
					}
				}
				
				// Generate the slots on demand when a tab is expanded
				(function(iTab)
				{
					iTab.find(".bnkTabSeparator").one("click", function()
					{
						var slotscontainer = B.getSlotsContainer(iTab);
						for (var ii = 0; ii < pCategory.achievements.length; ii++)
						{
							achid = pCategory.achievements[ii];
							box = Q.getBoxedAchievement(achid);
							if (box)
							{
								ithach = box.oData;
								ithunlock = unlocks[achid];
								processedach = Q.processAchievement(ithach, ithunlock);
								
								slot = B.createPseudoSlot(slotscontainer, {
									aID: "achSlot_" + achid,
									aIsUnlocked: (ithunlock && ithunlock.done) ? true : false,
									aName: ithach.name,
									aLabel: ithach.name,
									aIcon: pCategory.icon,
									aPayment: {achievement: processedach.oAPPointCurrent},
									aIsTab: false,
									aPossible: processedach.oAPPointPossible,
									aCard: Q.analyzeAchievement(ithach, {aAchievement: processedach, aWantCard: true}),
									aTooltip: Q.analyzeAchievement(ithach, {aAchievement: processedach}),
									aKeywords: pCategory.name + " " + ithach.name + " " + ithach.requirement
								});
								// Include a completion percent if this achievement is partially participated
								var apratio = processedach.oAPCountCurrent / processedach.oAPCountPossible;
								if (apratio < 1 && processedach.oAPCountPossible > 1)
								{
									slot.append("<var class='bnkSlotCount'>" + processedach.oAPCountCurrent + "/" + processedach.oAPCountPossible + "</var>");
								}
								
								// Right click achievement slot prints raw data
								(function(iAchievement, iUnlock, iProcessed)
								{
									slot.contextmenu(function(pEvent)
									{
										pEvent.preventDefault();
										I.prettyJSON(iAchievement);
										I.prettyJSON(iUnlock);
										I.prettyJSON(iProcessed);
									});
								})(ithach, ithunlock, processedach);
							}
						}
					});
				})(tab);
			};
			
			// Create the achievement category tabs in the same order as the game, not the API
			pData.forEach(function(iCategory)
			{
				categories[iCategory.id] = iCategory;
			});
			A.Metadata.AchievementCategories.forEach(function(iCategoryID)
			{
				if (typeof iCategoryID === "object")
				{
					B.createTabDivider(bank, {aTitle: D.getObjectTranslation(iCategoryID)});
				}
				else
				{
					cat = categories[iCategoryID];
					if (cat)
					{
						createTab(cat);
						delete categories[iCategoryID]; // Any unknown categories will remain in the assoc
					}
					else if (iCategoryID === -1) // Extra category for achievements without a category
					{
						var fauxcategory = {
							name: "",
							icon: "img/ui/unknown.png",
							achievements: []
						};
						for (var i in Q.Boxes.Achievements)
						{
							if (categorizedach[i] === undefined)
							{
								fauxcategory.achievements.push(i);
							}
						}
						createTab(fauxcategory);
					}
				}
			});
			// Include any unknown categories not in the pre-sorted achievement categories
			for (var i in categories)
			{
				createTab(categories[i]);
			}
			
			// Finish up UI
			B.tallyBank(container);
			B.createBankDivider(container);
			B.createBankMenu(bank, {
				aIsPseudo: true,
				aIsCollapsed: true,
				aWantCard: true,
				aWantSearchHighlight: true
			});
			// Total the account's achievement points
			$.getJSON(A.getURL(A.URL.Account), function(pData)
			{
				var bankap = B.getBankPrice(container);
				var dailyap = pData.daily_ap;
				var monthlyap = pData.monthly_ap;
				container.find(".bnkPrice").append("<div class='achBankTotal'>"
					+ E.PaymentFormat.achievement(bankap[0]) + " + "
					+ dailyap.toLocaleString() + "<img class='css24' src='img/account/summary/daily.png' /> + "
					+ monthlyap.toLocaleString() + "<img class='css24' src='img/account/summary/monthly.png' /> = "
					+ "<var class='achBankActual'>" + E.PaymentFormat.achievement(bankap[0] + dailyap + monthlyap) + "</var>"
					+ " / " + E.PaymentFormat.achievement(bankap[0] + bankap[1] + Q.GameLimit.DailyAP)
				+ "</div>");
			});
			
			// Piggyback on the bank search bar with custom search for achievements
			Q.bindItemSearch(B.getBankSearch(section), {
				aDatabase: searchdb,
				aFillerText: null,
				aAchievements: unlocks,
				aCallback: function(pAch)
				{
					// Scroll to the bank tab (category) when clicked on an achievement in the search results
					B.showBankTab($("#achTab_" + pAch.oCategoryID));
					I.scrollToElement($("#achSlot_" + pAch.id), {
						aOffset: -A.getOverheadHeight(),
						aSpeed: "fast"
					});
				}
			});
		};
		
		dish.prepend(I.cThrobber);
		// Get account's achievement unlocks
		U.getJSON(A.getURL(A.URL.Achievements), function(pAccountAch)
		{
			// Convert array into associative array for constant access
			pAccountAch.forEach(function(iUnlock)
			{
				unlocks[iUnlock.id] = iUnlock;
			});
			// Get achievement categories
			U.getJSON(U.getAPI("achievements/categories", true), function(pCategories)
			{
				// Get all possible achievements
				U.getJSON(U.getCacheURL(section), function(pAchievements)
				{
					Q.initializeBoxes(section, pAchievements);
					generateBank(pCategories);
				});
			});
		}).fail(function()
		{
			A.printError(A.PermissionEnum.Progression);
		});
	},
	
	/*
	 * Generates mastery unlocks.
	 */
	serveMasteries: function()
	{
		var dish = $("#accDish_Masteries");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var unlockassoc = {};
		var generateBank = function(pData)
		{
			I.removeThrobber(dish);
			var container = B.createBank(dish, {
				aIsPseudo: true
			});
			var bank = B.getTabsContainer(container);
			var tab, slotscontainer, slot;
			var ithmastery;
			
			pData.forEach(function(iLine)
			{
				tab = B.createBankTab(bank, {aTitle: iLine.name});
				slotscontainer = B.getSlotsContainer(tab);
				for (var ii = 0; ii < iLine.levels.length; ii++)
				{
					ithmastery = iLine.levels[ii];
					slot = B.createPseudoSlot(slotscontainer, {
						aIsUnlocked: unlockassoc[iLine.id + "_" + ii],
						aName: ithmastery.name,
						aIcon: ithmastery.icon,
						aLabel: ithmastery.name,
						aTooltip: Q.analyzeAchievement(ithmastery, {
							aClass: "itmTooltipMastery",
							aWantIcon: true
						}),
						aCard: Q.analyzeAchievement(ithmastery, {aWantCard: true}),
						aPayment: {mastery: ithmastery.point_cost}
					});
				}
			});
			B.tallyBank(container);
			B.createBankDivider(container);
			B.createBankMenu(bank, {
				aIsPseudo: true,
				aWantCard: true
			});
		};
		
		// Get all possible masteries
		dish.prepend(I.cThrobber);
		U.getJSON(U.getAPI("masteries", true), function(pData)
		{
			// Get account's mastery unlocks
			U.getJSON(A.getURL(A.URL.Masteries), function(pDataInner)
			{
				/*
				 * The API gives how far in the mastery line the account has
				 * progressed (array length) rather than the ID of mastery unlocked.
				 * Level 0 counts as completing the first mastery in the line;
				 * a line not in the account unlocks means no point was spent on it.
				 */
				pDataInner.forEach(function(iLine)
				{
					for (var ii = 0; ii <= iLine.level; ii++)
					{
						// Create a custom ID based on mastery line ID and the mastery's array index
						unlockassoc[iLine.id + "_" + ii] = true;
					}
				});
				generateBank(pData);
			}).fail(function()
			{
				A.printError(A.PermissionEnum.Progression);
			});
		});
	},
	
	/*
	 * Generates the gem exchange columns in the Trading section.
	 */
	generateExchange: function()
	{
		var container = $("#accTrading");
		var rowduration = 100;
		var blurduration = 200;
		var goldsamples = $("#exgGoldSamples");
		var gemsamples = $("#exgGemSamples");
		var animateRows = function(pElements)
		{
			pElements.find("tr").each(function(i) {
				$(this).css({opacity: 0})
					.delay(i * (rowduration / 2))
					.animate({opacity: 1}, rowduration);
			});
		};
		var removeBlur = function()
		{
			setTimeout(function()
			{
				container.find(".cssBlur").removeClass("cssBlur");
			}, blurduration);
		};
		var fillExchange = function()
		{
			goldsamples.empty().html(I.cThrobber);
			gemsamples.empty().html(I.cThrobber);
			E.updateExchangeRatios(function()
			{
				goldsamples.empty();
				A.Metadata.Exchange.GoldSamples.forEach(function(iSample)
				{
					goldsamples.prepend("<tr>"
						+ "<td>" + iSample.toLocaleString() + "<img class='exgUnit' src='img/account/trading/gold_small.png' /></td>"
						+ "<td>" + E.formatCoinToGem(iSample * E.Exchange.COPPER_IN_GOLD) + "</td>"
						+ "<td>" + E.formatGemToMoney(E.convertCoinToGem(iSample * E.Exchange.COPPER_IN_GOLD)) + "</td>"
					+ "</tr>");
				});
				animateRows(goldsamples);
				
				gemsamples.empty();
				A.Metadata.Exchange.GemSamples.forEach(function(iSample)
				{
					gemsamples.prepend("<tr>"
						+ "<td>" + iSample.toLocaleString() + "<img class='exgUnit' src='img/account/trading/gem_small.png' /></td>"
						+ "<td>" + E.formatGemToCoin(iSample) + "</td>"
						+ "<td>" + E.formatGemToMoney(iSample) + "</td>"
					+ "</tr>");
				});
				animateRows(gemsamples);
			});
		};
		
		// Initialize
		I.loadImg(container);
		$("#exgGoldTitle").text(D.getPhraseOriginal("Get Coin"));
		$("#exgGemTitle").text(D.getPhraseOriginal("Get Gem"));
		fillExchange();
		
		// Custom exchange
		var goldcustom = $("#exgGoldCustom");
		var gemcustom = $("#exgGemCustom");
		var goldinput = goldcustom.find(".exgCustomInput");
		var geminput = gemcustom.find(".exgCustomInput");
		var goldoutput0 = goldcustom.find(".exgCustomOutput0");
		var goldoutput1 = goldcustom.find(".exgCustomOutput1");
		var gemoutput0 = gemcustom.find(".exgCustomOutput0");
		var gemoutput1 = gemcustom.find(".exgCustomOutput1");
		goldinput.on("input", $.throttle(Q.cSEARCH_LIMIT, function()
		{
			var val = parseInt($(this).val());
			if (val > 0)
			{
				E.updateGemInCoin(function()
				{
					goldoutput0.html(E.formatCoinToGem(val * E.Exchange.COPPER_IN_GOLD)).addClass("cssBlur");
					goldoutput1.html(E.formatGemToMoney(E.convertCoinToGem(val * E.Exchange.COPPER_IN_GOLD))).addClass("cssBlur");
					removeBlur();
				});
			}
		})).trigger("input");
		geminput.on("input", $.throttle(Q.cSEARCH_LIMIT, function()
		{
			var val = parseInt($(this).val());
			if (val > 0)
			{
				E.updateGemInCoin(function()
				{
					gemoutput0.html(E.formatGemToCoin(val)).addClass("cssBlur");
					gemoutput1.html(E.formatGemToMoney(val)).addClass("cssBlur");
					removeBlur();
				});
			}
		})).trigger("input");
		
		// Search bar to place an item's gold value into the custom gold exchange
		var itemsearch = $("#exgItemSearch");
		var itemquantity = $("#exgItemQuantity");
		var itempricetype = $("#exgItemPriceType");
		var exchangeItem = function(pPrice)
		{
			var price;
			if (pPrice)
			{
				price = pPrice;
				itemsearch.data("price", pPrice);
			}
			else
			{
				price = itemsearch.data("price");
			}
			var quantity = T.parseQuantity(itemquantity.val());
			var pricequantity = (quantity * price);
			var itemgold = (pricequantity > E.Exchange.COPPER_IN_GOLD) ? Math.ceil(pricequantity / E.Exchange.COPPER_IN_GOLD) : 1;
			goldinput.val(itemgold).trigger("input");
		};
		Q.bindItemSearch(itemsearch, {aCallback: function(pItem)
		{
			E.getPrice(pItem.id, function(pPrice)
			{
				var price = (itempricetype.prop("checked")) ? pPrice.oPriceSell : pPrice.oPriceBuy;
				exchangeItem(price);
			});
		}});
		itemquantity.change(function()
		{
			exchangeItem();
		});
		
		// Button to refresh exchange rates
		$("#exgReload").click(function()
		{
			goldinput.trigger("input");
			geminput.trigger("input");
			fillExchange();
		});
	},
	
	/*
	 * Generates the recent transactions column of the Trading section.
	 */
	generateRecent: function()
	{
		$("#trsRecentTitle").text(D.getPhraseOriginal("Recent"));
		var table = $("#trsRecentTable");
		var reloader = $("#trsRecentReload");
		var transactionsrecentlimit = 20;
		var bought, sold, combined;
		var boughtword = D.getWordCapital("bought");
		var soldword = D.getWordCapital("sold");
		
		var fillRecent = function()
		{
			var nowms = (new Date()).getTime();
			table.empty();
			reloader.removeClass("jsSuspended");
			A.adjustAccountScrollbar();
			// Get the first few transactions from the retrieved
			for (var i = 0; i < bought.length; i++)
			{
				bought[i].isBought = true;
			}
			combined = bought.concat(sold);
			U.sortObjects(combined, {aKeyName: "purchased", aIsDescending: true});
			combined = combined.slice(0, transactionsrecentlimit);
			
			combined.forEach(function(iTransaction)
			{
				var row = $("<tr></tr>").appendTo(table);
				(function(iTransaction)
				{
					Q.getItem(iTransaction.item_id, function(pItem)
					{
						var timestamp = (new Date(iTransaction.purchased)).toLocaleString();
						var type = (iTransaction.isBought) ? boughtword : soldword;
						var quantitystr = (iTransaction.quantity > 1) ? ("<var class='trsRecentCount'>" + iTransaction.quantity + "</var>") : "";
						row.html("<td>"
							+ "<span class='trsRecentItem'>"
								+ "<span class='trsRecentSlot'><img class='trsRecentIcon' src='" + pItem.icon + "' />" + quantitystr + "</span>"
								+ "<span class='trsRecentName'><var class='trsRecentType'>" + type
									+ "</var>: <var class='" + Q.getRarityClass(pItem.rarity) + "'>" + pItem.name + "</var></span>"
							+ "</span>"
							+ "<span>"
								+ "<var class='trsRecentTime' title='" + timestamp + "'>" + T.formatMilliseconds(nowms - (new Date(iTransaction.purchased)).getTime()) + "</var>"
								+ "<var class='trsRecentPrice'>" + E.formatCoinStringColored(iTransaction.quantity * iTransaction.price) + "</var>"
							+ "</span>"
						+ "</td>");
						var slot = row.find(".trsRecentSlot");
						I.qTip.init(row.find(".trsRecentTime"));
						Q.scanItem(pItem, {aElement: slot});
						Q.bindItemSlotBehavior(slot, {aItem: pItem, aWantClick: true});
					});
				})(iTransaction);
			});
		};
		var dealError = function()
		{
			table.html("<tr><td class='trsRecentError'>" + D.getPhraseOriginal("No transactions") + ".</td></tr>");
			reloader.removeClass("jsSuspended");
		};
		var retrieveTransactions = function()
		{
			table.empty().html(I.cThrobber);
			// Retrieves the first page of the historical transactions
			U.getJSON(A.getURL(A.URL.HistoryBuys), function(pData)
			{
				bought = pData;
				U.getJSON(A.getURL(A.URL.HistorySells), function(pDataInner)
				{
					sold = pDataInner;
					fillRecent();
				}, false).fail(function(){
					dealError();
				});
			}, false).fail(function(){
				dealError();
			});
		};
		
		// Initialize
		retrieveTransactions();
		reloader.click(function()
		{
			retrieveTransactions();
			$(this).addClass("jsSuspended");
		});
	},
	
	/*
	 * Generates the Trading Post overview page. This function only initializes once.
	 */
	serveTrading: function()
	{
		var dish = $("#accDish_Trading");
		if ( ! dish.data("isloaded"))
		{
			V.generateExchange();
			V.generateRecent();
			var inputs = I.bindInputSelect(dish.find("input"));
			I.qTip.init(inputs);
			dish.data("isloaded", true);
			X.rewrapCheckboxes();
		}
		else if (dish.data("token") !== A.TokenCurrent)
		{
			// If already loaded but changed account, then reload the recent transactions
			dish.data("token", A.TokenCurrent);
			$("#trsRecentReload").trigger("click");
		}
	},
	
	/*
	 * Generates gem store gallery displayed as bank tabs. Does not require account information.
	 */
	serveGem: function()
	{
		var dish = $("#accDish_Gem");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var section = "Gem";
		var container = B.createBank(dish, {
			aIsCollection: true,
			aWantCoin: false
		});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var validids = {}, availableids = {}, recordedvalues = {};
		
		// Sets the memory of a slot
		var toggleSlotAlarm = function(pSlot, pItem)
		{
			var id = pItem.id;
			var issubscribed = (pSlot.find(".bnkSlotSymbol").hasClass("bnkSlotSymbolActive"));
			if (issubscribed)
			{
				// If subscribed then unsubscribe the slot
				toggleSlotSymbol(pSlot, false);
				H.unsubscribeGem(id);
			}
			else
			{
				X.setCheckboxEnumState($("#opt_bol_alertGem"), X.ChecklistEnum.Checked); // Turn on voice alert
				H.isGemPaused = false;
				if (availableids[id])
				{
					// Subscribing to an available item will alert for discounted condition
					H.subscribeGemDiscounted(id);
					I.write(U.escapeHTML(pItem.name) + D.getPhraseOriginal(" is available - Alarm when item is discount"));
				}
				else
				{
					// Subscribing to an unavailable item will alert for available condition
					H.subscribeGemAvailable(id);
					I.write(U.escapeHTML(pItem.name) + D.getPhraseOriginal(" is not available - Alarm when item is available"));
				}
				toggleSlotSymbol(pSlot, true);
			}
			
			// Save to storage
			H.saveGemSubscription();
		};
		
		// Sets the appearance of a slot
		var toggleSlotSymbol = function(pSlot, pState, pItem)
		{
			if (pSlot)
			{
				var symbol = pSlot.find(".bnkSlotSymbol");
				symbol.removeClass("bnkSlotSymbolActive");
				if (pState)
				{
					symbol.addClass("bnkSlotSymbolActive");
					pSlot.data("ismarked", true);
				}
				else
				{
					pSlot.data("ismarked", false);
				}
			}
			else
			{
				// If did not provide a slot then consider as a wipe all command
				bank.find(".bnkSlotSymbol").removeClass("bnkSlotSymbolActive");
				bank.find(".bnkSlot").data("ismarked", false);
			}
			if (pItem)
			{
				var value = recordedvalues[pItem.id];
				var salevalue = H.Sale.Values[pItem.id];
				if (value !== undefined && salevalue >= 0)
				{
					pSlot.data("ismarked", true);
					if (salevalue < Math.abs(value) || salevalue === 0)
					{
						pSlot.addClass("bnkSlotDiscount");
						// Show pre-discounted gem price when hovered
						pSlot.append("<var class='bnkSlotPriceBuy'>" + E.formatGemString(Math.abs(value), true) + "</var>");
					}
					else if (salevalue)
					{
						pSlot.addClass("bnkSlotAvailable");
					}
				}
			}
		};
		
		var doGenerate = function()
		{
			// An item is "unlocked" if it is available on the gem store, which is a positive-number gem payment
			var record = U.getRecordData(section);
			A.iterateRecord(record, function(pEntry)
			{
				var id = pEntry.i;
				validids[id] = true;
				pEntry.u = id; // The item's ID is its unlock ID
				var payment = pEntry.p;
				var salevalue = H.Sale.Values[id];
				if (payment)
				{
					for (var i in payment)
					{
						recordedvalues[id] = payment[i];
						if (salevalue >= 0 && salevalue <= Math.abs(payment[i])) // Items being promoted overrides the payment value of the record's
						{
							payment[i] = salevalue;
							availableids[id] = true;
						}
						if (payment[i] <= 0)
						{
							// Negative price signifies it is unavailable, restore the positive price after iterating
							payment[i] = -1 * payment[i];
						}
						else
						{
							// Positive price signifies it is available
							availableids[id] = true;
						}
						break; // Consider only the first payment type
					}
				}
			});
			// Erase entries in the subscription that do not exist in the gem record
			for (var i in H.GemSubscription)
			{
				if (validids[i] === undefined)
				{
					delete H.GemSubscription[i];
				}
			}
			
			// Fill the "bank"
			B.generateUnlockables(bank, {
				aHeaders: U.getRecordHeader(section),
				aRecord: record,
				aUnlockeds: availableids,
				aWantGemConvert: true,
				aWantDefaultHelp: false,
				aWantSearchHighlight: false,
				aBind: function(pSlot, pItem)
				{
					var id = pItem.id;
					var symbol = $("<img class='bnkSlotSymbol curToggle' src='img/ui/menu/alarm.png' />").appendTo(pSlot);
					toggleSlotSymbol(pSlot, H.isGemSubscribed(id), pItem);
					symbol.click(function(pEvent)
					{
						pEvent.stopPropagation();
						toggleSlotAlarm(pSlot, pItem);
					});
				}
			});
			
			// Button to clear all subscriptions
			var controller = $("<div class='cssCenter'></div>").prependTo(dish);
			var dishmenu = $("#accDishMenu_Gem");
			$("<button class='accButton'>" + D.getPhraseOriginal("Help") + "</button>").appendTo(controller).click(function()
			{
				dishmenu.find(".bnkButtonHelp").trigger("click");
			});
			$("<button class='accButton curToggle'>" + D.getPhraseOriginal("View Subscription") + "</button>").appendTo(controller).click(function()
			{
				dishmenu.find(".bnkButtonEmpty").trigger("click").trigger("click"); // Cycle to the tier that shows marked slots
			});
			$("<button class='accButton'>" + D.getPhraseOriginal("Clear Subscription") + "</button>").appendTo(controller).click(function()
			{
				if (confirm("Delete all gem store subscriptions?"))
				{
					I.write(D.getPhraseOriginal("Gem alarm and subscription off"));
					H.initializeGemSubscription(true);
					X.setCheckboxEnumState($("#opt_bol_alertGem"), X.ChecklistEnum.Unchecked); // Turn off voice alert
					toggleSlotSymbol();
				}
			});
		};
		
		H.updateGemSubscription(function()
		{
			Q.loadItemsSubdatabase(section.toLowerCase(), function()
			{
				doGenerate();
			});
		});
	},
	
	/*
	 * Creates the bank of historical API items.
	 */
	serveMuseum: function()
	{
		var dish = $("#accDish_Museum");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var container = B.createBank(dish, {
			aIsCollection: true,
			aWantGem: false
		});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		
		U.getScript(U.URL_DATA.Museum, function()
		{
			B.generateUnlockables(bank, {
				aRecord: U.getRecordData("Museum"),
				aIsCollapsed: true,
				aWantSearchHighlight: false,
				aWantDefaultHelp: false
			});
			// Open the first tab, leaving the rest collapsed
			setTimeout(function()
			{
				dish.find(".bnkTabSeparator").first().trigger("click");
			}, 400);
		});
	},
	
	/*
	 * Generates Pact Supply history and statistics.
	 */
	servePact: function()
	{
		var dish = $("#accDish_Pact");
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		$("<div id='pctBank'></div>"
			+ "<div id='pctStatistics' data-date='2015-2016'>"
				+ "<div class='bnkTitle cssCenter'>Statistics</div><br />"
				+ "<table id='pctStatTable'></table>"
			+ "</div>").appendTo(dish);
		
		var section = "Pact";
		var container = B.createBank($("#pctBank"));
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var tab, slotscontainer, slot;
		var numfetched = 0;
		var numtofetch = 0;
		
		var history, products = H.Pact.Products;
		var occurnums = {}, occurdates = {}, highestoccur = 0, highestprice = 0;
		U.convertExternalLink("#accDish_Pact a");
		var generateStatistics = function()
		{
			var stat = $("#pctStatTable").append("<tr class='pctTableHeader'><th></th><th>Occurrence</th><th>Recipe</th><th>Price</th><th></th></tr>");
			for (var i in products)
			{
				Q.getItem(products[i], function(pItem)
				{
					var name = U.escapeHTML(pItem.name);
					var priceobj = E.Pricelist[i];
					var pricevalue = (priceobj) ? priceobj.oPriceSell : 0;
					var pricestr = ((priceobj) ? E.formatCoinStringColored(priceobj.oPriceSell)
						: E.formatKarmaString(H.Pact.Prices[i] || H.Pact.PriceDefault));
					stat.append("<tr class='pctStatRow cssStats'>"
						+ "<td class='pctStatCount' data-value='" + occurnums[i] + "'>" + occurnums[i] + "</td>"
						+ "<td data-value='" + occurnums[i] +  "'>" + I.getBar((occurnums[i] / highestoccur) * T.cPERCENT_100, true) + "</td>"
						+ "<td class='pctStatName' data-value='" + name + "' title='" + occurdates[i] + "'>"
							+ "<a class='" + Q.getRarityClass(pItem.rarity) + "'" + U.convertExternalAnchor(U.getTradingItemLink(i, pItem.name)) + "'>" + name + "</a></td>"
						+ "<td data-value='" + pricevalue + "'>" + I.getBar((((priceobj) ? priceobj.oPriceSell : 0) / highestprice) * T.cPERCENT_100) + "</td>"
						+ "<td class='pctStatPrice' data-value='" + pricevalue + "'>" + pricestr + "</td>"
					+ "</tr>");
				});
			}
			I.qTip.init(".pctStatName");
			I.bindSortableTable(stat, {aPresortColumn: 4});
		};
		
		var doGenerate = function()
		{
			history = GW2T_PACT_DATA;
			// Count occurences
			for (var i in history)
			{
				var day = history[i];
				var dayoccur = {};
				for (var ii = 0; ii < day.length; ii++)
				{
					var id = day[ii];
					if (occurnums[id] === undefined) // Initialize occurence entry for this item ID
					{
						occurnums[id] = 0;
						occurdates[id] = "";
					}
					if (dayoccur[id] === undefined) // Prevent counting of multiple offers of the same item in a day
					{
						occurnums[id]++;
						occurdates[id] += i + "<br />";
						dayoccur[id] = true;
					}
					if (occurnums[id] > highestoccur)
					{
						highestoccur = occurnums[id];
					}
				}
			}
			// Count the number of items in the bank first, because empty slots are written as "null" in the API
			var itemids = [];
			for (var i in products)
			{
				itemids.push(i);
				itemids.push(products[i]);
			}
			numtofetch = itemids.length;
			Q.getPricedItems(itemids, function()
			{
				// First generate empty bank slots, then fill them up asynchronously by item details retrieval
				bank.empty();
				tab = B.createBankTab(bank, {
					aTitle: $("#pctStatistics").attr("data-date")
				});
				slotscontainer = B.getSlotsContainer(tab);
				for (var i = 0; i < itemids.length; i++)
				{
					var itemid = itemids[i];
					var count = occurnums[itemid] || 1;
					slot = B.createBankSlot(slotscontainer);
					slot.data("count", 1);
					(function(iSlot, iSlotData)
					{
						Q.getItem(iSlotData.id, function(iItem)
						{
							B.styleBankSlot(iSlot, {aItem: iItem, aSlotMeta: iSlotData, aCallback: function()
							{
								numfetched++;
								A.setProgressBar(numfetched, numtofetch);
							}});
						});
					})(slot, {id: itemid, count: -count});
					if (occurnums[itemid])
					{
						E.getPriceObject(itemid, function(pPrice)
						{
							if (pPrice && pPrice.oPriceSell > highestprice)
							{
								highestprice = pPrice.oPriceSell;
							}
						});
					}
				}
				// Update tallies
				B.tallyBank(container);
				// Create search bar
				B.createBankMenu(bank, {
					aIsCollection: true
				});
				generateStatistics();
			});
		};
		
		U.getScript(U.URL_DATA.Pact, function()
		{
			Q.loadItemsSubdatabase(section.toLowerCase(), function()
			{
				doGenerate();
			});
		});
	},
	
	/*
	 * Generates the Trading Post transactions page.
	 */
	serveBuying: function()
	{
		B.generateTransactions("Buying", A.URL.CurrentBuys);
	},
	serveSelling: function()
	{
		B.generateTransactions("Selling", A.URL.CurrentSells);
	},
	serveBought: function()
	{
		B.generateTransactions("Bought", A.URL.HistoryBuys);
	},
	serveSold: function()
	{
		B.generateTransactions("Sold", A.URL.HistorySells);
	}
};
B = {
/* =============================================================================
 * @@Bank window, tab, item slot, catalog, and transactions generation
 * ========================================================================== */

	/*
	 * Creates a bank container element.
	 * @param jqobject pDestination to append bank.
	 * @objparam string aTitle of the bank, optional.
	 * @objparam string aID HTML ID for the container.
	 * @objparam string aClass CSS style class for bank element, optional.
	 * @objparam boolean aIsCollection whether the bank is an unlock collection, which will show untaxed prices, optional
	 * @objparam boolean aWantCoin whether to display the coin tally, optional.
	 * @objparam boolean aWantGem whether to display the gem tally, optional.
	 * @objparam int aSlotsPerRow to resize the bank beforehand, optional.
	 * @returns jqobject bank.
	 */
	createBank: function(pDestination, pSettings)
	{
		var Settings = pSettings || {};
		if (Settings.aIsPseudo)
		{
			Settings.aIsCollection = true;
			Settings.aWantGem = false;
		}
		
		var container = $("<div " + ((Settings.aID) ? "id='" + Settings.aID + "'" : "") + " class='bnkContainer'>"
			+ "<div class='bnkTop'>"
				+ ((Settings.aTitle) ? "<aside class='bnkTitle'>" + Settings.aTitle + "</aside>" : "")
				+ "<aside class='bnkBankTally'></aside>"
				+ ((Settings.aWantCoin !== false) ? ("<aside class='bnkPrice'>"
					+ "<var class='bnkPriceTitleA'></var><var class='bnkPriceValueA_Coin'></var>"
					+ " &nbsp; "
					+ "<var class='bnkPriceTitleB'></var><var class='bnkPriceValueB_Coin'></var>"
				+ "</aside>") : "")
				+ ((Settings.aIsCollection && Settings.aWantGem !== false) ? ("<aside class='bnkGem'>"
					+ "<var class='bnkPriceTitleA'></var><var class='bnkPriceValueA_Gem'></var>"
					+ " &nbsp; "
					+ "<var class='bnkPriceTitleB'></var><var class='bnkPriceValueB_Gem'></var>"
				+ "</aside>") : "")
			+ "</div>"
		+ "</div>").appendTo(pDestination);
		var bank = $("<div class='bnkBank " + (Settings.aClass || "") + "'></div>").appendTo(container);
		bank.css({width: ((Settings.aSlotsPerRow || A.Metadata.Bank.NumSlotsHorizontal) * B.getBankSlotWidth()) + "px"});

		if (Settings.aIsCollection)
		{
			var strunlocked = D.getWordCapital("unlocked") + ": +";
			var strlocked = D.getWordCapital("locked") + ": −";
			container.data("iscollection", true);
			container.find(".bnkPriceTitleA").html(strunlocked);
			container.find(".bnkPriceTitleB").html(strlocked);
			container.find(".bnkPriceValueA_Coin").html(E.formatCoinStringColored(0));
			container.find(".bnkPriceValueB_Coin").html(E.formatCoinStringColored(0));
			container.find(".bnkPriceValueA_Gem").html(E.formatGemString(0, true));
			container.find(".bnkPriceValueB_Gem").html(E.formatGemString(0, true));
		}

		return container;
	},
	getBankContainer: function(pBank)
	{
		return pBank.closest(".bnkContainer");
	},
	getTabsContainer: function(pContainer)
	{
		return pContainer.find(".bnkBank");
	},
	createBankDivider: function(pContainer)
	{
		pContainer.append("<div class='bnkDivider'></div>");
	},
	
	/*
	 * Gets the bank slot's current desired width.
	 * @param boolean pBoolean used if called from the bank buttons rather than creation.
	 * @returns boolean true if currently want smaller slots.
	 */
	getBankSlotWidth: function(pBoolean)
	{
		var boolean = (pBoolean !== undefined) ? pBoolean : O.Options.bol_condenseBank;
		return (boolean) ? A.Metadata.Bank.SlotWidthCondensed : A.Metadata.Bank.SlotWidth;
	},
	
	/*
	 * Creates a standard bank window tab that holds item slots, and a separator
	 * that toggles the tab.
	 * @param jqobject pBank container of tabs.
	 * @objparam string aTitle for tab header title.
	 * @objparam string aIcon HTML for tab header icon, optional.
	 * @objparam boolean aWantPrepend to place the tab on top, optional.
	 * @objparam boolean aIsCollapsed whether the tab is pre-collapsed, for tabs
	 * that generate slots on demand, optional.
	 * @returns jqobject bank tab.
	 */
	createBankTab: function(pBank, pSettings)
	{
		var Settings = pSettings || {};
		
		var tab = $("<div class='bnkTab'></div>");
		var iconstr = (Settings.aIcon) ? Settings.aIcon : "";
		var titlestr = (Settings.aTitle) ? "<var class='bnkTabText'>" + Settings.aTitle + "</var>" : "";
		var tabseparator = $("<div class='bnkTabSeparator curToggle'>"
			+ "<aside class='bnkTabHeader'>"
				+ iconstr
				+ titlestr
				+ "<var class='bnkTabPrice bnkTabPrice_Coin'></var>"
				+ "<var class='bnkTabPrice bnkTabPrice_Gem'></var>"
				+ "<var class='bnkTabToggle'></var>"
				+ "<var class='bnkTabTally'></var>"
			+ "</aside>"
		+ "</div>").appendTo(tab);
		var tabtoggle = tabseparator.find(".bnkTabToggle");
		var tabslots = $("<div class='bnkTabSlots'></div>").appendTo(tab);
		
		tabseparator.click(function()
		{
			B.toggleBankTab(tab);
		});
		if (Settings.aID)
		{
			tab.attr("id", Settings.aID);
		}
		if (Settings.aIsCollapsed)
		{
			I.toggleToggleIcon(tabtoggle, false);
			tabslots.hide();
		}
		if (Settings.aIsCustomCatalog)
		{
			B.placeCatalogTab(pBank, tab, Settings.aWantPrepend);
		}
		else if (Settings.aWantPrepend)
		{
			pBank.prepend(tab);
		}
		else
		{
			pBank.append(tab);
		}
		return tab;
	},
	getSlotsContainer: function(pElement)
	{
		return pElement.find(".bnkTabSlots");
	},
	
	/*
	 * Toggles a bank tab which contains slots.
	 * @param jqobject pTab a single tab or a bank for toggling all tabs.
	 * @param boolean pBoolean
	 * @param boolean pIsExclusive whether to show only one tab at a time, optional.
	 */
	toggleBankTab: function(pTab, pBoolean, pIsExclusive)
	{
		var tab = (pTab.hasClass("bnkBank")) ? pTab.find(".bnkTab") : pTab;
		var tabslots = B.getSlotsContainer(tab);
		var state = (typeof pBoolean === "boolean") ? pBoolean : !(tabslots.is(":visible"));
		
		if (state)
		{
			if (pIsExclusive)
			{
				// One time recursive call to hide all tabs, then show the desired tab
				B.toggleBankTab(tab.closest(".bnkBank"), false);
			}
			tabslots.slideDown("fast", function()
			{
				A.adjustAccountScrollbar();
			});
		}
		else
		{
			tabslots.slideUp("fast", function()
			{
				A.adjustAccountScrollbar();
			});
		}
		// Also change the toggle icon
		I.toggleToggleIcon(tab.find(".bnkTabToggle"), state);
	},
	showBankTab: function(pTab)
	{
		if (B.getSlotsContainer(pTab).is(":visible") === false)
		{
			pTab.find(".bnkTabSeparator").trigger("click");
		}
	},
	
	/**
	 * Macro function for bank search bar, to scroll to a tab and refreshes the
	 * search, assuming an item was found in the search results.
	 * @param jqobject pTab
	 */
	scrollToBankTab: function(pTab)
	{
		var tab = $(pTab);
		B.showBankTab(tab);
		// First scroll to the tab
		I.scrollToElement(tab, {
			aOffset: -A.getOverheadHeight(),
			aSpeed: "fast"
		});
		// Scroll tab again after it's assumed that content have been downloaded and generated
		setTimeout(function()
		{
			I.scrollToElement(tab, {
				aOffset: -A.getOverheadHeight()
			});
			B.refreshBankSearch(A.getDishName(tab));
		}, 2000);
	},
	
	/*
	 * Creates a divider between tabs in a bank.
	 * @param jqobject pBank container.
	 * @param string pHTML within the divider, optional.
	 */
	createTabDivider: function(pBank, pSettings)
	{
		var Settings = pSettings || {};
		
		var titlestr = (Settings.aTitle) ? "<var class='bnkTabDividerText'>" + Settings.aTitle + "</var>" : "";
		$("<div class='bnkTabDivider'>"
			+ "<aside class='bnkTabHeader'>"
				+ titlestr
			+ "</aside>"
		+ "</div>").appendTo(pBank);
	},
	
	/*
	 * Gets the tally numbers on the tab header of how many slots are filled.
	 * @param int pFilled number of filled slots
	 * @param int pCapacity number of slots the tab has.
	 * @param int pCount number of items summed from all slots, optional.
	 */
	getTallyString: function(pFilled, pCapacity, pCount)
	{
		var acquiredstr = (pCount) ? (" " + pCount + I.Symbol.Quantity) : "";
		var ratio = pFilled / pCapacity;
		var ratioclass = (ratio === 1) ? "accSignificant" : "accTrivial";
		var remaining = (ratio === 1) ? "" : ("<span class='accTrifle'>" + (pCapacity - pFilled) + "+</span>");
		return remaining + pFilled + " / " + pCapacity
			+ "<span class='" + ratioclass + "'> (" + U.convertRatioToPercent(ratio) + ")" + acquiredstr + "</span>";
	},
	updateTabTally: function(pElement, pFilled, pCapacity, pCount)
	{
		pElement.find(".bnkTabTally").html(B.getTallyString(pFilled, pCapacity, pCount));
	},
	updateBankTally: function(pElement, pFilled, pCapacity, pCount)
	{
		pElement.find(".bnkBankTally").html(B.getTallyString(pFilled, pCapacity, pCount));
	},
	
	/*
	 * Updates the tally of every tabs in a bank, and of the bank itself.
	 * Not to be used with unlockables because those banks may have on demand tab generation.
	 * @param jqobject pContainer of the bank.
	 */
	tallyBank: function(pContainer)
	{
		var itemsinbank = 0;
		var bankfill = 0;
		var bankcapacity = 0;
		var iscollection = pContainer.data("iscollection");
		B.getSlotsContainer(pContainer).each(function()
		{
			var tab = $(this).parent();
			var itemsintab = 0;
			var tabfill = 0;
			var tabcapacity = 0;
			var precount = tab.data("tabcount");
			var prefill = tab.data("tabfill");
			var precapacity = tab.data("tabcapacity");
			
			if (prefill !== undefined)
			{
				itemsintab += precount;
				itemsinbank += precount;
				tabfill += prefill;
				tabcapacity = precapacity;
			}
			else
			{
				var slots = $(this).find(".bnkSlot");
				slots.each(function()
				{
					var count = $(this).data("count");
					if (count)
					{
						// Sum slot
						itemsintab += count;
						itemsinbank += count;
						tabfill++;
					}
				});
				tabcapacity = slots.length;
			}
			if (iscollection)
			{
				itemsintab = 0;
			}
			// Tally tab
			B.updateTabTally(tab, tabfill, tabcapacity, itemsintab);
			// Sum tab
			bankfill += tabfill;
			bankcapacity += tabcapacity;
		});
		// Tally bank
		if (iscollection)
		{
			itemsinbank = 0;
		}
		B.updateBankTally(pContainer, bankfill, bankcapacity, itemsinbank);
	},
	
	/*
	 * Creates a vertical bar that holds bags on the left side of a bank tab.
	 * @param jqobject pTab to append.
	 * @param objarray pBags from characters API.
	 */
	createInventorySidebar: function(pTab, pBagsData)
	{
		if (pBagsData === undefined)
		{
			return;
		}
		
		pTab.addClass("bnkTabInventory");
		var sidebarcontainer = $("<div class='bnkSidebarContainer'></div>").prependTo(pTab);
		var sidebar = $("<div class='bnkSidebar'></div>").prependTo(sidebarcontainer);
		$("<div class='bnkSidebarBorder'></div>").appendTo(sidebarcontainer);
		var bagscolumn = $("<div class='bnkSidebarColumn'></div>").appendTo(sidebar);
		var bagouter, bag;
		pBagsData.forEach(function(iBagData)
		{
			if (iBagData)
			{
				// Count the number of items the bag is holding
				var bagfill = 0;
				for (var i = 0; i < iBagData.inventory.length; i++)
				{
					if (iBagData.inventory[i])
					{
						bagfill++;
					}
				}
				// Create the bag icon
				bagouter = $("<div class='bnkSidebarBagOuter'></div>").appendTo(bagscolumn);
				bag = $("<span class='bnkSidebarBag'><var class='bnkSidebarBagCount'>" + bagfill + "/" + iBagData.size + "</var></span>").appendTo(bagouter);
				(function(iBag)
				{
					Q.getItem(iBagData.id, function(iItem)
					{
						iBag.css({backgroundImage: "url(" + iItem.icon + ")"});
						Q.scanItem(iItem, {aElement: iBag});
						Q.bindItemSlotBehavior(iBag, {aItem: iItem, aWantClick: true});
					});
				})(bag);
			}
			else
			{
				// For ununused bag slots (no bag placed in the sidebar slot)
				bagouter = $("<div class='bnkSidebarBagOuter'></div>").appendTo(bagscolumn);
				bag = $("<span class='bnkSidebarBag'><var class='bnkSidebarBagCount'></var></span>").appendTo(bagouter);
			}
		});
	},
		
	/*
	 * Inserts a standard inventory slot for use in inventory, bank, materials,
	 * and other windows. Uses native DOM manipulation for performance.
	 * @param jqobject pSlotContainer of a tab.
	 * @param string pClass to change the slot style.
	 * @returns jqobject slot.
	 */
	createBankSlot: function(pSlotContainer, pClass)
	{
		var slot = document.createElement("span");
		slot.innerHTML = "<var class='bnkSlotBackground " + (pClass || "") + "'></var>"
			+ "<var class='bnkSlotIcon'></var>"
			+ "<var class='bnkSlotForeground'></var>";
		slot.className = "bnkSlot";
		pSlotContainer[0].appendChild(slot);
		return $(slot);
	},
	createPseudoSlot: function(pSlotContainer, pSettings)
	{
		// Pseudo slot does not contain a game item
		var Settings = pSettings || {};
		
		var slot = B.createBankSlot(pSlotContainer);
		var count = 0;
		
		if (Settings.aID)
		{
			slot.attr("id", Settings.aID);
		}
		if (Settings.aName)
		{
			slot.click(function(pEvent)
			{
				if (pEvent.which === I.ClickEnum.Left)
				{
					U.openExternalURL(U.getWikiSearchDefault(Settings.aName));
				}
			});
		}
		if (Settings.aTooltip)
		{
			slot.attr("title", Settings.aTooltip);
			I.qTip.init(slot);
		}
		if (Settings.aIcon)
		{
			slot.find(".bnkSlotIcon").css({backgroundImage: "url(" + Settings.aIcon + ")"});
		}
		if (!Settings.aIsUnlocked)
		{
			slot.addClass("bnkSlotZero");
		}
		if (Settings.aIsUnlocked)
		{
			count = Settings.aCount || 1;
		}
		if (Settings.aCount !== undefined)
		{
			slot.append("<var class='bnkSlotCount'>" + Settings.aCount + "</var>");
		}
		if (Settings.aLabel)
		{
			slot.append("<var class='bnkSlotLabel'>" + Settings.aLabel + "</var>");
		}
		if (Settings.aPayment)
		{
			for (var i in Settings.aPayment)
			{
				B.updateSlotPrice(slot, {
					aIsTab: Settings.aIsTab,
					aPrice: Settings.aPayment[i],
					aPossible: Settings.aPossible,
					aCount: count,
					aPaymentEnum: i
				});
			}
		}
		if (Settings.aCard)
		{
			slot.after("<span class='bnkCard itmTooltip cssTooltip'>" + Settings.aCard + "</span>");
		}
		
		slot.data("keywords", $("<div>" + (Settings.aKeywords || Settings.aTooltip || "").toLowerCase() + "</div>").text());
		slot.data("count", count);
		return slot;
	},
	createBankCard: function(pSlotContainer, pSettings)
	{
		// Bank "slots" that are tooltip blocks inserted into the bank
		var Settings = pSettings || {};
		var slot = document.createElement("span");
		slot.innerHTML = Settings.aHTML;
		slot.className = "bnkCard";
		pSlotContainer[0].appendChild(slot);
		return $(slot);
	},
	
	/*
	 * Styles a standard inventory slot and prepare it for search.
	 * @param jqobject pSlot to style.
	 * @objparam object aSlotMeta data retrieved from characters or bank API,
	 * containing stack count and transmutation data.
	 * @objparam object aItem item details retrieved from API.
	 * @objparam int aTradeableID ID of item to get TP price, such as the tradeable container of the bound item, optional.
	 * @objparam int aPrice custom coin price for untradeable items, optional.
	 * @objparam int aGem custom gem price for untradeable items, optional.
	 * @objparam boolean aWantGemConvert whether to convert gem to coin for hover price display, optional.
	 * @objparam string aComment to append to tooltip, optional.
	 * @objparam string aLabel to append to slot label, optional.
	 * @objparam string aWiki name of wiki article to open when double clicked, optional.
	 * @objparam function aCallback to execute after styling.
	 * @objparam function aPriceCallback to execute after fetching the item price, optional.
	 * @objparam function aBind for custom slot behavior binding, must manually
	 * unbind click event, can be used a slot iterator, optional.
	 */
	styleBankSlot: function(pSlot, pSettings)
	{
		var Settings = pSettings || {};
		if (pSettings)
		{
			var count = 1, pricecount = 1;
			if (Settings.aSlotMeta.count >= 0)
			{
				count = Settings.aSlotMeta.count;
				pricecount = count;
			}
			// Negative "count" is regarded as 1 for price, and visually as the positive count
			else if (Settings.aSlotMeta.count < 0)
			{
				count = Settings.aSlotMeta.count * -1;
				pricecount = 1;
			}
			var itemmeta = null;
			var validmeta = {
				upgrades: true, infusions: true, skin: true, bound_to: true
			};
			for (var i in Settings.aSlotMeta)
			{
				if (validmeta[i])
				{
					itemmeta = Settings.aSlotMeta;
					break;
				}
			}
			
			Q.scanItem(Settings.aItem, {
				aElement: pSlot,
				aItemMeta: itemmeta,
				aComment: Settings.aComment,
				aCallback: function(pBox)
			{
				// Load retrieved proper transmuted icon if available
				var icon = (pBox.oSkin) ? pBox.oSkin.icon : Settings.aItem.icon;
				pSlot.find(".bnkSlotIcon").css({backgroundImage: "url(" + icon + ")"}).addClass("bnkSlotRarity_" + Settings.aItem.rarity);
				// Make the item searchable by converting its tooltip HTML into plain text
				var keywords = ($(pBox.oHTML).text() + " " + D.getString(Settings.aItem.rarity)).toLowerCase();
				pSlot.data("keywords", keywords);
				pSlot.data("itemid", Settings.aItem.id);
				if (itemmeta && itemmeta.skin)
				{
					pSlot.data("skinid", itemmeta.skin);
				}
				// Bind slot click behavior
				var wikisearch = Settings.aWiki || Settings.aItem.name;
				var searchurl = (Settings.aWiki) ? U.getWikiSearchDefault(wikisearch) : U.getWikiSearchLanguage(wikisearch);
				pSlot.click(function(pEvent)
				{
					if (pEvent.which === I.ClickEnum.Left)
					{
						U.openExternalURL(searchurl);
					}
				});
				if (Settings.aBind)
				{
					Settings.aBind(pSlot, Settings.aItem);
				}
				else if (Settings.aIsCustomCatalog)
				{
					B.bindCatalogSlot(pSlot);
				}
				Q.bindItemSlotBehavior(pSlot, {
					aItem: Settings.aItem,
					aTradeableID: Settings.aTradeableID,
					aSearch: wikisearch
				});
				// Custom label over the slot icon, if available
				if (Settings.aLabel && Settings.aLabel.length)
				{
					pSlot.append("<var class='bnkSlotLabel'>" + Settings.aLabel + "</var>");
				}
				// Numeric label over the slot icon indicating stack size or charges remaining
				if (count > 1)
				{
					// Stack size
					var countmaxclass = (count % Q.GameLimit.StackSize === 0) ? "bnkSlotCountMax" : "";
					pSlot.append("<var class='bnkSlotCount " + countmaxclass + "'>" + count + "</var>");
				}
				else if ((Settings.aItem.type === "Tool" || Settings.aItem.type === "Gathering") && Settings.aSlotMeta && Settings.aSlotMeta.charges)
				{
					// Remaining charges
					pSlot.append("<var class='bnkSlotCount'>" + Settings.aSlotMeta.charges + "</var>");
				}
				// Fade the slots that act as collections
				if (count === 0)
				{
					pSlot.addClass("bnkSlotZero");
					pSlot.data("count", count);
				}
				else
				{
					// Assign count data for the hide empty slots filter
					pSlot.data("count", count);
				}
				// Custom price has priority over TP price
				if (Settings.aPrice > 0)
				{
					B.updateSlotPrice(pSlot, {
						aPrice: Settings.aPrice,
						aCount: pricecount,
						aPaymentEnum: E.PaymentEnum.Coin
					});
				}
				else if (Settings.aGem > 0)
				{
					B.updateSlotPrice(pSlot, {
						aPrice: Settings.aGem,
						aCount: pricecount,
						aPaymentEnum: E.PaymentEnum.Gem,
						aWantGemConvert: Settings.aWantGemConvert
					});
				}
				else if (pBox.oIsTradeable || Settings.aTradeableID)
				{
					// Add the boolean for the bank filter button to look for
					pSlot.addClass("bnkSlotTradeable");
					pSlot.data("istradeable", true);
					var itemidforprice = Settings.aTradeableID || Settings.aItem.id;
					E.getPriceObject(itemidforprice, function(pPrice)
					{
						B.updateSlotPrice(pSlot, {
							aPrice: pPrice,
							aCount: pricecount,
							aPaymentEnum: E.PaymentEnum.Coin,
							aTransactionBuy: Settings.aTransactionBuy,
							aTransactionSell: Settings.aTransactionSell
						});
						if (Settings.aPriceCallback)
						{
							Settings.aPriceCallback(pPrice);
						}
					});
				}
				// Execute callback if requested
				if (Settings.aCallback)
				{
					Settings.aCallback();
				}
			}});
		}
		else
		{
			// Empty slot gets keywords anyway for use in search
			pSlot.data("keywords", "*");
		}
	},
	
	/*
	 * Updates the price displayed over the bank slot, the bank tab, and bank top.
	 * @param jqobject pSlot for price label.
	 * @objparam int or object aPrice amount or processed object by the get price function.
	 * @objparam int aPossible the max possible price, optional.
	 * @objparam int aTransactionBuy of a transaction, optional.
	 * @objparam int aTransactionSell of a transaction, optional.
	 * @objparam int aCount of items.
	 * @objparam enum aPaymentEnum such as coin or gem.
	 * @objparam boolean aWantGemConvert whether to convert gem to coin for hover price display, optional.
	 */
	updateSlotPrice: function(pSlot, pSettings)
	{
		var Settings = pSettings || {};
		
		var elementsuffix = (E.PaymentEnum[Settings.aPaymentEnum]) ? Settings.aPaymentEnum : E.PaymentEnum.Coin;
		var container = B.getBankContainer(pSlot);
		var top = container.find(".bnkTop");
		var iscollection = container.data("iscollection");
		var tabdisplayprice = ((Settings.aIsTab) ? pSlot : pSlot.closest(".bnkTab")).find(".bnkTabPrice_" + elementsuffix);
		
		var count = (Settings.aPossible !== undefined) ? 1 : (Settings.aCount || 1);
		var prices = (typeof Settings.aPrice === "number") ?
			((Settings.aPaymentEnum) ? E.createPricePlain(Settings.aPrice, count) : E.createPrice(Settings.aPrice, count))
			: E.recountPrice(Settings.aPrice, count);
		var pricetorecord = (iscollection || Settings.aPaymentEnum) ? prices.oPriceSell : prices.oPriceSellTaxed;
		
		if (Settings.aTransactionBuy)
		{
			prices = E.createPrice(Settings.aTransactionBuy);
			pricetorecord = prices.oPriceBuy;
		}
		else if (Settings.aTransactionSell)
		{
			prices = E.createPrice(Settings.aTransactionSell);
			pricetorecord = prices.oPriceSellTaxed;
		}
		
		var updatePriceDisplay = function(pDisplay, pLeft, pRight, pIsCollectionTab)
		{
			var displaypriceleft = (pDisplay.data("priceleft") || 0) + pLeft;
			var displaypriceright = (pDisplay.data("priceright") || 0) + pRight;
			pDisplay.data("priceleft", displaypriceleft).data("priceright", displaypriceright);
			var tabtext, pricestrleft, pricestrright;
			switch (Settings.aPaymentEnum)
			{
				case E.PaymentEnum.Coin: {
					pricestrleft = E.formatCoinStringShort(displaypriceleft);
					pricestrright = E.formatCoinStringShort(displaypriceright);
					tabtext = (pIsCollectionTab) ? ("+" + pricestrleft + " −" + pricestrright) : (pricestrright + " <span class='accTrivial'>" + pricestrleft + "</span>");
				}; break;
				case E.PaymentEnum.Gem: {
					pricestrleft = E.formatGemString(displaypriceleft, true);
					pricestrright = E.formatGemString(displaypriceright, true);
					tabtext = (pIsCollectionTab) ? ("+" + pricestrleft + " −" + pricestrright) : (pricestrright);
				}; break;
				default: {
					pricestrleft = E.PaymentFormat[Settings.aPaymentEnum](displaypriceleft, true);
					pricestrright = E.PaymentFormat[Settings.aPaymentEnum](displaypriceright, true);
					tabtext = (pIsCollectionTab) ? ("+" + pricestrleft + " −" + pricestrright) : (pricestrright);
				}
			}
			pDisplay.html(tabtext);
		};
		
		// Label the slot with the item's or stack's price
		if (Settings.aIsTab !== true)
		{
			switch (Settings.aPaymentEnum)
			{
				case E.PaymentEnum.Coin: {
					pSlot.append("<var class='bnkSlotPrice'>" + E.formatCoinStringSlot(pricetorecord) + "</var>");
					if (pSlot.data("istradeable"))
					{
						var priceone = (typeof Settings.aPrice === "number") ? E.createPrice(Settings.aPrice, 1) : E.recountPrice(Settings.aPrice, 1);
						pSlot.append("<var class='bnkSlotPriceBuy'>" + E.formatCoinStringSlot(priceone.oPriceBuy) + "</var>");
						pSlot.append("<var class='bnkSlotPriceSell'>" + E.formatCoinStringSlot(priceone.oPriceSell) + "</var>");
					}
				}; break;
				case E.PaymentEnum.Gem: {
					pSlot.append("<var class='bnkSlotPrice'>" + E.formatGemString(pricetorecord, true) + "</var>");
					if (Settings.aCount > 1)
					{
						pSlot.append("<var class='bnkSlotPriceBuy'>" + E.formatGemString(Settings.aPrice, true) + "</var>");
					}
					if (Settings.aWantGemConvert)
					{
						pSlot.append("<var class='bnkSlotPriceSell'>" + E.formatGemToCoin(pricetorecord) + "</var>");
					}
				}; break;
				default: {
					var possiblestr = E.PaymentFormat[Settings.aPaymentEnum](pricetorecord);
					if (Settings.aPossible === 0)
					{
						possiblestr = "";
					}
					else if (Settings.aPossible > 0 && pricetorecord !== Settings.aPossible)
					{
						possiblestr = pricetorecord + " / " + E.PaymentFormat[Settings.aPaymentEnum](Settings.aPossible);
					}
					pSlot.append("<var class='bnkSlotPrice'>" + possiblestr + "</var>");
				}
			}
			
			// Remember coin value for price search
			if (Settings.aPaymentEnum === E.PaymentEnum.Coin)
			{
				pSlot.data("price", pricetorecord);
				pSlot.data("pricebuy", prices.oPriceBuy);
				pSlot.data("pricesell", prices.oPriceSell);
			}
			else if (Settings.aPaymentEnum === E.PaymentEnum.Gem)
			{
				var gemadjusted = pricetorecord * E.Exchange.COPPER_IN_SILVER; // Integers are in silver, so gem was considered copper
				pSlot.data("price", gemadjusted);
				pSlot.data("pricebuy", gemadjusted);
				pSlot.data("pricesell", gemadjusted);
			}
		}

		if (Settings.aIsTab !== false)
		{
			pSlot.data("tabcount", (pSlot.data("tabcount") || 0) + Settings.aCount);
			pSlot.data("tabfill", (pSlot.data("tabfill") || 0) + ((Settings.aCount > 0) ? 1 : 0));
			pSlot.data("tabcapacity", (pSlot.data("tabcapacity") || 0) + 1);
			// Only add if item actually exists (not a zero stack slot)
			var priceleft, priceright;
			if (iscollection)
			{
				priceleft = prices.oPriceBuy;
				priceright = prices.oPriceSell;
				// Update the display
				if (Settings.aPossible !== undefined)
				{
					priceleft = pricetorecord;
					priceright = Settings.aPossible - pricetorecord;
					updatePriceDisplay(tabdisplayprice, priceleft, priceright, true);
					updatePriceDisplay(top.find(".bnkPriceValueA_" + elementsuffix), priceleft, priceleft);
					updatePriceDisplay(top.find(".bnkPriceValueB_" + elementsuffix), priceright, priceright);
				}
				else if (Settings.aCount !== 0)
				{
					updatePriceDisplay(tabdisplayprice, prices.oPriceSell, 0, true);
					updatePriceDisplay(top.find(".bnkPriceValueA_" + elementsuffix), priceleft, priceright);
				}
				else
				{
					updatePriceDisplay(tabdisplayprice, 0, prices.oPriceSell, true);
					updatePriceDisplay(top.find(".bnkPriceValueB_" + elementsuffix), priceleft, priceright);
				}
			}
			else
			{
				if (Settings.aTransactionBuy)
				{
					priceleft = prices.oPriceBuy;
					priceright = prices.oPriceBuy;
				}
				else if (Settings.aTransactionSell)
				{
					priceleft = prices.oPriceSell;
					priceright = prices.oPriceSellTaxed;
				}
				else
				{
					priceleft = prices.oPriceBuyTaxed;
					priceright = prices.oPriceSellTaxed;
				}
				// Update the display
				if (Settings.aCount !== 0)
				{
					updatePriceDisplay(tabdisplayprice, priceleft, priceright);
					updatePriceDisplay(top.find(".bnkPriceValueA_" + elementsuffix), priceleft, priceright);
				}
			}
		}
	},
	getBankPrice: function(pContainer)
	{
		var valueA = pContainer.find(".bnkPriceValueA_Coin").data("priceleft") || 0;
		var valueB = pContainer.find(".bnkPriceValueB_Coin").data("priceleft") || 0;
		return [valueA, valueB];
	},
	
	/*
	 * Updates the price displayed over a slot with a payment.
	 * @param jqobject pSlot.
	 * @param object pPayment.
	 * @param int pCount.
	 * @param string pSlotClass optional.
	 */
	updateSlotPayment: function(pSlot, pPayment, pCount, pSlotClass)
	{
		for (var paymentkey in pPayment) // This is not a loop, used to access the key of the object
		{
			var paymentvalue = pPayment[paymentkey];
			var priceclass = "";
			if (paymentvalue < 0)
			{
				// A negative price means it should not be added, only displayed subtly
				priceclass = "bnkSlotPriceTrivial";
				paymentvalue *= -1;
			}
			pSlot.append("<var class='" + (pSlotClass || "bnkSlotPrice") + " " + priceclass + "'>"
				+ E.PaymentFormat[paymentkey](paymentvalue * (pCount || 1))
			+ "</var>");
			break;
		}
	},
	
	/*
	 * Creates and binds a search bar and buttons for a bank.
	 * @param jqobject pBank for insertion.
	 * @objparam boolean aWantClear whether to wipe the dish menu to recreate the menu, optional.
	 * @objparam boolean aWantSearchHighlight whether to highlight instead of show and hide when searching, optional.
	 * @objparam boolean aWantCard whether to allow info elements adjacent to slots.
	 * @objparam boolean aIsCollection whether the bank is an unlock collection.
	 * @objparam boolean aIsPseudo if bank contains pseudo slots instead of items.
	 * @objparam boolean aIsCollapsed whether to initially collapse all the tabs, assuming slots are generated, optional.
	 * @objparam jqobject aReloadElement to trigger instead of the default reload, optional.
	 * @pre Bank slots were generated.
	 */
	createBankMenu: function(pBank, pSettings)
	{
		var Settings = pSettings || {};
		// Initialize commonly used elements
		var sectionname = A.getDishName(pBank);
		var dishmenu = A.getDishMenu(sectionname);
		if (Settings.aWantClear)
		{
			dishmenu.empty();
		}
		var bankmenu = $("<div class='bnkMenu'></div>").prependTo(dishmenu);
		
		// Toggles a bank slot and card if available, to be used in iteration
		var toggleSlot = function(pSlot, pBoolean)
		{
			pSlot.toggle(pBoolean);
			if (Settings.aWantCard)
			{
				pSlot.each(function()
				{
					var card = $(this).next();
					if (card.length && card.hasClass("bnkCard"))
					{
						card.toggle(pBoolean);
						if (pBoolean)
						{
							card.css({display: ""}); // Showing the card adds a display CSS rule to the element
						}
					}
				});
			}
		};
		
		/*
		 * Search bar.
		 */
		var searchcontainer = $("<div class='bnkSearch'></div>").prependTo(bankmenu);
		var input = $("<input class='bnkSearchInput' type='text' />").appendTo(searchcontainer);
		I.bindInputBarText(input);
		input.on("input", $.throttle(Q.cSEARCH_LIMIT, function()
		{
			$(this).removeClass("cssSearchNone");
			var slots = pBank.find(".bnkSlot");
			var query = $(this).val().toLowerCase();
			var queries = [];
			var equality0, equality1;
			var keywords = "";
			var ismatchslots = false;
			if (query.length > 0)
			{
				equality0 = query.charAt(0);
				equality1 = query.charAt(1);
				// If searching by price range
				if ((equality0 === "<" || equality0 === ">") && query.length > 1)
				{
					var wantsell = (equality1 === "<" || equality1 === ">" && query.length > 2);
					var pricequeryindex = wantsell ? 2 : 1;
					var pricetype = wantsell ? "pricesell" : "pricebuy";
					var pricewant = E.parseCoinString(query.substring(pricequeryindex, query.length));
					slots.each(function()
					{
						var priceslot = $(this).data(pricetype);
						if (priceslot && ((equality0 === ">" && priceslot >= pricewant) || (equality0 === "<" && priceslot <= pricewant)))
						{
							toggleSlot($(this), true);
							ismatchslots = true;
						}
						else
						{
							toggleSlot($(this), false);
						}
					});
				}
				// If searching by keywords
				else
				{
					queries = query.split(" ");
					// Search for every substring in the user's query, which is space separated
					slots.each(function()
					{
						keywords = $(this).data("keywords"); // The text version of the item's tooltip HTML
						var ismatchkeywords = true;
						if (keywords)
						{
							if (Settings.aWantSearchHighlight)
							{
								for (var i = 0; i < queries.length; i++)
								{
									// If at least one substring of the search query isn't found, then hide that item
									if (keywords.indexOf(queries[i]) === -1)
									{
										$(this).removeClass("bnkSlotMatch");
										ismatchkeywords = false;
										break;
									}
								}
								// The boolean is only true if every substrings were found
								if (ismatchkeywords)
								{
									$(this).addClass("bnkSlotMatch");
									ismatchslots = true;
								}
							}
							else
							{
								for (var i = 0; i < queries.length; i++)
								{
									// If at least one substring of the search query isn't found, then hide that item
									if (keywords.indexOf(queries[i]) === -1)
									{
										toggleSlot($(this), false);
										ismatchkeywords = false;
										break;
									}
								}
								// The boolean is only true if every substrings were found
								if (ismatchkeywords)
								{
									toggleSlot($(this), true);
									ismatchslots = true;
								}
							}
						}
					});
				}
				// Recolor the search bar text if no match was fou
				if (ismatchslots === false)
				{
					$(this).addClass("cssSearchNone", !ismatchslots);
				}
			}
			else
			{
				slots.each(function()
				{
					$(this).removeClass("bnkSlotMatch");
					toggleSlot($(this), true);
				});
			}
			A.adjustAccountScrollbar();
		})).click(function()
		{
			$(this).select();
		});
		
		/*
		 * Add buttons next to the search bar for bank functionalities.
		 */
		var buttoncontainer = $("<aside class='bnkButtons'></aside>").appendTo(bankmenu);
		
		// Reload button reloads the section entirely
		$("<div class='bnkButtonReload bnkButton curClick' title='<dfn>Reload</dfn> this bank.<br />Press this if the progress bar has frozen.'></div>")
			.appendTo(buttoncontainer).click(function()
		{
			if (Settings.aReloadElement)
			{
				Settings.aReloadElement.trigger("click");
			}
			else
			{
				A.regenerateDish(sectionname);
			}
		});
		
		// Button to show help and search usage message
		var isshowinghelp = true;
		$("<div class='bnkButtonHelp bnkButton curClick' title='Show this bank&apos;s <dfn>help</dfn> message.'></div>")
			.appendTo(buttoncontainer).click(function()
		{
			var helpelm = $("#accHelp" + sectionname);
			var helpsec = (helpelm.length) ? helpelm.html() : "";
			if (isshowinghelp || I.isConsoleShown() === false)
			{
				I.help(helpsec + (Settings.aHelpMessage || "") + $("#accHelpBank").html());
			}
			isshowinghelp = !isshowinghelp;
		});
		
		// Empty slot filter: first click show filled slots only, second click show empty slots only, third show full stacks, fourth click show all slots, cycle
		var emptyfilterstate = 0;
		$("<div class='bnkButtonEmpty bnkButton curToggle' title='"
			+ "Filter:<br />1st click: non-empty/unlocked <dfn>slots</dfn><br />2nd click: marked or "
			+ Q.GameLimit.StackSize + " stack slots<br />3rd click: empty/locked slots<br />4th click: any slot (reset)'></div>")
			.appendTo(buttoncontainer).click(function()
		{
			var slots = pBank.find(".bnkSlot");
			if (emptyfilterstate === 0 || emptyfilterstate === 2 ) // Filter 
			{
				var wantshow = (emptyfilterstate === 0);
				slots.each(function()
				{
					// The style slot function should have initialized the count data for slots without an item
					if ($(this).data("count") > 0)
					{
						toggleSlot($(this), wantshow);
					}
					else
					{
						toggleSlot($(this), !wantshow);
					}
				});
				$(this).addClass("bnkButtonFocused");
				emptyfilterstate++;
			}
			else if (emptyfilterstate === 1)
			{
				slots.each(function()
				{
					if ($(this).data("count") >= Q.GameLimit.StackSize || $(this).data("ismarked"))
					{
						toggleSlot($(this), true);
					}
					else
					{
						toggleSlot($(this), false);
					}
				});
				emptyfilterstate++;
			}
			else
			{
				toggleSlot(slots, true);
				$(this).removeClass("bnkButtonFocused");
				emptyfilterstate = 0;
			}
			A.adjustAccountScrollbar();
		});
		
		// Button to filter tradeable items
		if (Settings.aIsPseudo !== true)
		{
			var tradefilterstate = 0;
			$("<div class='bnkButtonTrade bnkButton curToggle' title='Filter:<br />1st click: <dfn>tradeable</dfn> items<br />2nd click: bound items<br />3rd click: any items (reset).'></div>")
				.appendTo(buttoncontainer).click(function()
			{
				var slots = pBank.find(".bnkSlot");
				if (tradefilterstate === 0 || tradefilterstate === 1)
				{
					slots.each(function()
					{
						if ($(this).data("istradeable"))
						{
							toggleSlot($(this), tradefilterstate === 0);
						}
						else
						{
							toggleSlot($(this), tradefilterstate === 1);
						}
						if ($(this).data("count") === undefined)
						{
							toggleSlot($(this), false);
						}
					});
					$(this).addClass("bnkButtonFocused");
					pBank.addClass("bnkTradeable");
					tradefilterstate++;
				}
				else
				{
					toggleSlot(slots, true);
					$(this).removeClass("bnkButtonFocused");
					pBank.removeClass("bnkTradeable");
					tradefilterstate = 0;
				}
				A.adjustAccountScrollbar();
			});
		}
		
		if (Settings.aIsPseudo !== true && Settings.aIsCollection !== true)
		{
			// Button to filter cleanable items
			var cleanupfilterstate = 0;
			$("<div class='bnkButtonClean bnkButton curToggle' title='Filter:<br />"
				+ "1st click: <dfn>cleanable</dfn> items<br />2nd click: any items (reset).<br />"
				+ "Example: salvageable items, vendorable items, unopened bags.'></div>")
				.appendTo(buttoncontainer).click(function()
			{
				var thisbutton = $(this);
				var slots = pBank.find(".bnkSlot");
				if (cleanupfilterstate === 0)
				{
					Q.initializeCleanableFilter(function()
					{
						slots.each(function()
						{
							var itemid = $(this).data("itemid");
							if (itemid && $(this).data("skinid") === undefined) // Ignore transmuted items
							{
								if (Q.isCleanable(itemid))
								{
									$(this).addClass("bnkSlotMatchAlternate");
								}
							}
						});
						thisbutton.addClass("bnkButtonFocused");
						cleanupfilterstate++;
					});
				}
				else
				{
					slots.removeClass("bnkSlotMatchAlternate");
					thisbutton.removeClass("bnkButtonFocused");
					cleanupfilterstate = 0;
				}
				A.adjustAccountScrollbar();
			});
		}
		
		// Button to show rarity colored borders over items
		if (Settings.aIsPseudo !== true)
		{
			var isfilteringrarity = O.Options.bol_showRarity;
			var changeRarity = function(pRarityButton)
			{
				pBank.toggleClass("bnkRarity", isfilteringrarity);
				pRarityButton.toggleClass("bnkButtonFocused");
			};
			var raritybutton = $("<div class='bnkButtonRarity bnkButton curToggle' title='"
				+ "Show <dfn>rarity</dfn> colored boxes.<br />Change permanently at Options page, Account section.'></div>")
				.appendTo(buttoncontainer).click(function()
			{
				isfilteringrarity = !isfilteringrarity;
				changeRarity($(this));
			});
			if (O.Options.bol_showRarity)
			{
				changeRarity(raritybutton);
			}
		}
		
		// Button to condense bank and smaller slots
		var isbankcondense = O.Options.bol_condenseBank;
		var resizeSlots = function(pRarityButton)
		{
			pBank.toggleClass("bnkCondense", isbankcondense);
			pRarityButton.toggleClass("bnkButtonFocused");
			// Update bank 
			pBank.css({width: A.Metadata.Bank.NumSlotsHorizontal * B.getBankSlotWidth(isbankcondense)});
			A.adjustAccountScrollbar();
		};
		var raritybutton = $("<div class='bnkButtonCondense bnkButton curToggle' title='"
			+ "Toggle bank <dfn>size</dfn>.<br />Change permanently at Options page, Account section.'></div>")
			.appendTo(buttoncontainer).click(function()
		{
			isbankcondense = !isbankcondense;
			resizeSlots($(this));
		});
		if (O.Options.bol_condenseBank)
		{
			resizeSlots(raritybutton);
		}
		
		// Button to toggle informational card next to slots
		if (Settings.aWantCard)
		{
			var isbankcard = false;
			var cardbutton = $("<div class='bnkButtonCard bnkButton curToggle' title='"
				+ "Toggle info <dfn>cards</dfn>.'></div>")
				.appendTo(buttoncontainer).click(function()
			{
				isbankcard = !isbankcard;
				pBank.toggleClass("bnkCarded", isbankcard);
				$(this).toggleClass("bnkButtonFocused");
				A.adjustAccountScrollbar();
			}).trigger("click");
		}
		
		// Button to toggle all tabs
		var istabscollapsed = false;
		var collapsebutton = $("<div class='bnkButtonTab bnkButton curToggle' title='Expand/<dfn>Collapse</dfn> all tabs.'></div>")
			.appendTo(buttoncontainer).click(function()
		{
			B.toggleBankTab(pBank, istabscollapsed);
			$(this).toggleClass("bnkButtonFocused");
			istabscollapsed = !istabscollapsed;
		});
		if (Settings.aIsCollapsed)
		{
			collapsebutton.trigger("click");
		}
		
		// Button to increase or decrease bank width
		$("<div class='bnkButtonWideLess bnkButton curClick' title='<dfn>Decrease</dfn> bank width.'></div>")
			.appendTo(buttoncontainer).click(function()
		{
			var slotsize = B.getBankSlotWidth(isbankcondense);
			var minbankwidth = slotsize * 4;
			var oldwidth = pBank.width();
			if (oldwidth > minbankwidth)
			{
				pBank.css({width: oldwidth - slotsize});
				A.adjustAccountScrollbar();
			}
		});
		$("<div class='bnkButtonWideMore bnkButton curClick' title='<dfn>Increase</dfn> bank width.'></div>")
			.appendTo(buttoncontainer).click(function()
		{
			var slotsize = B.getBankSlotWidth(isbankcondense);
			var maxbankwidth = $("#accContent").width() - (slotsize * 2);
			var oldwidth = pBank.width();
			if (oldwidth < maxbankwidth)
			{
				pBank.css({width: oldwidth + slotsize});
				A.adjustAccountScrollbar();
			}
		});
		
		// Finally
		searchcontainer.css({width: searchcontainer.width() - buttoncontainer.width()});
		I.qTip.init(buttoncontainer.find(".bnkButton"));
		A.adjustAccountPanel();
	},
	getBankSearch: function(pSection)
	{
		return $("#accDishMenu_" + U.toFirstUpperCase(pSection)).find(".bnkSearch .bnkSearchInput").first();
	},
	refreshBankSearch: function(pSection)
	{
		B.getBankSearch(pSection).trigger("input");
	},
	
	/*
	 * Fills a bank tab with slots.
	 * @param jqobject pTab to fill.
	 * @param array pCatArr of the unlockables record.
	 * @param object pSettings for the slot fill function.
	 */
	fillTab: function(pTab, pCatArr, pSettings)
	{
		var Settings = pSettings || {};
		var slot, unlockobj;
		var numfetched = 0;
		var numtofetch = U.getObjectLength(pCatArr);
		var slotscontainer = B.getSlotsContainer(pTab);
		if (Settings.aIsCollapsed)
		{
			pTab.append(I.cThrobber);
		}
		
		var doGenerate = function()
		{
			for (var ii = 0; ii < pCatArr.length; ii++)
			{
				slot = B.createBankSlot(slotscontainer);
				unlockobj = pCatArr[ii];
				// Fill the slot with the item icon
				B.fillSlot(slot, unlockobj.i || unlockobj, {
					aUnlockAssoc: Settings.aUnlockAssoc,
					aUnlockObj: unlockobj,
					aComment: unlockobj.t,
					aLabel: unlockobj.l,
					aIsCatalog: Settings.aIsCatalog,
					aIsCustomCatalog: Settings.aIsCustomCatalog,
					aWantGemConvert: Settings.aWantGemConvert,
					aBind: Settings.aBind,
					aCallback: function()
					{
						numfetched++;
						A.setProgressBar(numfetched, numtofetch);
					}
				});
			}
		};
		
		// Prefetch items if this tab was manually expanded
		if (Settings.aIsCollapsed)
		{
			var itemids = [];
			for (var ii = 0; ii < pCatArr.length; ii++)
			{
				unlockobj = pCatArr[ii];
				itemids.push(unlockobj.i || unlockobj);
			}
			Q.getPricedItems(itemids, function()
			{
				I.removeThrobber(pTab);
				doGenerate();
			});
		}
		else
		{
			doGenerate();
		}
		
		// Also include button for custom tabs
		if (Settings.aIsCustomCatalog)
		{
			B.bindCatalogTab(pTab);
		}
	},
	
	/*
	 * Fills a bank tab with dyes (as bank slots).
	 * @param jqobject pTab.
	 * @param array pCatArr of unlockable objects, which are dyes.
	 * @param object pUnlockAssoc associative array to check against.
	 * @param string pCatArrName to determine dye rarity.
	 * @pre Data from the dye section of the account page was loaded.
	 */
	fillDyeTab: function(pTab, pCatArr, pUnlockAssoc, pCatArrName)
	{
		var slot, unlockobj;
		var slotscontainer = B.getSlotsContainer(pTab);
		var metadata = GW2T_DYES_METADATA;
		var translations = {};
		for (var i in metadata.Translations)
		{
			translations[i] = D.getObjectTranslation(metadata.Translations[i]);
		}
		
		for (var i = 0; i < pCatArr.length; i++)
		{
			slot = B.createBankSlot(slotscontainer);
			unlockobj = pCatArr[i];
			(function(iSlot, iUnlockObj, iUnlockID, iItemID, iWiki, iColors, iHue, iMaterial, iChatlink, iName)
			{
				// Color the bank slot as that dye
				iSlot.find(".bnkSlotIcon").css({background: iColors[0]});
				// Include name over the slot
				iSlot.append("<var class='bnkSlotDyeName'>" + iName + "</var>");
				// Set slot rarity depending on its tab
				var rarity = (metadata.Rarities[pCatArrName]) ? metadata.Rarities[pCatArrName] : metadata.Rarities.Default;
				iSlot.find(".bnkSlotIcon").addClass("bnkSlotRarity_" + rarity);
				// Label the price, if there is an associated dye item
				var count = (pUnlockAssoc[iUnlockID]) ? 1 : 0;
				if (count)
				{
					iSlot.data("count", count);
				}
				if (iItemID)
				{
					slot.addClass("bnkSlotTradeable");
					slot.data("istradeable", true);
					E.getPriceObject(iItemID, function(pPrice)
					{
						B.updateSlotPrice(iSlot, {
							aPrice: pPrice,
							aCount: count,
							aPaymentEnum: E.PaymentEnum.Coin
						});
						if (count)
						{
							// Fade the price label if already unlocked that dye
							iSlot.find(".bnkSlotPrice").addClass("accTrivial");
						}
					});
				}
				
				// Tooltip shows the different colors on different materials
				var tiphtml = "<div class='bnkDyePreview'>"
					+ "<aside class='bnkDyePreviewTitle'><var class='bnkDyePreviewName' style='color:" + iColors[0] + "'>" + iName + "</var> ("
						+ translations[iHue] + " " + translations[iMaterial] + ")</aside>"
					+ "<div class='bnkDyePreviewSwatches'>"
						+ "<aside class='bnkDyePreviewSwatch' style='background:" + iColors[0] + "'>"
							+ "<var class='bnkDyePreviewMaterial'>" + translations["Vibrant"] + "</var></aside>"
						+ "<aside class='bnkDyePreviewSwatch' style='background:" + iColors[1] + "'>"
							+ "<var class='bnkDyePreviewMaterial'>" + translations["Leather"] + "</var></aside>"
						+ "<aside class='bnkDyePreviewSwatch' style='background:" + iColors[2] + "'>"
							+ "<var class='bnkDyePreviewMaterial'>" + translations["Metal"] + "</var></aside>"
					+ "</div>"
				+ "</div>";
				iSlot.attr("title", tiphtml);
				I.qTip.init(iSlot);
				
				// Remember search keywords
				var keywords = (iName + " " + translations[iHue] + " " + translations[iMaterial]).toLowerCase();
				iSlot.data("keywords", keywords);
				
				// Bind slot click behavior
				iSlot.click(function(pEvent)
				{
					if (pEvent.which === I.ClickEnum.Left)
					{
						U.openExternalURL(U.getWikiSearchDefault(iWiki));
					}
				});
				// Bind context menu
				Q.bindItemSlotBehavior(iSlot, {
					aObject: iUnlockObj,
					aChatlink: iChatlink,
					aTradeableID: iItemID,
					aSearch: iWiki
				});
				
			})(slot, unlockobj, unlockobj.u, unlockobj.i, unlockobj.n,
				unlockobj.c, unlockobj.h, unlockobj.m, unlockobj.l, D.getObjectTranslation(unlockobj));
		}
	},
	
	/*
	 * Fills a slot with item icon and labels.
	 * @param jqobject pSlot to fill.
	 * @param int pItemID associated with the unlockable.
	 * @objparam object aUnlockAssoc to find the association.
	 * @objparam object aUnlockObj for slot info.
	 * @objparam string aComment HTML to append to the item tooltip, optional.
	 * @objparam string aLabel to append to slot label, optional.
	 * @objparam boolean aIsCatalog whether to use the user's possessions rather
	 * than unlockeds, optional.
	 */
	fillSlot: function(pSlot, pItemID, pSettings)
	{
		var Settings = pSettings || {};
		var unlocksassoc = Settings.aUnlockAssoc;
		var unlockobj = Settings.aUnlockObj;
		var unlockid = (typeof unlockobj === "number") ? pItemID : unlockobj.u;
		var tradeableid = (Settings.aIsCatalog && unlockobj.u) ? unlockobj.u : null;
		var wiki = unlockobj.n;
		var payment = unlockobj.p;
		
		Q.getItem(pItemID, function(iItem)
		{
			if (Settings.aIsCustomCatalog)
			{
				pSlot.addClass("bnkSlotCatalog");
				unlockid = pItemID;
				wiki = iItem.name;
			}
			var slotcoin, slotgem, slotgemvalue;
			if (payment)
			{
				slotcoin = payment["coin"];
				// Some items with a gem price may be marked to not be added to the tab display
				slotgem = payment["gem"];
				if (slotgem !== undefined)
				{
					if (slotgem < 0)
					{
						slotgem = 0; // Let the payment function create the price label rather than the style function
					}
					else
					{
						slotgemvalue = slotgem;
					}
				}
			}
			// Determine the item count number to display
			var entry = unlocksassoc[unlockid];
			var count = (entry) ? ((entry.oCount !== undefined) ? entry.oCount : 1) : 0;
			// Optional comment appended at the bottom of item tooltip
			var comment = Settings.aComment;
			var label = Settings.aLabel;
			// Catalog includes custom count
			entry = unlocksassoc[pItemID];
			if (Settings.aIsCatalog && entry)
			{
				count = entry.oCount;
				comment = A.getFoundString(entry);
			}
			// Style the slot
			B.styleBankSlot(pSlot, {
				aItem: iItem,
				aTradeableID: tradeableid,
				aPrice: slotcoin,
				aGem: slotgemvalue,
				aSlotMeta: {count: count},
				aComment: comment,
				aLabel: label,
				aWiki: wiki,
				aIsCustomCatalog: Settings.aIsCustomCatalog,
				aWantGemConvert: Settings.aWantGemConvert,
				aBind: Settings.aBind,
				aCallback: function()
				{
					// Include payment if the item cannot be obtained on the Trading Post
					if (payment && ((slotcoin === undefined && slotgem === undefined) || (slotcoin === 0 || slotgem === 0)))
					{
						B.updateSlotPayment(pSlot, payment, count);
					}
				}
			});
			if (Settings.aCallback)
			{
				Settings.aCallback();
			}
		});
	},
	
	/*
	 * Macro function for creating unlockables style banks.
	 * @param jqobject pBank to manipulate.
	 * @objparam object aHeaders containing category header translations.
	 * @objparam object aRecord containing categorized unlockable entries.
	 * @objparam array aUnlockeds IDs of user's unlocked unlockables from account API, or an associative array containing a count property.
	 * @objparam boolean aIsCatalog to use the user's possessions rather than unlockeds.
	 * @objparam boolean aIsLookup to generate unlocked slots only.
	 * @objparam boolean aIsCollapsed if all tabs should be initially collapsed.
	 * @objparam boolean aWantItems to prefetch item details for all items.
	 * @objparam boolean aWantPrices to prefetch TP prices for all items.
	 * @objparam boolean aWantSearchHighlight to use search highlight, optional.
	 * @objparam boolean aWantDefaultHelp to append the unlockables help message, optional.
	 * @objparam function aCallback to execute after generation.
	 * @objparam function aTabIterator to create a tab and execute at every category's iteration.
	 * @objparam string aIsCustomCatalog if is the default catalog with custom tabs.
	 * An unlockables record has arrays that hold entries with these properties:
	 * u: Unlockable ID (such as a skin ID, or mini ID)
	 * i: Item ID associated with that unlock
	 * n: Name of the unlockable.
	 * b: Tradeable array of item IDs, optional.
	 * p: Payment to acquire the associated item if the item is not tradeable.
	 */
	generateUnlockables: function(pBank, pSettings)
	{
		var Settings = pSettings || {};
		if (Settings.aIsCollapsed)
		{
			Settings.aWantPrices = false;
		}
		// Convert the API array of unlocks into an associative array
		var unlocksassoc = {};
		if (Settings.aIsCatalog)
		{
			unlocksassoc = A.Possessions;
		}
		else
		{
			if (Settings.aUnlockeds === undefined)
			{
				Settings.aUnlockeds = [];
				A.iterateRecord(Settings.aRecord, function(pEntry)
				{
					unlocksassoc[pEntry] = true;
				});
			}
			else
			{
				if (Array.isArray(Settings.aUnlockeds))
				{
					if (Settings.aUnlockeds.length)
					{
						// If unlockeds data is an array or assoc of object containing item IDs and additional info
						if (Settings.aUnlockeds[0].id !== undefined)
						{
							for (var i = 0; i < Settings.aUnlockeds.length; i++)
							{
								if (Settings.aUnlockeds[i].permanent !== false)
								{
									unlocksassoc[(Settings.aUnlockeds[i].id)] = true;
								}
							}
						}
						// If unlockeds data is an array of item IDs
						else
						{
							for (var i = 0; i < Settings.aUnlockeds.length; i++)
							{
								unlocksassoc[(Settings.aUnlockeds[i])] = true;
							}
						}
					}
				}
				else
				{
					unlocksassoc = Settings.aUnlockeds;
				}
			}
		}

		var container = B.getBankContainer(pBank);
		var headers = {};
		var record = {};
		var tab;
		var catarr, catobj;
		var unlockid;

		if (Settings.aIsCustomCatalog)
		{
			/*
			 * Add to the current unlockable database if provided custom tabs.
			 */
			var customdb = B.bindCatalog(pBank, unlocksassoc, Settings.aHeaders, Settings.aRecord);
			headers = customdb.oHeaders;
			record = customdb.oRecord;
		}
		else if (Settings.aIsLookup)
		{
			/*
			 * Records called with this boolean will be in the form of an array
			 * of item IDs rather array of objects. Reformat the record so it
			 * only contains items that is already unlocked (no locked slots
			 * will be generated).
			 */
			headers = Settings.aHeaders;
			for (var i in Settings.aRecord)
			{
				record[i] = [];
				catarr = Settings.aRecord[i];
				for (var ii = 0; ii < catarr.length; ii++)
				{
					if (unlocksassoc[(catarr[ii])])
					{
						record[i].push(catarr[ii]);
					}
				}
			}
		}
		else
		{
			/*
			 * For normal unlockables record.
			 */
			headers = Settings.aHeaders;
			record = Settings.aRecord;
		}
		
		var doGenerate = function()
		{
			/*
			 * Create tabs for each unlockable category.
			 */
			I.removeThrobber(pBank);
			var numsunlockedtotal = 0;
			var numintabstotal = 0;
			var numacquiredtotal = 0;
			var isheadersundefined = false;
			if (headers === undefined)
			{
				headers = {};
				isheadersundefined = true;
			}
			for (var i in record)
			{
				if (isheadersundefined)
				{
					headers[i] = {name_en: i};
				}
				catobj = headers[i];
				catarr = record[i];
				tab = (Settings.aTabIterator) ? Settings.aTabIterator(i) : B.createBankTab(pBank, {
					aTitle: D.getObjectName(catobj),
					aIsCollapsed: (Settings.aIsCollapsed !== undefined) ? Settings.aIsCollapsed : catobj.iscollapsed,
					aIsCustomCatalog: catobj.iscustomtab
				});
				(function(iTab, iCatObj, iCatArr, iCatArrName)
				{
					if (Settings.aIsDyes)
					{
						B.fillDyeTab(iTab, iCatArr, unlocksassoc, iCatArrName);
					}
					else
					{
						if (Settings.aIsCollapsed || iCatObj.iscollapsed)
						{
							iTab.find(".bnkTabSeparator").one("click", function()
							{
								B.fillTab(iTab, iCatArr, {
									aUnlockAssoc: unlocksassoc,
									aIsCatalog: Settings.aIsCatalog,
									aIsCollapsed: Settings.aIsCollapsed,
									aWantGemConvert: Settings.aWantGemConvert,
									aBind: Settings.aBind
								});
							});
						}
						else
						{
							B.fillTab(iTab, iCatArr, {
								aUnlockAssoc: unlocksassoc,
								aIsCatalog: Settings.aIsCatalog,
								aIsCustomCatalog: iCatObj.iscustomtab,
								aWantGemConvert: Settings.aWantGemConvert,
								aBind: Settings.aBind
							});
						}
					}
				})(tab, catobj, catarr, i);

				// For this ith tab, write the number of unlockables unlocked on the tab header
				var numunlocked = 0;
				var numacquired = 0;
				for (var ii = 0; ii < catarr.length; ii++)
				{
					unlockid = ((Settings.aIsCatalog) ? catarr[ii].i : catarr[ii].u) || catarr[ii];
					if (unlocksassoc[unlockid])
					{
						numunlocked++;
						numsunlockedtotal++;
						if (unlocksassoc[unlockid].oCount)
						{
							numacquired += unlocksassoc[unlockid].oCount;
						}
					}
				}
				var numintab = catarr.length;
				numintabstotal += numintab;
				B.updateTabTally(tab, numunlocked, numintab, numacquired);
				if (numacquired)
				{
					numacquiredtotal += numacquired;
				}
			}
			// Create bank menu
			var wantsearchhighlight = (Settings.aWantSearchHighlight === undefined) ? true : Settings.aWantSearchHighlight;
			B.createBankMenu(pBank, {
				aIsCollection: true,
				aWantSearchHighlight: wantsearchhighlight,
				aHelpMessage: $("#accHelpUnlockables").html(),
				aIsCustomCatalog: Settings.aIsCustomCatalog
			});
			B.updateBankTally(container, numsunlockedtotal, numintabstotal, numacquiredtotal);
			
			if (Settings.aCallback)
			{
				Settings.aCallback({
					aUnlockAssoc: unlocksassoc
				});
			}
		};
		
		/*
		 * Compile item IDs to bulk fetch item details and prices beforehand
		 */
		if (Settings.aWantItems === true || Settings.aWantPrices !== false)
		{
			var itemids = [];
			A.iterateRecord(record, function(pEntry)
			{
				if (isNaN(pEntry) === false)
				{
					itemids.push(pEntry);
				}
				else
				{
					if (pEntry.i)
					{
						itemids.push(pEntry.i);
					}
					else if (pEntry.u)
					{
						itemids.push(pEntry.u);
					}
				}
			});
			if (Settings.aWantItems === true && Settings.aWantPrices !== false)
			{
				Q.getPricedItems(itemids, function()
				{
					doGenerate();
				});
			}
			else if (Settings.aWantItems === true)
			{
				Q.getItems(itemids, function()
				{
					doGenerate();
				});
			}
			else if (Settings.aWantPrices !== false)
			{
				E.getPrices(itemids, function()
				{
					doGenerate();
				});
			}
		}
		else
		{
			doGenerate();
		}
	},
	
	/*
	 * Macro function to serve a catalog style bank to an account page's section.
	 * A catalog is a bank based on the account's entire inventory, bank, and 
	 * materials items possessions.
	 * @param string pSection name.
	 * @param object pSettings for the generate unlockables function.
	 */
	generateCatalog: function(pSection, pSettings)
	{
		var Settings = $.extend({
			aIsCatalog: true,
			aWantGem: true,
			aWantSearchHighlight: false
		}, pSettings);
		
		var sectionnameupper = U.toFirstUpperCase(pSection);
		var sectionnamelower = pSection.toLowerCase();
		if (V.requireCharacters(sectionnameupper))
		{
			return;
		}
		else if ( ! A.Data.Characters[0].bags)
		{
			A.printError(A.PermissionEnum.Inventories);
			return;
		}
		var dish = $("#accDish_" + sectionnameupper);
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var container = B.createBank(dish, {
			aIsCollection: (Settings.aIsCollection !== undefined) ? Settings.aIsCollection : true,
			aWantGem: Settings.aWantGem
		});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var fillCatalog = function()
		{
			Settings.aHeaders = U.getRecordHeader(pSection);
			Settings.aRecord = U.getRecordData(pSection);
			B.generateUnlockables(bank, Settings);
			/*
			 * Piggyback on the bank search bar (created by the generate unlockables
			 * function) and make it print the characters who have an item.
			 */
			Q.bindItemSearch(B.getBankSearch(pSection), {
				aFillerText: null,
				aCallback: function(pItem)
				{
					var itemname = "&quot;<a" + U.convertExternalAnchor(U.getWikiLinkLanguage(pItem.name)) + ">" + pItem.name + "</a>&quot;";
					if (A.Possessions[pItem.id])
					{
						var locations = A.formatPossessionLocations(A.Possessions[pItem.id]);
						I.print(itemname + " was found in:<br /><br />" + locations);
					}
					else
					{
						I.write("Nowhere in your account has the item " + itemname);
					}
				}
			});
		};
		
		U.getScript(U.URL_DATA[sectionnameupper], function()
		{
			Q.loadItemsSubdatabase(sectionnamelower, function()
			{
				/*
				 * Catalog is a custom unlockable whose collection is generated
				 * based on the user's bank and inventory contents rather than
				 * a list provided by the API.
				 */
				A.initializePossessions(function()
				{
					fillCatalog();
				});
			});
		});
	},
	
	/*
	 * Places a newly created tab of a custom catalog to the proper container.
	 * @param jqobject pBank.
	 * @param jqobject pTab.
	 * @param boolean pWantPrepend to place the tab on top.
	 */
	placeCatalogTab: function(pBank, pTab, pWantPrepend)
	{
		var tabcontainer = pBank.find(".bnkCatalogTabContainer");
		if ( ! tabcontainer.length)
		{
			tabcontainer = $("<div class='bnkCatalogTabContainer'></div>").prependTo(pBank);
		}
		if (pWantPrepend)
		{
			tabcontainer.prepend(pTab);
		}
		else
		{
			tabcontainer.append(pTab);
		}
	},
	
	/*
	 * Binds a custom tab of a catalog bank to have a button that shows the edit menu.
	 * @param jqobject pTab to bind.
	 */
	bindCatalogTab: function(pTab)
	{
		pTab.addClass("bnkCatalogTab");
		var edit = $("<kbd class='bnkCatalogTabEdit btnWindow' title='Click to <dfn>edit</dfn> this tab.<br />"
			+ "Click again to stop editing.<br />To edit custom slots, click the slot.'></kbd>").prependTo(pTab).click(function()
		{
			var bank = $(this).closest(".bnkBank");
			var currenttab = $(bank.data("currenttab"));
			var clickedtab = $(this).closest(".bnkTab").first();
			var tabeditor = bank.data("tabeditor");
			var tabheader = pTab.find(".bnkTabHeader");
			bank.find(".bnkTabHeader").removeClass("bnkCatalogTabHighlight");
			/*
			 * All custom tabs share the same editor menu that decides which
			 * tab to edit based on the bank object's current tab data.
			 * Clicking on the edit button next to a tab updates that tab as the
			 * current tab to be edited.
			 */
			if (clickedtab.is(currenttab) && tabeditor.is(":visible"))
			{
				// Hide the tab editor if is already editing it and user clicked edit again
				tabeditor.hide();
				bank.data("currenttab", null);
				tabheader.removeClass("bnkCatalogTabHighlight");
			}
			else if (clickedtab.is(currenttab) === false || tabeditor.is(":visible") === false)
			{
				// Show the tab editor if clicked edit on a different tab or isn't already editing
				tabeditor.show();
				bank.data("currenttab", $(this).closest(".bnkTab"));
				tabheader.addClass("bnkCatalogTabHighlight");
				// Update the name of the tab rename input
				var tabname = pTab.find(".bnkTabText").text();
				tabeditor.find(".bnkCatalogTabRename").val(tabname);
				tabeditor.find(".bnkCatalogSlotAdd").select().trigger("focus").trigger("click");
			}
			A.adjustAccountPanel();
		});
		I.qTip.init(edit);
	},
	
	/*
	 * A catalog's custom tab's slot when clicked on shows the slot editor rather
	 * than go to the wiki page.
	 * @param jqobject pSlot to bind.
	 */
	bindCatalogSlot: function(pSlot)
	{
		pSlot.unbind("click").click(function()
		{
			// Set the clicked slot as the current and highlight it
			var bank = $(this).closest(".bnkBank");
			bank.find(".bnkCatalogSlotHighlight").removeClass("bnkCatalogSlotHighlight");
			var currentslot = bank.data("currentslot");
			var sloteditor = bank.data("sloteditor");
			if ($(this).is(currentslot) && sloteditor.is(":visible"))
			{
				sloteditor.hide();
				bank.data("currentslot", null);
				$(this).removeClass("bnkCatalogSlotHighlight");
			}
			else if ($(this).is(currentslot) === false || sloteditor.is(":visible") === false)
			{
				// The slot editor appears next to the user's cursor rather than the bank menu
				sloteditor.css({left: I.posX, top: I.posY}).show();
				bank.data("currentslot", $(this));
				$(this).addClass("bnkCatalogSlotHighlight");
			}
			A.adjustAccountPanel();
		});
	},
	
	/*
	 * Saves the custom catalog to storage.
	 * @param jqobject pBank to extract custom tabs.
	 * Example structure of the stored custom catalog:
	 * [
	 *	{name: "My Tab", items: [123, 1234, 12345]},
	 *	{name: "My Tab 2", items: [321, 4321, 54321, 21]},
	 * ]
	 */
	saveCatalog: function(pBank)
	{
		var tabs = [];
		pBank.find(".bnkCatalogTab").each(function()
		{
			var items = [];
			var itemid;
			var slotscontainer = B.getSlotsContainer($(this)).first();
			slotscontainer.find(".bnkSlotCatalog").each(function()
			{
				itemid = $(this).data("itemid");
				if (itemid)
				{
					items.push(itemid);
				}
			});
			tabs.push({
				name: $(this).find(".bnkTabText").text(),
				items: items
			});
		});
		localStorage[O.Utilities.CustomCatalog.key] = JSON.stringify(tabs);
	},
	
	/*
	 * Binds additional behaviors to a bank which the user can add custom tabs to.
	 * @param jqobject pBank element.
	 * @param object pUnlockAssoc associative array of the account's possessions.
	 * @param object pHeaders original to extend.
	 * @param object pRecord original to extend.
	 */
	bindCatalog: function(pBank, pUnlockAssoc, pHeaders, pRecord)
	{
		/*
		 * Try to the retrieve the stored custom tabs if available and add them
		 * to the unlockables record.
		 */
		var headers = {};
		var record = {};
		var customitems = {};
		var itemid, defaulttab, customtab, tabkey;
		var customtabs = [];
		try
		{
			customtabs = JSON.parse(localStorage[O.Utilities.CustomCatalog.key]);
		}
		catch (e) {}
		
		// Create a list of custom items
		for (var i = 0; i < customtabs.length; i++)
		{
			customtab = customtabs[i];
			for (var ii = 0; ii < customtab.items.length; ii++)
			{
				customitems[(customtab.items[ii])] = true;
			}
		}
		// To avoid duplicate slots, remove items from the default list if the item's already in the custom list
		for (var i in pRecord)
		{
			defaulttab = pRecord[i];
			for (var ii = defaulttab.length - 1; ii >= 0; ii--)
			{
				if (customitems[(defaulttab[ii].i)])
				{
					defaulttab.splice(ii, 1);
				}
			}
		}
		
		// Convert the custom tabs object into the unlockables record format
		for (var i = 0; i < customtabs.length; i++)
		{
			customtab = customtabs[i];
			tabkey = "Tab_" + i;
			headers[tabkey] = {
				name_en: U.escapeHTML(customtab.name || ""),
				iscustomtab: true
			};
			record[tabkey] = [];
			// Reconstruct an unlockable entry using just the stored item ID
			for (var ii = 0; ii < customtab.items.length; ii++)
			{
				itemid = customtab.items[ii];
				if (itemid)
				{
					record[tabkey].push({
						i: itemid,
						n: null
					});
				}
			}
		}
		// Add the default unlockables to the custom unlockables, so that the custom ones are top ordered
		for (var i in pHeaders)
		{
			headers[i] = pHeaders[i];
		}
		for (var i in pRecord)
		{
			record[i] = pRecord[i];
		}
		
		/*
		 * New tab button.
		 */
		var newtabutton = $("<kbd class='bnkCatalogTabAdd btnWindow' title='<dfn>Add a custom bank tab.</dfn><br />"
			+ "To edit a custom tab or add an item to it, click the<img src=\"img/ui/edit.png\" />icon next to one.'></kbd>").appendTo(pBank)
			.click(function()
		{
			if (pBank.find(".bnkCatalogTab").length < A.Metadata.Bank.CustomTabsLimit)
			{
				var tab = B.createBankTab(pBank, {
					aTitle: D.getPhraseTitle("rename tab"),
					aIsCustomCatalog: true,
					aWantPrepend: true
				});
				B.fillTab(tab, [], {
					aUnlockAssoc: pUnlockAssoc,
					aIsCatalog: true,
					aIsCustomCatalog: true
				});
				// Automatically open the tab editor for the newly created tab
				tab.find(".bnkCatalogTabEdit").trigger("click");
			}
			else
			{
				I.write("Custom tabs limit reached.");
			}
		});
		I.qTip.init(newtabutton);
		
		// Create a menu to edit custom tabs and slots
		var sectionname = A.getDishName(pBank);
		var dishmenu = A.getDishMenu(sectionname);
		
		/*
		 * Tab editor.
		 */
		var tabeditor = $("<div class='bnkCatalogTabEditor'></div>").appendTo(dishmenu).hide();
		pBank.data("tabeditor", tabeditor);
		$("<div class='bnkCatalogMenuClose bnkButton curClick' title='<dfn>Close</dfn> the tab editor.'></div>")
			.appendTo(tabeditor).click(function()
		{
			var currenttab = pBank.data("currenttab");
			if (currenttab)
			{
				currenttab.find(".bnkTabHeader").removeClass("bnkCatalogTabHighlight");
			}
			pBank.data("currenttab", null);
			tabeditor.hide();
			A.adjustAccountPanel();
		});
		var slotadd = $("<input class='bnkCatalogSlotAdd bnkSearchInput' type='text' />").appendTo(tabeditor);
		Q.bindItemSearch(slotadd, {
			aFillerText: D.getPhraseTitle(D.orderModifier("item", "new")) + "...",
			aCallback: function(pItem)
			{
				var tab = pBank.data("currenttab");
				if (tab)
				{
					var slotscontainer = B.getSlotsContainer(tab);
					var slot = B.createBankSlot(slotscontainer);
					B.fillSlot(slot, pItem.id, {
						aUnlockAssoc: pUnlockAssoc,
						aUnlockObj: pItem.id,
						aIsCatalog: true,
						aIsCustomCatalog: true
					});
					B.saveCatalog(pBank);
				}
			}}
		);
		$("<input class='bnkCatalogTabRename bnkSearchInput' type='text' />").appendTo(tabeditor).change(function()
		{
			var tab = pBank.data("currenttab");
			if (tab)
			{
				tab.find(".bnkTabText").text($(this).val());
				B.saveCatalog(pBank);
			}
		}).click(function()
		{
			$(this).select();
		});
		var tabeditorbuttons = $("<aside class='bnkButtons'></aside>").appendTo(tabeditor);
		$("<div class='bnkCatalogTabUp bnkButton curClick' title='Move this tab <dfn>up</dfn>.'></div>")
			.appendTo(tabeditorbuttons).click(function()
		{
			var tab = pBank.data("currenttab");
			if (tab && tab.prev())
			{
				tab.insertBefore(tab.prev());
			}
			B.saveCatalog(pBank);
		});
		$("<div class='bnkCatalogTabDown bnkButton curClick' title='Move this tab <dfn>down</dfn>.'></div>")
			.appendTo(tabeditorbuttons).click(function()
		{
			var tab = pBank.data("currenttab");
			if (tab && tab.next())
			{
				tab.insertAfter(tab.next());
			}
			B.saveCatalog(pBank);
		});
		$("<div class='bnkCatalogTabDelete bnkButton curClick' title='<dfn>Delete</dfn> this custom bank tab.'></div>")
			.appendTo(tabeditorbuttons).click(function()
		{
			var tab = pBank.data("currenttab");
			var removeTab = function()
			{
				tab.remove();
				tabeditor.hide();
				A.adjustAccountPanel();
				B.saveCatalog(pBank);
			};
			if (tab)
			{
				// Show confirmation if the tab is not empty
				if (tab.find(".bnkSlot").length > 0)
				{
					if (confirm("Delete this custom tab?"))
					{
						removeTab();
					}
				}
				else
				{
					removeTab();
				}
			}
		});
		
		/*
		 * Slot editor.
		 */
		var sloteditor = $("<div class='bnkCatalogSlotEditor'></div>").appendTo(dishmenu).hide();
		pBank.data("sloteditor", sloteditor);
		$("<div class='bnkCatalogMenuClose bnkButton curClick' title='<dfn>Close</dfn> the slot editor.'></div>")
			.appendTo(sloteditor).click(function()
		{
			var currentslot = pBank.data("currentslot");
			if (currentslot)
			{
				currentslot.removeClass("bnkCatalogSlotHighlight");
			}
			pBank.data("currentslot", null);
			sloteditor.hide();
			A.adjustAccountPanel();
		});
		var sloteditorbuttons = $("<aside class='bnkButtons'></aside>").appendTo(sloteditor);
		$("<div class='bnkCatalogSlotLeft bnkButton curClick' title='Move this slot <dfn>left</dfn>.'></div>")
			.appendTo(sloteditorbuttons).click(function()
		{
			var slot = pBank.data("currentslot");
			if (slot && slot.prev())
			{
				slot.insertBefore(slot.prev());
			}
			B.saveCatalog(pBank);
		});
		$("<div class='bnkCatalogSlotRight bnkButton curClick' title='Move this slot <dfn>right</dfn>.'></div>")
			.appendTo(sloteditorbuttons).click(function()
		{
			var slot = pBank.data("currentslot");
			if (slot && slot.next())
			{
				slot.insertAfter(slot.next());
			}
			B.saveCatalog(pBank);
		});
		$("<div class='bnkCatalogSlotDelete bnkButton curClick' title='<dfn>Delete</dfn> this custom bank slot.'></div>")
			.appendTo(sloteditorbuttons).click(function()
		{
			var slot = pBank.data("currentslot");
			if (slot)
			{
				slot.remove();
				sloteditor.hide();
				A.adjustAccountPanel();
			}
			B.saveCatalog(pBank);
		});
		
		I.qTip.init(tabeditor.find(".bnkButton"));
		I.qTip.init(sloteditor.find(".bnkButton"));
		
		// Return the extended unlockables data for the generate function to use
		return {
			oHeaders: headers,
			oRecord: record
		};
	},
	
	/*
	 * Generates a Trading Post transactions style bank.
	 * @param string pSection account section name.
	 * @param enum pURL of the API endpoint.
	 */
	generateTransactions: function(pSection, pURL)
	{
		var section = U.toFirstUpperCase(pSection);
		var sectionlower = pSection.toLowerCase();
		var dish = $("#accDish_" + section);
		if (A.reinitializeDish(dish) === false)
		{
			return;
		}
		
		var container = B.createBank(dish, {
			aTitle: D.getWordCapital(sectionlower),
			aClass: "bnkBankTrading",
			aIsCollection: false,
			aWantGem: false
		});
		var bank = B.getTabsContainer(container).append(I.cThrobber);
		var itemids = [];
		var numfetched = 0, numtofetch = 0;
		var calendar = {}, datestr, datearray, calkey, timesince, transaction, multitrans, transactionstr;
		var pricebuy, pricesell;
		var wantcollapsed = false;
		
		var fillTab = function(pTab, pMonthKey)
		{
			var tabnumfetched = 0, tabnumtofetch = U.getObjectLength(calendar[pMonthKey]);
			var slot;
			var slotscontainer = B.getSlotsContainer(pTab);
			var tabdata = []; // Contains the multi-transactions objects but will be chronologically sorted instead of by item ID
			for (var ii in calendar[pMonthKey])
			{
				multitrans = (calendar[pMonthKey])[ii];
				slot = B.createBankSlot(slotscontainer);
				slot.data("count", multitrans.oCount);
				tabdata.push(multitrans);
				(function(iSlot, iMultiTrans)
				{
					Q.getItem(iMultiTrans.oItemID, function(iItem)
					{
						pricebuy = (sectionlower === "buying" || sectionlower === "bought") ? iMultiTrans.oPrice : null;
						pricesell = (sectionlower === "selling" || sectionlower === "sold") ? iMultiTrans.oPrice : null;
						B.styleBankSlot(iSlot,
						{
							aItem: iItem,
							aComment: "<table class='bnkTransactionsTooltip'>" + iMultiTrans.oStampsTip + "</table>",
							aTransactionBuy: pricebuy,
							aTransactionSell: pricesell,
							aSlotMeta: {count: iMultiTrans.oCount},
							aCallback: function()
							{
								if (wantcollapsed)
								{
									tabnumfetched++;
									A.setProgressBar(tabnumfetched, tabnumtofetch);
								}
								else
								{
									numfetched++;
									A.setProgressBar(numfetched, numtofetch);
								}
							},
							aPriceCallback: function(pPrice)
							{
								if (sectionlower === "buying")
								{
									// If the item the user is buying is outbidded, then highlight it
									if (pPrice.oPriceBuy === iMultiTrans.oHighest)
									{
										iSlot.addClass("bnkSlotMatchAlternate");
									}
								}
								else if (sectionlower === "selling")
								{
									// If the item the user is selling is not outbidded, then highlight it
									if (pPrice.oPriceSell === iMultiTrans.oLowest)
									{
										iSlot.addClass("bnkSlotMatchAlternate");
									}
								}
							},
							aBind: function(pSlot, pItem)
							{
								pSlot.unbind("click").click(function(pEvent)
								{
									if (pEvent.which === I.ClickEnum.Left)
									{
										E.printListings(pItem.id);
									}
								});
							}
						});
					});
				})(slot, multitrans);
			}
			U.sortObjects(tabdata, {aKeyName: "oLatest"});
			pTab.data("transactions", tabdata);
			// Button next to each tab to print that tab's transactions in text list format
			var tabprint = $("<kbd class='bnkTransactionsPrint btnWindow' title='<dfn>Print</dfn> this month of transactions in chronological order.'></kbd>")
				.prependTo(pTab).click(function()
			{
				var clickedtab = $(this).closest(".bnkTab").first();
				var data = clickedtab.data("transactions");
				// Assume item is already fetched and cached, so the string order is sequential
				var str = "<div class='bnkTransactionsContainer'>";
				for (var i = data.length - 1; i >= 0; i--)
				{
					Q.getItem(data[i].oItemID, function(iItem)
					{
						if (data[i])
						{
							str += "<div class='bnkTransactionsBox'>"
								+ Q.getItemPreface(iItem, data[i].oCount)
								+ "<table class='bnkTransactionsTable'>" + data[i].oStamps + "</table>"
							+ "</div>";
						}
					});
				}
				str += "</div>";
				I.print(str, true);
				I.bindConsoleInput();
			});
			I.qTip.init(tabprint);
		};
		
		A.getTransactions(pURL, {aCallback: function(pData)
		{
			if (pData === null) // For the case that there are no current transactions
			{
				bank.empty();
				bank.append("<span class='bnkError'>" + D.getWordCapital("no")
					+ " " + D.getModifiedWord("transactions", "current") + ".</span>");
				return;
			}
			/*
			 * Categorize each transaction chronologically by its month; however,
			 * the items in the tab will be sorted by item ID.
			 */
			var nowms = (new Date()).getTime();
			for (var i = 0; i < pData.length; i++)
			{
				transaction = pData[i];
				// Example date string: "2000-01-01T13:59:59+00:00"
				datestr = transaction.purchased || transaction.created;
				datearray = datestr.split("-");
				calkey = datearray[0] + "-" + datearray[1]; // [0] is year, [1] is month
				if (calendar[calkey] === undefined)
				{
					calendar[calkey] = {};
				}
				// Remember time since purchased for historical transactions, or time since creation for current transactions
				timesince = (transaction.purchased)
					? T.formatMilliseconds((new Date(transaction.purchased)).getTime() - (new Date(transaction.created)).getTime())
					: T.formatMilliseconds(nowms - (new Date(transaction.created)).getTime());
				/*
				 * Transactions of the same item will be assigned to the same
				 * "slot" in the month associative array, accessed by the item ID.
				 * Transactions' metadata will still be accumulated in the stamp
				 * string for display in the slot tooltip.
				 */
				if ((calendar[calkey])[transaction.item_id] === undefined)
				{
					itemids.push(transaction.item_id);
					(calendar[calkey])[transaction.item_id] = {
						oLatest: transaction.purchased || transaction.created, // For chronological sorting
						oHighest: Number.NEGATIVE_INFINITY, // For outbid checking
						oLowest: Number.POSITIVE_INFINITY, // For outprice checking
						oItemID: transaction.item_id,
						oNumTransactions: 0,
						oCount: 0,
						oPrice: 0,
						oStamps: "",
						oStampsTip: ""
					};
					numtofetch++;
				}
				multitrans = (calendar[calkey])[transaction.item_id];
				multitrans.oCount += transaction.quantity;
				multitrans.oPrice += (transaction.price * transaction.quantity);
				multitrans.oNumTransactions += 1;
				transactionstr = "<tr>"
					+ "<td>" + transaction.quantity + " " + I.Symbol.Quantity + "&nbsp;</td>"
					+ "<td>" + E.formatCoinStringColored(transaction.price) + " =&nbsp;</td>"
					+ "<td>" + E.formatCoinStringColored(transaction.price * transaction.quantity) + "</td>"
					+ "<td>&nbsp;(" + timesince + ")</td>"
					+ "<td>&nbsp;@ " + (new Date(transaction.purchased || transaction.created)).toLocaleString() + "</td>"
				+ "</tr>";
				multitrans.oStamps += transactionstr;
				// Limit the number of transactions listed in the tooltip
				if (multitrans.oNumTransactions < Q.GameLimit.TooltipLines)
				{
					multitrans.oStampsTip += transactionstr;
				}
				if (transaction.price > multitrans.oHighest)
				{
					multitrans.oHighest = transaction.price;
				}
				if (transaction.price < multitrans.oLowest)
				{
					multitrans.oLowest = transaction.price;
				}
			}
			/*
			 * Automatically fills the tabs if the total number of slots to generate
			 * is less than the threshold, otherwise the user has to manually
			 * expand the tab headers to trigger the fill tabs function.
			 */
			Q.getPricedItems(itemids, function()
			{
				bank.empty();
				wantcollapsed = numtofetch > Q.GameLimit.FetchAPI;
				var tab, tabtitle, tabcapacity, tabcount, bankcapacity = 0, bankcount = 0;
				for (var i in calendar)
				{
					tabcapacity = 0, tabcount = 0;
					// The tab title is the year number and the month word
					calkey = i.split("-");
					tabtitle = T.formatLocal(
						new Date(Date.UTC(calkey[0], calkey[1], 1, 0, 0, 0)),
						{year: "numeric", month: "long"}
					);
					// Create bank tabs representing months
					tab = B.createBankTab(bank, {aTitle: tabtitle, aIsCollapsed: wantcollapsed});
					if (wantcollapsed)
					{
						(function(iTab, iMonthKey)
						{
							iTab.find(".bnkTabSeparator").one("click", function()
							{
								fillTab(iTab, iMonthKey);
							});
						})(tab, i);
					}
					else
					{
						fillTab(tab, i);
					}
					// Sum tab capacity and slot count
					for (var ii in calendar[i])
					{
						tabcapacity++;
						tabcount += (calendar[i])[ii].oCount;
					}
					bankcapacity += tabcapacity;
					bankcount += tabcount;
					B.updateTabTally(tab, tabcapacity, tabcapacity, tabcount);
				}
				B.updateBankTally(container, bankcapacity, bankcapacity, bankcount);
				B.createBankMenu(bank, {
					aHelpMessage: $("#accHelpTransactions").html()
				});
			});
		}});
	}
};
Q = {
/* =============================================================================
 * @@Quantify items, attributes, traits, and achievements
 * ========================================================================== */

	Boxes: {
	/*
	 * Associative arrays for container objects of retrieved raw API data (oData),
	 * analyzed data (oHTML), and other optional properties, accessed by the ID
	 * number of the datum.
	 */
		Items: {},
		Skins: {},
		Guilds: {},
		Achievements: {},
		Titles: {},
		Specializations: {},
		Traits: {},
		Skills: {}
	},
	isBoxedFully: {}, // Whether all data has been stored for that API type
	RetrievedDatabases: {}, // Stores names of retrieved items databases to avoid redoing
	SearchDatabase: null, // Search array for all items
	CleanableFilter: null, // Associative array of cleanable items to be used by the bank filters, not the cleanup tool
	ItemEnum: // Corresponds to item details type property
	{
		Gathering: "Gathering",
		Tool: "Tool",
		Gizmo: "Gizmo",
		Bag: "Bag",
		Back: "Back",
		Armor: "Armor",
		Weapon: "Weapon",
		Trinket: "Trinket",
		UpgradeComponent: "UpgradeComponent",
		Consumable: "Consumable",
		Container: "Container",
		CraftingMaterial: "CraftingMaterial",
		MiniPet: "MiniPet",
		Trophy: "Trophy"
	},
	ItemRank:
	{
		Gathering: "A",
		Tool: "B",
		Gizmo: "C",
		Bag: "D",
		Back: "E",
		Armor: "F",
		Weapon: "G",
		Trinket: "H",
		UpgradeComponent: "I",
		Consumable: "J",
		Container: "K",
		CraftingMaterial: "L",
		MiniPet: "M",
		Trophy: "N"
	},
	RarityEnum: // Corresponds to API names for rarity levels
	{
		Junk: "Junk",
		Basic: "Basic",
		Fine: "Fine",
		Masterwork: "Masterwork",
		Rare: "Rare",
		Exotic: "Exotic",
		Ascended: "Ascended",
		Legendary: "Legendary"
	},
	RarityNumber: // Corresponds to API names for rarity levels
	{
		Junk: 1,
		Basic: 2,
		Fine: 3,
		Masterwork: 4,
		Rare: 5,
		Exotic: 6,
		Ascended: 7,
		Legendary: 8
	},
	RarityRank:
	{
		Junk: "A",
		Basic: "B",
		Fine: "C",
		Masterwork: "D",
		Rare: "E",
		Exotic: "F",
		Ascended: "G",
		Legendary: "H"
	},
	WeightRank:
	{
		Light: "A",
		Medium: "B",
		Heavy: "C"
	},
	ArmorRank:
	{
		HelmAquatic: "A",
		Helm: "B",
		Shoulders: "C",
		Coat: "D",
		Gloves: "E",
		Leggings: "F",
		Boots: "G"
	},
	WeaponRank:
	{
		Axe: "A",
		Dagger: "B",
		Mace: "C",
		Pistol: "D",
		Scepter: "E",
		Sword: "F",
		Focus: "G",
		Shield: "H",
		Torch: "I",
		Warhorn: "J",
		Greatsword: "K",
		Hammer: "L",
		LongBow: "M",
		Rifle: "N",
		ShortBow: "O",
		Staff: "P",
		Harpoon: "Q",
		Speargun: "R",
		Trident: "S"
	},
	TrinketRank:
	{
		Amulet: "A",
		Accessory: "B",
		Ring: "C"
	},
	RunePieces:
	{
		Masterwork: 2,
		Rare: 4,
		Exotic: 6
	},
	GameLimit:
	{
		Unknown: 8055, // ID of an "unknown" item
		DailyAP: 15000,
		FetchAPI: 800, // Max items before a function resorts to on demand downloads
		TooltipLines: 100, // Text lines in a tooltip window
		LevelMax: 80,
		StackSize: 250,
		EctoSalvageLevel: 68
	},
	cSEARCH_LIMIT: 200, // Inventory search throttle limit
	Context: // Bank slots context menu data
	{
		Item: null,
		ItemName: null,
		ItemID: null,
		ItemSearch: null
	},
	isFauxInitialized: false,
	
	/*
	 * Loads a database file containing item details objects precached from API.
	 * @param string pName of the database.
	 * @param function pCallback to execute after success.
	 * @pre The database files exist in the proper directory and suffixed with
	 * the supported language nick.
	 */
	loadItemsSubdatabase: function(pName, pCallback)
	{
		if (Q.RetrievedDatabases[pName])
		{
			pCallback();
		}
		else
		{
			$.getJSON(U.getCacheURL(pName), function(pData)
			{
				Q.RetrievedDatabases[pName] = true;
				Q.initializeBoxes("items", pData);
			}).always(function()
			{
				// Execute callback regardless of success, in case of failed retrieval
				pCallback();
			});
		}
	},
	
	/*
	 * Loads the search database to search by item name.
	 * @param function pCallback to execute after success.
	 */
	loadItemsSearch: function(pCallback)
	{
		if (Q.SearchDatabase)
		{
			pCallback();
		}
		else
		{
			$.getJSON("cache/search_" + D.langPartiallySupported + I.cJSON, function(pData)
			{
				Q.SearchDatabase = pData;
				pCallback();
			});
		}
	},
	
	/*
	 * Sets an object with an item rarity CSS class. Removes all if level is not provided.
	 * @param jqobject pEntry to remove.
	 * @param string pLevel of rarity.
	 */
	setRarityClass: function(pEntry, pLevel)
	{
		for (var i in Q.RarityEnum)
		{
			pEntry.removeClass("rarity_" + i);
		}
		if (Q.RarityEnum[pLevel] !== undefined)
		{
			pEntry.addClass("rarity_" + pLevel);
		}
	},
	
	/*
	 * Gets a rarity CSS class from a rarity name.
	 * @param string pRarity.
	 * @returns string CSS class.
	 */
	getRarityClass: function(pRarity)
	{
		return "rarity_" + pRarity;
	},
	
	/*
	 * Gets the translated type name of an item.
	 * @param object pItem details from API.
	 * @returns string translated type.
	 */
	getItemType: function(pItem)
	{
		var det = pItem.details;
		if (det)
		{
			var type = pItem.type;
			// These top level types have overriding priority
			var validtypes = {
				Back: 1,
				Consumable: 1,
				Container: 1,
				CraftingMaterial: 1,
				Gathering: 1,
				Gizmo: 1,
				MiniPet: 1,
				Trophy: 1,
				UpgradeComponent: 1
			};
			if (validtypes[type])
			{
				return "<br />" + D.getString(type) + "<br />";
			}
			else if (det.type && det.type !== "Default") // Else use the subtype in the details property object
			{
				return D.getString(det.type) + "<br />";
			}
		}
		return "";
	},
	
	/*
	 * Standardizes attribute names to the base attribute object's keys.
	 * @param string pString.
	 * @returns string attribute name proper.
	 */
	getAttributeString: function(pString)
	{
		// Correct naming inconsistency of the attributes property in item API
		var correction = { 
			CritDamage: "Ferocity",
			Healing: "HealingPower",
			ConditionDuration: "Expertise",
			BoonDuration: "Concentration"
		};
		if (correction[pString])
		{
			return correction[pString];
		}
		return pString;
	},
	getAttributeTranslation: function(pString)
	{
		return D.getString(Q.getAttributeString(pString));
	},
	
	/*
	 * Looks for attribute points in an item and adds them to an attributes-containing object.
	 * @param object pAttrObj.
	 * @objparam object aItem to find attributes.
	 * @objparam object aRuneSets numbers of runes equipped, optional.
	 * @objparam object aStats selectable stats that the player had chosen for that equipment, used in place of item.
	 * @pre Account page's script has been loaded, which contains attribute association.
	 * Properties this function looks for:
	 * item.details.infix_upgrade.attributes // [{attribute: "Abc", "modifier": 123}, ...] language independent
	 * item.details.bonuses // ["+123 Abc", ...] language dependent
	 * item.details.infix_upgrade.buff.description // "+123 Abc\n+123 Abc..." language dependent
	 * stats.attributes // {"Abc": 123, ...}
	 */
	sumItemAttribute: function(pAttrObj, pSettings)
	{
		var Settings = pSettings || {};
		var det, attrstr, points, keyextracted, keyproper;
		// This object translates the current language extracted attribute name to the proper key name
		var assocobj = A.Attribute["KeyDescription_" + D.langFullySupported];
		// Reuseable function to parse array of attribute strings which are language dependent
		var sumAttributeArray = function(pArray)
		{
			var length = pArray.length;
			var runepieces = 0;
			// Special case if summing for a rune
			if (Settings.aRuneSets && Settings.aRuneSets[Settings.aItem.id])
			{
				// Don't re-sum if already did
				if (Settings.aRuneSets[Settings.aItem.id].issummed === true)
				{
					return;
				}
				runepieces = Settings.aRuneSets[Settings.aItem.id].numslotted;
				length = runepieces;
			}
			
			for (var i = 0; i < length; i++)
			{
				attrstr = pArray[i];
				points = U.stripToNumbers(attrstr);
				// The attribute key name shall be whatever that remains after stripping the description of non-letter characters
				keyextracted = (attrstr.replace(/[\s0-9%,.\-+']/g, "")).toLowerCase();
				if (assocobj[keyextracted])
				{
					keyproper = assocobj[keyextracted];
					/*
					 * Skip an anomaly in the API details for "infused" items
					 * that contains agony attribute in the description (being
					 * redundant because of infusion slots).
					 */
					if (keyproper === "AgonyResistance" && det.infusion_slots)
					{
						continue;
					}
					pAttrObj[keyproper] += points;
				}
			}
			if (Settings.aRuneSets && Settings.aRuneSets[Settings.aItem.id])
			{
				// Mark the rune to avoid resumming it
				Settings.aRuneSets[Settings.aItem.id].issummed = true;
			}
		};
		
		// For items themselves or runes
		var item = Settings.aItem;
		if (item && item.details)
		{
			det = item.details;
			
			// Non-rune items
			if (det.infix_upgrade && det.infix_upgrade.attributes)
			{
				det.infix_upgrade.attributes.forEach(function(iAttr)
				{
					var attrname = A.Attribute.KeyAttributes[iAttr.attribute];
					if (attrname)
					{
						pAttrObj[attrname] += iAttr.modifier;
					}
				});
			}
			// Runes
			if (det.bonuses)
			{
				sumAttributeArray(det.bonuses);
			}
			// Armor and shield that have defense attribute (adds to armor)
			if (det.defense !== undefined)
			{
				pAttrObj["Armor"] += det.defense;
			}
		}
		
		// For selectable-stats equipment
		if (Settings.aStats)
		{
			var selectattr = Settings.aStats.attributes;
			if (selectattr)
			{
				for (var i in selectattr)
				{
					pAttrObj[Q.getAttributeString(i)] += selectattr[i];
				}
			}
		}
	},
	
	/*
	 * Adds the attribute points of one attributes-containing object to another.
	 * @param object pAttrMain destination.
	 * @param object pAttrAdd source.
	 */
	sumAttributeObject: function(pAttrMain, pAttrAdd)
	{
		for (var i in pAttrMain)
		{
			pAttrMain[i] += pAttrAdd[i];
		};
	},
	
	/*
	 * Uses an attributes-containing object and calculates it with the base stats.
	 * @param object pAttrObj for adding geared stats.
	 * @param object pCharacter for calculating base stats.
	 * @param boolean pWantValue whether to return an object with numbers instead of formatted strings.
	 * @returns object attributes as string representation of the numbers.
	 */
	calculateAttributes: function(pAttrObj, pCharacter, pWantValue)
	{
		var attrobj = {};
		var level = pCharacter.level;
		var profession = pCharacter.oCharProfession;
		var constants = A.Attribute.Constants;
		var baseattr = A.Attribute.PrimaryPoints[level - 1];
		var precisiondivisor = A.Attribute.PrecisionDivisor[level - 1];
		var secondarydivisor = precisiondivisor / A.Attribute.SecondaryDivisorRatio;
		/*
		 * Calculate the health by adding converted base vitality with the base
		 * health points, then add it with the object's.
		 */
		var profhealth = 0;
		var levelprev = 0;
		var healthtype = A.Metadata.Profession[profession].health;
		var healthgrowth = A.Attribute.HealthGrowth[healthtype];
		var healthtier = 0;
		for (var i in healthgrowth)
		{
			healthtier = parseInt(i);
			if (healthtier <= level)
			{
				profhealth += (healthtier - levelprev) * healthgrowth[i];
				levelprev = healthtier;
			}
			else
			{
				profhealth += (level - levelprev) * healthgrowth[i];
				break;
			}
		}
		/*
		 * Use simple additions (with base attribute if available) and ratios to
		 * get these attributes. This object contains unformatted raw numbers.
		 */
		var attrnew = {
			Power:				baseattr + pAttrObj.Power,
			Toughness:			baseattr + pAttrObj.Toughness,
			Armor:				baseattr + pAttrObj.Armor + pAttrObj.Toughness,
			Vitality:			baseattr + pAttrObj.Vitality,
			Health:				(baseattr / constants.VITALITY_IN_HEALTH) + profhealth + pAttrObj.Health + (pAttrObj.Vitality / constants.VITALITY_IN_HEALTH),
			Precision:			baseattr + pAttrObj.Precision,
			CriticalChance:		constants.BASE_CRITICALCHANCE + pAttrObj.CriticalChance + (pAttrObj.Precision / precisiondivisor),
			Ferocity:			pAttrObj.Ferocity,
			CriticalDamage:		constants.BASE_CRITICALDAMAGE + pAttrObj.CriticalDamage + (pAttrObj.Ferocity / secondarydivisor),
			ConditionDamage:	pAttrObj.ConditionDamage,
			HealingPower:		pAttrObj.HealingPower,
			Expertise:			pAttrObj.Expertise,
			ConditionDuration:	pAttrObj.ConditionDuration + (pAttrObj.Expertise / secondarydivisor),
			Concentration:		pAttrObj.Concentration,
			BoonDuration:		pAttrObj.BoonDuration + (pAttrObj.Concentration / secondarydivisor),
			AgonyResistance:	pAttrObj.AgonyResistance,
			MagicFind:			pAttrObj.MagicFind
		};
		// Return raw values if requested
		if (pWantValue)
		{
			return attrnew;
		}
		// Otherwise format the values as strings
		for (var i in attrnew)
		{
			attrobj[i] = (A.Attribute.KeyType[i]) ? U.formatPercentage(attrnew[i], 2, 1) : parseInt(attrnew[i]).toLocaleString();
		}
		return attrobj;
	},
	
	/*
	 * Looks through a character object's equipment property and tally the
	 * number of same runes.
	 * @param object pCharacter.
	 * @returns object with rune item ID and count.
	 */
	countRuneSets: function(pCharacter)
	{
		var equip = pCharacter.equipment;
		var armorcount = 0;
		if (equip)
		{
			var obj = {};
			for (var i = 0; i < equip.length; i++)
			{
				// If it is an armor slot and has upgrades
				if (A.Equipment.ArmorSlots[(equip[i].slot)] && equip[i].upgrades)
				{
					var runeid = equip[i].upgrades[0];
					if (obj[runeid] === undefined)
					{
						obj[runeid] = {
							numslotted: 0,
							issummed: false // Whether the rune's attributes (if it is equipped) have been summed yet
						};
					}
					obj[runeid].numslotted = obj[runeid].numslotted + 1;
					armorcount++;
				}
				if (armorcount === A.Equipment.NumArmorSlots)
				{
					break;
				}
			}
			return obj;
		}
		return null;
	},
	
	/*
	 * Formats the text of a rune's bonuses.
	 * @param object pItem details from API.
	 * @param object or int pRuneSets numbers of runes equipped, optional.
	 * @returns string HTML.
	 */
	getRuneBonus: function(pItem, pRuneSets)
	{
		var str = "";
		var det = pItem.details;
		var runeith = 0;
		var runemax = Q.RunePieces[pItem.rarity];
		var runepieces = (pRuneSets && pRuneSets[pItem.id]) ? pRuneSets[pItem.id].numslotted : null;
		if (typeof pRuneSets === "number")
		{
			runepieces = pRuneSets;
		}
		if (runepieces > runemax)
		{
			runepieces = runemax; // Prevent overcounting of bonuses if equipped too many of same runes
		}
		
		var runecolor = "";
		if (det.bonuses)
		{
			str += (runepieces !== null) ? "" : "<br />";
			str += "<span class='itmGrayed'>";
			if (runepieces !== null)
			{
				str += "<var class='itmBuff'>" + pItem.name + " (" + runepieces + "/" + runemax + ")</var><br />";
			}
			for (var i in det.bonuses)
			{
				// Colorize the bonus line if the rune is equipped
				runecolor = (runeith < runepieces) ? " class='itmBuff'" : "";
				runeith++;
				str += "<var" + runecolor + ">(" + runeith + "): " + det.bonuses[i] + "</var><br />";
			}
			str += "</span>";
		}
		return str;
	},
	
	/*
	 * Gets the description of the buff property of an item.
	 * @param object or string pItem details from API or the description itself.
	 * @returns string description.
	 */
	formatItemDescription: function(pItem)
	{
		try
		{
			var desc = (typeof pItem === "string") ? pItem : pItem.details.infix_upgrade.buff.description;
			/*
			 * Item details' description may be pretagged with XML that colorizes
			 * a portion of text. Example: <c=@flavor>Description</c>
			 * If a tag exists, it shall have the "=@flavor" replaced with " class='.itmColor_flavor'"
			 */
			if (desc.indexOf("<c=@") !== -1)
			{
				desc = desc.replace(/<c=@abilitytype>/g, "<c class='itmColor_abilitytype'>");
				desc = desc.replace(/<c=@flavor>/g, "<c class='itmColor_flavor'>");
				desc = desc.replace(/<c=@reminder>/g, "<c class='itmColor_reminder'>");
				desc = desc.replace(/<c=@warning>/g, "<c class='itmColor_warning'>");
			}
			if (desc.indexOf("\n") !== -1)
			{
				return desc.replace(/\n/g, "<br />");
			}
			else
			{
				return desc;
			}
		}
		catch (e) {}
		return "";
	},
	
	/*
	 * Tells whether an item can be traded and has price on the Trading Post.
	 * @param int or object pItem ID of an item, or the item itself.
	 * @returns boolean.
	 * @pre Item was analyzed if requesting by ID.
	 */
	isTradeable: function(pItem)
	{
		if (pItem === undefined)
		{
			return false;
		}
		// If item is an ID
		if (typeof pItem === "number")
		{
			var box = Q.getBoxedItem(pItem);
			// Assume item is tradeable, unless it was analyzed not to be so
			if (box)
			{
				return (box.oIsTradeable === false) ? false : true;
			}
		}
		// If item is an item details object
		if (pItem.flags)
		{
			var flag;
			for (var i = 0; i < pItem.flags.length; i++)
			{
				flag = pItem.flags[i];
				if (flag === "AccountBound" || flag === "SoulbindOnAcquire")
				{
					return false;
				}
			}
		}
		return true;
	},
	
	/*
	 * Retrieves item details from API if haven't already, then execute callback
	 * function. Basically a wrapper for getJSON with item ID function.
	 * @param int pItemID to get item.
	 * @param function pCallback to execute after successful retrieval.
	 * @returns jqXHR object.
	 * @pre Method chaining is at most one level with "fail" function call only.
	 */
	getItem: function(pItemID, pCallback)
	{
		var box = Q.getBoxedItem(pItemID);
		if (box)
		{
			pCallback(box.oData);
			// Dummy fail jqxhr function that never executes because the item was successfully cached
			return {fail: function() {}};
		}
		else
		{
			var jqxhr = $.ajax({
				dataType: "json",
				url: U.getAPIItem(pItemID),
				cache: true,
				success: function(pItem)
				{
					if (Q.Boxes.Items[pItem.id] === undefined)
					{
						Q.Boxes.Items[pItem.id] = {};
						Q.Boxes.Items[pItem.id].oData = pItem;
					}
					pCallback(pItem);
				}
			});
			return jqxhr;
		}
	},
	getPricedItems: function(pItemIDs, pCallback, pWantCache)
	{
		// Combine item details and TP price retrieval in one call
		Q.getItems(pItemIDs, function()
		{
			E.getPrices(pItemIDs, function()
			{
				pCallback();
			}, pWantCache);
		});
	},
	
	/*
	 * Adds a faux item to the cache using simplified data.
	 * @param object pData containing multilingual name and description, type, rarity, and icon.
	 */
	createFaux: function(pData)
	{
		var id = U.stripToVariable(D.getObjectDefaultName(pData)).toLowerCase(); // Use the encoded default name as the item ID
		if (Q.Boxes.Items[id] === undefined)
		{
			var item = $.extend({
				name: D.getObjectName(pData) || "Unnamed Item",
				description: D.getObjectDesc(pData) || "",
				type: pData.type || "Consumable",
				level: (pData.level) ? pData.level : 0,
				rarity: pData.rarity || "Basic",
				vendor_value: 0,
				game_types: ["Pvp", "PvpLobby", "Wvw", "Dungeon", "Pve"],
				flags: ["AccountBound", "NoSell", "DeleteWarning", "AccountBindOnUse"],
				restrictions: [],
				id: id,
				chat_link: "[&AgF3HwAA]",
				icon: (pData.icon) ? pData.icon : "img/faux/" + id + I.cPNG,
				details: {}
			}, pData);
			// Enter into cache
			Q.Boxes.Items[id] = {};
			Q.Boxes.Items[id].oData = item;
		}
	},
	initializeFaux: function()
	{
		// Initialize the standard set of faux items
		if (Q.isFauxInitialized)
		{
			return;
		}
		for (var i in H.Faux)
		{
			Q.createFaux(H.Faux[i]);
		}
	},
	
	/*
	 * Sorts an array of item IDs by item type, subtype, and other properties.
	 * @param intarray pItemIDs
	 * @param function pCallback with sorted items and IDs, or the items database for return.
	 */
	sortItems: function(pItemIDs, pCallback)
	{
		var isasync = false;
		var categorizeItem = function(pItem)
		{
			var itemrank = Q.ItemRank[pItem.type] || "0";
			var name = pItem.name;
			var type = pItem.type;
			var subtype = (pItem.details && pItem.details.type) ? pItem.details.type : "";
			var rarity = pItem.rarity;
			var rarityrank = Q.RarityRank[rarity];
			var desc = (pItem.description) ? pItem.description.toLowerCase() : "";
			var midstr = "?" + subtype;
			if (type === "Armor")
			{
				midstr = Q.WeightRank[pItem.details.weight_class] + "_" + Q.ArmorRank[subtype];
			}
			else if (type === "Weapon")
			{
				midstr = Q.WeaponRank[subtype];
			}
			else if (type === "Trinket")
			{
				midstr = Q.TrinketRank[subtype];
			}
			else if (desc.indexOf("decoration") !== -1)
			{
				midstr = "Decoration";
			}
			else if (desc.indexOf("recipe") !== -1)
			{
				midstr = "Recipe";
			}

			return itemrank + "_" + midstr + "_" + rarityrank + "_" + U.stripToAlphanumeric(name);
		};
		
		var startSort = function()
		{
			var items = [], id, item, retitems = [], retids = [];
			// Create an array of objects for the sort function
			for (var i = 0; i < pItemIDs.length; i++)
			{
				id = pItemIDs[i];
				item = (isasync) ? ((Q.Boxes.Items[id]) ? Q.Boxes.Items[id].oData : null) : pCallback[id];
				if (item)
				{
					items.push({
						oData: item,
						oType: categorizeItem(item)
					});
				}
			}
			// Sort then return as plain array of IDs
			U.sortObjects(items, {aKeyName: "oType"});
			items.forEach(function(iObject)
			{
				retitems.push(iObject.oData);
				retids.push(iObject.oData.id);
			});
			if (isasync)
			{
				pCallback(retitems, retids);
			}
			else
			{
				return {
					oItems: retitems,
					oIDs: retids
				};
			}
		};
		
		// Asynchronous if database is not provided
		if (typeof pCallback === "function")
		{
			isasync = true;
			Q.getItems(pItemIDs, function()
			{
				startSort();
			});
		}
		else
		{
			// If callback parameter is an items database
			return startSort();
		}
	},
	
	/*
	 * Gets the cleanup category of an item, if not cleanable then null.
	 * @param object pItem details.
	 * @param boolean pIsFilter if called by a filter action rather than collate.
	 * Calling without this boolean assumes it is for filtering inventory items.
	 * @returns string category.
	 */
	categorizeCleanableItem: function(pItem, pIsFilter)
	{
		var name = pItem.name.toLowerCase();
		var desc = (pItem.description) ? pItem.description.toLowerCase() : "";
		
		// These language-independent filters supplement the cleanup filter associative array
		if (pIsFilter)
		{
			if (pItem.type === Q.ItemEnum.UpgradeComponent || pItem.type === Q.ItemEnum.CraftingMaterial)
			{
				return "Combine";
			}
			if ((pItem.type === Q.ItemEnum.Armor || pItem.type === Q.ItemEnum.Weapon)
				&& Q.RarityNumber[pItem.rarity] < Q.RarityNumber.Rare)
			{
				return "Junk";
			}
			return null; // Do not proceed with other filters
		}
		
		// These filters are for the collate function
		if (desc.indexOf("decoration") !== -1)
		{
			if (pItem.type === Q.ItemEnum.Gizmo || pItem.type === Q.ItemEnum.Consumable || pItem.type === Q.ItemEnum.Trophy)
			{
				return "Decoration";
			}
		}
		if (desc.indexOf("value as part of a collection") !== -1)
		{
			return "Collection";
		}
		if (name.indexOf("recipe") !== -1)
		{
			return "Recipe";
		}
		if (pItem.rarity === Q.RarityEnum.Rare && pItem.level && pItem.level > Q.GameLimit.EctoSalvageLevel)
		{
			if (pItem.type === Q.ItemEnum.Weapon || pItem.type === Q.ItemEnum.Armor || pItem.type === Q.ItemEnum.Trinket || pItem.type === Q.ItemEnum.Back)
			{
				if (pItem.flags.indexOf("NoSalvage") === -1)
				{
					return "Rare";
				}
			}
		}
		if (pItem.type === Q.ItemEnum.Container)
		{
			if (pItem.rarity === Q.RarityEnum.Ascended)
			{
				return "ContainerAscended";
			}
			if (name.indexOf("weapon") !== -1 || name.indexOf("armor") !== -1 || name.indexOf("skin") !== -1)
			{
				return "ContainerGear";
			}
			if (pItem.rarity === Q.RarityEnum.Rare || pItem.rarity === Q.RarityEnum.Exotic)
			{
				if (name.indexOf("gear") !== -1 
					|| desc.indexOf("weapon") !== -1 || desc.indexOf("armor") !== -1 || desc.indexOf("gear") !== -1 || desc.indexOf("skin") !== -1)
				{
					return "ContainerGear";
				}
			}
			return "Container";
		}
		if (pItem.type === Q.ItemEnum.Trophy)
		{
			if (desc.indexOf("salvage item") !== -1)
			{
				return "Salvage";
			}
			if (desc.indexOf("used to") !== -1 || desc.indexOf("to make") !== -1)
			{
				return "Combine";
			}
			if (pItem.rarity === Q.RarityEnum.Junk)
			{
				return "Junk";
			}
			if (pItem.rarity !== "Legendary" &&
				(Q.isTradeable(pItem) === false
				|| desc.indexOf("event item") !== -1
				|| desc.indexOf("task item") !== -1
				|| (pItem.vendor_value > 0 && pItem.flags.indexOf("NoSell") === -1)))
			{
				return "Collection";
			}
		}
		if (pItem.type === Q.ItemEnum.Gizmo)
		{
			if (desc.indexOf("combine") !== -1 && desc.indexOf("tier") === -1)
			{
				return "Combine";
			}
		}
		if (pItem.type === Q.ItemEnum.Consumable)
		{
			if (pItem.details.type === "Food" || pItem.details.type === "Utility")
			{
				return "Food";
			}
			if (pItem.details.type === "Transmutation")
			{
				return "Skin";
			}
			return "Consumable";
		}
		
		// No match so return none
		return null;
	},
	
	/*
	 * Initializes the filter used by the bank menu button that highlights
	 * cleanable items.
	 * @param function pCallback after initialization.
	 */
	initializeCleanableFilter: function(pCallback)
	{
		var section = "Cleanup";
		if (Q.CleanableFilter !== null)
		{
			pCallback();
		}
		else
		{
			U.getScript(U.URL_DATA.Cleanup, function()
			{
				Q.CleanableFilter = {};
				var record = U.getRecordData(section), catarr;
				for (var i in record)
				{
					// Exclude some categories
					if (i === "Food")
					{
						continue;
					}
					catarr = record[i];
					for (var ii = 0; ii < catarr.length; ii++)
					{
						Q.CleanableFilter[(catarr[ii])] = true;
					}
				}
				pCallback();
			});
		}
	},
	
	/*
	 * Tells if an item as shown in a bank or inventory can salvaged, vendored, or destroyed.
	 * @param int pItemID
	 * @returns boolean
	 * @pre Cleanup filter was initialized.
	 */
	isCleanable: function(pItemID)
	{
		return (Q.CleanableFilter[pItemID] || Q.categorizeCleanableItem(Q.getCachedItem(pItemID), true));
	},
	
	/*
	 * Lightweight preliminary function to check if the requested item has
	 * already been analyzed, and simply retrieve the cache if available,
	 * otherwise proceed with the actual analysis function.
	 * @param object pItem item details.
	 * @param object pSettings.
	 */
	scanItem: function(pItem, pSettings)
	{
		var Settings = pSettings || {};
		var itemmeta = Settings.aItemMeta || {};
		var box = Q.getBoxedItem(pItem.id);
		
		if (box && box.oHTML)
		{
			if (itemmeta.upgrades || itemmeta.infusions || itemmeta.skin || itemmeta.slot || itemmeta.bound_to
				|| Settings.aWantAttr || Settings.aComment)
			{
				Q.analyzeItem(pItem, pSettings);
			}
			else
			{
				// Only use the cached analysis if the item is fresh (unupgraded, untransmuted, unsoulbound, not commented)
				if (Settings.aElement)
				{
					var elm = $(Settings.aElement);
					elm.attr("title", box.oHTML);
					I.qTip.init(elm);
				}
				// Execute callback if provided
				if (Settings.aCallback)
				{
					Settings.aCallback(box);
				}
			}
		}
		else
		{
			Q.analyzeItem(pItem, pSettings);
		}
	},
	
	/*
	 * Generates item tooltip HTML, compiles attributes, and retrieves linked
	 * upgrades and skins if available.
	 * @param object pItem details retrieved from API.
	 * @objparam jqobject aElement to bind tooltip.
	 * @objparam object aItemMeta contains information about the item's upgrades,
	 * infusions, skins, and bindings, which are found in characters and bank API.
	 * @objparam object aRuneSets containing counts of runes associated with rune's item ID.
	 * @objparam string aSoulbound name of character the item is bound to.
	 * @objparam function aCallback what to do after the tooltip generation
	 * completes. This provides an object containing additionally retrieved
	 * API objects like upgrades and skin.
	 */
	analyzeItem: function(pItem, pSettings)
	{
		var Settings = pSettings || {};
		// These will hold retrieved API objects, if a callback was requested
		var infusionobjs = [];
		var upgradeobjs = [];
		var skinobj = null;
		var attrobj = null; // Holds attribute points
		var isitemmeta = false;
		var istradeable = true;
		/* Example structure of aItemMeta object:
			{
				"id": 68390,
				"slot": "Coat",
				"count": 8,
				"binding": "Character",
				"bound_to": "Character Name"
				"upgrades": [24693],
				"infusions": [70852, 49433],
				"skin": 2346
			}
		 */
		if (Settings.aItemMeta)
		{
			isitemmeta = true;
		}
		Settings.aItemMeta = Settings.aItemMeta || {}; // If not provided then initialize as a blank object with undefined properties
		// Initialize attribute object if requested
		if (Settings.aWantAttr && A.isAccountInitialized)
		{
			attrobj = new A.Attribute.Base();
		}
		
		var item = pItem;
		var type = item.type;
		var subtype = "";
		var det = item.details;
		var buff = (det && det.infix_upgrade && det.infix_upgrade.buff) ? det.infix_upgrade.buff : null;
		var isweapon = (type === "Weapon");
		var isequipment = (isweapon || type === "Armor" || type === "Trinket" || type === "Back");
		var isbackitem = (type === "Back");
		var istrinket = (type === "Trinket" || isbackitem);
		var isascended = (item.rarity === Q.RarityEnum.Ascended || item.rarity === Q.RarityEnum.Legendary);
		var isdouble = false;
		var isvendorable = true;
		var isaccountbound = false;
		var issoulbound = false;
		var numfetched = 0;
		var numtofetch = 0;
		if (det && det.type)
		{
			subtype = det.type;
			if (type === "Weapon") // Only weapons can have two upgrade slots
			{
				isdouble = (subtype === "Greatsword" || subtype === "Hammer" || subtype === "LongBow"
					|| subtype === "ShortBow" || subtype === "Rifle" || subtype === "Staff"
					|| subtype === "Harpoon" || subtype === "Speargun" || subtype === "Trident");
			}
		}
		
		// NAME
		var namestr = "";
		var rarity = (item.rarity !== undefined) ? item.rarity : Q.RarityEnum.Basic;
		namestr = "<aside class='itmName " + Q.getRarityClass(rarity)
			+ "'><img class='itmIcon itmIconMain' src='" + item.icon + "' />" + U.escapeHTML(item.name) + "</aside>";
		
		// WEAPON STRENGTH
		var damagestr = "";
		if (det && det.min_power !== undefined && det.max_power !== undefined)
		{
			damagestr += "<span class='itmText'>" + D.getString("WeaponStrength") + ":</span> <span class='itmAttr'>"
				+ (det.min_power).toLocaleString() + " - " + (det.max_power).toLocaleString() + "</span><br />";
		}
		
		// DEFENSE
		var defensestr = "";
		if (det && det.defense > 0)
		{
			defensestr += "<span class='itmText'>" + D.getString("Defense") + ":</span> <span class='itmAttr'>" + (det.defense).toLocaleString() + "</span><br />";
		}
		
		// ATTRIBUTES
		var attrstr = "";
		var statsbrktop = "";
		if (det && det.infix_upgrade)
		{
			var attr = det.infix_upgrade.attributes;
			attrstr += "<aside class='itmAttr'>";
			
			if (det.infix_upgrade !== undefined)
			{
				// Armors, weapons, trinkets
				if (isequipment)
				{
					if (buff && buff.description && buff.description.indexOf("\n") === -1) // Disallow multi-line buff descriptions
					{
						attrstr += U.escapeHTML(buff.description) + "<br />";
					}
					attr.forEach(function(iStats)
					{
						attrstr += "+" + parseInt(iStats.modifier) + " " + Q.getAttributeTranslation(iStats.attribute) + "<br />";
					});
				}
				// Sigils
				else if (buff)
				{
					attrstr += "<span class='itmBuff'>" + Q.formatItemDescription(item) + "</span>";
					statsbrktop = "<br />";
				}
				// Runes
				else if (det.bonuses && det.type === "Rune")
				{
					attrstr += Q.getRuneBonus(item);
				}
			}
			
			attrstr = statsbrktop + attrstr;
			attrstr += "</aside>";
		}
		// Selectable stats equipment
		else if (Settings.aItemMeta.stats)
		{
			var selectattr = Settings.aItemMeta.stats.attributes;
			attrstr += "<aside class='itmAttr'>";
			for (var i in selectattr)
			{
				// Example output: +63 Condition Damage
				attrstr += "+" + selectattr[i] + " " + Q.getAttributeTranslation(i) + "<br />";
			}
			attrstr += "</aside>";
		}
		// Foods and Utilities
		else if (type === "Consumable")
		{
			attrstr += D.getString("DoubleClickToConsume") + "<br />";
			if (det.duration_ms !== undefined)
			{
				var consumeimgsrc = det.icon || ("img/account/item/nourishment" + ((det.type === "Food" || det.type === "Utility") ? ("_" + (det.type).toLowerCase()) : "") + I.cPNG);
				var consumetypestr = det.name || ((det.type === "Immediate") ? D.getString("Boost") : D.getString("Nourishment"));
				var consumedurstr = (det.duration_ms > 0) ? (" (" + T.formatTooltipTimeMS(det.duration_ms, true) + ")") : "";
				attrstr += "<span class='itmConsumableLine'><img class='itmIcon itmConsumableIcon' src='" + consumeimgsrc + "' /> "
					+ "<var class='itmGrayed itmConsumableDesc'>" + consumetypestr + consumedurstr + ": " + Q.formatItemDescription(det.description) + "</var></span>";
			}
			else if (det.type === "Booze")
			{
				attrstr += D.getString("ExcessiveAlcohol") + "<br />";
			}
		}
		// Sum attribute points if requested
		if (attrobj)
		{
			Q.sumItemAttribute(attrobj, {aItem: item, aStats: Settings.aItemMeta.stats});
		}
		
		// RARITY
		var raritystr = "";
		if (isequipment)
		{
			// Back item will have a beginning line break because of its type name
			raritystr = D.getString(item.rarity) + ((isbackitem) ? "" : "<br />");
		}
		
		// WEIGHT
		var weightstr = "";
		if (det && det.weight_class)
		{
			weightstr = D.getString(det.weight_class) + "<br />";
		}
		
		// TYPE
		var typestr = Q.getItemType(item);
		
		// LEVEL
		var levelstr = "";
		if (item.level > 1)
		{
			levelstr += D.getString("RequiredLevel") + ": " + item.level + "<br />";
		}
		
		// DESCRIPTION
		/*
		 * Item details' description may be pretagged with XML that colorizes
		 * a portion of text. Example: <c=@flavor>Description</c>
		 * If a tag exists, it shall have the "=@flavor" replaced with " class='.itmColor_flavor'"
		 */
		var desctopstr = "";
		var descbottomstr = "";
		var desc = item.description || "";
		desc = Q.formatItemDescription(desc);
		if (item.description)
		{
			desc = "<aside>" + desc + "</aside>";
			if (isequipment)
			{
				descbottomstr = desc;
			}
			else
			{
				desctopstr = desc;
			}
		}
		
		// SELECTABLE STATS
		var selectstatsstr = "";
		if (isequipment)
		{
			// If the item does not have attributes nor are attributes assigned yet
			if (det && det.infix_upgrade === undefined && Settings.aItemMeta.stats === undefined)
			{
				selectstatsstr = D.getString("DoubleClickToSelectStats") + "<br />";
			}
		}
		
		// FLAGS
		var flagsstr = "";
		var flagsobj = {};
		var addFlag = function(pFlagName)
		{
			flagsstr += D.getString(pFlagName) + "<br />";
		};
		if (item.flags)
		{
			// Convert the flags array to an associative array for easier reading
			item.flags.forEach(function(iFlag)
			{
				flagsobj[iFlag] = true;
			});
			// Uniqueness flag
			if (flagsobj["Unique"])
			{
				addFlag("Unique");
			}
			// Binding flags for custom items (equipped items or in bound in inventory)
			if (isitemmeta && Settings.aItemMeta.binding)
			{
				istradeable = false;
				if (Settings.aItemMeta.binding === "Character" && Settings.aItemMeta.bound_to)
				{
					flagsstr += "<var class='itmColor_warning'>" + D.getString("SoulboundToCharacter")
						+ ": " + Settings.aItemMeta.bound_to + "</var><br />";
				} 
				else if (Settings.aItemMeta.binding === "Account")
				{
					addFlag("AccountBound");
				}
			}
			else // Binding flags for fresh items
			{
				// "SoulbindOnAcquire" flag shall override "SoulBindOnUse"
				if (flagsobj["SoulbindOnAcquire"])
				{
					issoulbound = true;
					istradeable = false;
					addFlag("SoulbindOnAcquire");
				}
				else if (flagsobj["SoulBindOnUse"] && issoulbound === false)
				{
					addFlag("SoulBindOnUse");
				}
				// "AccountBound" flag shall override "AccountBindOnUse"
				if (flagsobj["AccountBound"]) 
				{
					isaccountbound = true;
					istradeable = false;
					addFlag("AccountBound");
				}
				else if (flagsobj["AccountBindOnUse"] && isaccountbound === false)
				{
					addFlag("AccountBindOnUse");
				}
			}
			// Vendorability flag
			if (flagsobj["NoSell"])
			{
				isvendorable = false;
			}
		}
		
		// CHARACTER BINDING
		var charbindstr = "";
		if (Settings.aSoulbound)
		{
			charbindstr = D.getString("SoulboundToCharacter") + ": " + U.escapeHTML(Settings.aSoulbound);
		}
		
		// ADDED COMMENT
		var commentstr = "";
		if (Settings.aComment)
		{
			commentstr = "<aside>" + Settings.aComment + "</aside>";
		}
		
		// VENDOR PRICE
		var vendorstr = "";
		var vendorvalue = 0;
		if (item.vendor_value > 0 && isvendorable)
		{
			// If stack count is included then multiply vendor price for one item by that number
			vendorvalue = (Settings.aItemMeta.count) ? Settings.aItemMeta.count * item.vendor_value : item.vendor_value;
			vendorstr = E.formatCoinString(vendorvalue, {aWantColor: true, aWantSpace: true});
		}
		
		/*
		 * Upgrades and transmutations requires loading AJAX, so they must be
		 * done last and checked that every requests have been fulfilled then
		 * the tooltip HTML generation is finalized.
		 */
		// UPGRADES
		var upgradebrk = "";
		var infusionslot;
		var infusiontype = "";
		var preinfusions = [];
		var infusionstr = [];
		var preupgrades = [];
		var upgradestr = [];
		if (isequipment)
		{
			if (isascended || (isascended && istrinket) === false)
			{
				upgradebrk = "<br />";
			}
			
			if (isascended)
			{
				if (det && det.infusion_slots)
				{
					for (var i = 0; i < det.infusion_slots.length; i++)
					{
						infusionslot = det.infusion_slots[i];
						infusiontype = (det.type === "Amulet") ? "Enrichment" : "Infusion";
						infusionstr.push("<img class='itmSlotIcon' src='img/account/item/" + infusiontype.toLowerCase() + ".png' /> "
							+ D.getString("Unused" + infusiontype + "Slot") + "<br /><br />");
						if (infusionslot.item_id !== undefined && Settings.aItemMeta.infusions === undefined)
						{
							preinfusions.push(infusionslot.item_id);
							numtofetch++;
						}
						else
						{
							preinfusions.push(null);
						}
					}
				}
			}
			if ((isascended && istrinket) === false)
			{
				var unupgradedslot = "<img class='itmSlotIcon' src='img/account/item/upgrade.png' /> "
					+ D.getString("UnusedUpgradeSlot") + "<br /><br />";
				upgradestr.push(unupgradedslot);
				upgradestr.push((isdouble) ? unupgradedslot : "");
				if (det && det.suffix_item_id && Settings.aItemMeta.upgrades === undefined)
				{
					preupgrades.push(det.suffix_item_id);
					numtofetch++;
				}
				else
				{
					preupgrades.push(null);
					if (isdouble)
					{
						preupgrades.push(null);
					}
				}
			}
		}
		
		// OVERWRITE INFUSIONS AND UPGRADES
		if (Settings.aItemMeta.infusions)
		{
			for (var i = 0; i < Settings.aItemMeta.infusions.length; i++)
			{
				if (i < preinfusions.length)
				{
					preinfusions[i] = Settings.aItemMeta.infusions[i];
					if (preinfusions[i])
					{
						numtofetch++;
					}
				}
			}
		}
		if (Settings.aItemMeta.upgrades)
		{
			for (var i = 0; i < Settings.aItemMeta.upgrades.length; i++)
			{
				if (i < preupgrades.length)
				{
					preupgrades[i] = Settings.aItemMeta.upgrades[i];
					if (preupgrades[i])
					{
						numtofetch++;
					}
				}
			}
		}
		
		// TRANSMUTATION
		var transmstr = "";
		if (Settings.aItemMeta.skin)
		{
			numtofetch++;
		}
		
		/*
		 * Final actions and binding to be done after the tooltip HTML has been
		 * formatted and additional AJAX HTML included.
		 */
		var finalizeTooltip = function()
		{
			if (numfetched !== numtofetch)
			{
				return;
			}
			var html = "<div class='itmTooltip'>"
				+ namestr
				+ damagestr
				+ defensestr
				+ attrstr
				+ desctopstr
				+ upgradebrk
				+ ((isweapon) ? (upgradestr.join("") + infusionstr.join("")) : (infusionstr.join("") + upgradestr.join("")))
				+ transmstr
				+ raritystr
				+ weightstr
				+ typestr
				+ levelstr
				+ descbottomstr
				+ selectstatsstr
				+ flagsstr
				+ charbindstr
				+ vendorstr
				+ commentstr
			+ "</div>";
			// Bind tooltip if provided an element
			if (Settings.aElement)
			{
				var elm = $(Settings.aElement);
				elm.attr("title", html);
				I.qTip.init(elm);
			}
			/*
			 * This object is the result of the analysis, containing tooltip
			 * information and additionally retrieved slotted items.
			 */
			var box = {
				oData: item,
				oInfusions: infusionobjs,
				oUpgrades: upgradeobjs,
				oSkin: skinobj,
				oAttr: attrobj,
				oHTML: html,
				oIsTradeable: istradeable
			};
			// Cache the item only if it's not custom (no upgrades or transmutations)
			if (isitemmeta === false && Settings.aComment === undefined)
			{
				Q.Boxes.Items[item.id] = box;
			}
			// Execute callback if provided
			if (Settings.aCallback)
			{
				Settings.aCallback(box);
			}
			// Already succeeded, so prevent recalling this subfunction
			numfetched = null;
		};
		
		/*
		 * Fetch additional data like slotted upgrades and transmutations.
		 */
		// SLOTTED INFUSIONS
		for (var i = 0; i < preinfusions.length; i++)
		{
			if (preinfusions[i] === null)
			{
				continue;
			}
			(function(iIndex, iInfusionID)
			{
				Q.getItem(iInfusionID, function(iData)
				{
					infusionstr[iIndex] = "<span class='itmUpgrade'><img class='itmSlotIcon' src='" + iData.icon + "' /> " + iData.name + "<br />"
						+ iData.details.infix_upgrade.buff.description + "</span><br /><br />";
					if (Settings.aCallback)
					{
						infusionobjs.push(iData);
					}
					if (attrobj)
					{
						Q.sumItemAttribute(attrobj, {aItem: iData});
					}
					numfetched++;
					finalizeTooltip();
				}).fail(function()
				{
					numtofetch--;
					finalizeTooltip();
				});
			})(i, preinfusions[i]);
		}
		
		// SLOTTED UPGRADES
		for (var i = 0; i < preupgrades.length; i++)
		{
			if (preupgrades[i] === null)
			{
				continue;
			}
			(function(iIndex, iUpgradeID)
			{
				Q.getItem(iUpgradeID, function(iData)
				{
					var upgdesc = "";
					if (iData.details.type === "Rune")
					{
						var runepieces = 0;
						if (det.type === "HelmAquatic")
						{
							// Count the rune in the aquatic helm for its own slotted description
							runepieces = (Settings.aRuneSets && Settings.aRuneSets[iData.id]) ? (1 + Settings.aRuneSets[iData.id].numslotted) : 1;
						}
						else if (Settings.aRuneSets)
						{
							runepieces = Settings.aRuneSets;
						}
						upgdesc = Q.getRuneBonus(iData, runepieces);
						if (attrobj)
						{
							Q.sumItemAttribute(attrobj, {aItem: iData, aRuneSets: Settings.aRuneSets});
						}
					}
					else
					{
						upgdesc = iData.name + "<br />" + Q.formatItemDescription(iData);
						if (attrobj)
						{
							Q.sumItemAttribute(attrobj, {aItem: iData});
						}
					}
					
					upgradestr[iIndex] = "<aside class='itmUpgrade'><img class='itmSlotIcon' src='" + iData.icon + "' /> " + upgdesc + "</aside><br />";
					if (Settings.aCallback)
					{
						upgradeobjs.push(iData);
					}
					numfetched++;
					finalizeTooltip();
				}).fail(function()
				{
					numtofetch--;
					finalizeTooltip();
				});
			})(i, preupgrades[i]);
		}
		
		// TRANSMUTED
		if (Settings.aItemMeta.skin)
		{
			Q.getSkins(Settings.aItemMeta.skin, function()
			{
				var skinbox = Q.getBoxedSkin(Settings.aItemMeta.skin);
				if (skinbox)
				{
					var skin = skinbox.oData;
					namestr = "<aside class='itmName " + Q.getRarityClass(rarity)
						+ "'><img class='itmIcon itmIconMain' src='" + skin.icon + "' />" + U.escapeHTML(skin.name) + "</aside>";
					transmstr = "<aside='itmTransmute'>" + D.getString("Transmuted") + "<br />" + U.escapeHTML(item.name) + "</aside><br /><br />";
					if (Settings.aCallback)
					{
						skinobj = skin;
					}
					numfetched++;
					finalizeTooltip();
				}
				else
				{
					numtofetch--;
					finalizeTooltip();
				}
			});
		}
		
		// In case no fetching is needed at all
		if (numfetched === numtofetch)
		{
			finalizeTooltip();
		}
	},
	
	/*
	 * Puts all data entries of an API database into boxes.
	 * @param string pType
	 */
	initializeBoxes: function(pType, pDatabase)
	{
		var type = U.toFirstUpperCase(pType);
		for (var i in pDatabase)
		{
			if ((Q.Boxes[type])[i] === undefined)
			{
				(Q.Boxes[type])[i] = {};
			}
			(Q.Boxes[type])[i].oData = pDatabase[i];
		}
	},
	
	/*
	 * Macro function to retrieve and cache API data with IDs.
	 * @param string pType name of the API endpoint.
	 * @param intarray or int pIDs, or "true" if want fetch of entire API of that type
	 * @param function pCallback
	 */
	getBoxes: function(pType, pIDs, pCallback)
	{
		var ids = pIDs;
		var idstofetch = [];
		var cache = Q.Boxes[pType];
		var getData = function()
		{
			// Filter out duplicates if provided an array
			ids = U.getUnique(ids);
			// Filter out cached data
			for (var i in ids)
			{
				if (cache[ids[i]] === undefined)
				{
					idstofetch.push(ids[i]);
				}
			}
			// Fetch
			U.fetchAPI(U.getAPIURL(pType), idstofetch, {
				aCallback: function(pData)
				{
					for (var i in pData)
					{
						var ithdata = pData[i];
						cache[ithdata.id] = {};
						cache[ithdata.id].oData = ithdata;
					}
					pCallback();
				}
			});
		};
		// If provided a single ID
		if (typeof pIDs === "number")
		{
			var id = pIDs;
			if (cache[id])
			{
				pCallback();
			}
			else
			{
				U.getJSON(U.getAPI(pType.toLowerCase(), id), function(pData)
				{
					cache[id] = {};
					cache[id].oData = pData;
					pCallback();
				}).fail(function()
				{
					pCallback();
				});
			}
		}
		// If no IDs to fetch
		else if (pIDs.length === 0)
		{
			pCallback();
		}
		// If provided array of IDs
		else
		{
			// If provided as so then regard as all possible IDs
			if (pIDs === true)
			{
				if (Q.isBoxedFully[pType])
				{
					pCallback();
				}
				else
				{
					Q.isBoxedFully[pType] = true;
					U.getJSON(U.getAPI(pType), function(pArray)
					{
						ids = pArray;
						getData();
					});
				}
			}
			else
			{
				getData();
			}
		}
	},
	getItems: function(pIDs, pCallback)
	{
		Q.getBoxes("Items", pIDs, pCallback);
	},
	getSkins: function(pIDs, pCallback)
	{
		Q.getBoxes("Skins", pIDs, pCallback);
	},
	getAchievements: function(pIDs, pCallback)
	{
		Q.getBoxes("Achievements", pIDs, pCallback);
	},
	getTitles: function(pIDs, pCallback)
	{
		Q.getBoxes("Titles", pIDs, pCallback);
	},
	getSpecializations: function(pIDs, pCallback)
	{
		Q.getBoxes("Specializations", pIDs, pCallback);
	},
	getTraits: function(pIDs, pCallback)
	{
		Q.getBoxes("Traits", pIDs, pCallback);
	},
	getSkills: function(pIDs, pCallback)
	{
		Q.getBoxes("Skills", pIDs, pCallback);
	},
	getBoxedItem: function(pID)
	{
		return Q.Boxes.Items[pID];
	},
	getBoxedSkin: function(pID)
	{
		return Q.Boxes.Skins[pID];
	},
	getBoxedAchievement: function(pID)
	{
		return Q.Boxes.Achievements[pID];
	},
	getBoxedTitle: function(pID)
	{
		return Q.Boxes.Titles[pID];
	},
	getBoxedSpecialization: function(pID)
	{
		return Q.Boxes.Specializations[pID];
	},
	getBoxedTrait: function(pID)
	{
		return Q.Boxes.Traits[pID];
	},
	getBoxedSkill: function(pID)
	{
		return Q.Boxes.Skills[pID];
	},
	getCachedItem: function(pID)
	{
		var box = Q.getBoxedItem(pID);
		if (box)
		{
			return box.oData;
		}
		return null;
	},
	
	/*
	 * Lightweight preliminary function to check if the requested data had been
	 * analyzed, with HTML ready for showing.
	 * @param object pBox
	 * @param object pSettings
	 */
	scanData: function(pType, pBox, pSettings)
	{
		var Settings = pSettings || {};
		if (pBox && pBox.oHTML)
		{
			if (Settings.aElement)
			{
				var elm = $(Settings.aElement);
				elm.attr("title", pBox.oHTML);
				I.qTip.init(elm);
			}
			// Execute callback if provided
			if (Settings.aCallback)
			{
				Settings.aCallback(pBox);
			}
		}
		else
		{
			(Q["analyze" + pType])(pBox.oData, pSettings);
		}
	},
	scanAchievement: function(pID, pSettings)
	{
		Q.scanData("Achievement", Q.getBoxedAchievement(pID), pSettings);
	},
	scanSpecialization: function(pID, pSettings)
	{
		Q.scanData("Specialization", Q.getBoxedSpecialization(pID), pSettings);
	},
	scanTrait: function(pID, pSettings)
	{
		Q.scanData("Trait", Q.getBoxedTrait(pID), pSettings);
	},
	scanSkill: function(pID, pSettings)
	{
		Q.scanData("Skill", Q.getBoxedSkill(pID), pSettings);
	},
	
	/*
	 * Generates achievement tooltip HTML
	 * @param object pAchievement details retrieved from API.
	 * @objparam jqobject aElement to bind tooltip.
	 * @objparam boolean aWantIcon whether to include achievement's icon.
	 * @objapram boolean aWantCard whether to format for bank cards.
	 * @objparam object aAchievement processed object, optional.
	 * @objparam function aCallback what to do after the tooltip generation.
	 */
	analyzeAchievement: function(pAchievement, pSettings)
	{
		var Settings = pSettings || {};
		var ach = pAchievement;
		var iconstr = "";
		var namestr = "<aside class='itmName achName'>" + U.escapeHTML(ach.name) + "</aside>";
		var descstr = "";
		var instructstr = "";
		var reqstr = "";
		var countstr = "";
		var tierstr = "";
		var pointsstr = "";
		var searchpointsstr = "";
		
		if (Settings.aWantIcon && ach.icon)
		{
			iconstr = "<img class='achIcon' src='" + ach.icon + "'/ >";
		}
		if (ach.instruction)
		{
			instructstr = "<aside class='achInstruction'>" + ach.instruction + "</aside>";
		}
		if (ach.description)
		{
			descstr = "<aside class='achDescription'>" + ach.description + "</aside>";
		}
		if (ach.requirement)
		{
			reqstr = "<aside class='achRequirement'>" + ach.requirement + "</aside>";
		}
		if (Settings.aWantCard)
		{
			return namestr + ((ach.instruction) ? instructstr : ((reqstr.length) ? reqstr : descstr));
		}
		
		if (pAchievement.tiers)
		{
			var processedach = Settings.aAchievement || Q.processAchievement(pAchievement);
			var tierword = D.getWordCapital("tier");
			countstr = "<aside class='achCount'>" + processedach.oAPCountCurrent.toLocaleString()
				+ " / " + processedach.oAPCountPossible.toLocaleString() + " " + D.getWordCapital("completion")
				+ " (" + U.convertRatioToPercent(processedach.oAPCountCurrent / processedach.oAPCountPossible) + ")</aside>";
			tierstr = "<aside class='achTier'>" + tierword + " " + processedach.oAPTierCurrent + " "
				+ D.getWord("of") + " " + processedach.oAPTierPossible + " " + tierword + "</aside>";
			pointsstr = "<aside class='achPoints'>" + ((processedach.oAPPointPossible > 0)
				? (processedach.oAPPointCurrent + " / " + processedach.oAPPointPossible) : "0") + " <img src='img/ui/ap.png' /></aside";
			searchpointsstr = "<var class='achSearchPoints'>" + ((processedach.oAPPointCurrent === processedach.oAPPointPossible)
				? "" : (processedach.oAPPointCurrent + " / ")) + E.PaymentFormat.achievement(processedach.oAPPointPossible) + "</var>";
		}
		
		var html = "<div class='itmTooltip " + (Settings.aClass || "") + "'>"
			+ "<div class='achWrap'>"
				+ iconstr
				+ "<div class='achText'>"
					+ namestr
					+ reqstr
					+ instructstr
					+ descstr
					+ countstr
					+ tierstr
					+ pointsstr
				+ "</div>"
			+ "</div>"
		+ "</div>";
		// Bind tooltip if provided an element
		if (Settings.aElement)
		{
			var elm = $(Settings.aElement);
			elm.attr("title", html);
			I.qTip.init(elm);
		}
		var box = Q.getBoxedAchievement(ach.id) || {};
		box.oHTML = html;
		box.oSearchPoints = searchpointsstr; // For displaying in the achievements search results
		if (Settings.aCallback)
		{
			Settings.aCallback(box);
		}
		else
		{
			return html;
		}
	},
	
	/*
	 * Gets the computed points, counts, and tiers of an achievement.
	 * @param object pAchievement
	 * @param object pAccountAch account unlocks for getting progress, optional.
	 * @returns object
	 */
	processAchievement: function(pAchievement, pAccountAch)
	{
		var tiers = pAchievement.tiers;
		var currentpoints = 0;
		var possiblepoints = 0;
		var currentcount = (pAccountAch && pAccountAch.current !== undefined) ? pAccountAch.current : 0;
		var possiblecount = tiers[tiers.length - 1].count;
		var currenttier = 0;
		var possibletiers = tiers.length;
		tiers.forEach(function(iTier)
		{
			if (pAccountAch && pAccountAch.current >= iTier.count)
			{
				currenttier++;
				currentpoints += iTier.points;
			}
			possiblepoints += iTier.points;
		});
		
		return {
			oAPPointCurrent: currentpoints,
			oAPPointPossible: possiblepoints,
			oAPCountCurrent: currentcount,
			oAPCountPossible: possiblecount,
			oAPTierCurrent: currenttier,
			oAPTierPossible: possibletiers
		};
	},
	
	/*
	 * Gives tooltip to elements with data-ach attribute.
	 * @param jqobject or string pSelector
	 */
	bindAchievement: function(pSelector)
	{
		var ids = [];
		var elms = [];
		$(pSelector).each(function()
		{
			var id = $(this).attr("data-ach");
			if (id)
			{
				ids.push(id);
				elms.push($(this));
			}
		});
		Q.getAchievements(ids, function()
		{
			for (var i = 0; i < elms.length; i++)
			{
				Q.scanAchievement(ids[i], {aElement: elms[i]});
			}
		});
	},
	
	/*
	 * Formats a trait or skill object to be used in tooltips.
	 * @param object pTrait details retrieved from API.
	 * @returns string content for tooltip window.
	 */
	formatSkillTrait: function(pTrait)
	{
		var formatFact = function(pFact)
		{
			var text = pFact.text;
			var type = pFact.type;
			var value = pFact.value;
			var attrtarget = (pFact.target !== undefined) ? Q.getAttributeTranslation(pFact.target) : "";
			var attrsource = (pFact.source !== undefined) ? Q.getAttributeTranslation(pFact.source) : "";
			var buffconv = (type === "BuffConversion") ? D.getString("GainBasedPercentage").replace("{0}", attrsource).replace("{1}", attrtarget) : "";
			var icon = "<img class='trtFactIcon' src='" + pFact.icon + "' />";
			var prefixicon = (pFact.prefix && pFact.prefix.icon) ? "<img class='trtFactIcon' src='" + pFact.prefix.icon + "' />" : "";
			var desc = pFact.description;
			var stacks = (pFact.apply_count > 1) ? "<var class='trtStacks'>" + pFact.apply_count + "</var>" : "";
			var duration = (pFact.duration !== undefined) ? (pFact.duration + " " + D.getWord("seconds")) : "";
			var durationabbr = (pFact.duration !== undefined) ? " (" + T.formatTooltipTime(pFact.duration) + ")" : "";
			var status = pFact.status;
			var combofield = pFact.field_type;
			var combofinisher = pFact.finisher_type;
			var percent = pFact.percent + "%";
			var hitcount = pFact.hit_count + "x";
			var distance = pFact.distance;
			
			var wrap = function(pIcon, pText)
			{
				return "<var class='trtFactIcons'>" + pIcon + "</var><var class='trtFactText'>" + pText + "</var>";
			};
			
			var facttype = {
				AttributeAdjust: function(){
					return wrap(icon, "+" + value + " " + attrtarget);},
				Buff: function(){
					return wrap(stacks + icon, status + durationabbr + ": " + desc);},
				BuffConversion: function(){
					return wrap(icon, buffconv);},
				ComboField: function(){
					return wrap(icon, text + ": " + combofield);},
				ComboFinisher: function(){
					return wrap(icon, text + ": " + combofinisher + " (" + percent + ")");},
				Damage: function(){
					return wrap(icon, text + ": " + hitcount);},
				Distance: function(){
					return wrap(icon, text + ": " + distance);},
				Duration: function(){
					return wrap(icon, text + ": " + duration);},
				Heal: function(){
					return wrap(icon, text + ": " + hitcount);},
				HealingAdjust: function(){
					return wrap(icon, text + ": " + hitcount);},
				NoData: function(){
					return wrap(icon, text);},
				Number: function(){
					return wrap(icon, text + ": " + value);},
				Percent: function(){
					return wrap(icon, text + ": " + percent);},
				PrefixedBuff: function(){
					return wrap(icon + prefixicon, status + durationabbr + ": " + desc);},
				Radius: function(){
					return wrap(icon, text + ": " + distance);},
				Range: function(){
					return wrap(icon, text + ": " + value);},
				Time: function(){
					return wrap(icon, text + ": " + duration);},
				Unblockable: function(){
					return wrap(icon, text);}
			};
			
			if (facttype[type])
			{
				return "<span class='trtFactLine'>" + facttype[type]() + "</span>";
			}
			return "";
		};
		
		var name = "<span class='trtName'>" + pTrait.name + "</span>";
		var desc = "<span class='trtDesc'>" + Q.formatItemDescription(pTrait.description) + "</span>";
		var recharge = "";
		var facts = "";
		var factsinner = "";
		if (pTrait.facts && pTrait.facts.length > 0)
		{
			facts += "<aside class='trtFacts'>";
			pTrait.facts.forEach(function(iFact)
			{
				if (iFact.type === "Recharge")
				{
					recharge = "<span class='trtRecharge'>" + iFact.value + "<img class='trtRechargeIcon' src='" + iFact.icon + "' /></span>";
				}
				else
				{
					factsinner += formatFact(iFact);
				}
			});
			// Don't include facts element if no fact lines were added
			facts = (factsinner === "") ? "" : (facts + factsinner + "</aside>");
		}
		
		return recharge + name + desc + facts;
	},
	
	/*
	 * Generates skill or trait tooltip HTML.
	 * @param string pType cache as skill or trait.
	 * @param object pData details retrieved from API.
	 * @objparam jqobject aElement to bind tooltip.
	 */
	analyzeSkillTrait: function(pType, pData, pSettings)
	{
		var Settings = pSettings || {};
		var content = Q.formatSkillTrait(pData);
		
		// Calculate an extra tooltip's height by actually making it then measuring its height
		var computeOffset = function(pContent)
		{
			var nullcon = $("#itemNull").empty();
			var height = $(pContent).appendTo(nullcon).height();
			nullcon.empty(); // Served its purpose, so delete the element
			return height;
		};
		
		// Include additional tooltips if trait has a skills array
		var skilltooltips = "";
		var offsetcumulative = 6;
		var offsetbetween = 20;
		if (pData.skills)
		{
			pData.skills.forEach(function(iSkill)
			{
				/*
				 * A trait may contain skill tooltips above its own tooltip. To
				 * position them like in game, the vertical offsets need to be
				 * computed so the extra tooltips float by absolute position,
				 * even though all the tooltips share a single container.
				 */
				var dummytooltip = "<div class='qTip'><div class='trtTooltip'>" + Q.formatSkillTrait(iSkill) + "</div></div>";
				offsetcumulative += computeOffset(dummytooltip) + offsetbetween;
				// Write the actual extra skill tooltip
				skilltooltips += "<div class='trtTooltip trtTooltipExtra' style='margin-top:" + "-" + offsetcumulative + "px" + "'>"
					+ Q.formatSkillTrait(iSkill) + "</div>";
			});
		}
		
		var html = "<div class='trtTooltipBorder'>" + I.Symbol.Filler + "</div>"
			+ skilltooltips + "<div class='trtTooltip'>" + content + "</div>";
		var box = (Q.Boxes[pType])[pData.id];
		if (box)
		{
			box.oHTML = html;
		}
		if (Settings.aElement)
		{
			var elm = $(Settings.aElement);
			elm.attr("title", html);
			I.qTip.init(elm);
			elm.click(function()
			{
				I.prettyJSON(pData);
			});
		}
	},
	analyzeTrait: function(pTrait, pSettings)
	{
		Q.analyzeSkillTrait("Traits", pTrait, pSettings);
	},
	analyzeSkill: function(pSkill, pSettings)
	{
		Q.analyzeSkillTrait("Skills", pSkill, pSettings);
	},
	
	/*
	 * Retrieves and caches guild details.
	 * @param array pIDs of guilds
	 * @param function pCallback
	 * @param boolean pWantCache true if undefined.
	 */
	getGuilds: function(pIDs, pCallback, pWantCache)
	{
		var ids = (Array.isArray(pIDs)) ? pIDs : [pIDs];
		var wantcache = (pWantCache !== undefined) ? pWantCache : true;
		var idstofetch = [];
		// Only fetch those not already cached
		if (wantcache)
		{
			for (var i in ids)
			{
				var id = ids[i];
				if (Q.Boxes.Guilds[id] === undefined)
				{
					idstofetch.push(id);
				}
			}
			if (idstofetch.length === 0)
			{
				pCallback();
				return;
			}
		}
		else
		{
			idstofetch = ids;
		}
		
		// Guild details cannot be bulk fetched, so retrieve them one by one
		var numfetched = 0;
		var numtofetch = ids.length;
		for (var i in idstofetch)
		{
			U.getJSON(U.URL_API.Guild + idstofetch[i], function(pData)
			{
				pData.oTag = "[" + pData.tag + "]";
				Q.Boxes.Guilds[pData.id] = pData;
				numfetched++;
				if (numfetched === numtofetch)
				{
					pCallback();
				}
			}, wantcache).fail(function()
			{
				numfetched--;
			});
		}
	},
	getCachedGuild: function(pID)
	{
		var guild = Q.Boxes.Guilds[pID];
		if (guild)
		{
			return guild;
		}
		return null;
	},
	
	/*
	 * Initializes the context menu that is shown for all banks' slots.
	 */
	initializeItemContextMenu: function()
	{
		I.styleContextMenu("#itmContext");
		$("#itmContext").click(function()
		{
			$(this).hide();
		});
		// The context variables should be assigned by the function that styles the bank slot
		$("#itmContextWiki").click(function()
		{
			U.openExternalURL(U.getWikiLinkLanguage(Q.Context.ItemName));
		});
		$("#itmContextWikiSearch").click(function()
		{
			U.openExternalURL(U.getWikiSearchLanguage(Q.Context.ItemSearch));
		});
		$("#itmContextTrading").click(function()
		{
			U.openExternalURL(U.getTradingItemLink(Q.Context.ItemID, Q.Context.ItemName));
		});
		$("#itmContextTradingSearch").click(function()
		{
			E.printListings(Q.Context.ItemID);
		});
		$("#itmContextInfo").click(function()
		{
			if (Q.Context.Item)
			{
				if (Q.Context.Item.name)
				{
					Q.printItemInfo(Q.Context.Item);
				}
				else
				{
					I.prettyJSON(Q.Context.Item);
				}
			}
			else
			{
				I.print("No information available.");
			}
		});
		I.bindClipboard("#itmContextChatlink");
	},
	
	/*
	 * Binds an element that represents a game item to have a context menu.
	 * @param jqobject pSlot to bind.
	 * @objparam object aItem from item details API.
	 * @objparam object aObject non-item object for printing the slot's information, optional.
	 * @objparam string aSearch for wiki search link, optional.
	 * @objparam int aTradeableID for TP webpage, optional.
	 */
	bindItemSlotBehavior: function(pSlot, pSettings)
	{
		var Settings = pSettings || {};
		// Right click on the item slot shows context menu
		pSlot.contextmenu(function(pEvent)
		{
			pEvent.preventDefault();
			var chatlink;
			if (Settings.aItem)
			{
				Q.Context.Item = Settings.aItem;
				Q.Context.ItemName = Settings.aItem.name;
				Q.Context.ItemID = Settings.aTradeableID || Settings.aItem.id;
				Q.Context.ItemSearch = Settings.aSearch || Settings.aItem.name;
				chatlink = Settings.aItem.chat_link + " " + Q.Context.ItemSearch;
			}
			else
			{
				Q.Context.Item = Settings.aObject;
				Q.Context.ItemName = Settings.aSearch;
				Q.Context.ItemID = Settings.aTradeableID;
				Q.Context.ItemSearch = Settings.aSearch;
				chatlink = Settings.aChatlink || "No chatlink available.";
			}
			I.updateClipboard("#itmContextChatlink", chatlink);
			I.showContextMenu("#itmContext");
		});
		// Bind the click to go to wiki behavior if requested
		if (Settings.aWantClick)
		{
			pSlot.click(function(pEvent)
			{
				if (pEvent.which === I.ClickEnum.Left)
				{
					U.openExternalURL(U.getWikiSearchLanguage(Settings.aItem.name));
				}
			});
		}
	},
	
	/*
	 * Binds an input bar to search for items (or a database for objects) by name.
	 * @param jqobject pElement to bind.
	 * @objparam string aFillerText to display over the input bar, provide null for no text, optional.
	 * @objparam string aInfo search usage, optional.
	 * @objparam string aResultsClass CSS class for results container element, optional.
	 * @objparam int aResultsLimit max number of results to show, optional.
	 * @objparam boolean aIsSelect whether to emulate the <select> functionality, requires aDatabase, optional.
	 * @objparam boolean aIsInline whether the search box does not take all available width, optional.
	 * @objparam boolean aWantEnter whether to bind the default Enter key event, optional.
	 * @objparam boolean aWantClose whether to close the search results after clicking, optional.
	 * @objparam object aSubset associative array of item IDs to limit the search, optional.
	 * @objparam objarray aDatabase custom search database to use instead of items search, optional.
	 * @objparam object aAchievements account's achievement unlocks, optional.
	 * @objparam function aCallback to execute after the user selects an item.
	 * @objparam function aCancel to execute when user clicks on the close button, optional.
	 * @pre Input bar has a parent container element in order to position the results list.
	 * Item search database format: [[int_itemid, str_keywords], ...]
	 * Custom search database format: [{name: "", icon: "", keywords: ""}, ...]
	 * keywords is the searchable name of the result in lowercase.
	 */
	bindItemSearch: function(pElement, pSettings)
	{
		var Settings = pSettings || {};
		var elm = $(pElement).wrap("<span class='itmSearchContainer " + ((Settings.aIsInline) ? "itmSearchInline" : "") + "'></span>");
		var queryminchar = D.isLanguageLogographic ? 1 : 2;
		var queryminitemidlength = 4;
		var resultslimit = Settings.aResultsLimit || O.Options.int_numTradingResults;
		var resultscontainer = $("<div class='itmSearchResultContainer jsHidable'></div>").insertAfter(elm).hide();
		var resultsscroll = $("<div class='itmSearchResultScroll cntPopup jsScrollable'></div>").appendTo(resultscontainer);
		var resultslist = $("<div class='itmSearchResultList'></div>").appendTo(resultsscroll);
		var notfoundstr = "<var class='itmSearchResultNone'>" + D.getPhraseOriginal("Not found") + "." + "</var>";
		var isitemsearch = (Settings.aDatabase === undefined);
		var itemsearchdb, customsearchdb = [], searchindexes = [], isdirectionchanged, searchtimestamp;
		var resultsarrall = [];
		
		if (Settings.aFillerText !== null)
		{
			I.bindInputBarText(elm, (Settings.aIsSelect) ? I.Symbol.TriDown + " " + Settings.aFillerText : Settings.aFillerText);
		}
		if (Settings.aResultsClass)
		{
			resultsscroll.addClass(Settings.aResultsClass);
		}
		I.bindScrollbar(resultsscroll);
		// Pseudo <select> element shows the entire database when clicked
		if (Settings.aIsSelect)
		{
			resultsarrall = Settings.aDatabase;
		}
		// Initialize custom search database
		if (Settings.aDatabase)
		{
			for (var i in Settings.aDatabase)
			{
				var ithobj = Settings.aDatabase[i];
				customsearchdb.push([ithobj, ithobj.keywords || ithobj.name.toLowerCase()]);
			}
		}
		
		// Toggles display of the results container popup
		var resetSearch = function()
		{
			isdirectionchanged = true;
			searchindexes = [];
		};
		var toggleResults = function(pBoolean, pMessage)
		{
			resultslist.empty().removeData("selectedresult");
			resultscontainer.toggle(pBoolean);
			if (pMessage)
			{
				resultslist.html(pMessage);
			}
			if (pBoolean === false)
			{
				resetSearch();
				I.qTip.hide();
			}
		};
		var searchinfo = "<br />" + ((isitemsearch) ? "Right click an item for menu.<br />Type a number to search by item ID." : (Settings.aInfo || ""));
		var searchclose = $("<ins class='itmSearchClose btnWindow btnClose' "
			+ "title='<dfn>Close the search results.</dfn>" + searchinfo + "'></ins>")
			.appendTo(resultscontainer).click(function()
		{
			if (Settings.aCancel)
			{
				Settings.aCancel();
			}
			toggleResults(false);
		});
		I.qTip.init(searchclose);
		
		// Standard behavior when clicked on a search result
		var bindResultClick = function(pResultsList, pResultEntry, pDataEntry, pCloseResults)
		{
			pResultEntry.click(function()
			{
				if (Settings.aCallback)
				{
					Settings.aCallback(pDataEntry);
					if (pCloseResults || Settings.aWantClose)
					{
						toggleResults(false);
					}
				}
				pResultsList.removeData("selectedresult");
			});
		};
		
		// Fills the results list with downloaded API data for each result item
		var renderSearch = function(pResults, pQuery)
		{
			if (pResults.length === 0)
			{
				toggleResults(true, notfoundstr);
				return;
			}
			
			toggleResults(true);
			if (isitemsearch)
			{
				// A new search updates the timestamp, only the earliest results are allowed to be shown
				searchtimestamp = (new Date()).getTime();
				// Create an ordered list that acts as containers for each result entry
				resultslist.append(I.cThrobber);
				for (var i = 0; i < pResults.length; i++)
				{
					resultslist.append("<span class='itmSearchResultLine itmSearchResultLine_" + pResults[i] + "'></span>");
				}
				(function(iTimestamp)
				{
					Q.getPricedItems(pResults, function()
					{
						// Prevent older searches from entering the results because of API retrieval lag
						if (iTimestamp === searchtimestamp)
						{
							I.removeThrobber(resultslist);
							for (var i = 0; i < pResults.length; i++)
							{
								var itemid = pResults[i];
								var item = Q.getCachedItem(itemid);
								if (item === null)
								{
									continue;
								}
								var resultentry = $("<dfn class='itmSearchResultEntry " + Q.getRarityClass(item.rarity) + "' data-id='" + itemid + "'>"
									+ "<img src='" + item.icon + "'>"
									+ U.highlightSubstring(item.name, pQuery) + "</dfn>").appendTo(resultslist.find(".itmSearchResultLine_" + itemid));
								bindResultClick(resultslist, resultentry, item, true);
								
								I.updateScrollbar(resultsscroll);
								// Tooltip for the listed item
								Q.scanItem(item, {aElement: resultentry});
								Q.bindItemSlotBehavior(resultentry, {aItem: item});
								// Also include price next to tradeable items
								var priceobj = E.getCachedPrice(itemid);
								if (priceobj)
								{
									var pricestr = "<span class='itmSearchResultPrice'>" + E.formatCoinStringSlot(priceobj.oPriceSell)
										+ " <var class='cssFaded'>" + E.formatCoinStringSlot(priceobj.oPriceBuy) + "</var></span>";
									resultentry.append(pricestr);
								}
							}
						}
					}, true);
				})(searchtimestamp);
			}
			else
			{
				for (var i = 0; i < pResults.length; i++)
				{
					var resultentry = $("<span class='itmSearchResultLine'><dfn class='itmSearchResultEntry'>"
						+ "<img src='" + (pResults[i].icon || "img/ui/sixteen/bullet.png") + "' />"
						+ U.highlightSubstring(pResults[i].name, pQuery) + "</dfn></span>").appendTo(resultslist);
					bindResultClick(resultslist, resultentry, pResults[i]);
					
					// Custom features for custom database
					if (Settings.aAchievements)
					{
						(function(iResult, iEntry)
						{
							var achid = iResult.id;
							Q.analyzeAchievement(iResult, {
								aAchievement: Q.processAchievement(iResult, Settings.aAchievements[achid]),
								aElement: iEntry,
								aCallback: function(pBox)
								{
									iEntry.append(pBox.oSearchPoints);
								}
							});
						})(pResults[i], resultentry.find(".itmSearchResultEntry").first());
					}
				}
				I.updateScrollbar(resultsscroll);
			}
			// Traversal buttons
			if (pResults.length === resultslimit)
			{
				$("<span class='itmSearchResultNext curClick'>" + D.getWordCapital("next") + " &gt;</span>")
					.prependTo(resultslist).click(function()
				{
					if (isdirectionchanged === false)
					{
						isdirectionchanged = true;
						executeSearch(searchindexes[searchindexes.length - 1]);
					}
					executeSearch(searchindexes[searchindexes.length - 1]);
				});
			}
			if (searchindexes.length > 1)
			{
				$("<span class='itmSearchResultPrev curClick'>&lt; " + D.getWordCapital("previous") + "</span>")
					.prependTo(resultslist).click(function()
				{
					if (isdirectionchanged === true)
					{
						searchindexes.pop();
						isdirectionchanged = false;
					}
					searchindexes.pop();
					executeSearch(searchindexes[searchindexes.length - 1]);
					searchindexes.pop();
				});
			}
		};
		
		// Searches the search database for matching items' names
		var executeSearch = function(pIndex)
		{
			var startingindex = (pIndex === undefined) ? 0 : pIndex;
			var query = elm.val().toLowerCase();
			var entry, subqueries, result, searchname, ismatch;
			var resultsarr = [];
			var searchdatabase = (isitemsearch) ? itemsearchdb : customsearchdb;
			
			// For emulating the <select> input, show all possible items
			if (Settings.aIsSelect && !query.length)
			{
				renderSearch(resultsarrall, "");
				return;
			}
			else
			{
				// If query is empty or below minimum length
				if (query.length < queryminchar)
				{
					toggleResults(false);
					return;
				}
				// If query is an integer, assume it is an item ID
				if (U.isInteger(query) && Settings.aDatabase === undefined && query.length >= queryminitemidlength)
				{
					renderSearch([parseInt(query)], query);
					return;
				}
			}

			// Else proceed with regular search through the database
			for (var i = startingindex; i < searchdatabase.length; i++)
			{
				entry = searchdatabase[i];
				subqueries = query.split(" ");
				result = entry[0];
				searchname = entry[1];
				// Search using every space separated substrings in the query
				ismatch = true;
				for (var ii = 0; ii < subqueries.length; ii++)
				{
					if (searchname.indexOf(subqueries[ii]) === -1)
					{
						ismatch = false;
						continue;
					}
				}
				if (ismatch)
				{
					// Only include in result if every subquery was found in the item's name
					resultsarr.push(result);
				}
				// Show the results if found enough matching items
				if (resultsarr.length >= resultslimit)
				{
					if (pIndex !== undefined || searchindexes.length === 0)
					{
						searchindexes.push(i+1);
					}
					renderSearch(resultsarr, query);
					return;
				}
			}
			// In case number of items found is below the limit
			if (pIndex !== undefined || searchindexes.length === 0)
			{
				searchindexes.push(startingindex);
			}
			renderSearch(resultsarr, query);
		};
		
		// Select an entry from the result list when user presses up or down arrow key
		var executeArrowKey = function(pDirection)
		{
			var selectedresult = resultslist.data("selectedresult") || resultslist.find(".itmSearchResultEntry").first().parent();
			if (selectedresult && selectedresult.length)
			{
				var nextresult = (pDirection) ? selectedresult.next() : selectedresult.prev();
				if (nextresult && nextresult.hasClass("itmSearchResultLine"))
				{
					resultslist.find(".itmSearchSelected").removeClass("itmSearchSelected");
					resultslist.data("selectedresult", nextresult);
					nextresult.addClass("itmSearchSelected");
					I.scrollToElement(nextresult, {
						aContainer: resultsscroll,
						aOffset: -(resultsscroll.height() / 2) // Scroll so the entry appears in the middle of the results window
					});
				}
			}
		};
		
		// Bind the search only after the user has clicked on the search bar
		elm.one("click", function()
		{
			toggleResults(true);
			resultslist.append(I.cThrobber);
			var bindSearch = function()
			{
				// Initialize the item search if used
				if (isitemsearch)
				{
					if (Settings.aSubset)
					{
						itemsearchdb = [];
						for (var i = 0; i < Q.SearchDatabase.length; i++)
						{
							if (Settings.aSubset[((Q.SearchDatabase[i])[0])])
							{
								itemsearchdb.push(Q.SearchDatabase[i]);
							}
						}
					}
					else
					{
						itemsearchdb = Q.SearchDatabase;
					}
				}
				
				toggleResults(false);
				// Bind search execution
				elm.on("input", $.throttle(E.cSEARCH_LIMIT, function()
				{
					executeSearch();
				})).click(function()
				{
					executeSearch();
					$(this).select();
				}).onEscapeKey(function()
				{
					toggleResults(false);
				});
				// Bind the enter key event to autoselect the first search result entry
				if (Settings.aWantEnter !== false)
				{
					elm.onEnterKey(function()
					{
						// Use the selected entry or the first entry in the results list if haven't selected any
						var selectedresult = resultslist.data("selectedresult") || resultslist.find(".itmSearchResultEntry").first().parent();
						if (selectedresult && selectedresult.length)
						{
							selectedresult.find(".itmSearchResultEntry").trigger("click");
						}
					}).onArrowDownKey(function()
					{
						executeArrowKey(true);
					}).onArrowUpKey(function()
					{
						executeArrowKey(false);
					});
				}
				// Execute search in case the user typed something during the database load
				elm.trigger("input");
			};
			
			// Load the items database if using items search
			if (isitemsearch)
			{
				Q.loadItemsSearch(function()
				{
					bindSearch();
				});
			}
			else
			{
				bindSearch();
			}
		}).click(function()
		{
			resetSearch();
		});
	},
	
	/*
	 * Gets HTML containing an item's icon and colorized name, for use in printing.
	 * @param object pItem details.
	 * @param int pCount of item stack, optional.
	 * @returns string.
	 */
	getItemPreface: function(pItem, pCount)
	{
		var countstr = (pCount > 1) ? (pCount + " ") : "";
		var itemname = U.escapeHTML(pItem.name);
		return "<div class='itmPreface'>"
			+ "<aside class='itmPrefaceLeft'>"
				+ "<a class='itmPrefaceIcon'" + U.convertExternalAnchor(U.getWikiItemDefault(pItem)) + "'>"
					+ "<img class='itmPrefaceIconImage' src='" + pItem.icon + "' /></a> "
				+ "<var class='itmPrefaceName " + Q.getRarityClass(pItem.rarity) + "'>" + countstr + itemname + "</var>"
			+ "</aside>"
			+ "<aside class='itmPrefaceRight'>"
				+ "<input class='cssInputText' type='text' value='" + itemname + "' /><br />"
				+ "<input class='cssInputText' type='text' value='" + U.escapeHTML(pItem.chat_link) + "' /><br />"
				+ "<input class='cssInputText' type='text' value='" + pItem.id + "' />"
			+ "</aside>"
		+ "</div>";
	},
	
	/*
	 * Prints an item's details in standard format.
	 * @object pItem from API items.
	 * @boolean pWantListings whether to include Trading Post results too.
	 */
	printItemInfo: function(pItem, pWantListings)
	{
		I.print(Q.getItemPreface(pItem));
		I.prettyJSON(pItem);
		if (Q.isTradeable(pItem) && pWantListings)
		{
			E.printListings(pItem.id, false);
		}
		I.bindConsoleInput();
	}
};
E = {
/* =============================================================================
 * @@Economy Trading Post and money
 * ========================================================================== */

	Exchange:
	{
		COPPER_IN_SILVER: 100,
		COPPER_IN_GOLD: 10000,
		SILVER_IN_GOLD: 100,
		
		CENTS_IN_DOLLAR: 100,
		
		GEM_PER_DOLLAR: 0.80,
		DOLLAR_PER_GEM: 1.25,
		
		GEM_SAMPLE: 100, // 100 gem
		COIN_SAMPLE: 1000000, // 100 gold
		
		TAX_LIST: 0.05,
		TAX_SOLD: 0.10,
		TAX_TOTAL: 0.15,
		TAX_INVERSE: 0.85,
		
		// These variable ratios will be set by API functions
		GemInCoin: 0,
		CoinInGem: 0
	},
	
	// Timings in milliseconds
	cREFRESH_LIMIT: 5000, // Time before user is allowed to refresh all outputs again
	cSEARCH_LIMIT: 750, // Time before "as you type" search executes again
	cEXCHANGE_LIMIT: 250, // Time before "as you type" exchange executes again
	
	isTradingCalculatorsInitialized: false,
	ItemsArray: [],
	RefreshTimeout: {},
	ProgressTimeout: {},
	ProgressWait: 0,
	ProgressTick: 0,
	SwapIndex: -1,
	
	CalculatorHistoryArray: new Array(64),
	CalcHistoryIndex: 0,
	
	Pricelist: {}, // Associative array of price objects
	Paylist: {}, // To be used by audit function, associative array accessed by item ID containing payment (a price object, gem, karma, or other currencies)
	/*
	 * Associative array of functions that format the payment of an item.
	 * The function names correspond to the object key in unlockables records.
	 */
	PaymentFormat:
	{
		coin: function(pAmount) { return E.formatCoinStringShort(pAmount); },
		gem: function(pAmount) { return E.formatGemString(pAmount, true); },
		karma: function(pAmount) { return E.formatKarmaString(pAmount, true); },
		laurel: function(pAmount) { return E.formatLaurelString(pAmount, true); },
		token: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_token'></ins>"; },
		mastery: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_mastery'></ins>"; },
		achievement: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_achievement'></ins>"; },
		monument: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_monument'></ins>"; },
		craft: function() { return "<ins class='s16 s16_craft'></ins>"; },
		pvp: function() { return "<ins class='s16 s16_pvp'></ins>"; },
		starting: function() { return "<ins class='s16 s16_starting'></ins>"; },
		spirit: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_spirit'></ins>"; },
		cob: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_cob'></ins>"; },
		blticket: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_blticket'></ins>"; },
		bubble: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_bubble'></ins>"; },
		badge: function(pAmount) { return ((pAmount === 0) ? "" : pAmount.toLocaleString()) + "<ins class='s16 s16_badge'></ins>"; },
		proof: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_proof'></ins>"; },
		commendation: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_commendation'></ins>"; },
		provisioner: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_provisioner'></ins>"; },
		skirmish: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_skirmish'></ins>"; },
		league: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_league'></ins>"; },
		glory: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_glory'></ins>"; },
		dungeon_ac: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_dungeon_ac'></ins>"; },
		dungeon_arah: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_dungeon_arah'></ins>"; },
		dungeon_cm: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_dungeon_cm'></ins>"; },
		dungeon_se: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_dungeon_se'></ins>"; },
		dungeon_ta: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_dungeon_ta'></ins>"; },
		dungeon_hotw: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_dungeon_hotw'></ins>"; },
		dungeon_cof: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_dungeon_cof'></ins>"; },
		dungeon_coe: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_dungeon_coe'></ins>"; },
		fotm_relic: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_fotm_relic'></ins>"; },
		fotm_pristine: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_fotm_pristine'></ins>"; },
		matrix: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_matrix'></ins>"; },
		magnetite: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_magnetite'></ins>"; },
		map_dt: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_dt'></ins>"; },
		map_sw: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_sw'></ins>"; },
		map_vb: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_vb'></ins>"; },
		map_ab: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_ab'></ins>"; },
		map_td: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_td'></ins>"; },
		map_ds: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_ds'></ins>"; },
		magic: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_magic'></ins>"; },
		map_bs: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_bs'></ins>"; },
		map_eb: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_eb'></ins>"; },
		map_bf: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_bf'></ins>"; },
		map_ld: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_ld'></ins>"; },
		map_dm: function(pAmount) { return pAmount.toLocaleString() + "<ins class='s16 s16_map_dm'></ins>"; }
	},
	PaymentEnum:
	{
		Coin: "Coin",
		Gem: "Gem"
	},
	
	/*
	 * Gets the first payment amount from an object.
	 * @param object pObject
	 * @returns int
	 */
	getPaymentAmount: function(pObject)
	{
		for (var i in pObject.p)
		{
			return pObject.p[i];
		}
		return 0;
	},
	
	/*
	 * Parses a period separated string representing those units.
	 * @param string pString to parse.
	 * @returns int the money in copper value for calculating.
	 * @pre String does not contain negative numbers.
	 */
	parseCoinString: function(pString)
	{
		if (pString === undefined || pString === null)
		{
			return 0;
		}
		
		var str = pString.replace(/[^0-9.-]/gi, "").split("."); // Only allow numbers, negative sign, and period separators
		var len = str.length;
		var copper = 0, silver = 0, gold = 0;
		
		if (len === 0)
		{
			return 0;
		}
		if (len === 1)
		{
			silver = parseInt(str[0]);
		}
		
		if (len >= 2)
		{
			copper = parseInt(str[len-1]);
			silver = parseInt(str[len-2]);
		}
		if (len === 2 && str[len-1].length === 1)
		{
			copper = copper * T.cBASE_10; // 0.1 = 10 copper
		}
		if (len >= 3)
		{
			gold = parseInt(str[len-3]);
		}
		
		if ( ! isFinite(copper)) { copper = 0; }
		if ( ! isFinite(silver)) { silver = 0; }
		if ( ! isFinite(gold)) { gold = 0; }
		
		return parseInt(copper + (silver * E.Exchange.COPPER_IN_SILVER) + (gold * E.Exchange.COPPER_IN_GOLD));
	},
	parseGemString: function(pString)
	{
		if (pString === undefined || pString === null)
		{
			return 0;
		}
		if ( ! isFinite(parseInt(pString)))
		{
			return 0;
		}
		return parseInt(pString);
	},
	
	/*
	 * Parses a period separated dollars and cents string.
	 * @param string pString to parse.
	 * @returns int the money in cent value for calculating.
	 * @pre String does not contain negative numbers.
	 */
	parseMoneyString: function(pString)
	{
		if (pString === undefined || pString === null)
		{
			return 0;
		}
		
		var str = pString.split(".");
		var len = str.length;
		var cent = 0, dollar = 0;
		
		if (len === 0)
		{
			return 0;
		}
		if (len === 1)
		{
			dollar = parseInt(str[0]);
		}
		
		if (len >= 2)
		{
			cent = parseInt(str[len-1]);
			dollar = parseInt(str[len-2]);
		}
		if (len >= 2 && str[len-1].length === 1)
		{
			cent = cent * T.cBASE_10; // 0.1 = 10 cent
		}
		else if (len >= 2 && str[len-1].length >= 2)
		{
			cent = parseInt(cent.toString().substring(0, 2)); // Only accept first two digits of cent
		}
		
		if ( ! isFinite(cent)) { cent = 0; }
		if ( ! isFinite(dollar)) { dollar = 0; }
		
		return parseInt(cent + (dollar * E.Exchange.CENTS_IN_DOLLAR));
	},
	
	/*
	 * Converts a coin amount in copper to a period separated string.
	 * @param int pAmount of copper.
	 * @objparam boolean aWantColor whether to include the coin image instead of periods.
	 * @objparam boolean aWantBig whether to use big coin text and icons.
	 * @objparam boolean aWantSpace whether to separate the different coins with spaces.
	 * @objparam boolean aWantShort whether to truncate lower denominations.
	 * @returns string coin for displaying.
	 */
	formatCoinString: function(pAmount, pSettings)
	{
		var amount = (pAmount === undefined || isFinite(pAmount) === false) ? 0 : parseInt(pAmount);
		var Settings = pSettings || {};
		
		var sep = ".";
		var sg0 = ""; var ss0 = ""; var sc0 = "";
		var sg1 = ""; var ss1 = ""; var sc1 = "";
		// Because the coin image is not text copyable, include additional hidden selectable text
		var abbrg = ""; var abbrs = ""; var abbrc = "";
		if (Settings.aWantCopy !== false)
		{
			abbrg = "<abbr class='cssCopyText'>" + D.getString("CoinGold") + "&nbsp;</abbr>";
			abbrs = "<abbr class='cssCopyText'>" + D.getString("CoinSilver") + "&nbsp;</abbr>";
			abbrc = "<abbr class='cssCopyText'>" + D.getString("CoinCopper") + "&nbsp;</abbr>";
		}
		
		if (Settings.aWantColor)
		{
			// Instead of period separating the currency units, use the coin images
			sep = "";
			sg0 = "<gold>"; ss0 = "<silver>"; sc0 = "<copper>";
			sg1 = "</gold>" + abbrg + "<goldcoin></goldcoin>";
			ss1 = "</silver>" + abbrs + "<silvercoin></silvercoin>";
			sc1 = "</copper>" + abbrc + "<coppercoin></coppercoin>";
		}
		if (Settings.aWantBig)
		{
			sep = "";
			sg0 = "<gold>"; ss0 = "<silver>"; sc0 = "<copper>";
			sg1 = "</gold>" + abbrg + "<img src='img/ui/coin_gold.png' />";
			ss1 = "</silver>" + abbrs + "<img src='img/ui/coin_silver.png' />";
			sc1 = "</copper>" + abbrc + "<img src='img/ui/coin_copper.png' />";
		}
		if (Settings.aWantSpace)
		{
			sep = " ";
		}
		
		var gold = Math.abs(~~(amount / E.Exchange.COPPER_IN_GOLD));
		var silver = Math.abs(~~(amount / E.Exchange.SILVER_IN_GOLD) % E.Exchange.COPPER_IN_SILVER);
		var copper = Math.abs(amount % E.Exchange.COPPER_IN_SILVER);
		var goldstr = (Settings.aWantColor || Settings.aWantBig || Settings.aWantShort) ? gold.toLocaleString() : gold;
		var silverstr = silver;
		var copperstr = copper;
		var sign = (amount < 0) ? I.Symbol.Negative : "";
		
		// Leading zero for units that are right side of the leftmost unit
		if ( ! Settings.aWantColor && (gold > 0 && silver < T.cBASE_10))
		{
			silverstr = "0" + silver;
		}
		if ( ! Settings.aWantColor && ((silver > 0 && copper < T.cBASE_10) || (copper < T.cBASE_10)))
		{
			copperstr = "0" + copper;
		}
		// For short version exclude copper if showing gold and silver, or is zero
		if (Settings.aWantShort)
		{
			if (gold > 0 || (copper === 0 && amount > 0))
			{
				sc0 = "";
				copperstr = "";
				sc1 = "";
			}
			if (silver === 0)
			{
				ss0 = "";
				silverstr = "";
				ss1 = "";
			}
		}
		
		// Returns
		if (gold > 0)
		{
			return sign + sg0 + goldstr + sg1 + sep + ss0 + silverstr + ss1 + sep + sc0 + copperstr + sc1;
		}
		if (silver > 0)
		{
			return sign + ss0 + silverstr + ss1 + sep + sc0 + copperstr + sc1;
		}
		if (Settings.aWantColor)
		{
			// No 0 silver prefix for copper-only price if showing color
			return sc0 + copperstr + sc1;
		}
		return sign + ss0 + "0" + sep + ss1 + sc0 + copperstr + sc1;
	},
	formatCoinStringColored: function(pAmount)
	{
		return E.formatCoinString(pAmount, {aWantColor: true});
	},
	formatCoinStringShort: function(pAmount)
	{
		return E.formatCoinString(pAmount, {aWantColor: true, aWantShort: true});
	},
	formatCoinStringSlot: function(pAmount)
	{
		return E.formatCoinString(pAmount, {aWantColor: true, aWantShort: true, aWantCopy: false});
	},
	
	/*
	 * Converts a money amount in cents to dollars period separated cents string.
	 * @param int pAmount of cents.
	 * @returns string money for displaying.
	 */
	formatMoneyString: function(pAmount, pWantColor)
	{
		if (pAmount === undefined || isFinite(pAmount) === false)
		{
			return "0.00";
		}
		pAmount = parseInt(pAmount);
		
		var dollar = Math.abs(~~(pAmount / E.Exchange.CENTS_IN_DOLLAR));
		var cent = Math.abs(pAmount % E.Exchange.CENTS_IN_DOLLAR);
		var sign = (pAmount < 0) ? I.Symbol.Negative : "";
		
		if (cent < T.cBASE_10)
		{
			cent = "0" + cent;
		}
		var sm0 = (pWantColor) ? "<money>" : "";
		var sm1 = (pWantColor) ? "</money>" : "";
		return sm0 + sign + "$" + dollar + "." + cent + sm1;
	},
	
	/*
	 * Formats a currency amount and appends a currency unit icon.
	 * @param string pCurrency as defined in the CSS as a custom HTML tag that
	 * has color attribute associated with that currency.
	 * @param int pAmount.
	 * @param boolean pWantColor whether to colorize the amount.
	 * @returns HTML string.
	 */
	formatCurrencyString: function(pCurrency, pAmount, pWantColor)
	{
		if (pAmount === undefined || isFinite(pAmount) === false)
		{
			return "0";
		}
		pAmount = parseInt(pAmount);
		
		var c = pCurrency;
		var s0 = "";
		var s1 = "";
		var s2 = "<" + c + "unit></" + c + "unit>";
		if (pWantColor)
		{
			s0 = "<" + c + ">";
			s1 = "</" + c + ">";
		}
		return s0 + pAmount.toLocaleString() + s1 + s2;
	},
	formatKarmaString: function(pAmount, pWantColor)
	{
		return E.formatCurrencyString("karma", pAmount, pWantColor);
	},
	formatLaurelString: function(pAmount, pWantColor)
	{
		return E.formatCurrencyString("laurel", pAmount, pWantColor);
	},
	formatGemString: function(pAmount, pWantColor)
	{
		return E.formatCurrencyString("gem", pAmount, pWantColor);
	},
	
	/*
	 * Animates the input box's value or the box itself depending on difference.
	 * @param int pOldValue for comparison.
	 * @param int pNewValue for comparison.
	 * @param jqobject pInput to manipulate.
	 */
	animateValue: function(pInput, pOldValue, pNewValue)
	{
		if (pNewValue < pOldValue)
		{
			// Red if value went down
			pInput.css({color: "#ff2200"}).animate({color: "#ffeebb"}, 5000);
		}
		else if (pNewValue > pOldValue )
		{
			// Green if value went up
			pInput.css({color: "#44dd44"}).animate({color: "#ffeebb"}, 5000);
		}
		else
		{
			// Round the box if no change
			pInput.css({"border-radius": 32}).animate({"border-radius": 4}, 1000);
		}
	},
	
	/*
	 * Updates the coin to gem ratio and executes a callback. Use the convert
	 * functions in the callback.
	 */
	updateCoinInGem: function(pCallback)
	{
		$.getJSON(U.URL_API.GemPrice + E.Exchange.COIN_SAMPLE, function(pData)
		{
			if (pData.quantity !== undefined)
			{
				E.Exchange.CoinInGem = E.Exchange.COIN_SAMPLE / pData.quantity;
				pCallback();
			}
		}).fail(function()
		{
			pCallback();
		});
	},
	updateGemInCoin: function(pCallback)
	{
		$.getJSON(U.URL_API.CoinPrice + E.Exchange.GEM_SAMPLE, function(pData)
		{
			if (pData.quantity !== undefined)
			{
				E.Exchange.GemInCoin = E.Exchange.GEM_SAMPLE / pData.quantity;
				pCallback();
			}
		}).fail(function()
		{
			pCallback();
		});
	},
	updateExchangeRatios: function(pCallback)
	{
		E.updateCoinInGem(function()
		{
			E.updateGemInCoin(function()
			{
				pCallback();
			});
		});
	},
	
	/*
	 * Converts a currency using the updated exchange rate.
	 */
	convertGemToCoin: function(pAmount)
	{
		return Math.round(pAmount * E.Exchange.CoinInGem);
	},
	convertCoinToGem: function(pAmount)
	{
		return Math.round(pAmount * E.Exchange.GemInCoin);
	},
	convertGemToMoney: function(pAmount)
	{
		return Math.round(pAmount * E.Exchange.DOLLAR_PER_GEM);
	},
	convertMoneyToGem: function(pAmount)
	{
		return Math.floor(pAmount * E.Exchange.GEM_PER_DOLLAR);
	},
	formatGemToCoin: function(pAmount)
	{
		return E.formatCoinStringShort(E.convertGemToCoin(pAmount));
	},
	formatCoinToGem: function(pAmount)
	{
		return E.formatGemString(E.convertCoinToGem(pAmount), true);
	},
	formatGemToMoney: function(pAmount)
	{
		return E.formatMoneyString(E.convertGemToMoney(pAmount), true);
	},
	formatMoneyToGem: function(pAmount)
	{
		return E.formatGemString(E.convertMoneyToGem(pAmount), true);
	},
	
	/*
	 * Converts gem to coin or coin to gem with the input as the parameter, and
	 * the output as the argument in the callback.
	 */
	getGemFromCoin: function(pCoin, pCallback)
	{
		// INPUT amount of coin results in OUTPUT amount of gems
		$.getJSON(U.URL_API.GemPrice + pCoin, function(pData)
		{
			if (pData.quantity !== undefined)
			{
				var currentgem = parseInt(pData.quantity);
				pCallback(currentgem);
			}
		}).fail(function()
		{
			pCallback(0);
		});
	},
	getGemFromCoinInverse: function(pCoin, pCallback)
	{
		// OUTPUT amount of gems in order to buy INPUT amount of coin
		E.updateGemInCoin(function()
		{
			if (E.Exchange.GemInCoin !== 0)
			{
				pCallback(E.convertCoinToGem(pCoin));
			}
		});
	},
	getCoinFromGem: function(pGem, pCallback)
	{
		// INPUT amount of gems results in OUTPUT amount of coin
		$.getJSON(U.URL_API.CoinPrice + pGem, function(pData)
		{
			if (pData.quantity !== undefined)
			{
				var currentcoin = parseInt(pData.quantity);
				pCallback(currentcoin);
			}
		}).fail(function()
		{
			pCallback(0);
		});
	},
	getCoinFromGemInverse: function(pGem, pCallback)
	{
		// OUTPUT amount of coin in order to buy INPUT amount of gems
		E.updateCoinInGem(function()
		{
			pCallback(E.convertGemToCoin(pGem));
		});
	},
	
	/*
	 * Deducts Trading Post tax from a value.
	 * @param int pAmount of copper.
	 * @returns int taxed value.
	 */
	deductTax: function(pAmount)
	{
		return Math.floor(pAmount - (pAmount * E.Exchange.TAX_TOTAL));
	},
	
	/*
	 * Reads a price object that was returned from API and returns a processed object.
	 * @param object pPriceData.
	 * @param object pCount quantity of the items, optional.
	 * @returns object.
	 */
	processPrice: function(pPriceData, pCount)
	{
		var count = (pCount === undefined) ? 1 : pCount;
		var isarray = Array.isArray(pPriceData);
		var pricebuy = ((isarray) ? pPriceData[0] : pPriceData.buys.unit_price) * count;
		var pricesell = ((isarray) ? (pPriceData[1] || pPriceData[0]) : (pPriceData.sells.unit_price || pPriceData.buys.unit_price)) * count;
		return {
			oPriceBuy: pricebuy,
			oPriceSell: pricesell,
			oPriceBuyTaxed: E.deductTax(pricebuy),
			oPriceSellTaxed: E.deductTax(pricesell)
		};
	},
	createPrice: function(pPrice, pCount)
	{
		var count = (pCount === undefined) ? 1 : pCount;
		var price = (pPrice === undefined) ? 0 : (pPrice * count);
		return {
			oPriceBuy: price,
			oPriceSell: price,
			oPriceBuyTaxed: E.deductTax(price),
			oPriceSellTaxed: E.deductTax(price)
		};
	},
	createPricePlain: function(pPrice, pCount)
	{
		var count = (pCount === undefined) ? 1 : pCount;
		var price = (pPrice === undefined) ? 0 : (pPrice * count);
		return {
			oPriceBuy: price,
			oPriceSell: price,
			oPriceBuyTaxed: price,
			oPriceSellTaxed: price
		};
	},
	createPriceBound: function(pPrice, pCount)
	{
		if (E.isPriceObject(pPrice))
		{
			return {
				oPriceBuy: pPrice.oPriceBuy,
				oPriceSell: pPrice.oPriceSell,
				oPriceBuyTaxed: 0,
				oPriceSellTaxed: 0
			};
		}
		// If provided a numerical price instead of object
		var count = (pCount === undefined) ? 1 : pCount;
		var price = (pPrice === undefined) ? 0 : (pPrice * count);
		return {
			oPriceBuy: price,
			oPriceSell: price,
			oPriceBuyTaxed: 0,
			oPriceSellTaxed: 0
		};
	},
	addPrice: function(pPriceA, pPriceB)
	{
		return {
			oPriceBuy: pPriceA.oPriceBuy + pPriceB.oPriceBuy,
			oPriceSell: pPriceA.oPriceSell + pPriceB.oPriceSell,
			oPriceBuyTaxed: pPriceA.oPriceBuyTaxed + pPriceB.oPriceBuyTaxed,
			oPriceSellTaxed: pPriceA.oPriceSellTaxed + pPriceB.oPriceSellTaxed
		};
	},
	recountPrice: function(pPrice, pCount)
	{
		return {
			oPriceBuy: pPrice.oPriceBuy * pCount,
			oPriceSell: pPrice.oPriceSell * pCount,
			oPriceBuyTaxed: pPrice.oPriceBuyTaxed * pCount,
			oPriceSellTaxed: pPrice.oPriceSellTaxed * pCount
		};
	},
	isPriceObject: function(pPrice)
	{
		if (pPrice.oPriceBuy !== undefined)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Retrieves the Trading Post prices for an item.
	 * @param int pItemID.
	 * @param function pCallback to execute after retrieval.
	 * @param boolean pWantCache whether to cache the price or always use freshest, optional.
	 * @returns object processed price.
	 */
	getPrice: function(pItemID, pCallback, pWantCache)
	{
		var wantcache = (pWantCache !== undefined) ? pWantCache : false;
		if (Q.isTradeable(pItemID))
		{
			$.ajax({
				dataType: "json",
				url: U.getAPIPrice(pItemID),
				cache: wantcache,
				success: function(pData)
				{
					E.Pricelist[pData.id] = priceobj;
					if (pCallback)
					{
						var priceobj = E.processPrice(pData);
						pCallback(priceobj);
					}
				}
			});
		}
	},
	getCachedPrice: function(pItemID)
	{
		var priceobj = E.Pricelist[pItemID];
		if (priceobj)
		{
			return priceobj;
		}
		return null;
	},
	getPrices: function(pItemIDs, pCallback, pWantCache)
	{
		var tradeableids = [];
		var itemid;
		// Check if item IDs are tradeable beforehand
		if (pItemIDs && pItemIDs.length)
		{
			for (var i = 0; i < pItemIDs.length; i++)
			{
				itemid = pItemIDs[i];
				if (Q.Boxes.Items[itemid] === undefined ||
					(Q.Boxes.Items[itemid] && Q.isTradeable(Q.Boxes.Items[itemid].oData)))
				{
					tradeableids.push(itemid);
				}
			}
		}
		
		U.fetchAPI(U.URL_API.ItemPrice, tradeableids, {
			aWantCache: pWantCache,
			aCallback: function(pData, pFailedIDs)
		{
			var pricedb = {};
			if (pData)
			{
				// Add prices to database for later uses
				pData.forEach(function(iData)
				{
					var priceobj = E.processPrice(iData);
					pricedb[iData.id] = priceobj;
					E.Pricelist[iData.id] = priceobj;
				});
				pCallback(pricedb, pFailedIDs);
			}
			else
			{
				pCallback();
			}
		}});
	},
	getPriceObject: function(pItemID, pCallback)
	{
		// To be used after get prices function was called
		if (E.Pricelist[pItemID])
		{
			pCallback(E.Pricelist[pItemID]);
		}
		else
		{
			E.getPrice(pItemID, function(pData)
			{
				pCallback(pData);
			});
		}
	},
	
	/*
	 * Get the current buy orders and sell listings.
	 * @param int pItemID.
	 * @param function pCallback to execute after retrieval.
	 * @param boolean pWantCache whether to cache the price or always use freshest, optional.
	 * @returns object listings.
	 */
	getListings: function(pItemID, pCallback, pWantCache)
	{
		var wantcache = (pWantCache !== undefined) ? pWantCache : false;
		if (Q.isTradeable(pItemID))
		{
			$.ajax({
				dataType: "json",
				url: U.getAPIListings(pItemID),
				cache: wantcache,
				success: function(pData)
				{
					if (pCallback)
					{
						pCallback(pData);
					}
				},
				error: function()
				{
					I.removeThrobber(I.getConsole());
					I.print("Item is not on the Trading Post.");
				}
			});
		}
		else
		{
			I.clear();
			I.write("Item is not tradeable.");
		}
	},
	
	/*
	 * Formats a Trading Post listings API object into HTML tables.
	 * @param object pItem details retrieved from API.
	 * @param object pListings.
	 * @returns string HTML.
	 */
	formatListings: function(pItem, pListings)
	{
		var str = "";
		var priceword = D.getWordCapital("price");
		var byword = D.getWord("by");
		var buys = "", sells = "";
		var supply = 0;
		var demand = 0;
		var suppliers = 0;
		var demanders = 0;
		// Buys and Sells tables
		pListings.buys.forEach(function(iEntry)
		{
			buys += "<tr><td>" + iEntry.quantity + " " + D.getWordCapital("ordered") + "</td><td>" + E.formatCoinStringColored(iEntry.unit_price) + "</td></tr>";
			demand += iEntry.quantity;
			demanders += iEntry.listings;
		});
		buys += "</tbody></table>";
		pListings.sells.forEach(function(iEntry)
		{
			sells += "<tr><td>" + iEntry.quantity + " " + D.getWordCapital("available") + "</td><td>" + E.formatCoinStringColored(iEntry.unit_price) + "</td></tr>";
			supply += iEntry.quantity;
			suppliers += iEntry.listings;
		});
		sells += "</tbody></table>";
		// Headers
		var demandstr = "<span class='trsListingsDemand'>" + D.getWordCapital("demand") + ": "
			+ demand.toLocaleString() + " " + byword + " " + demanders.toLocaleString() + "</span>";
		var supplystr = "<span class='trsListingsSupply'>" + D.getWordCapital("supply") + ": "
			+ supply.toLocaleString() + " " + byword + " " + suppliers.toLocaleString() + "</span>";
		var buysheader = "<table class='trsListingsBuys'><thead><tr><th>" + demandstr + "</th><th>" + priceword + "</th></tr></thead><tbody>";
		var sellsheader = "<table class='trsListingsSells'><thead><tr><th>" + supplystr + "</th><th>" + priceword + "</th></tr></thead><tbody>";
		// Combine HTML
		str += "<div class='trsListings'>" + buysheader + buys + sellsheader + sells + "</div>";
		return str;
	},
	
	/*
	 * Retrieves listings for an item and prints them to the console.
	 * @param int pItemID.
	 * @param boolean pWantPlain whether to just print the listing.
	 */
	printListings: function(pItemID, pWantPlain)
	{
		if (pWantPlain !== false)
		{
			I.print(I.cThrobber, true);
		}
		Q.getItem(pItemID, function(pItem)
		{
			E.getListings(pItemID, function(pListing)
			{
				if (pWantPlain !== false)
				{
					I.clear();
					I.print(Q.getItemPreface(pItem));
				}
				I.print(E.formatListings(pItem, pListing));
				I.bindConsoleInput();
			});
		});
	},
	
	/*
	 * Calculates the trading calculator's output textboxes using input textboxes' values.
	 * @param jqobject pEntry trading calculator HTML parent.
	 */
	calculateTrading: function(pEntry)
	{
		// Computable data
		var buy = E.parseCoinString(pEntry.find(".trdBuy").val());
		var sell = E.parseCoinString(pEntry.find(".trdSell").val());
		var quantity = T.parseQuantity(pEntry.find(".trdQuantity").val());
		
		// Output elements
		var cost = pEntry.find(".trdCost");
		var tax = pEntry.find(".trdTax");
		var revenue = pEntry.find(".trdRevenue");
		var profit = pEntry.find(".trdProfit");
		var breakpoint = pEntry.find(".trdBreak");
		var margin = pEntry.find(".trdMargin");
		
		var profitamount = (sell - (sell * E.Exchange.TAX_TOTAL) - buy) * quantity;
		var revenueamount = (sell - (sell * E.Exchange.TAX_SOLD)) * quantity;
		var costamount = buy * quantity;
		var listamount = (sell * E.Exchange.TAX_LIST) * quantity;
		var taxamount = (sell * E.Exchange.TAX_SOLD) * quantity;
		
		// Do calculation and put them in outputs
		cost.val(I.Symbol.Negative + E.formatCoinString(Math.round(
			costamount
		)));
		tax.val(I.Symbol.Negative + E.formatCoinString(Math.round(
			listamount
			)) + " + −" + E.formatCoinString(Math.round(
			taxamount
		)));
		breakpoint.val(E.formatCoinString(Math.round(
			buy / E.Exchange.TAX_INVERSE
		)));
		revenue.val(E.formatCoinString(Math.round(
			revenueamount
		)));
		profit.val(E.formatCoinString(Math.round(
			profitamount
		)));
		margin.val(U.convertRatioToPercent(
			(revenueamount / (costamount + listamount)) - 1, 2
		));

		// Color the output numbers depending on sign
		$([profit, margin]).each(function()
		{
			var roundedprofit = Math.round(profitamount);
			$(this).removeClass("trdZero trdGain trdLoss");
			if (roundedprofit === 0) { $(this).addClass("trdZero"); }
			else if (roundedprofit > 0) { $(this).addClass("trdGain"); }
			else if (roundedprofit < 0) { $(this).addClass("trdLoss"); }
		});
	},
	
	/*
	 * Gets an array of all item IDs in the calculators, for use in bulk fetching.
	 * @returns array
	 * @pre Used Textlist is initialized.
	 */
	getTradingIDs: function()
	{
		var idstofetch = [];
		X.Textlists.TradingItem.value.forEach(function(iID)
		{
			var id = parseInt(iID);
			if (isFinite(parseInt(id)))
			{
				idstofetch.push(id);
			}
		});
		return idstofetch;
	},
	
	/*
	 * Retrieves non-price information about the item and updates those boxes.
	 * @param jqobject pEntry trading calculator HTML parent.
	 */
	updateTradingDetails: function(pEntry)
	{
		var name = pEntry.find(".trdName").val();
		var id = pEntry.find(".trdItem").val();
		if (isFinite(parseInt(id)) === false || name.length === 0)
		{
			return;
		}
		
		Q.getItem(id, function(pItem)
		{
			var icon = pEntry.find(".trdIcon");
			Q.setRarityClass(pEntry.find(".trdName"), pItem.rarity);
			pEntry.attr("data-rarity", pItem.rarity);
			pEntry.find(".trdLink").val(pItem.chat_link || "");
			icon.attr("src", pItem.icon);
			icon.unbind("click").click(function()
			{
				Q.printItemInfo(pItem);
			});
			Q.scanItem(pItem, {aElement: icon, aCallback: function(pBox)
			{
				pEntry.data("istradeable", pBox.oIsTradeable);
			}});
		});
	},
	
	/*
	 * Retrieves prices from API and updates those boxes.
	 * @param jqobject pEntry trading calculator HTML parent.
	 * @param boolean pWantCache whether to use prefetched prices.
	 */
	updateTradingPrices: function(pEntry, pWantCache)
	{
		var name = pEntry.find(".trdName").val();
		var id = pEntry.find(".trdItem").val();
		if (isFinite(parseInt(id)) === false || name.length === 0)
		{
			return;
		}
		
		var previousbuy = 0, previoussell = 0;
		var currentbuy = 0, currentsell = 0;
		var nameelm = pEntry.find(".trdName");
		var buyelm = pEntry.find(".trdCurrentBuy");
		var sellelm = pEntry.find(".trdCurrentSell");
		var buylowelm = pEntry.find(".trdNotifyBuyLow");
		var buyhighelm = pEntry.find(".trdNotifyBuyHigh");
		var selllowelm = pEntry.find(".trdNotifySellLow");
		var sellhighelm = pEntry.find(".trdNotifySellHigh");
		var buylow = E.parseCoinString(buylowelm.val());
		var buyhigh = E.parseCoinString(buyhighelm.val());
		var selllow = E.parseCoinString(selllowelm.val());
		var sellhigh = E.parseCoinString(sellhighelm.val());
		var wantcache = (pWantCache !== false) ? true : false;
		
		if (pEntry.data("istradeable") === false)
		{
			buyelm.val("");
			sellelm.val("");
			if (X.getChecklistItem(X.Checklists.TradingOverwrite, U.getSubintegerFromHTMLID(pEntry))
					=== X.ChecklistEnum.Checked)
			{
				pEntry.find(".trdBuy").val("").trigger("input");
				pEntry.find(".trdSell").val("").trigger("input");
			}
			return;
		}
		
		var updatePrice = function(pPriceObj)
		{
			if (!pPriceObj)
			{
				buyelm.val(I.Symbol.Ellipsis);
				sellelm.val(I.Symbol.Ellipsis);
				return;
			}
			previousbuy = E.parseCoinString(pEntry.find(".trdCurrentBuy").first().val());
			previoussell = E.parseCoinString(pEntry.find(".trdCurrentSell").first().val());
			currentbuy = pPriceObj.oPriceBuy;
			currentsell = pPriceObj.oPriceSell;
			buyelm.val(E.formatCoinString(currentbuy));
			sellelm.val(E.formatCoinString(currentsell));
			
			// Overwrite calculator buy and sell prices if opted
			if (X.getChecklistItem(X.Checklists.TradingOverwrite, U.getSubintegerFromHTMLID(pEntry)) === X.ChecklistEnum.Checked)
			{
				pEntry.find(".trdBuy").val(buyelm.val()).trigger("input");
				pEntry.find(".trdSell").val(sellelm.val()).trigger("input");
			}
			
			// Animate prices that have changed
			E.animateValue(buyelm, previousbuy, currentbuy);
			E.animateValue(sellelm, previoussell, currentsell);
			
			// Notify if tracked price is within range
			if (X.isChecked(X.Checklists.TradingNotify, pEntry))
			{
				nameelm.removeClass("trdMatched");
				
				if (currentbuy <= buylow && buylow !== 0 && currentbuy !== 0)
				{
					nameelm.addClass("trdMatched");
					buylowelm.addClass("trdMatched");
					D.speak(D.getPhraseTitle("buy low") + " " + name);
				}
				else
				{
					buylowelm.removeClass("trdMatched");
				}

				if (currentbuy >= buyhigh && buyhigh !== 0 && currentbuy !== 0)
				{
					nameelm.addClass("trdMatched");
					buyhighelm.addClass("trdMatched");
					D.speak(D.getPhraseTitle("buy high") + " " + name);
				}
				else
				{
					buyhighelm.removeClass("trdMatched");
				}

				if (currentsell <= selllow && selllow !== 0 && currentsell !== 0)
				{
					nameelm.addClass("trdMatched");
					selllowelm.addClass("trdMatched");
					D.speak(D.getPhraseTitle("sell low") + " " + name);
				}
				else
				{
					selllowelm.removeClass("trdMatched");
				}

				if (currentsell >= sellhigh && sellhigh !== 0 && currentsell !== 0)
				{
					nameelm.addClass("trdMatched");
					sellhighelm.addClass("trdMatched");
					D.speak(D.getPhraseTitle("sell high") + " " + name);
				}
				else
				{
					sellhighelm.removeClass("trdMatched");
				}
			}
		};
		
		if (wantcache)
		{
			updatePrice(E.getCachedPrice(id));
		}
		else
		{
			E.getPrice(id, function(pPriceObj)
			{
				updatePrice(pPriceObj);
			});
		}
	},
	updateAllTradingDetails: function()
	{
		Q.getItems(E.getTradingIDs(), function()
		{
			$("#trdList .trdEntry").each(function() { E.updateTradingDetails($(this)); });
		});
	},
	updateAllTradingPrices: function()
	{
		E.getPrices(E.getTradingIDs(), function()
		{
			$("#trdList .trdEntry").each(function() { E.updateTradingPrices($(this)); });
		});
	},
	
	/*
	 * Erases unneeded data from the calculator.
	 * @param jqobject pEntry of a calculator.
	 */
	clearCalculator: function(pEntry)
	{
		Q.setRarityClass(pEntry.find(".trdName"));
		pEntry.find(".trdIcon").attr("src", U.URL_IMG.Placeholder);
		pEntry.find(".trdItem").val("").trigger("change");
		pEntry.find(".trdCurrentBuy").val("");
		pEntry.find(".trdCurrentSell").val("");
		pEntry.find(".trdLink").val("");
		
		pEntry.find(".trdNotifyBuyLow").val("").trigger("change");
		pEntry.find(".trdNotifyBuyHigh").val("").trigger("change");
		pEntry.find(".trdNotifySellLow").val("").trigger("change");
		pEntry.find(".trdNotifySellHigh").val("").trigger("change");
		E.clearMatched(pEntry);
	},
	clearMatched: function(pEntry)
	{
		pEntry.find(".trdName").removeClass("trdMatched");
		pEntry.find(".trdNotifyBuyLow").removeClass("trdMatched");
		pEntry.find(".trdNotifyBuyHigh").removeClass("trdMatched");
		pEntry.find(".trdNotifySellLow").removeClass("trdMatched");
		pEntry.find(".trdNotifySellHigh").removeClass("trdMatched");
	},
	
	/*
	 * Generates calculators and binds behavior.
	 */
	initializeTrading: function()
	{
		var i;
		var entry = "";
		var name, buy, sell, quantity;
		
		for (i = 0; i < O.Options.int_numTradingCalculators; i++)
		{
			entry = "#trdEntry_" + i;
			// Generate individual calculators
			$("#trdList").append(
				"<div id='trdEntry_" + i + "' class='trdEntry'>"
					+ "<div class='trdAccordion trdAccordionShut'>"
						+ "<abbr><img class='trdIcon' src='" + U.URL_IMG.Placeholder + "' /></abbr>"
							+ "<div class='trdResultsFocus'><input class='trdName' type='text' /></div>"
						+ "<div class='trdButtons'>"
							+ "<button class='trdSearch' tabindex='-1'>S</button><button class='trdListings' tabindex='-1'>$</button><br />"
						+ "</div>"
						+ "<div class='trdExpand'>"
							+ "<abbr>$~O</abbr><input class='trdBuy' type='text' />"
							+ "<abbr>−$~</abbr><input class='trdCost trdOutput' type='text' tabindex='-1' /><br />"
							+ "<abbr>O~$</abbr><input class='trdSell' type='text' />"
							+ "<abbr>$=$</abbr><input class='trdBreak trdOutput' type='text' tabindex='-1' /><br />"
							+ "<abbr>×</abbr><input class='trdQuantity' type='text' />"
							+ "<abbr>−$%</abbr><input class='trdTax trdOutput' type='text' tabindex='-1' /><br />"
							+ "<abbr>+$</abbr><input class='trdProfit trdOutput' type='text' tabindex='-1' />"
							+ "<abbr>=$</abbr><input class='trdRevenue trdOutput' type='text' tabindex='-1' /><br />"
							+ "<abbr>+$%</abbr><input class='trdMargin trdOutput' type='text' tabindex='-1' />"
							+ "<abbr>[]</abbr><input class='trdLink trdOutput' type='text' tabindex='-1' />"
							+ "<input class='trdItem trdOutput' type='text' /><br />"
							+ "<abbr>$~!</abbr>"
								+ "<input class='trdNotifyBuyHigh' type='text' />"
								+ "<input class='trdCurrentBuy trdOutput' type='text' tabindex='-1' />"
								+ "<input class='trdNotifyBuyLow' type='text' />"
								+ "<label title='<dfn>" + D.getWordCapital("overwrite") + "</dfn>: Replace your buy and sell prices with the current prices when refreshing.'>"
									+ "<input class='trdOverwrite' type='checkbox' tabindex='-1' />" + I.Symbol.Filler + "</label><br />"
							+ "<abbr>!~$</abbr>"
								+ "<input class='trdNotifySellHigh' type='text' />"
								+ "<input class='trdCurrentSell trdOutput' type='text' tabindex='-1' />"
								+ "<input class='trdNotifySellLow' type='text' />"
								+ "<label title='<dfn>" + D.getWordCapital("notify") + "</dfn>: Turn on sound notification for this item.'>"
									+"<input class='trdNotify' type='checkbox' tabindex='-1' />" + I.Symbol.Filler + "</label>"
						+ "<br /><br /></div>"
					+ "</div>"
					+ "<div class='trdPreview'>"
						+ "<input class='trdCurrentBuy trdOutput' type='text' tabindex='-1' />"
						+ "<input class='trdCurrentSell trdOutput' type='text' tabindex='-1' />"
						+ "<div class='btnSwap'>"
							+ "<button class='btnSwapUp' tabindex='-1'></button><button class='btnSwapDown' tabindex='-1'></button>"
						+ "</div>"
					+ "</div>"
				+ "</div>"
			);
			I.qTip.init($(entry + " .trdOverwrite").parent());
			I.qTip.init($(entry + " .trdNotify").parent());
			X.rewrapCheckboxes();
			
			name = $(entry + " .trdName");
			buy = $(entry + " .trdBuy");
			sell = $(entry + " .trdSell");
			quantity = $(entry + " .trdQuantity");
			
			// Bind click to select all text behavior
			I.bindInputSelect(entry + " input");
			
			// Bind search button behavior for ith calculator
			$(entry + " .trdListings").click(function()
			{
				if (I.isConsoleShown() === false)
				{
					var id = $(this).closest(".trdEntry").find(".trdItem").val();
					E.printListings(id);
				}
			}).dblclick(function()
			{
				var query = $(this).closest(".trdEntry").find(".trdName").val();
				U.openExternalURL(U.getWikiLinkLanguage(query));
			});
			$(entry + " .trdSearch").click(function()
			{
				var id = $(this).closest(".trdEntry").find(".trdItem").val();
				var query = $(this).closest(".trdEntry").find(".trdName").val();
				if (id.length === 0)
				{
					U.openExternalURL(U.getTradingSearchLink(query));
				}
				else
				{
					U.openExternalURL(U.getTradingItemLink(id, query));
				}
			});
			
			// Bind input textboxes calculate behavior
			$([buy, sell, quantity]).each(function()
			{
				$(this).on("input", function()
				{
					E.calculateTrading($(this).parent());
				});
			});
			
			// Bind current buy/sell prices change auto flanking
			$(entry + " .trdCurrentBuy, " + entry + " .trdCurrentSell").each(function()
			{
				$(this).dblclick(function()
				{
					var price = E.parseCoinString($(this).val());
					if (price !== 0)
					{
						// Assume the inputs are siblings
						$(this).prev().val(E.formatCoinString(price + 1)).trigger("change");
						$(this).next().val(E.formatCoinString(price - 1)).trigger("change");
						E.updateTradingPrices($(this).closest(".trdEntry"), false);
						D.stopSpeech();
					}
				});
			});
			
			// Initial registering of the swap index variable
			$(entry + " .btnSwap").hover(
				function()
				{
					$(this).closest(".trdEntry").find(".trdName").addClass("trdHovered");
					E.SwapIndex = U.getSubintegerFromHTMLID($(this).closest(".trdEntry"));
				},
				function()
				{
					$(".trdName").removeClass("trdHovered");
				}
			);
			
			// Bind swap up/down buttons to swap data between calculators (for manual rearranging)
			$(entry + " .btnSwapUp, " + entry + " .btnSwapDown").each(function()
			{
				$(this).click(function()
				{
					var i = E.SwapIndex;
					var isUp = ($(this).hasClass("btnSwapUp")) ? true : false;
					
					// Do not allow swapping outside of range
					if (isUp && i === 0)
					{
						return;
					}
					if ( ! isUp === $(".trdEntry").length - 1) 
					{
						return;
					}
					
					var j = isUp ? (i-1) : (i+1);
					var calcA = $("#trdEntry_" + i);
					var calcB = $("#trdEntry_" + j);
					
					// Swap item icon
					var imgA = calcA.find(".trdIcon").attr("src");
					var imgB = calcB.find(".trdIcon").attr("src");
					calcA.find(".trdIcon").attr("src", imgB);
					calcB.find(".trdIcon").attr("src", imgA);
					
					// Swap text data from inputs
					var dataA = [];
					var dataB = [];
					var counterA = 0;
					var counterB = 0;
					calcA.find("input[type='text']").each(function()
					{
						dataA.push($(this).val());
					});
					calcB.find("input[type='text']").each(function()
					{
						dataB.push($(this).val());
					});
					calcA.find("input[type='text']").each(function()
					{
						$(this).val(dataB[counterA]).trigger("change");
						counterA++;
					});
					calcB.find("input[type='text']").each(function()
					{
						$(this).val(dataA[counterB]).trigger("change");
						counterB++;
					});
					// Swap rarity color code of the item name
					var rarityA = calcA.attr("data-rarity");
					var rarityB = calcB.attr("data-rarity");
					calcA.attr("data-rarity", rarityB);
					calcB.attr("data-rarity", rarityA);
					Q.setRarityClass(calcA.find(".trdName"), rarityB);
					Q.setRarityClass(calcB.find(".trdName"), rarityA);
					// Clear matched price styles
					E.clearMatched(calcA);
					E.clearMatched(calcB);
					calcA.find(".trdName").removeClass("trdHovered");
					calcB.find(".trdName").addClass("trdHovered");
					
					// Adjust swap index
					E.SwapIndex = isUp ? (E.SwapIndex-1) : (E.SwapIndex+1);
				});
			});
			
			// Bind name search box behavior
			(function(iEntry)
			{
				Q.bindItemSearch($(name), {
					aFillerText: null,
					aWantEnter: false,
					aResultsClass: "trdResultsContainer",
					aCallback: function(pItem)
					{
						// Change triggers the storage, input triggers the calculation
						iEntry.find(".trdItem").val(pItem.id).trigger("change");
						iEntry.find(".trdName").val(pItem.name).trigger("change");
						E.updateTradingDetails(iEntry);
						E.updateTradingPrices(iEntry, false);
					}}
				);
			})($(entry));
			$(name).change(function()
			{
				var query = $(this).val();
				var entryinner = $(this).closest(".trdEntry");
				if (query.length < 1)
				{
					E.clearCalculator(entryinner);
				}
			}).onEnterKey(function()
			{
				U.openExternalURL(U.getTradingSearchLink($(this).val()));
			});
		}
		
		// Set the first entry with initial text as an example
		entry = "#trdEntry_" + 0;
		$(entry + " .trdIcon").attr("src", "img/ui/question.png");
		$(entry + " .trdName").val("Kudzu");
		$(entry + " .trdBuy").val("4500.37.68");
		$(entry + " .trdSell").val("550037.68");
		$(entry + " .trdQuantity").val("1");
		$(entry).css("margin-bottom", "6px");
		
		// Set tooltip only for the first entry
		var tip = function(pBoxName, pWord, pInfo)
		{
			if (pInfo === undefined)
			{
				pInfo = "";
			}
			else
			{
				pInfo = ": " + pInfo;
			}
			$(entry + " .trd" + pBoxName).attr("title", "<dfn>" + D.getPhraseTitle(pWord) + "</dfn>" + pInfo);
		};
		tip("Name", "name");
		tip("Buy", "your buy");
		tip("Sell", "your sell");
		tip("Quantity", "quantity");
		tip("Cost", "cost", "Money needed to buy the items.");
		tip("Break", "breakpoint" , "Sell higher than this to make a profit.");
		tip("Tax", "tax", "Pay 5% fee of sell price to list, and deduct 10% tax of sell price when sold.");
		tip("Profit", "profit", "Gains after losses from buying and tax.");
		tip("Margin", "margin", "Revenue over cost and fee.");
		tip("Revenue", "revenue", "What you will receive at the trader.");
		tip("Link", "chatlink", "Paste this in game chat to see the item.");
		tip("Item", "ID", "API item number.");
		tip("NotifyBuyLow", "notify if current buy < this buy");
		tip("NotifyBuyHigh", "notify if this buy < current buy");
		tip("NotifySellLow", "notify if current sell < this sell");
		tip("NotifySellHigh", "notify if this sell < current sell");
		tip("CurrentBuy", "current buy", "Double click to flank price.");
		tip("CurrentSell", "current sell", "Double click to flank price.");
		I.qTip.init($(entry + " input"));
		
		// Initialize storage behavior of the input textboxes
		X.initializeTextlist(X.Textlists.TradingItem, $("#trdList .trdItem"), null, 16);
		X.initializeTextlist(X.Textlists.TradingName, $("#trdList .trdName"), null, 64);
		X.initializeTextlist(X.Textlists.TradingBuy, $("#trdList .trdBuy"), null, 16);
		X.initializeTextlist(X.Textlists.TradingSell, $("#trdList .trdSell"), null, 16);
		X.initializeTextlist(X.Textlists.TradingQuantity, $("#trdList .trdQuantity"), null, 16);
		X.initializeTextlist(X.Textlists.NotifyBuyLow, $("#trdList .trdNotifyBuyLow"), null, 16);
		X.initializeTextlist(X.Textlists.NotifyBuyHigh, $("#trdList .trdNotifyBuyHigh"), null, 16);
		X.initializeTextlist(X.Textlists.NotifySellLow, $("#trdList .trdNotifySellLow"), null, 16);
		X.initializeTextlist(X.Textlists.NotifySellHigh, $("#trdList .trdNotifySellHigh"), null, 16);
		
		X.initializeCheckboxlist(X.Checklists.TradingOverwrite, $("#trdList .trdOverwrite"), X.ChecklistJob.CheckAll, null, false);
		X.initializeCheckboxlist(X.Checklists.TradingNotify, $("#trdList .trdNotify"), X.ChecklistJob.CheckAll, null, false);
		
		// Trigger input textboxes to make the output textboxes update
		$("#trdList .trdSell").trigger("input");
		E.updateAllTradingDetails();
		
		// Bind toggle button to switch between accordion view or open list view of the calculators
		$("#trdToggle").click(function()
		{
			if ($("#trdEntry_0 .trdBuy").is(":visible"))
			{
				$(".trdAccordion").addClass("trdAccordionShut").removeClass("trdAccordionOpen");
				$(".trdPreview").removeClass("cssHidden");
			}
			else
			{
				$(".trdAccordion").removeClass("trdAccordionShut").addClass("trdAccordionOpen");
				$(".trdPreview").addClass("cssHidden");
			}
		});
		
		// Bind refresh button to re-download API data to refresh the calculators
		D.verifyNativeTTS();
		$("#trdRefresh, #trdRefreshMirror").click($.throttle(E.cREFRESH_LIMIT, function()
		{
			E.loopRefresh(true);
		}));
		$("#trdPause").click(function()
		{
			E.cancelLoopRefresh();
		});
		$("#trdMute").click(function()
		{
			D.stopSpeech();
		});
		// Button to print all saved calculator data to console as Comma Separated Values (CSV)
		$("#trdPrint").click(function()
		{
			I.clear();
			var length = X.Textlists.TradingItem.value.length;
			var str = "ItemID,Name,Buy,Sell,Quantity,BuyLow,BuyHigh,SellLow,SellHigh<br />";
			for (var i = 0; i < length; i++)
			{
				str += U.escapeHTML(
					X.Textlists.TradingItem.value[i] + "," +
					X.Textlists.TradingName.value[i] + "," +
					X.Textlists.TradingBuy.value[i] + "," +
					X.Textlists.TradingSell.value[i] + "," +
					X.Textlists.TradingQuantity.value[i] + "," +
					X.Textlists.NotifyBuyLow.value[i] + "," +
					X.Textlists.NotifyBuyHigh.value[i] + "," +
					X.Textlists.NotifySellLow.value[i] + "," +
					X.Textlists.NotifySellHigh.value[i])
				+ "<br />";
			}
			Z.createFile(str.replace(/<br \/>/g, "\r\n"), "tp.csv");
			I.print(str);
		});
	},
	
	/*
	 * Updates the respective exchanges using the input from top row.
	 */
	updateCoinTo: function(pWantAnimate)
	{
		var previousgem = 0, currentgem = 0;
		var previousmoney = 0, currentmoney = 0;
		var previousgeminverse = 0, currentgeminverse = 0;
		var previousmoneyinverse = 0, currentmoneyinverse = 0;
		var cointo = $("#trdExchange .trdCoinTo");
		var cointogem = $("#trdExchange .trdCoinToGem");
		var cointomoney = $("#trdExchange .trdCoinToMoney");
		var cointogeminverse = $("#trdExchange .trdCoinToGemInverse");
		var cointomoneyinverse = $("#trdExchange .trdCoinToMoneyInverse");
		
		var cointoamount = E.parseCoinString(cointo.val());
		if (cointoamount === 0 || cointo.val() === "")
		{
			cointogem.val("");
			cointomoney.val("");
			cointogeminverse.val("");
			cointomoneyinverse.val("");
		}
		else
		{
			// User's coin to gem
			E.getGemFromCoin(cointoamount, function(pGem)
			{
				previousgem = parseInt(cointogem.val());
				previousmoney = E.parseMoneyString(cointomoney.val());
				currentgem = pGem;
				currentmoney = Math.round(currentgem * E.Exchange.DOLLAR_PER_GEM);

				cointogem.val(currentgem);
				cointomoney.val(E.formatMoneyString(currentmoney));
				if (pWantAnimate === undefined || pWantAnimate)
				{
					E.animateValue(cointogem, previousgem, currentgem);
					E.animateValue(cointomoney, previousmoney, currentmoney);
				}
				
				if (currentgem === 0)
				{
					// Got here if value is too low be exchanged
					cointogem.val("0");
					cointomoney.val("0");
				}
			});
			
			// Gem to user's coin
			E.getGemFromCoinInverse(cointoamount, function(pGem)
			{
				previousgeminverse = parseInt(cointogeminverse.val());
				previousmoneyinverse = E.parseMoneyString(cointomoneyinverse.val());

				currentgeminverse = pGem;
				currentmoneyinverse = Math.round(currentgeminverse * E.Exchange.DOLLAR_PER_GEM);
				cointogeminverse.val(currentgeminverse);
				cointomoneyinverse.val(E.formatMoneyString(currentmoneyinverse));

				if (pWantAnimate === undefined || pWantAnimate)
				{
					E.animateValue(cointogeminverse, previousgeminverse, currentgeminverse);
					E.animateValue(cointomoneyinverse, previousmoneyinverse, currentmoneyinverse);
				}
			});
		}
	},
	updateGemTo: function(pWantAnimate)
	{
		var previouscoin = 0, currentcoin = 0;
		var previousmoney = 0, currentmoney = 0;
		var previouscoininverse = 0, currentcoininverse = 0;
		var gemto = $("#trdExchange .trdGemTo");
		var gemtocoin = $("#trdExchange .trdGemToCoin");
		var gemtomoney = $("#trdExchange .trdGemToMoney");
		var gemtocoininverse = $("#trdExchange .trdGemToCoinInverse");
		
		var gemtoamount = gemto.val();
		if (gemtoamount === 0 || gemto.val() === "")
		{
			gemtocoin.val("");
			gemtomoney.val("");
			gemtocoininverse.val("");
		}
		else
		{
			// User's gem to coin
			E.getCoinFromGem(gemtoamount, function(pCoin)
			{
				previouscoin = E.parseCoinString(gemtocoin.val());
				previousmoney = E.parseMoneyString(gemtomoney.val());
				currentcoin = pCoin;
				currentmoney = parseInt(gemtoamount * E.Exchange.DOLLAR_PER_GEM);

				gemtocoin.val(E.formatCoinString(currentcoin));
				gemtomoney.val(E.formatMoneyString(currentmoney));
				if (pWantAnimate === undefined || pWantAnimate)
				{
					E.animateValue(gemtocoin, previouscoin, currentcoin);
					E.animateValue(gemtomoney, previousmoney, currentmoney);
				}

				if (currentcoin === 0)
				{
					// Got here if value is too low be exchanged
					gemtocoin.val("0");
					gemtomoney.val("0");
				}
			});
			
			// Coin to user's gem
			E.getCoinFromGemInverse(gemtoamount, function(pCoin)
			{
				previouscoininverse = E.parseCoinString(gemtocoininverse.val());
				currentcoininverse = pCoin;
				gemtocoininverse.val(E.formatCoinString(currentcoininverse));

				if (pWantAnimate === undefined || pWantAnimate)
				{
					E.animateValue(gemtocoininverse, previouscoininverse, currentcoininverse);
				}
			});
		}
	},
	updateMoneyTo: function(pWantAnimate)
	{
		var previousgem = 0, currentgem = 0;
		var previouscoin = 0, currentcoin = 0;
		var moneyto = $("#trdExchange .trdMoneyTo");
		var moneytogem = $("#trdExchange .trdMoneyToGem");
		var moneytocoin = $("#trdExchange .trdMoneyToCoin");
		
		var moneytoamount = E.parseMoneyString(moneyto.val());
		var gems = moneytoamount * E.Exchange.GEM_PER_DOLLAR;
		if (moneytoamount === 0 || moneyto.val() === "")
		{
			moneytogem.val("");
			moneytocoin.val("");
		}
		else
		{
			E.getCoinFromGem(gems, function(pCoin)
			{
				previousgem = parseInt(moneytogem.val());
				previouscoin = E.parseCoinString(moneytocoin.val());
				currentgem = gems;
				currentcoin = pCoin;

				moneytogem.val(gems);
				moneytocoin.val(E.formatCoinString(currentcoin));
				if (pWantAnimate === undefined || pWantAnimate)
				{
					E.animateValue(moneytogem, previousgem, currentgem);
					E.animateValue(moneytocoin, previouscoin, currentcoin);
				}
				if (currentcoin === 0)
				{
					// Got here if value is too low be exchanged
					moneytogem.val("0");
					moneytocoin.val("0");
				}
			});
		}
	},
	updateNotifyCoinTo: function(pWantAnimate)
	{
		var previousgem = 0, currentgem = 0;
		var cointo = $("#trdExchange .trdNotifyCoinTo");
		var cointogem = $("#trdExchange .trdNotifyCoinToGem");
		
		var gemhighelm = $("#trdExchange .trdNotifyCoinToGemHigh");
		var gemhigh = E.parseGemString(gemhighelm.val());
		
		var cointoamount = E.parseCoinString(cointo.val());
		if (cointoamount === 0 || cointo.val() === "")
		{
			cointogem.val("");
		}
		else
		{
			// User's coin to gem
			E.getGemFromCoin(cointoamount, function(pGem)
			{
				previousgem = parseInt(cointogem.val());
				currentgem = pGem;

				cointogem.val(currentgem);
				if (pWantAnimate === undefined || pWantAnimate)
				{
					E.animateValue(cointogem, previousgem, currentgem);
				}
				
				if (currentgem === 0)
				{
					// Got here if value is too low be exchanged
					cointogem.val("0");
				}
				else if (currentgem >= gemhigh && gemhigh !== 0)
				{
					gemhighelm.addClass("trdMatched");
					D.speak(D.getPhraseTitle("buy gem high"));
				}
				else
				{
					gemhighelm.removeClass("trdMatched");
				}
			});
		}
	},
	updateNotifyGemTo: function(pWantAnimate)
	{
		var previouscoin = 0, currentcoin = 0;
		var gemto = $("#trdExchange .trdNotifyGemTo");
		var gemtocoin = $("#trdExchange .trdNotifyGemToCoin");
		
		var coinhighelm = $("#trdExchange .trdNotifyGemToCoinHigh");
		var coinhigh = E.parseCoinString(coinhighelm.val());
		
		var gemtoamount = gemto.val();
		if (gemtoamount === 0 || gemto.val() === "")
		{
			gemtocoin.val("");
		}
		else
		{
			// User's gem to coin
			E.getCoinFromGem(gemtoamount, function(pCoin)
			{
				previouscoin = E.parseCoinString(gemtocoin.val());
				currentcoin = pCoin;

				gemtocoin.val(E.formatCoinString(currentcoin));
				if (pWantAnimate === undefined || pWantAnimate)
				{
					E.animateValue(gemtocoin, previouscoin, currentcoin);
				}
				
				if (currentcoin === 0)
				{
					// Got here if value is too low be exchanged
					gemtocoin.val("0");
				}
				else if (currentcoin >= coinhigh && coinhigh !== 0)
				{
					coinhighelm.addClass("trdMatched");
					D.speak(D.getPhraseTitle("buy coin high"));
				}
				else
				{
					coinhighelm.removeClass("trdMatched");
				}
			});
		}
	},
	updateAllExchange: function()
	{
		E.updateCoinTo();
		E.updateGemTo();
		E.updateMoneyTo();
		
		E.updateNotifyCoinTo();
		E.updateNotifyGemTo();
	},
	
	/*
	 * Binds behavior of exchange input boxes.
	 */
	initializeExchange: function()
	{
		var cointo = $("#trdExchange .trdCoinTo");
		var gemto = $("#trdExchange .trdGemTo");
		var moneyto = $("#trdExchange .trdMoneyTo");
		var notifycointo = $("#trdExchange .trdNotifyCoinTo");
		var notifygemto = $("#trdExchange .trdNotifyGemTo");
		var notifycointogemhigh = $("#trdExchange .trdNotifyCoinToGemHigh");
		var notifygemtocoinhigh = $("#trdExchange .trdNotifyGemToCoinHigh");
		
		// Initial values as an example
		cointo.val("200..");
		gemto.val("4000");
		moneyto.val("50");
		
		var tip = function(pBoxName, pPhrase)
		{
			$("#trdExchange .trd" + pBoxName).attr("title", "<dfn>" + D.getPhraseTitle(pPhrase) + "</dfn>");
		};
		tip("CoinTo", "your coin");
		tip("GemTo", "your gem");
		tip("MoneyTo", "your dollar");
		tip("CoinToGem", "your coin to gem");
		tip("GemToCoin", "your gem to coin");
		tip("MoneyToGem", "your dollar to gem");
		tip("CoinToMoney", "your coin to dollar");
		tip("GemToMoney", "your gem to dollar");
		tip("MoneyToCoin", "your dollar to coin");
		tip("CoinToGemInverse", "gem to your coin");
		tip("GemToCoinInverse", "coin to your gem");
		tip("CoinToMoneyInverse", "dollar to your coin");
		
		tip("NotifyCoinTo", "your coin");
		tip("NotifyGemTo", "your gem");
		tip("NotifyCoinToGem", "your coin to current gem");
		tip("NotifyGemToCoin", "your gem to current coin");
		tip("NotifyCoinToGemHigh", "notify if current gem > this gem");
		tip("NotifyGemToCoinHigh", "notify if current coin > this coin");
		I.qTip.init($("#trdExchange input"));
		
		// Bind behavior
		I.bindInputSelect("#trdExchange input");
		
		cointo.on("input", $.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateCoinTo(false);
		})).onEnterKey($.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateCoinTo();
		}));
		
		gemto.on("input", $.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateGemTo(false);
		})).onEnterKey($.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateGemTo();
		}));
		
		moneyto.on("input", $.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateMoneyTo(false);
		})).onEnterKey($.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateMoneyTo();
		}));
		
		notifycointo.on("input", $.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateNotifyCoinTo(false);
		})).onEnterKey($.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateNotifyCoinTo();
		}));
		
		notifygemto.on("input", $.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateNotifyGemTo(false);
		})).onEnterKey($.throttle(E.cEXCHANGE_LIMIT, function()
		{
			E.updateNotifyGemTo();
		}));
		
		// Initialize storage behavior of inputs
		X.initializeTextlist(X.Textlists.ExchangeUnit,
			$([cointo, gemto, moneyto, notifycointo, notifygemto, notifycointogemhigh, notifygemtocoinhigh]), null, 16);
		
		// Finally, loop the refresh function
		$(".trdProgress").data("width", $(".trdProgress").width());
		E.isTradingCalculatorsInitialized = true;
		E.loopRefresh();
	},
	
	/*
	 * Cancels current loop refresh and progress bar.
	 */
	cancelLoopRefresh: function()
	{
		window.clearTimeout(E.ProgressTimeout);
		window.clearTimeout(E.RefreshTimeout);
		$(".trdProgress").width($(".trdProgress").data("width"));
	},
	
	/*
	 * Decreases the width of the progress line every second for the duration
	 * of the refresh wait time.
	 */
	animateProgress: function()
	{
		var progress = $(".trdProgress");
		if (E.ProgressTick < E.ProgressWait)
		{
			progress.width(progress.width() - (progress.data("width") / E.ProgressWait));
		}
		E.ProgressTick -= 1;
		
		E.ProgressTimeout = setTimeout(E.animateProgress, T.cMSECONDS_IN_SECOND);
	},
	
	/*
	 * Calls the refresh calculator function on regular interval.
	 */
	loopRefresh: function(pForce)
	{
		E.cancelLoopRefresh();
		
		if (pForce === true || O.Options.bol_refreshPrices)
		{
			E.updateAllTradingPrices();
			E.updateAllExchange();
			
			if (O.Options.bol_refreshPrices)
			{
				var wait = O.Options.int_secTradingRefresh * T.cMSECONDS_IN_SECOND;
				// Animate progress bar with same duration as refresh wait time
				E.ProgressTick = O.Options.int_secTradingRefresh;
				E.ProgressWait = O.Options.int_secTradingRefresh;
				E.animateProgress();
				// Repeat this function
				E.RefreshTimeout = setTimeout(E.loopRefresh, wait);
			}
		}
	},
	
	/*
	 * Binds behavior of the generic calculator.
	 */
	initializeCalculator: function()
	{
		// Calculation behavior
		$("#trdCalculation .trdCalculator").onEnterKey(function()
		{
			E.doCalculation($(this));
		}).click(function()
		{
			$(this).select();
		});
		// Assume expression input box is left sibling of the submit button
		$("#trdCalculation .trdCalcSubmit").click(function()
		{
			E.doCalculation($(this).prev());
		});
		
		// History behavior
		for (var i in E.CalculatorHistoryArray)
		{
			E.CalculatorHistoryArray[i] = "";
		}
		
		$("#trdCalculation .trdCalculator").onArrowUpKey(function()
		{
			if (E.CalcHistoryIndex === 0)
			{
				var expression = U.stripToCalculation($(this).val());
				if (E.CalculatorHistoryArray[0] !== $(this).val().toString())
				{
					E.CalculatorHistoryArray.pop();
					E.CalculatorHistoryArray.unshift(expression);
				}
			}
			if (E.CalcHistoryIndex + 1 < E.CalculatorHistoryArray.length)
			{
				E.CalcHistoryIndex++;
				$(this).val(E.CalculatorHistoryArray[E.CalcHistoryIndex]);
			}
		});
		$("#trdCalculation .trdCalculator").onArrowDownKey(function()
		{
			if (E.CalcHistoryIndex - 1 >= 0)
			{
				E.CalcHistoryIndex--;
				$(this).val(E.CalculatorHistoryArray[E.CalcHistoryIndex]);
			}
		});
	},
	
	/*
	 * Performs the expression on the arithmetic calculator.
	 * This function uses eval(), so must sanitize user input.
	 * @param jqobject pCalculator input box containing user's expression.
	 */
	doCalculation: function(pCalculator)
	{
		var expression = U.stripToCalculation(pCalculator.val());
		var result = "";
		try
		{
			result = eval(expression);
		}
		catch (e) {}
		
		pCalculator.val(parseFloat(result)).select();
		if (result.toString().length > 0)
		{
			E.CalculatorHistoryArray.pop();
			E.CalculatorHistoryArray.unshift(expression);
			E.CalcHistoryIndex = 0;
		}
	}
};
D = {
/* =============================================================================
 * @@Dictionary to translate readable/listenable strings
 * ========================================================================== */

	/*
	 * Words to be used alone or to form a phrase.
	 * HTML characters like "'" (single quote) must be escaped because these
	 * strings are used directly.
	 */
	Dictionary:
	{
		s_TEMPLATE: {de: "", es: "", fr: "",
			cs: "", it: "", pl: "", pt: "", ru: "", zh: ""},
		
		// Time
		s_y: {de: "j", es: "a", fr: "a", cs: "r", it: "a", pl: "r", pt: "a", ru: "г", zh: "年"},
		s_mo: {de: "mo", es: "me", fr: "mo", cs: "mě", it: "me", pl: "mi", pt: "mê", ru: "ме", zh: "月"},
		s_w: {de: "w", es: "s", fr: "s", cs: "t", it: "s", pl: "t", pt: "s", ru: "н", zh: "周"},
		s_d: {de: "t", es: "d", fr: "j", cs: "d", it: "g", pl: "d", pt: "d", ru: "д", zh: "日"},
		s_h: {de: "h", es: "h", fr: "h", cs: "h", it: "o", pl: "g", pt: "h", ru: "ч", zh: "时"},
		s_m: {de: "m", es: "m", fr: "m", cs: "m", it: "m", pl: "m", pt: "m", ru: "м", zh: "分"},
		s_s: {de: "s", es: "s", fr: "s", cs: "s", it: "s", pl: "s", pt: "s", ru: "с", zh: "秒"},
		s_hour: {de: "stunde", es: "hora", fr: "heure", cs: "hodina", it: "ora", pl: "godzinę", pt: "hora", ru: "час", zh: "时"},
		s_minute: {de: "minute", es: "minuto", fr: "minute", cs: "minuta", it: "minuto", pl: "minuta", pt: "minuto", ru: "минута", zh: "分"},
		s_second: {de: "sekunde", es: "segundo", fr: "seconde", cs: "sekunda", it: "secondo", pl: "sekund", pt: "segundo", ru: "секунду", zh: "秒"},
		s_hours: {de: "stunden", es: "horas", fr: "heures", cs: "hodin", it: "secondi", pl: "godzin", pt: "horas", ru: "часов", zh: "时"},
		s_minutes: {de: "minuten", es: "minutos", fr: "minutes", cs: "minut", it: "minuti", pl: "minut", pt: "minutos", ru: "минут", zh: "分"},
		s_seconds: {de: "sekunden", es: "segundos", fr: "secondes", cs: "sekund", it: "ore", pl: "sekund", pt: "segundos", ru: "секунд", zh: "秒"},
		s_half_an_hour: {de: "eine halbe stunde", es: "media hora", fr: "demi-heure",
			cs: "půl hodiny", it: "mezz&apos;ora", pl: "pół godziny", pt: "meia hora", ru: "полчаса", zh: "半小时"},
		s_cooldown: {de: "abkühl", es: "recuperación", fr: "recharge",
			cs: "dobíjení", it: "raffreddamento", pl: "ochładzania", pt: "resfriamento", ru: "перезарядка", zh: "冷却"},
		s_remaining: {de: "verbleibend", es: "restante", fr: "restant",
			cs: "zbývající", it: "rimanente", pl: "pozostały", pt: "restante", ru: "оставшиеся", zh: "剩馀"},
		s_day: {de: "tag", es: "día", fr: "jour",
			cs: "den", it: "giorno", pl: "dzień", pt: "dia", ru: "день", zh: "白天"},
		s_night: {de: "nacht", es: "noche", fr: "nuit",
			cs: "noc", it: "notturne", pl: "nocna", pt: "noturno", ru: "ночь", zh: "夜间"},
		s_dawn: {de: "tagesanbruch", es: "amanecer", fr: "aube",
			cs: "svítání", it: "alba", pl: "świt", pt: "alvorecer", ru: "рассвет", zh: "黎明"},
		s_dusk: {de: "dämmerung", es: "crepúsculo", fr: "crépuscule",
			cs: "soumrak", it: "crepuscolo", pl: "zmierzch", pt: "crepúsculo", ru: "сумрак", zh: "黄昏"},
		s_approaching: {de: "nähert", es: "acerca", fr: "approchant",
			cs: "blíží", it: "avvicina", pl: "zbliża", pt: "aproximava", ru: "приближается", zh: "来临"},
		s_when: {de: "wann", es: "cuando", fr: "quand",
			cs: "když", it: "quando", pl: "gdy", pt: "quando", ru: "когда", zh: "什么时候"},
		s_now: {de: "jetzt", es: "ahora", fr: "présent",
			cs: "nyní", it: "adesso", pl: "teraz", pt: "agora", ru: "теперь", zh: "现在"},
		
		// Nouns
		s_directory: {de: "verzeichnis", es: "directorio", fr: "répertoire",
			cs: "adresář", it: "directory", pl: "katalog", pt: "diretório", ru: "каталог", zh: "目录"},
		s_dashboard: {de: "dashboard", es: "panel", fr: "tableau de bord",
			cs: "řídicí panel", it: "dashboard", pl: "pulpit nawigacyjny", pt: "painel", ru: "панель мониторинга", zh: "仪表板"},
		s_leaderboard: {de: "bestenliste", es: "marcador", fr: "classement",
			cs: "žebříček", it: "classifica", pl: "liderzy sprzedaży", pt: "placar de líderes", ru: "список лидеров", zh: "排行榜"},
		s_server: {de: "server", es: "servidor", fr: "serveur",
			cs: "server", it: "server", pl: "serwer", pt: "servidor", ru: "сервер", zh: "服务器"},
		s_account: {de: "account", es: "cuenta", fr: "compte",
			cs: "účet", it: "conto", pl: "konto", pt: "conta", ru: "счёт", zh: "帐户"},
		s_key: {de: "schlüssel", es: "tecla", fr: "clé",
			cs: "klávesa", it: "chiave", pl: "klawisz", pt: "chave", ru: "ключ", zh: "索引键"},
		s_history: {de: "verlauf", es: "historial", fr: "historique",
			cs: "historie", it: "cronologia", pl: "historii", pt: "histórico", ru: "истории", zh: "历史"},
		s_info: {de: "info", es: "información", fr: "info",
			cs: "informace", it: "info", pl: "informacje", pt: "informações", ru: "информация", zh: "资讯"},
		s_item: {de: "gegenstand", es: "objeto", fr: "objet",
			cs: "objekt", it: "oggetto", pl: "obiekt", pt: "objeto", ru: " объект", zh: "物体"},
		s_items: {de: "gegenstände", es: "objetos", fr: "objets",
			cs: "objektů", it: "oggetti", pl: "obiekty", pt: "objetos", ru: "объекты", zh: "物体"},
		s_collectible: {de: "sammlerstücke", es: "coleccionable", fr: "collectable",
			cs: "sběratelský", it: "collezione", pl: "kolekcjonerski", pt: "colecionável", ru: "коллекционирования", zh: "收藏"},
		s_tier: {de: "rang", es: "rango", fr: "niveau",
			cs: "pořadí", it: "rango", pl: "ranga", pt: "classe", ru: "ранг", zh: "级"},
		s_clock: {de: "uhr", es: "reloj", fr: "horloge",
			cs: "hodiny", it: "orologio", pl: "zegar", pt: "relógio", ru: "часы", zh: "时钟"},
		s_timers: {de: "zeitgeber", es: "temporizadores", fr: "minuteurs",
			cs: "časovače", it: "timer", pl: "czasomierzy", pt: "temporizadores", ru: "таймеров", zh: "计时器"},
		s_timeline: {de: "zeitachse", es: "escala de tiempo", fr: "chronologie",
			cs: "časová osa", it: "sequenza temporale", pl: "oś czasu", pt: "linha do tempo", ru: "временная шкала", zh: "时间线"},
		s_countdowns: {de: "countdown", es: "cuenta regresiva", fr: "compte à rebours",
			cs: "odpočítávání", it: "conto alla rovescia", pl: "odliczanie", pt: "contagem regressiva", ru: "обратный отсчет", zh: "倒计时"},
		s_announcements: {de: "ankündigungen", es: "anuncios", fr: "annonces",
			cs: "oznámení", it: "annunci", pl: "ogłoszenia", pt: "anúncios", ru: "объявления", zh: "公告"},
		s_console: {de: "konsole", es: "consola", fr: "console",
			cs: "konzola", it: "console", pl: "konsola", pt: "console", ru: "консоль", zh: "控制台"},
		s_panel: {de: "panel", es: "panel", fr: "panneau",
			cs: "panel", it: "pannello", pl: "panel", pt: "painel", ru: "панель", zh: "面板"},
		s_tools: {de: "extras", es: "herramientas", fr: "outils",
			cs: "nástroje", it: "strumenti", pl: "narzędzia", pt: "ferramentas", ru: "инструменты", zh: "工具"},
		s_guides: {de: "handbuch", es: "guías", fr: "guides",
			cs: "vodítka", it: "guide", pl: "prowadnice", pt: "guias", ru: "руководства", zh: "指南"},
		s_links: {de: "links", es: "vínculos", fr: "liens",
			cs: "odkazy", it: "collegamenti", pl: "linki", pt: "vínculos", ru: "ссылки", zh: "链接"},
		s_help: {de: "hilfe", es: "ayuda", fr: "assistance",
			cs: "pomoci", it: "guida", pl: "pomoc", pt: "ajuda", ru: "помощь", zh: "辅助"},
		s_options: {de: "optionen", es: "opciónes", fr: "options",
			cs: "možnosti", it: "opzioni", pl: "opcje", pt: "opções", ru: "параметры", zh: "选项"},
		s_arrival: {de: "ankunft", es: "llegada", fr: "arrivée",
			cs: "příjezd", it: "arrivo", pl: "przyjazd", pt: "chegada", ru: "прибытие", zh: "到来"},
		s_world: {de: "welt", es: "mundo", fr: "monde",
			cs: "svět", it: "mondo", pl: "świat", pt: "mundo", ru: "босс", zh: "世界"},
		s_boss: {de: "boss", es: "jefe", fr: "chef",
			cs: "boss", it: "boss", pl: "szef", pt: "chefe", ru: "босс", zh: "头目"},
		s_event: {de: "event", es: "evento", fr: "événement",
			cs: "událost", it: "evento", pl: "wydarzenie", pt: "evento", ru: "собы́тие", zh: "事件"},
		s_section: {de: "abschnitt", es: "sección", fr: "section",
			cs: "oddíl", it: "sezione", pl: "sekcja", pt: "seção", ru: "раздел", zh: "节"},
		s_map: {de: "karte", es: "mapa", fr: "carte",
			cs: "mapa", it: "mappa", pl: "mapa", pt: "mapa", ru: "ка́рта", zh: "地图"},
		s_terrain: {de: "terrain", es: "terreno", fr: "terrain",
			cs: "terén", it: "terreno", pl: "teren", pt: "terreno", ru: "местность", zh: "地形"},
		s_center: {de: "zentrum", es: "centro", fr: "centre",
			cs: "střed", it: "centro", pl: "środek", pt: "centro", ru: "центр", zh: "中心"},
		s_completion: {de: "abschluss", es: "finalización", fr: "progression",
			cs: "dokončení", it: "completamento", pl: "ukończenie", pt: "progressão", ru: "завершение", zh: "完成"},
		s_route: {de: "route", es: "ruta", fr: "route",
			cs: "trasa", it: "percorso", pl: "trasa", pt: "rota", ru: "маршрут", zh: "路线"},
		s_pins: {de: "stecknadel", es: "chincheta", fr: "repère",
			cs: "špendlík", it: "segnaposto", pl: "pinezka", pt: "marcador", ru: "маркер", zh: "大头针"},
		s_path: {de: "pfad", es: "trazado", fr: "tracé",
			cs: "cesta", it: "tracciato", pl: "ścieżka", pt: "demarcador", ru: "контур", zh: "路径"},
		s_range: {de: "reichweite", es: "alcance", fr: "portée",
			cs: "dosah", it: "portata", pl: "zasięg", pt: "alcance", ru: "дальность", zh: "射程"},
		s_color: {de: "farbe", es: "color", fr: "couleur",
			cs: "barva", it: "colore", pl: "kolor", pt: "cor", ru: "цвет", zh: "色"},
		s_opacity: {de: "deckkraft", es: "opacidad", fr: "opacité",
			cs: "neprůhlednost", it: "opacità", pl: "nieprzezroczystość", pt: "opacidade", ru: "прозрачность", zh: "不透明度"},
		s_comment: {de: "kommentar", es: "comentario", fr: "commentaire",
			cs: "komentář", it: "commento", pl: "komentarz", pt: "comentário", ru: "примечание", zh: "注释"},
		s_compass: {de: "zirkel", es: "compás", fr: "compas",
			cs: "kružítko", it: "compasso", pl: "cyrkiel", pt: "compasso", ru: "циркуль", zh: "圆规"},
		s_slot: {de: "steckplatz", es: "ranura", fr: "emplacement",
			cs: "slot", it: "slot", pl: "gniazdo", pt: "slot", ru: "слот", zh: "插槽"},
		s_resource: {de: "ressourcen", es: "recursos", fr: "ressources",
			cs: "zdrojů", it: "risorse", pl: "zasobów", pt: "recursos", ru: "ресурсные", zh: "资源"},
		s_nodes: {de: "knoten", es: "nodos", fr: "zones",
			cs: "uzly", it: "nodi", pl: "węzły", pt: "nós", ru: "узлы", zh: "节点"},
		s_jumping: {de: "sprung", es: "salto", fr: "saut",
			cs: "skákání", it: "saltando", pl: "skoki", pt: "pulando", ru: "переход", zh: "跳跳"},
		s_puzzles: {de: "rätsel", es: "prueba", fr: "puzzle",
			cs: "hlavolam", it: "rompicapo", pl: "zagadki", pt: "desafio", ru: "пазлы", zh: "乐"},
		s_bookmarks: {de: "zeichen", es: "marcadores", fr: "signets",
			cs: "záložky", it: "segnalibri", pl: "zakładki", pt: "favoritos", ru: "закладки", zh: "书签"},
		s_lock: {de: "sperre", es: "bloqueo", fr: "verrou",
			cs: "zámek", it: "blocco", pl: "zablokuj", pt: "bloqueio", ru: "блокировка", zh: "锁定"},
		s_checklist: {de: "prüfliste", es: "lista de comprobación", fr: "liste de contrôle",
			cs: "kontrolní seznam", it: "elenco di controllo", pl: "lista kontrolna", pt: "lista de verificação", ru: "контрольный список", zh: "检查清单"},
		s_notepad: {de: "notizblock", es: "bloc de notas", fr: "blocnotes",
			cs: "poznámkový blok", it: "blocco note", pl: "notatnik", pt: "bloco de notas", ru: "блокнот", zh: "记事本"},
		s_subscription: {de: "abonnement", es: "suscripción", fr: "abonnement",
			cs: "předplatné", it: "sottoscrizione", pl: "abonament", pt: "assinatura", ru: "подписка", zh: "订阅"},
		s_alarm: {de: "alarm", es: "alarma", fr: "alarme",
			cs: "alarmu", it: "allarme", pl: "alarmu", pt: "alarme", ru: "будильника", zh: "闹钟"},
		s_mode: {de: "modus", es: "modo", fr: "mode",
			cs: "režim", it: "modalità", pl: "tryb", pt: "modo", ru: "режим", zh: "方式"},
		s_chatlink: {de: "chatlink", es: "vínculo chat", fr: "lien chat",
			cs: "chat odkaz", it: "collegamento chat", pl: "czat łącze", pt: "link bate-papo", ru: "чат связь", zh: "连结聊天"},
		s_stopwatch: {de: "stoppuhr", es: "cronómetro", fr: "chronomètre",
			cs: "stopky", it: "cronografo", pl: "stoper", pt: "cronômetro", ru: "секундомер", zh: "码表"},
		s_guild: {de: "gilden", es: "clan", fr: "guilde",
			cs: "cech", it: "clan", pl: "klan", pt: "clãs", ru: "гильдии", zh: "公会"},
		s_guilds: {de: "gilden", es: "clanes", fr: "guildes",
			cs: "cechy", it: "clan", pl: "klany", pt: "clãs", ru: "гильдий", zh: "战队"},
		s_missions: {de: "missionen", es: "misiónes", fr: "missions",
			cs: "mise", it: "missioni", pl: "misje", pt: "missões", ru: "миссии", zh: "任务"},
		s_pact: {de: "pakt", es: "pacto", fr: "pacte",
			cs: "pakt", it: "patto", pl: "pakt", pt: "pacto", ru: "пакт", zh: "契约团"},
		
		// Verbs
		s_is: {de: "ist", es: "es", fr: "est",
			cs: "je", it: "è", pl: "jest", pt: "é", ru: "является", zh: "是"},
		s_subscribe: {de: "abonnieren", es: "subscribir", fr: "abonner",
			cs: "předplatit si", it: "sottoscrivere", pl: "abonować", pt: "assinar", ru: "подписаться", zh: "订阅"},
		s_unsubscribe: {de: "abonnement kündigen", es: "cancelar suscripción", fr: "se désabonner",
			cs: "přestat odebírat", it: "annulla sottoscrizione", pl: "anulować subskrypcję", pt: "cancelar assinatura", ru: "отменить подписку", zh: "取消订阅"},
		s_pause: {de: "anhalten", es: "pausar", fr: "suspendre",
			cs: "pozastavit", it: "sospendere", pl: "wstrzymaj", pt: "pausar", ru: "приостановить", zh: "暂停"},
		s_resume: {de: "fortsetzen", es: "reanudar", fr: "reprendre",
			cs: "pokračovat", it: "riprendere", pl: "wznawiać", pt: "retomar", ru: "продолжить", zh: "继续"},
		s_will_start: {de: "wird starten", es: "se iniciará", fr: "débutera",
			cs: "začne", it: "inizierà", pl: "rozpocznie się", pt: "começará", ru: "начнется", zh: "开始"},
		s_click: {de: "klicken", es: "clic", fr: "cliquer",
			cs: "kliknout", it: "clic", pl: "klikać", pt: "clicar", ru: "щелкнуть", zh: "单击"},
		s_double: {de: "doppel", es: "doble", fr: "double",
			cs: "dvojité", it: "doppio", pl: "dwukrotnie", pt: "duplo", ru: "двойной", zh: "双"},
		s_drag: {de: "ziehen", es: "arrastrar", fr: "glisser",
			cs: "přetáhnout", it: "trascinare", pl: "przeciągnąć", pt: "arrastar", ru: "перетащить", zh: "拖动"},
		s_separate: {de: "trennen", es: "separar", fr: "séparer",
			cs: "oddělit", it: "separare", pl: "oddzielić", pt: "separar", ru: "разделять", zh: "分开"},
		s_view: {de: "anzeigen", es: "ver", fr: "afficher",
			cs: "zobrazit", it: "visualizzare", pl: "wyświetlać", pt: "exibir", ru: "представление", zh: "检视"},
		s_load: {de: "laden", es: "cargar", fr: "charger",
			cs: "načíst", it: "caricare", pl: "załaduj", pt: "carregar", ru: "загрузить", zh: "载入"},
		s_save: {de: "speichern", es: "guardar", fr: "enregistrer",
			cs: "uložit", it: "salvare", pl: "zapisać", pt: "salvar", ru: "сохранить", zh: "储存"},
		s_import: {de: "importieren", es: "importar", fr: "importer",
			cs: "importovat", it: "importować", pl: "", pt: "importar", ru: "импортировать", zh: "导入"},
		s_export: {de: "exportieren", es: "exportar", fr: "exporter",
			cs: "exportovat", it: "esportare", pl: "eksportować", pt: "exportar", ru: "экспортировать", zh: "导出"},
		s_select: {de: "markieren", es: "seleccionar", fr: "sélectionner",
			cs: "vybrat", it: "selezionare", pl: "zaznaczyć", pt: "selecionar", ru: "выделить", zh: "选择"},
		s_use: {de: "benutzen", es: "usar", fr: "utiliser",
			cs: "použít", it: "usare", pl: "używać", pt: "usar", ru: "использовать", zh: "用"},
		s_cancel: {de: "abbrechen", es: "cancelar", fr: "annuler",
			cs: "zrušit", it: "annullare", pl: "anulować", pt: "cancelar", ru: "отменить", zh: "取消"},
		s_add: {de: "hinzufügen", es: "añadir", fr: "ajouter",
			cs: "přidat", it: "aggiungere", pl: "dodać", pt: "adicionar", ru: "добавлять", zh: "加"},
		s_delete: {de: "löschen", es: "eliminar", fr: "supprimer",
			cs: "odstranit", it: "eliminare", pl: "usunąć", pt: "excluir", ru: "удалять", zh: "删除"},
		s_clear: {de: "löschen", es: "borrar", fr: "effacer",
			cs: "vymazat", it: "cancella", pl: "wyczyść", pt: "limpar", ru: "очистить", zh: "清除"},
		s_trim: {de: "trimmen", es: "recortar", fr: "découper",
			cs: "stříhat", it: "tagliare", pl: "odetnij", pt: "cortar", ru: "обрезать", zh: "剪裁"},
		s_toggle: {de: "umschalten", es: "alternar", fr: "basculer",
			cs: "přepnout", it: "alterna", pl: "przełączanie", pt: "alternar", ru: "переключить", zh: "切换"},
		s_condense: {de: "verkleinern", es: "condensar", fr: "condenser",
			cs: "zúžit", it: "riduci", pl: "zmniejsz", pt: "condensar", ru: "сжать", zh: "紧缩"},
		s_enable: {de: "aktivieren", es: "habilitar", fr: "activer",
			cs: "povolit", it: "abilitare", pl: "włączyć", pt: "habilitar", ru: "разрешить", zh: "启用"},
		s_disable: {de: "deaktivieren", es: "deshabilitar", fr: "désactiver",
			cs: "zakázat", it: "disabilitare", pl: "wyłączyć", pt: "desabilitar", ru: "отключить", zh: "禁用"},
		s_expand: {de: "erweiter", es: "expandir", fr: "développer",
			cs: "rozbalit", it: "espandere", pl: "rozwinąć", pt: "expandir", ru: "развернуть", zh: "展开"},
		s_collapse: {de: "verkleiner", es: "contraer", fr: "réduire",
			cs: "sbalit", it: "comprimere", pl: "zwinąć", pt: "recolher", ru: "свернуть", zh: "摺叠"},
		s_show: {de: "anzeigen", es: "mostrar", fr: "afficher",
			cs: "zobrazit", it: "mostra", pl: "pokaż", pt: "mostrar", ru: "показать", zh: "显示"},
		s_hide: {de: "ausblenden", es: "ocultar", fr: "masquer",
			cs: "skrýt", it: "nascondi", pl: "ukryj", pt: "ocultar", ru: "скрыть", zh: "隐藏"},
		s_draw: {de: "zeichnen", es: "dibujar", fr: "dessiner",
			cs: "kreslit", it: "disegnare", pl: "rysować", pt: "desenhar", ru: "рисова́ть", zh: "画"},
		s_undo: {de: "rückgängig", es: "deshacer", fr: "annuler",
			cs: "zpět", it: "annullare", pl: "cofnąć", pt: "desfazer", ru: "отменить", zh: "复原"},
		s_optimize: {de: "optimieren", es: "optimizar", fr: "optimiser",
			cs: "optimalizovat", it: "ottimizzare", pl: "optymalizować", pt: "otimizar", ru: "оптимизировать", zh: "最佳化"},
		s_search: {de: "suchen", es: "buscar", fr: "rechercher",
			cs: "vyhledat", it: "cerca", pl: "wyszukaj", pt: "pesquisar", ru: "поиск", zh: "搜寻"},
		s_get: {de: "erhalten", es: "conseguir", fr: "obtenir",
			cs: "dostat", it: "ottenere", pl: "dostawać", pt: "obter", ru: "достава́ть", zh: "获得"},
		s_update: {de: "aktualisieren", es: "actualizar", fr: "mettre à jour",
			cs: "aktualizovat", it: "aggiornare", pl: "aktualizować", pt: "atualizar", ru: "обновить", zh: "更新"},
		s_convert: {de: "konvertieren", es: "convertir", fr: "convertir",
			cs: "konvertovat", it: "convertire", pl: "converter", pt: "", ru: "конвертировать", zh: "兑换"},
		s_print: {de: "ausgeben", es: "imprimir", fr: "imprimer",
			cs: "tisk", it: "stampa", pl: "drukuj", pt: "imprimir", ru: "печать", zh: "打印"},
		
		// Adjectives, Adverbs, Participles
		s_yes: {de: "ja", es: "sí", fr: "oui",
			cs: "ano", it: "sì", pl: "tak", pt: "sim", ru: "да", zh: "是"},
		s_no: {de: "kein", es: "no", fr: "pas de",
			cs: "žádný", it: "non", pl: "żaden", pt: "nada de", ru: "нет", zh: "没有"},
		s_not: {de: "nicht", es: "no", fr: "ne",
			cs: "ne", it: "non", pl: "nie", pt: "não", ru: "не", zh: "不"},
		s_all: {de: "alle", es: "todos", fr: "tous",
			cs: "všechny", it: "tutti", pl: "wszystkie", pt: "todo", ru: "все", zh: "所有"},
		s_only: {de: "nur", es: "solamente", fr: "seulement",
			cs: "pouze", it: "solo", pl: "tylko", pt: "só", ru: "только", zh: "只要"},
		s_ago: {de: "vor", es: "hace", fr: "il ya",
			cs: "před", it: "fa", pl: "temu", pt: "há", ru: "назад", zh: "前"},
		s_also: {de: "auch", es: "también", fr: "aussi",
			cs: "také", it: "anche", pl: "też", pt: "também", ru: "то́же", zh: "也"},
		s_checked: {de: "abgehakt", es: "visto", fr: "coché",
			cs: "odškrtnout", it: "controllato", pl: "zakończony", pt: "marcado", ru: "включен", zh: "勾掉"},
		s_new: {de: "neu", es: "nuevo", fr: "nouveau",
			cs: "nový", it: "nuovo", pl: "nowy", pt: "novo", ru: "новый", zh: "新"},
		s_current: {de: "aktuelle", es: "actual", fr: "actuel",
			cs: "současný", it: "corrente", pl: "bieżący", pt: "corrente", ru: "текущий", zh: "活期"},
		s_expired: {de: "abgelaufen", es: "expirado", fr: "expiré",
			cs: "vypršel", it: "scaduto", pl: "wygasłe", pt: "expirado", ru: "просрочен", zh: "已过期"},
		s_daily: {de: "täglich", es: "diaria", fr: "quotidien",
			cs: "denní", it: "giornaliero", pl: "dzienny", pt: "diário", ru: "ежедневно", zh: "每天"},
		s_dailies: {de: "täglichen", es: "diarios", fr: "quotidiens",
			cs: "deníky", it: "quotidiani", pl: "dzienniki", pt: "diários", ru: "ежедневных", zh: "每天成就"},
		s_achievements: {de: "erfolge", es: "logros", fr: "succès",
			cs: "výsledky", it: "obiettivi", pl: "osiągnięcia", pt: "conquistas", ru: "достижения", zh: "成就"},
		s_personal: {de: "persönlicher", es: "personal", fr: "personnel",
			cs: "osobní", it: "personale", pl: "osobisty", pt: "pessoal", ru: "персональный", zh: "私人"},
		s_previous: {de: "vorhergehend", es: "previo", fr: "préalable",
			cs: "předchozí", it: "previo", pl: "poprzedni", pt: "prévio", ru: "предыдущий", zh: "以前的"},
		s_next: {de: "nächste", es: "siguiente", fr: "prochain",
			cs: "příští", it: "seguente", pl: "następny", pt: "próximo", ru: "следующий", zh: "下一"},
		s_off: {de: "aus", es: "desactivado", fr: "désactivé",
			cs: "vypnuto", it: "disattivato", pl: "wyłączany", pt: "desativado", ru: "выключено", zh: "关"},
		s_offline: {de: "offline", es: "sin conexión", fr: "hors connexion",
			cs: "offline", it: "offline", pl: "offline", pt: "", ru: "автономный", zh: "脱机"},
		s_predicted: {de: "vorhergesagt", es: "previsto", fr: "prédit",
			cs: "předpovídal", it: "previsto", pl: "przewiduje", pt: "predito", ru: "предсказанный", zh: "预测"},
		s_subscribed: {de: "abonniert", es: "suscrito", fr: "souscrit",
			cs: "odebírané", it: "sottoscritti", pl: "subskrypcji", pt: "assinado", ru: "подписан", zh: "订阅"},
		s_then: {de: "dann", es: "luego", fr: "puis",
			cs: "pak", it: "poi", pl: "potem", pt: "então", ru: "затем", zh: "接着"},
		s_found: {de: "gefunden", es: "encontró", fr: "trouvé",
			cs: "zjištěno", it: "trovato", pl: "stwierdzono", pt: "encontrado", ru: "найден", zh: "发现了"},
		s_loading: {de: "laden", es: "cargando", fr: "chargement",
			cs: "načítání", it: "caricamento", pl: "ładowanie", pt: "carregando", ru: "загрузка", zh: "正在载入"},
		s_done: {de: "erledigt", es: "hecho", fr: "terminé",
			cs: "hotovo", it: "fatto", pl: "gotowe", pt: "concluído", ru: "сделанный", zh: "完成了"},
		s_automatic: {de: "automatisch", es: "automático", fr: "automatique",
			cs: "automatický", it: "automatico", pl: "automatyczny", pt: "automático", ru: "автоматический", zh: "自动的"},
		s_custom: {de: "benutzerdefinierte", es: "personalizado", fr: "personnalisée",
			cs: "vlastní", it: "personalizzata", pl: "niestandardowy", pt: "personalizado", ru: "настраиваемая", zh: "自定义"},
		
		// Prepositions and Conjunctions
		s_and: {de: "und", es: "y", fr: "et",
			cs: "a", it: "e", pl: "i", pt: "e", ru: "и", zh: "和"},
		s_if: {de: "wenn", es: "si", fr: "si",
			cs: "jestliže", it: "se", pl: "jeśli", pt: "se", ru: "если", zh: "如果"},
		s_at: {de: "um", es: "a", fr: "à",
			cs: "v", it: "a", pl: "o", pt: "a", ru: "в", zh: "在"},
		s_by: {de: "von", es: "por", fr: "de",
			cs: "od", it: "da", pl: "przez", pt: "por", ru: "", zh: "由"},
		s_in: {de: "in", es: "en", fr: "en",
			cs: "za", it: "in", pl: "w", pt: "em", ru: "в", zh: "在"},
		s_of: {de: "von", es: "de", fr: "de",
			cs: "z", it: "di", pl: "z", pt: "de", ru: "из", zh: "的"},
		s_for: {de: "für", es: "para", fr: "pour",
			cs: "pro", it: "per", pl: "dla", pt: "para", ru: "для", zh: "为了"},
		s_to: {de: "zu", es: "a", fr: "contre",
			cs: "ku", it: "a", pl: "na", pt: "a", ru: "до", zh: "比"},
		
		// Automatic
		s_Sector: {de: "Sektor", es: "Sector", fr: "Secteur", zh: "扇形"},
		s_Waypoint: {de: "Wegmarke", es: "Punto de ruta", fr: "Point de passage", zh: "传送点"},
		s_Point_of_Interest: {de: "Sehenswürdigkeit", es: "Punto de interés", fr: "Site remarquable", zh: "鸟瞰点"},
		s_Vista: {de: "Aussichtspunkt", es: "Vista", fr: "Panorama", zh: "鸟瞰点"},
		s_Mastery_Insight: {de: "Einsicht", es: "Reflexión de dominio", fr: "Source de connaissance de maîtrise", zh: "专精揭秘点"},
		s_Hero_Challenge: {de: "Heldenherausforderung", es: "Desafío de héroe", fr: "Défi de héros", zh: "英雄挑战"},
		s_Heart: {de: "Herzchen-Quest", es: "Corazón de prestigio", fr: "Cœur de renommé", zh: "爱心任务"},
		s_Scheduled_Bosses: {de: "Geplant", es: "Programado", fr: "Planifié",
			cs: "Plánované", it: "Pianificata", pl: "Zaplanowane", pt: "Agendado", ru: "Запланирован", zh: "已排程"},
		s_Special_Bosses: {de: "Speziell", es: "Especial", fr: "Spécial",
			cs: "Speciální", it: "Speciale", pl: "Specjalny", pt: "Especial", ru: "Особый", zh: "特别的"},
		s_Dry_Top: {de: "Trockenkuppe", es: "Cima Seca", fr: "Cimesèche", zh: "干涸高地"},
		s_Legacy_Bosses: {de: "Legacy", es: "Heredado", fr: "Hérité",
			cs: "Starší", it: "Legacy", pl: "Starsze", pt: "Herdado", ru: "Устаревший", zh: "旧版"},
		s_Orr_Temples: {de: "Tempel", es: "Templos", fr: "Temples",
			cs: "Chrámy", it: "Templi", pl: "Świątynie", pt: "Templos", ru: "Храмы", zh: "寺庙"},
		s_Full_Timetable: {de: "Zeitplan", es: "Horario", fr: "Horaire",
			cs: "Plán", it: "Programma", pl: "Harmonogram", pt: "Horário", ru: "Расписание", zh: "时间表"},
		s_promotions: {de: "aktionen", es: "promociones", fr: "promotions",
			cs: "propagace", it: "promozioni", pl: "promocje", pt: "promoções", ru: "продвижения", zh: "促销"},
		s_menu: {de: "menü", es: "menú", fr: "menu",
			cs: "nabídka", it: "menu", pl: "menu", pt: "menu", ru: "меню", zh: "功能表"},
		s_wvw: {de: "WvW", es: "McM", fr: "McM",
			cs: "SpS", it: "McM", pl: "SkS", pt: "McM", ru: "МпМ", zh: "世界战场"},
		s_pve: {de: "SgU", es: "JcE", fr: "JcE",
			cs: "HpP", it: "GcA", pl: "PvE", pt: "JcA", ru: "ИпО", zh: "玩家对抗环境"},
		s_pvp: {de: "PvP", es: "JcJ", fr: "JcJ",
			cs: "HpH", it: "GcG", pl: "PvP", pt: "JcJ", ru: "ИпИ", zh: "玩家對戰"},
		s_display: {de: "anzeige", es: "presentación", fr: "affichage",
			cs: "zobrazení", it: "visualizzazione", pl: "wyświetlania", pt: "exibição", ru: "отображаемое", zh: "显示"},
		s_zone: {de: "gebiet", es: "zona", fr: "zone",
			cs: "zóna", it: "zona", pl: "zona", pt: "zona", ru: "зона", zh: "区"},
		s_forum: {de: "forum", es: "foro", fr: "forum",
			cs: "fórum", it: "forum", pl: "forum", pt: "fórum", ru: "форум", zh: "论坛"},
		s_possessions: {de: "besitzungen", es: "posesiones", fr: "possessions",
			cs: "bohatství", it: "patrimonio", pl: "dobytek", pt: "posses", ru: "пожитки", zh: "财产"},
		s_catalog: {de: "katalog", es: "catálogo", fr: "catalogue",
			cs: "katalog", it: "catalogo", pl: "katalog", pt: "catálogo", ru: "каталог", zh: "目录"},
		s_audit: {de: "prüfung", es: "auditar", fr: "auditer",
			cs: "audit", it: "audit", pl: "audyt", pt: "auditar", ru: "аудит", zh: "审计"},
		s_cleanup: {de: "aufräumen", es: "limpia", fr: "nettoyer",
			cs: "úklid", it: "ripulire", pl: "oczyszczenie", pt: "limpeza", ru: "уборка", zh: "净化"},
		s_simple: {de: "einfach", es: "simple", fr: "simple",
			cs: "prostý", it: "semplice", pl: "prosty", pt: "simples", ru: "простой", zh: "简单"},
		s_mobile: {de: "mobil", es: "móvil", fr: "mobile",
			cs: "mobilní", it: "mobile", pl: "mobilna", pt: "móvel", ru: "мобильный", zh: "行动"},
		s_tile: {de: "kacheln", es: "mosaico", fr: "mosaïque",
			cs: "dlaždice", it: "affianca", pl: "sąsiadująco", pt: "ladrilho", ru: "замостить", zh: "砖"},
		
		// Section names
		s_manager: {de: "manager", es: "administrador", fr: "gestionnaire",
			cs: "správce", it: "gestione", pl: "menedżer", pt: "gerenciador", ru: "диспетчер", zh: "管理员"},
		s_bank: {de: "bank", es: "banco", fr: "banque",
			cs: "banka", it: "banca", pl: "bank", pt: "banco", ru: "банк", zh: "银行"},
		s_vault: {de: "tresor", es: "arcón", fr: "coffre",
			cs: "trezor", it: "volta", pl: "kufer", pt: "tesouro", ru: "сундук", zh: "保险箱"},
		s_materials: {de: "materialien", es: "materiales", fr: "matériaux",
			cs: "materiály", it: "materiale", pl: "materiały", pt: "materiais", ru: "материалы", zh: "物料"},
		s_skins: {de: "skins", es: "diseños", fr: "apparences",
			cs: "vzhledy", it: "apparenze", pl: "karnacje", pt: "desenhos", ru: "конструкции", zh: "皮肤"},
		s_wardrobe: {de: "garderobenlager", es: "garderobe", fr: "garderobe",
			cs: "skříň", it: "armadio", pl: "szafa", pt: "roupeiro", ru: "гардероб", zh: "衣柜"},
		s_outfits: {de: "kleidungssets", es: "atuendos", fr: "tenues",
			cs: "oblečení", it: "abiti", pl: "strój", pt: "vestuário", ru: "костюмы", zh: "服装"},
		s_gliders: {de: "gleitschirm", es: "planeador", fr: "deltaplanes",
			cs: "kluzáky", it: "alianti", pl: "szybowce", pt: "planadores", ru: "планеры", zh: "滑翔机"},
		s_dyes: {de: "farben", es: "tintes", fr: "teintures",
			cs: "barviva", it: "tinturi", pl: "barwniki", pt: "tinturas", ru: "красители", zh: "染料"},
		s_minis: {de: "miniaturen", es: "miniaturas", fr: "miniatures",
			cs: "miniatury", it: "miniature", pl: "miniatury", pt: "miniaturas", ru: "миниатюры", zh: "微缩模型"},
		s_carriers: {de: "briefboten", es: "carteros", fr: "messagers",
			cs: "kurýři", it: "corrieri", pl: "kurierzy", pt: "correios", ru: "курьеры", zh: "快递"},
		s_champions: {de: "champion", es: "campeón", fr: "champion",
			cs: "mistr", it: "campione", pl: "mistrz", pt: "campeão", ru: "чемпион", zh: "迷雾首领"},
		s_finishers: {de: "todesstöße", es: "remates", fr: "coups de grâce",
			cs: "finišer", it: "finitore", pl: "apreter", pt: "arrematador", ru: "финишер", zh: "终结者"},
		s_cats: {de: "katzen", es: "gatos", fr: "chats",
			cs: "kočky", it: "gatti", pl: "koty", pt: "gatos", ru: "коты", zh: "猫"},
		s_characters: {de: "charaktere", es: "personajes", fr: "personnages",
			cs: "postavy", it: "personaggi", pl: "postacie", pt: "personagens", ru: "персонажей", zh: "人物"},
		s_hero: {de: "heldin", es: "héroe", fr: "héros",
			cs: "hrdina", it: "eroe", pl: "bohater", pt: "herói", ru: "геро́й", zh: "主角"},
		s_equipment: {de: "ausrüstung", es: "equipamiento", fr: "equipement",
			cs: "vybavení", it: "equipaggiamento", pl: "sprzęt", pt: "equipamento", ru: "обору́дование", zh: "设备"},
		s_inventory: {de: "inventar", es: "inventario", fr: "inventaire",
			cs: "inventář", it: "inventario", pl: "inwentarz", pt: "inventário", ru: "инвента́рь", zh: "库存"},
		s_ascended: {de: "aufgestiegen", es: "ascendido", fr: "élevé",
			cs: "vystoupal", it: "asceso", pl: "wstąpił", pt: "ascendeu", ru: "вознесся", zh: "登高"},
		s_recipes: {de: "rezepte", es: "recetas", fr: "recettes",
			cs: "recepty", it: "ricette", pl: "recepty", pt: "receitas", ru: "рецепты", zh: "食谱"},
		s_crafting: {de: "handwerkskunst", es: "artesanía", fr: "artisanat",
			cs: "řemeslo", it: "mestiere", pl: "rzemiosło", pt: "ofício", ru: "ремесло", zh: "手艺"},
		s_raids: {de: "schlachtzügen", es: "incursiones", fr: "raids",
			cs: "nájezd", it: "incursione", pl: "nalot", pt: "incursão", ru: "набег", zh: "大型地下城"},
		s_dungeons: {de: "verliesen", es: "mazmorras", fr: "donjons",
			cs: "dungeony", it: "dungeon", pl: "lochy", pt: "masmorras", ru: "подземелья", zh: "地下城"},
		s_masteries: {de: "beherrschungs", es: "dominios", fr: "maîtrises",
			cs: "nadvláda", it: "maestria", pl: "dominacji", pt: "mestrias", ru: "господства", zh: "专精"},
		s_museum: {de: "museum", es: "museo", fr: "musée",
			cs: "muzeum", it: "museo", pl: "muzeum", pt: "museu", ru: "музей", zh: "博物馆"},
		s_wishlist: {de: "wunschliste", es: "lista de deseos", fr: "liste d'envies",
			cs: "seznam přání", it: "lista desideri", pl: "lista życzeń", pt: "lista de desejos", ru: "список желаемого", zh: "愿望清单"},
		
		// Economy
		s_trading: {de: "handel", es: "comercio", fr: "commerciale",
			cs: "obchod", it: "commercio", pl: "handel", pt: "comércio", ru: "продажа", zh: "贸易"},
		s_tracker: {de: "tracker", es: "rastreador", fr: "suivi",
			cs: "tracker", it: "tracker", pl: "", pt: "rastreador", ru: "трекер", zh: "跟踪"},
		s_exchange: {de: "austauschen", es: "intercambiar", fr: "échanger",
			cs: "spoluužívat", it: "condividere", pl: "dzielić", pt: "compartilhar", ru: "предоставлять", zh: "交换"},
		s_recent: {de: "aktuell", es: "reciente", fr: "récent",
			cs: "poslední", it: "recenti", pl: "ostatnie", pt: "recente", ru: "последние", zh: "最近"},
		s_buying: {de: "kaufen", es: "comprando", fr: "achat en cours",
			cs: "nákup", it: "comprando", pl: "kupuje", pt: "comprando", ru: "покупаю", zh: "目前买"},
		s_selling: {de: "verkaufen", es: "vendiendo", fr: "vente en cours",
			cs: "prodávat", it: "vendendo", pl: "sprzedaje", pt: "vendendo", ru: "продаю", zh: "目前卖"},
		s_bought: {de: "gekauft", es: "comprado", fr: "achats historique",
			cs: "koupil", it: "comprato", pl: "kupiłem", pt: "comprei", ru: "купил", zh: "买了"},
		s_sold: {de: "verkauft", es: "vendido", fr: "ventes historique",
			cs: "prodal", it: "venduto", pl: "sprzedał", pt: "vendi", ru: "продал", zh: "卖了"},
		s_this: {de: "dieses", es: "esto", fr: "ce",
			cs: "toto", it: "questo", pl: "to", pt: "isto", ru: "это", zh: "这"},
		s_my: {de: "mein", es: "mi", fr: "mon",
			cs: "můj", it: "mio", pl: "mój", pt: "meu", ru: "мой", zh: "我的"},
		s_your: {de: "dein", es: "tu", fr: "ton",
			cs: "tvůj", it: "tuo", pl: "twój", pt: "teu", ru: "твой", zh: "你的"},
		s_name: {de: "namen", es: "nombre", fr: "nom",
			cs: "název", it: "nome", pl: "nazwa", pt: "nome", ru: "имя", zh: "名"},
		s_ordered: {de: "bestellt", es: "pedidos", fr: "demandée",
			cs: "objednal", it: "ordinato", pl: "zamówiony", pt: "encomendado", ru: "заказал", zh: "订了"},
		s_available: {de: "verfügbar", es: "disponibles", fr: "disponible",
			cs: "dostupný", it: "disponibile", pl: "dostępny", pt: "disponível", ru: "досту́пный", zh: "可用"},
		s_supply: {de: "angebot", es: "oferta", fr: "stock",
			cs: "nabídka", it: "offerta", pl: "podaż", pt: "suprimento", ru: "предложение", zh: "供应"},
		s_demand: {de: "nachfrage", es: "demanda", fr: "demande",
			cs: "poptávka", it: "domanda", pl: "popyt", pt: "demanda", ru: "спрос", zh: "需求"},
		s_discount: {de: "rabatt", es: "rebaja", fr: "rabais",
			cs: "sleva", it: "sconto", pl: "rabat", pt: "desconto", ru: "rabat", zh: "折扣"},
		s_price: {de: "preis", es: "precio", fr: "prix",
			cs: "cena", it: "prezzo", pl: "cena", pt: "preço", ru: "цена", zh: "价格"},
		s_buy: {de: "kaufen", es: "comprar", fr: "acheter",
			cs: "koupit", it: "comprare", pl: "kupić", pt: "comprar", ru: "купить", zh: "买"},
		s_sell: {de: "verkaufen", es: "vender", fr: "vendre",
			cs: "prodat", it: "vendere", pl: "sprzedać", pt: "vender", ru: "продать", zh: "卖"},
		s_outbid: {de: "überbieten", es: "sobrepujar", fr: "surenchérir",
			cs: "přelicitovat", it: "prezzo più alto", pl: "przelicytować", pt: "ultrapassar", ru: "перекупать", zh: "出价高於"},
		s_quantity: {de: "anzahl", es: "cantidad", fr: "quantité",
			cs: "množství", it: "quantità", pl: "ilość", pt: "quantidade", ru: "количество", zh: "量"},
		s_profit: {de: "gewinn", es: "beneficio", fr: "profit",
			cs: "zisk", it: "profitto", pl: "zysk", pt: "lucro", ru: "прибыль", zh: "利润"},
		s_cost: {de: "kosten", es: "costo", fr: "coût",
			cs: "náklady", it: "costo", pl: "koszt", pt: "custo", ru: "стоимость", zh: "成本"},
		s_breakpoint: {de: "gewinnschwelle", es: "punto muerto", fr: "seuil de rentabilité",
			cs: "bod zvratu", it: "punto di pareggio", pl: "próg rentowności", pt: "ponto de equilíbrio", ru: "точка безубыточности", zh: "收支平衡点"},
		s_tax: {de: "steuer", es: "impuestos", fr: "impôt",
			cs: "daň", it: "fiscale", pl: "podatek", pt: "fiscal", ru: "налог", zh: "税"},
		s_revenue: {de: "einnahmen", es: "ingresos", fr: "revenus",
			cs: "příjmy", it: "entrate", pl: "dochody", pt: "receita", ru: "доходов", zh: "收入"},
		s_margin: {de: "gewinnspanne", es: "margen", fr: "marge",
			cs: "marže", it: "margine", pl: "marża", pt: "margem", ru: "валовая", zh: "边际"},
		s_low: {de: "niedrigen", es: "bajo", fr: "bas",
			cs: "nízký", it: "bassa", pl: "niski", pt: "baixa", ru: "низкая", zh: "低"},
		s_high: {de: "hohen", es: "alta", fr: "haut",
			cs: "vysoký", it: "alta", pl: "wysoki", pt: "alta", ru: "высокая", zh: "高"},
		s_notify: {de: "benachrichtigen", es: "notificar", fr: "notifier",
			cs: "oznámit", it: "notifica", pl: "powiadom", pt: "notificar", ru: "уведомить", zh: "通知"},
		s_overwrite: {de: "überschreiben", es: "sobrescribir", fr: "remplacer",
			cs: "přepsat", it: "sovrascrivi", pl: "zastąp", pt: "substituir", ru: "перезаписать", zh: "覆写"},
		s_gem: {de: "edelsteine", es: "gema", fr: "gemme",
			cs: "klenot", it: "gemma", pl: "klejnot", pt: "gema", ru: "самоцвет", zh: "宝石"},
		s_coin: {de: "münze", es: "moneda", fr: "monnaie",
			cs: "mince", it: "moneta", pl: "moneta", pt: "moeda", ru: "монета", zh: "硬币"},
		s_dollar: {de: "dollar", es: "dólar", fr: "dollar",
			cs: "dolar", it: "dollaro", pl: "polar", pt: "dólar", ru: "доллар", zh: "元"}
	},
	
	// Strings from the game copied verbatim, for use mainly in tooltips
	Codex:
	{
		s_TEMPLATE: {en: "", de: "", es: "", fr: "", zh: ""},

		// Currency abbreviation
		s_CoinGold: {en: "g", de: "g", es: "o", fr: "o", cs: "z", it: "o", pl: "z", pt: "o", ru: "з", zh: "金"},
		s_CoinSilver: {en: "s", de: "s", es: "p", fr: "a", cs: "s", it: "a", pl: "s", pt: "p", ru: "с", zh: "银"},
		s_CoinCopper: {en: "c", de: "k", es: "c", fr: "c", cs: "m", it: "r", pl: "m", pt: "c", ru: "м", zh: "铜"},
		
		// Item Type
		s_Back: {en: "Back Item", de: "Rücken-Gegenstand", es: "Objeto para espalda", fr: "Objet de dos", zh: "背包"},
		s_Bag: {en: "Bag", de: "Tasche", es: "Saco", fr: "Sac", zh: "格包"},
		s_Boost: {en: "Boost", de: "Verstärker", es: "Potenciador", fr: "Augmentation", zh: "增幅剂"},
		s_Consumable: {en: "Consumable", de: "Verbrauchsgegenstand", es: "Consumible", fr: "Consommable", zh: "消耗"},
		s_Container: {en: "Container", de: "Behälter", es: "Contenedor", fr: "Conteneur", zh: "器箱"},
		s_CraftingMaterial: {en: "Crafting Material", de: "Handwerksmaterial", es: "Material de artesanía", fr: "Matériau d&apos;artisanat", zh: "制作材料"},
		s_Gathering: {en: "Gathering Tool", de: "Sammelwerkzeug", es: "Herramienta de recolección", fr: "Outil de récolte", zh: "采集工具"},
		s_Gizmo: {en: "Gizmo", de: "Dingsbums", es: "Aparato", fr: "Machin", zh: "聚能发明"},
		s_MiniPet: {en: "Miniature", de: "Miniatur", es: "Miniatura", fr: "Miniature", zh: "迷你"},
		s_Nourishment: {en: "Nourishment", de: "Verbrauchsstoff", es: "Consumible", fr: "Produit consommable", zh: "食品"},
		s_Salvage: {en: "Salvage", de: "Wiederverwertungs", es: "Recicla", fr: "Recyclage", zh: "拆解"},
		s_Tool: {en: "Salvage Kit", de: "Wiederverwertungskit", es: "Kit de recicla", fr: "Nécessaire de recyclage", zh: "拆解工具包"},
		s_Trophy: {en: "Trophy", de: "Trophäe", es: "Trofeo", fr: "Trophée", zh: "战利品"},
		s_UpgradeComponent: {en: "Upgrade Component", de: "Aufwertung", es: "Componente de mejora", fr: "Composant d&apos;amélioration", zh: "升级"},
		// Item Rarity
		s_Junk: {en: "Junk", de: "Schrott", es: "Basura", fr: "Inutile", zh: "垃圾"},
		s_Basic: {en: "Basic", de: "Einfach", es: "Básico", fr: "Simple", zh: "基本"},
		s_Fine: {en: "Fine", de: "Edel", es: "Selecto", fr: "Raffiné", zh: "精"},
		s_Masterwork: {en: "Masterwork", de: "Meisterwerk", es: "Obra de arte", fr: "Chef-d&apos;œuvre", zh: "杰作"},
		s_Rare: {en: "Rare", de: "Selten", es: "Excepcional", fr: "Rare", zh: "稀有"},
		s_Exotic: {en: "Exotic", de: "Exotisch", es: "Exótico", fr: "Exotique", zh: "傀"},
		s_Ascended: {en: "Ascended", de: "Aufgestiegen", es: "Ascendido", fr: "Élevé", zh: "上升"},
		s_Legendary: {en: "Legendary", de: "Legendär", es: "Legendario", fr: "Légendaire", zh: "传奇"},
		// Item Weight
		s_Light: {en: "Light", de: "Leicht", es: "Ligero", fr: "Légèr", zh: "轻"},
		s_Medium: {en: "Medium", de: "Mittel", es: "Medio", fr: "Intermédiaire", zh: "中型"},
		s_Heavy: {en: "Heavy", de: "Schwer", es: "Pesado", fr: "Lourd", zh: "重"},
		// Item Attributes
		s_Power: {en: "Power", de: "Kraft", es: "Potencia", fr: "Puissance"},
		s_Toughness: {en: "Toughness", de: "Zähigkeit", es: "Dureza", fr: "Robustesse"},
		s_Armor: {en: "Armor", de: "Rüstung", es: "Armadura", fr: "Armure"},
		s_Vitality: {en: "Vitality", de: "Vitalität", es: "Vitalidad", fr: "Vitalité"},
		s_Health: {en: "Health", de: "Lebenspunkte", es: "Salud", fr: "Santé"},
		s_Precision: {en: "Precision", de: "Präzision", es: "Precisión", fr: "Précision"},
		s_CriticalChance: {en: "Critical Chance", de: "Kritische Trefferchance", es: "Probabilidad de daño crítico", fr: "Chance de coup critique"},
		s_Ferocity: {en: "Ferocity", de: "Wildheit", es: "Ferocidad", fr: "Férocité"},
		s_CriticalDamage: {en: "Critical Damage", de: "Kritischer Schaden", es: "Daño crítico", fr: "Dégâts critiques"},
		s_ConditionDamage: {en: "Condition Damage", de: "Zustandsschaden", es: "Daño de condición", fr: "Dégâts par altération"},
		s_HealingPower: {en: "Healing Power", de: "Heilkraft", es: "Poder de curación", fr: "Guérison"},
		s_Expertise: {en: "Expertise", de: "Fachkenntnis", es: "Pericia", fr: "Expertise"},
		s_ConditionDuration: {en: "Condition Duration", de: "Zustandsdauer", es: "Duración de condición", fr: "Durée d&apos;altération"},
		s_Concentration: {en: "Concentration", de: "Konzentration", es: "Concentración", fr: "Concentration"},
		s_BoonDuration: {en: "Boon Duration", de: "Segensdauer", es: "Duración de bendición", fr: "Durée d&apos;avantage"},
		s_AgonyResistance: {en: "Agony Resistance", de: "Qual-Widerstand", es: "Resistencia a la agonía", fr: "Résistance à l&apos;agonie"},
		s_MagicFind: {en: "Magic Find", de: "Magisches Gespür", es: "Hallazgo mágico", fr: "Découverte de magie"},
		// Item Equipment
		s_Axe: {en: "Axe", de: "Axt", es: "Hacha", fr: "Haches"},
		s_Dagger: {en: "Dagger", de: "Dolch", es: "Daga", fr: "Dague"},
		s_Mace: {en: "Mace", de: "Streitkolben", es: "Maza", fr: "Masse"},
		s_Pistol: {en: "Pistol", de: "Pistole", es: "Pistola", fr: "Pistolet"},
		s_Scepter: {en: "Scepter", de: "Zepter", es: "Cetro", fr: "Sceptre"},
		s_Sword: {en: "Sword", de: "Schwert", es: "Espada", fr: "Epée"},
		s_Focus: {en: "Focus", de: "Fokus", es: "Foco", fr: "Focus"},
		s_Shield: {en: "Shield", de: "Schild", es: "Escudo", fr: "Bouclier"},
		s_Torch: {en: "Torch", de: "Fackel", es: "Antorcha", fr: "Torche"},
		s_Warhorn: {en: "Warhorn", de: "Kriegshorn", es: "Cuerno de guerra", fr: "Cor de guerre"},
		s_Greatsword: {en: "Greatsword", de: "Großschwert", es: "Mandoble", fr: "Espadon"},
		s_Hammer: {en: "Hammer", de: "Hammer", es: "Martillo", fr: "Marteau"},
		s_LongBow: {en: "Longbow", de: "Langbogen", es: "Arco largo", fr: "Arc long"},
		s_Rifle: {en: "Rifle", de: "Gewehr", es: "Rifle", fr: "Fusil"},
		s_ShortBow: {en: "Shortbow", de: "Kurzbogen", es: "Arco corto", fr: "Arc court"},
		s_Staff: {en: "Staff", de: "Stab", es: "Báculo", fr: "Bâton"},
		s_Harpoon: {en: "Harpoon", de: "Speer", es: "Lanza", fr: "Lance"},
		s_Speargun: {en: "Speargun", de: "Harpunenschleuder", es: "Cañón de arpón", fr: "Fusil-harpon"},
		s_Trident: {en: "Trident", de: "Dreizack", es: "Tridente", fr: "Trident"},
		s_HelmAquatic: {en: "Head Armor", de: "Kopf-Rüstung", es: "Armadura de cabeza", fr: "Armure : Couvre-chef"},
		s_Helm: {en: "Head Armor", de: "Kopf-Rüstung", es: "Armadura de cabeza", fr: "Armure : Couvre-chef"},
		s_Shoulders: {en: "Shoulder Armor", de: "Schulter-Rüstung", es: "Armadura de hombros", fr: "Armure : Épaulières"},
		s_Coat: {en: "Chest Armor", de: "Brust-Rüstung", es: "Armadura pectoral", fr: "Armure : Cuirasse"},
		s_Gloves: {en: "Hand Armor", de: "Hand-Rüstung", es: "Armadura de mano", fr: "Armure : Gants"},
		s_Leggings: {en: "Leg Armor", de: "Bein-Rüstung", es: "Armadura de pierna", fr: "Armure : Jambières"},
		s_Boots: {en: "Foot Armor", de: "Fuß-Rüstung", es: "Armadura de pie", fr: "Armure : Bottes"},
		s_Amulet: {en: "Amulet", de: "Amulett", es: "Amuleto", fr: "Amulette"},
		s_Accessory: {en: "Accessory", de: "Accessoire", es: "Accesorio", fr: "Accessoire"},
		s_Ring: {en: "Ring", de: "Ring", es: "Anillo", fr: "Anneau"},
		// Item Tooltip
		s_Defense: {en: "Defense", de: "Verteidigung", es: "Defensa", fr: "Défense"},
		s_WeaponStrength: {en: "Weapon Strength", de: "Waffenstärke", es: "Fuerza del arma", fr: "Puissance d&apos;arme"},
		s_Healing: {en: "Healing", de: "Heilung", es: "Curación", fr: "Guérison"},
		s_RequiredLevel: {en: "Required Level", de: "Erforderliche Stufe", es: "Nivel necesario", fr: "Niveau requis"},
		s_AccountBindOnUse: {en: "Account Bound on Use", de: "Accountgebunden bei Benutzung", es: "Vinculado a cuenta en uso", fr: "Lié au compte dès l&apos;utilisation"},
		s_AccountBound: {en: "Account Bound", de: "Accountgebunden", es: "Vinculado a cuenta", fr: "Lié au compte"},
		s_SoulBindOnUse: {en: "Soulbound on Use", de: "Seelengebunden bei Benutzung", es: "Ligado en uso", fr: "Lié à l&apos;âme dès l&apos;utilisation"},
		s_SoulbindOnAcquire: {en: "Soulbound", de: "Seelengebunden", es: "Ligado", fr: "Lié à l&apos;âme"},
		s_SoulboundToCharacter: {en: "Soulbound to another character", de: "An einen anderen Charakter seelengebunden", es: "Ligado a otro personaje", fr: "Lié à l&apos;âme d&apos;un autre personnage"},
		s_Unique: {en: "Unique", de: "Einzigartig", es: "Equipamiento único", fr: "Unique"},
		s_Transmuted: {en: "Transmuted", de: "Transmutiert", es: "Transmutado", fr: "Transmuté"},
		s_UnusedEnrichmentSlot: {en: "Unused Enrichment Slot", de: "Ungenutzter Anreicherungsplatz",
			es: "Casilla para enriquecimientos sin utilizar", fr: "Emplacement d'enrichissement inutilisé"},
		s_UnusedInfusionSlot: {en: "Unused Infusion Slot", de: "Freier Infusionsplatz",
			es: "Casilla de infusión sin utilizar", fr: "Emplacement d&apos;infusion inutilisé"},
		s_UnusedUpgradeSlot: {en: "Unused Upgrade Slot", de: "Freier Aufwertungsplatz",
			es: "Casilla para mejoras sin utilizar", fr: "Emplacement d&apos;amélioration inutilisé"},
		s_DoubleClickToSelectStats: {en: "Double-click to select stats.", de: "Doppelklicken, um Werte auszuwählen.",
			es: "Haz doble clic para seleccionar estadísticas.", fr: "Double-cliquez pour sélectionner les statistiques."},
		s_DoubleClickToConsume: {en: "Double-click to consume.", de: "Zum Benutzen doppelklicken.",
			es: "Haz doble clic para consumir.", fr: "Double-cliquez pour utiliser."},
		s_ExcessiveAlcohol: {en: "Excessive alcohol consumption will result in intoxication.", de: "Übermäßiger Alkoholkonsum führt zu Rauschzuständen.",
			es: "El consumo excesivo de alcohol provoca embriaguez.", fr: "Consommer trop d&apos;alcool entraîne une ivresse manifeste."},
		s_GainBasedPercentage: {en: "Gain {1} Based on a Percentage of {0}", de: "Erhaltener prozentualer Anteil von {0} auf {1}:",
			es: "Ganas {1} según tu porcentaje de {0}", fr: "Vous bénéficiez d'une augmentation de {1} de {0}%."},
		// Guild
		s_GuildStash: {en: "Guild Stash", de: "Geheimvorrat", es: "Alijo del clan", fr: "Réserve de guilde"},
		s_TreasureTrove: {en: "Treasure Trove", de: "Schatzgrube", es: "Tesoro oculto", fr: "Trésor"},
		s_DeepCave: {en: "Deep Cave", de: "Tiefe Höhle", es: "Cueva profunda", fr: "Grotte profonde"}
	},
	
	/*
	 * Information about the user's selected language in determining content to present.
	 */
	isLanguageFullySupported: null,
	isLanguageDefault: null,
	isLanguageTraditional: null,
	isLanguageModifierFirst: null,
	isLanguageLogographic: null,
	langFullySupported: null, // The API supports zh but the wiki does not
	langPartiallySupported: null,
	initializeLanguage: function()
	{
		D.isLanguageFullySupported = (O.LanguageMeta.isFullySupported[O.Options.enu_Language]) ? true : false;
		D.isLanguageDefault = (O.Options.enu_Language === O.OptionEnum.Language.Default);
		D.isLanguageTraditional = (O.Options.enu_Language === O.OptionEnum.Language.ChineseTraditional);
		D.isLanguageModifierFirst = (O.LanguageMeta.isModifierFirst[O.Options.enu_Language]) ? true : false;
		D.isLanguageLogographic = (O.LanguageMeta.isLogographic[O.Options.enu_Language]) ? true : false;
		D.langFullySupported = (D.isLanguageFullySupported) ? O.Options.enu_Language : O.OptionEnum.Language.Default;
		D.langPartiallySupported = (O.Options.enu_Language === O.OptionEnum.Language.ChineseSimplified
			|| O.Options.enu_Language === O.OptionEnum.Language.ChineseTraditional)
			? O.OptionEnum.Language.ChineseSimplified : D.langFullySupported;
		
		D.initializeDictionary();
		U.initializeAPIURLs();
	},
	
	/*
	 * Gets a codex string based on the opted language.
	 * @param string pText text to translate without spaces.
	 * @returns string translated text.
	 */
	getString: function(pText)
	{
		var entry = D.Codex["s_" + pText];
		if (entry)
		{
			// Get the text based on user's language if available, otherwise use default
			var value = entry[O.Options.enu_Language];
			if (value)
			{
				return value;
			}
			return entry[O.OptionEnum.Language.Default];
		}
		// Language not found so use given instead
		return pText;
	},
	
	/*
	 * Gets translation string that was written within an element's data attribute.
	 * @param jqobject pElm
	 * @returns string
	 */
	getDataAttribute: function(pElm)
	{
		var elm = $(pElm);
		if (D.isLanguageDefault === false)
		{
			var str = pElm.attr("data-" + O.Options.enu_Language);
			if (str)
			{
				return str;
			}
			else if (D.isLanguageTraditional)
			{
				return $.s2t(pElm.attr("data-" + O.OptionEnum.Language.ChineseSimplified));
			}
		}
		return elm.text();
	},
	
	/*
	 * Settings for special languages.
	 */
	initializeDictionary: function()
	{
		// Use Simplified Chinese to create a Traditional Chinese dictionary
		if (D.isLanguageTraditional)
		{
			var entry, simp = O.OptionEnum.Language.ChineseSimplified, trad = O.OptionEnum.Language.ChineseTraditional;
			for (var i in D.Dictionary)
			{
				entry = (D.Dictionary[i])[simp];
				if (entry)
				{
					(D.Dictionary[i])[trad] = $.s2t(entry);
				}
			}
			for (var i in D.Codex)
			{
				entry = (D.Codex[i])[simp];
				if (entry)
				{
					(D.Codex[i])[trad] = $.s2t(entry);
				}
			}
		}
	},
	
	/*
	 * Adds new words to the dictionary from an object of the same structure.
	 * Note that the words have to be unique from the ones here.
	 * @param object pDictionary.
	 */
	addDictionary: function(pDictionary)
	{
		for (var i in pDictionary)
		{
			D.Dictionary[i] = pDictionary[i];
		}
		D.initializeDictionary();
	},
	
	/*
	 * Gets a dictionary entry translated based on the opted language.
	 * @param string pText text to translate.
	 * @returns string translated text.
	 */
	getTranslation: function(pText)
	{
		// If opted language is English then just return the given text
		if (D.isLanguageDefault)
		{
			return pText;
		}
		
		// Else look up the text in the dictionary
		var value;
		var text = pText;
		if (text.indexOf(" ") !== -1)
		{
			// Spaces become underscores
			text = text.replace(/ /g, "_");
		}
		
		var entry = D.Dictionary["s_" + text];
		if (entry)
		{
			// Get the text based on user's language
			value = entry[O.Options.enu_Language];
			if (value)
			{
				return value;
			}
		}
		// Language not found so use given instead
		return pText;
	},
	getWord: function(pText)
	{
		if (D.isLanguageDefault)
		{
			return pText;
		}
		// No error checking, assume entry exists
		return (D.Dictionary["s_" + pText])[O.Options.enu_Language];
	},
	getWordCase: function(pWord, pCase)
	{
		return U.toCase(D.getTranslation(pWord), pCase);
	},
	getWordCapital: function(pWord)
	{
		return U.toFirstUpperCase(D.getTranslation(pWord));
	},
	
	/*
	 * Translates multiple space separated words.
	 * @param string pString of words.
	 * @param enum pCase to change capitalization.
	 * @returns string translated.
	 */
	getPhrase: function(pString, pCase)
	{
		if (pCase === undefined)
		{
			pCase = U.CaseEnum.None;
		}
		
		var str = pString.split(" ");
		if (pCase === U.CaseEnum.Original)
		{
			for (var i in str)
			{
				str[i] = D.duplicateCase(str[i], D.getTranslation(str[i].toLowerCase()));
			}
		}
		else
		{
			for (var i in str)
			{
				str[i] = D.getTranslation(str[i]);
			}
		}
		
		var text = (D.isLanguageLogographic) ? str.join("") : str.join(" ");
		if (pCase === U.CaseEnum.None || pCase === U.CaseEnum.Original)
		{
			return text;
		}
		return U.toCase(text, pCase);
	},
	getPhraseTitle: function(pString)
	{
		return D.getPhrase(pString, U.CaseEnum.Every);
	},
	getPhraseOriginal: function(pString)
	{
		if (D.isLanguageDefault === false)
		{
			return D.getPhrase(pString, U.CaseEnum.Original);
		}
		return pString;
	},
	
	/*
	 * Gets a word and modifier string in language-dependent order in specified case.
	 * @param string pWord a noun for example.
	 * @param string pModifier an adjective for example.
	 * @param enum pCase to change the phrase's capitalization.
	 * @returns string modified word phrase.
	 */
	getModifiedWord: function(pWord, pModifier, pCase)
	{
		return D.getPhrase(D.orderModifier(pWord, pModifier), pCase);
	},
	orderModifier: function(pWord, pModifier)
	{
		return D.isLanguageModifierFirst ? (pModifier + " " + pWord) : (pWord + " " + pModifier);
	},
	getModifiedPhrase: function(pString, pCase)
	{
		var str = pString.split(" ");
		if (str.length === 1)
		{
			return D.getWordCase(str[0], pCase);
		}
		else if (str.length === 2)
		{
			return D.getModifiedWord(str[1], str[0], pCase); // Default language has modifier before the word
		}
		return D.getPhrase(pString, pCase);
	},
	
	/*
	 * Duplicates the case style of a source word to the translated word.
	 * @param string pSourceWord single and without whitespace.
	 * @param string pTranslatedWord to format with the same case.
	 */
	duplicateCase: function(pSourceWord, pTranslatedWord)
	{
		// If first letter is lowercase, assume the whole word is lowercase
		var firstletter = pSourceWord.charAt(0);
		if (firstletter === firstletter.toLowerCase())
		{
			return pTranslatedWord; // The dictionary is in lowercase by default, so no need to do it again
		}
		// If first two letters are capitalized, then assume all caps
		if (pSourceWord.length > 2 && pTranslatedWord.length > 2)
		{
			var secondletter = pSourceWord.charAt(1);
			if (firstletter === firstletter.toUpperCase() && secondletter === secondletter.toUpperCase())
			{
				return pTranslatedWord.toUpperCase();
			}
		}
		// For any other conditions, capitalize the first letter of the translated word
		return pTranslatedWord.charAt(0).toUpperCase() + pTranslatedWord.slice(1);
	},
	
	/*
	 * Finds element with the translation CSS class and translates them.
	 */
	translateElements: function()
	{
		if (D.isLanguageDefault === false)
		{
			// Translate each word individually for these elements
			$(".jsTranslate").each(function()
			{
				$(this).text(D.getPhraseOriginal($(this).text()))
					.removeClass("jsTranslate");
			});
			// Translate the entire text content as a compound word for these elements
			$(".jsTranslateCompound").each(function()
			{
				$(this).text(D.getTranslation($(this).text()))
					.removeClass("jsTranslateCompound");
			});
		}
	},
	
	/*
	 * Does translations for preloaded (not AJAX or generated) content, also
	 * re-initializes tooltips.
	 */
	translateAfter: function()
	{
		if (D.isLanguageDefault === false)
		{
			// Translate tooltips
			$(".hudSelect, .btnWindow").each(function()
			{
				var title = $(this).attr(I.cTooltipAttribute);
				if (title !== undefined)
				{
					var jqobj = $("<div>" + title + "</div>");
					var transtext = D.getPhraseOriginal(jqobj.find("dfn").text());
					jqobj.find("dfn").remove();
					$(this).attr("title", "<dfn>" + transtext + "</dfn>" + jqobj.html());
				}
				I.qTip.init($(this));
			});
			D.translateElements();
		}
	},
	
	/*
	 * Tells whether a substring is within a string, with provided multilingual substrings.
	 * @param string pString to search for the substring.
	 * @param object pSubstrings search strings keyed by language code. Example: {en: "day", de: "tag", ...}
	 * @returns boolean
	 */
	isWithin: function(pString, pSubstrings)
	{
		var findstr = pSubstrings[D.langPartiallySupported];
		if (pString.indexOf(findstr) !== -1)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Retrieves the name property of an object that was prefixed with a language code.
	 * Example: Object has first level properties: name_en: "Example Name", name_de: "Weise Name"
	 * @param object pObject to extract name.
	 * @returns name in user's language.
	 */
	getNameKey: function()
	{
		return "name_" + D.langFullySupported;
	},
	getURLKey: function()
	{
		return "url_" + D.langFullySupported;
	},
	getObjectTranslation: function(pObject) // No prefix, just the language code
	{
		if (pObject[O.Options.enu_Language] !== undefined)
		{
			return pObject[O.Options.enu_Language];
		}
		else if (O.Options.enu_Language === O.OptionEnum.Language.ChineseTraditional
			&& pObject[O.OptionEnum.Language.ChineseSimplified])
		{
			// Obtain Traditional Chinese from Simplified Chinese
			pObject[O.Options.enu_Language] = $.s2t(pObject[O.OptionEnum.Language.ChineseSimplified]);
			return pObject[O.Options.enu_Language];
		}
		return pObject[O.OptionEnum.Language.Default];
	},
	getObjectString: function(pObject, pPrefix)
	{
		var key = pPrefix + O.Options.enu_Language;
		if (pObject)
		{
			if (pObject[key])
			{
				return pObject[key];
			}
			else if (O.Options.enu_Language === O.OptionEnum.Language.ChineseTraditional)
			{
				// Obtain Traditional Chinese from Simplified Chinese
				var simp = pObject[pPrefix + O.OptionEnum.Language.ChineseSimplified];
				if (simp)
				{
					pObject[key] = $.s2t(simp);
					return pObject[key];
				}
			}
			return pObject[pPrefix + O.OptionEnum.Language.Default];
		}
		return null;
	},
	getObjectName: function(pObject)
	{
		return D.getObjectString(pObject, "name_");
	},
	getObjectNick: function(pObject)
	{
		return D.getObjectString(pObject, "nick_");
	},
	getObjectDesc: function(pObject)
	{
		return D.getObjectString(pObject, "desc_");
	},
	getObjectDefaultName: function(pObject)
	{
		return pObject["name_" + O.OptionEnum.Language.Default];
	},
	getObjectDefaultNick: function(pObject)
	{
		return pObject["nick_" + O.OptionEnum.Language.Default];
	},
	getObjectURL: function(pObject)
	{
		return pObject["url_" + D.langFullySupported];
	},
	
	/*
	 * Gets title of chain in opted language.
	 * @param int pIndex of chain.
	 * @returns string title.
	 */
	getChainTitle: function(pChain)
	{
		if (D.isLanguageDefault)
		{
			return pChain.title;
		}
		return D.getObjectName(pChain);
	},
	
	/*
	 * Gets short title of chain in opted language.
	 * @param int pIndex of chain.
	 * @returns string short title.
	 */
	getChainAlias: function(pChain)
	{
		if (D.isLanguageDefault)
		{
			return C.parseChainAlias(pChain.alias);
		}
		return D.getChainTitle(pChain);
	},
	
	/*
	 * Loads the client-side TTS exclusively for the overlay if haven't already.
	 * Should be called by any feature that uses TTS so the engine is ready to speak.
	 */
	verifyNativeTTS: function(pCallback)
	{
		if (I.isSpeechNativeEnabled === false
			&& I.isProgramEmbedded === false
			&& I.ModeCurrent === I.ModeEnum.Overlay
			&& I.BrowserCurrent !== I.BrowserEnum.IE)
		{
			I.isSpeechNativeEnabled = true;
			U.getScript(U.URL_API.TextToSpeechNative, function()
			{
				I.isSpeechNativeLoaded = true;
				meSpeak.loadConfig("bin/tts/mespeak_config.json");
				meSpeak.loadVoice("bin/tts/voices/" + O.Options.enu_Language + ".json");
				if (pCallback)
				{
					pCallback();
				}
			});
		}
		else if (pCallback)
		{
			pCallback();
		}
	},
	
	/*
	 * Plays an audio representation of provided string, using Chrome's TTS
	 * system if the user is running it. Otherwise loads a TTS sound file
	 * generated from a TTS web service into a hidden audio tag.
	 * @param string pString to convert to speech.
	 * @param float pDuration of the speech in seconds.
	 */
	speechWait: 0, // In milliseconds
	speak: function(pString, pDuration)
	{
		var volume = (O.Options.int_setVolume / T.cPERCENT_100).toFixed(2);
		 /* 
		  * Chrome-only TTS service, Google Speech Synthesis API:
		  * https://developers.google.com/web/updates/2014/01/Web-apps-that-talk---Introduction-to-the-Speech-Synthesis-API?hl=en
			var msg = new SpeechSynthesisUtterance();
			var voices = window.speechSynthesis.getVoices();
			msg.voice = voices[10]; // Note: some voices don't support altering params
			msg.voiceURI = "native";
			msg.volume = 1; // 0 to 1
			msg.rate = 1; // 0.1 to 10
			msg.pitch = 2; //0 to 2
			msg.text = "Hello World";
			msg.lang = "en-US";
			speechSynthesis.speak(msg);
		 */
		try
		{
			if (I.isSpeechSynthesisEnabled)
			{
				var msg = new SpeechSynthesisUtterance(pString);
				/*
				 * Chrome bug https://code.google.com/p/chromium/issues/detail?id=582455
				 * Workaround is to manually set the voice. When the bug is fixed, can
				 * just set only the lang property and have the voice set automatically.
				 */
				//msg.lang = O.LanguageMeta.ISOCode[O.Options.enu_Language];
				msg.voice = window.speechSynthesis.getVoices().filter(function(iVoice)
				{
					return iVoice.name === O.LanguageMeta.VoiceCode[O.Options.enu_Language];
				})[0];
				msg.volume = volume;
				msg.rate = 0.8;
				window.speechSynthesis.speak(msg);
				return;
			}
		}
		catch (e)
		{
			I.isSpeechSynthesisEnabled = false;
		}
		
		// If using other TTS service then use custom queue system
		var doSpeak = function(pStringMacro)
		{
			D.verifyNativeTTS(function()
			{
				if (I.isSpeechNativeLoaded)
				{
					// API: http://www.masswerk.at/mespeak/
					meSpeak.speak(pStringMacro, {volume: volume, speed: 150, variant: "f5"});
				}
				else
				{
					// API: http://responsivevoice.org/api/
					var tts = document.getElementById("jsTTSAudio");
					tts.src = U.URL_API.TextToSpeech + "&vol=" + volume + "&t=" + pStringMacro;
					tts.volume = volume;
					tts.load();
					tts.play();
				}
			});
		};
		
		if (pDuration === undefined || pDuration === null)
		{
			// If no duration is given, then estimate speech length
			var charspersecond = (D.isLanguageLogographic) ? 4 : 12;
			pDuration = 1 + (Math.round(pString.length / charspersecond));
		}
		
		var durationms = pDuration * T.cMSECONDS_IN_SECOND;
		if (D.speechWait === 0)
		{
			// If no speech in queue then speak and add queue time, finally subtract after duration
			D.speechWait += durationms;
			doSpeak(pString);
			setTimeout(function()
			{
				D.speechWait -= durationms;
			}, durationms);
		}
		else
		{
			// If speech in queue then wait added queue time, finally speak and subtract after duration
			D.speechWait += durationms;
			setTimeout(function()
			{
				if (D.speechWait > 0)
				{
					doSpeak(pString);
					D.speechWait -= durationms;
				}
			}, D.speechWait - durationms);
		}
		
		// Prevent the speech queue to be too long, reset if it is
		var secmaxspeechduration = 30;
		D.resetSpeechQueue(secmaxspeechduration);
	},
	isSpeaking: function()
	{
		if (D.speechWait === 0)
		{
			return false;
		}
		return true;
	},
	stopSpeech: function()
	{
		if (I.isSpeechSynthesisEnabled)
		{
			window.speechSynthesis.cancel();
		}
		else if (I.isSpeechNativeLoaded)
		{
			meSpeak.stop();
		}
		else
		{
			document.getElementById("jsTTSAudio").src = "";
		}
	},
	
	/*
	 * Stops speech if the wait time is over the threshold.
	 * @param int pSeconds threshold.
	 */
	resetSpeechQueue: function(pSeconds)
	{
		if (pSeconds === undefined)
		{
			pSeconds = 0;
		}
		
		if (D.speechWait > (pSeconds * T.cMSECONDS_IN_SECOND))
		{
			D.speechWait = 0;
			D.stopSpeech();
		}
	},
	
	
	/*
	 * Gets translation for given text to be spoken.
	 * @param string pText to lookup.
	 * @param string pModifier optional adjective or adverb.
	 * @returns string translated text or given text.
	 */
	getSpeechWord: function(pText, pModifier)
	{
		if (pModifier)
		{
			return D.getModifiedWord(pText, pModifier);
		}
		return D.getPhrase(pText);
	},
		
	/*
	 * Adds spaces to a string so each letter is spoken separately.
	 * "SoS" returns "S O S" but "Mag" returns "Mag" (no change).
	 * @param string pString.
	 * @returns string of period separated initials.
	 */
	getSpeechInitials: function(pString, pWantTrim)
	{
		// If the last character of the string is lowercase, then don't do anything
		var finalchar = pString.charAt(pString.length - 1);
		if (finalchar === finalchar.toLowerCase())
		{
			return pString;
		}
		// Otherwise make initials
		if (pWantTrim)
		{
			pString = pString.replace(/ /g, "");
		}
		pString = pString.toUpperCase();
		var str = "";
		var char = "";
		for (var i = 0; i < pString.length; i++)
		{
			char = pString.charAt(i);
			str += (char === " ") ? char : (char + " ");
		}
		return str;
	},
	
	/*
	 * Gets a phrase such as " in 1 minute" or " in 15 minutes".
	 * @param int pTime amount of time units.
	 * @param string pUnit of time.
	 * @returns string phrase.
	 */
	getPluralTime: function(pTime, pUnit)
	{
		if (pTime > 1)
		{
			pUnit += "s";
		}
		return " " + D.getWord("in") + " " + pTime + " " + D.getWord(pUnit);
	},
	
	/*
	 * Gets pronunciation of chain in opted language.
	 * @param object pChain to get.
	 * @returns string pronunciation.
	 */
	getChainPronunciation: function(pChain)
	{
		if (D.isLanguageDefault
			|| I.BrowserCurrent !== I.BrowserEnum.Chrome)
		{
			return C.Chains[pChain.nexus].pronunciation;
		}
		return D.getChainTitle(pChain);
	}
};
C = {
/* =============================================================================
 * @@Chains of events
 * ========================================================================== */
	/*
	 * http://gw2timer.com/data/chains.js initially holds an array of scheduled
	 * meta event chain objects, which themselves contain an array of their events.
	 * This is referred to by the variable "C.Chains". It will be added with
	 * unscheduled chains when the user opens that section on the chains page.
	 */
	Chains: GW2T_CHAIN_DATA,
	ChainAssociation: {},
	UnscheduledChainsLength: GW2T_CHAIN_ADD_LENGTH,
	DryTop: {},
	// The word and variable "nexus" is simply a chain's index number in the Chains array
	cIndexSynonym: "nexus",
	ChainToday: null,
	ChainTomorrow: null,
	ChainDummy: {alias: "dummy"},
	CurrentChainSD: {}, NextChainSD1: {}, NextChainSD2: {}, NextChainSD3: {}, NextChainSD4: {},
	CurrentChainHC: {}, NextChainHC1: {}, NextChainHC2: {}, NextChainHC3: {}, NextChainHC4: {},
	NextChainLS1: {}, NextChainLS2: {},
	NextChainsMS1: [], NextChainsMS2: [],
	CurrentChains: [],
	CurrentChainsSD: [],
	PreviousChains1: [],
	PreviousChains2: [],
	NextChains1: [],
	cEventCharLimit: 44,
	cEventCharLimitLogographic: 20,
	cEventNameWidth: 320,
	TempleChains: [],
	LegacyChains: [],
	UnscheduledChains: [],
	ScheduledChains: [], // Any scheduled chain
	RegularChains: [], // Scheduled world bosses
	MiscellaneousChains: [],
	DryTopChains: [],
	LivingStoryChains: [],
	ChainSeriesEnum:
	{
		Temple: 0, // Unscheduled Orr temples
		Legacy: 1, // Unscheduled chains that still gives a rare
		ScheduledCutoff: 2,
		Standard: 2, // Scheduled non-hardcore chains
		Hardcore: 3, // Scheduled challenging chains with a separate schedule from non-hardcores
		Miscellaneous: 4, // Any scheduled chains not already defined here
		WorldBossCuttoff: 4,
		DryTop: 5, // Scheduled Dry Top chains
		LivingStory: 6 // Seasonal events
	},
	EventPrimacyEnum:
	{
		Optional: 0, // A failure or optional subevent; includes temple retake event which should be ignored
		Normal: 1, // A concurrent (multiple simultaneous) event that does not take the longest to complete
		Primary: 2, // An only event at the time or a concurrent event that takes the longest to complete
		Boss: 3 // The boss event, also considered a primary event
	},
	isUnscheduledChainsLoaded: false,
	isDryTopGenerated: false,
	isDryTopIconsShown: false,
	isTimetableGenerated: false,
	isTouringAuto: true, // False when the program starts touring by itself, to prevent multiple touring calls
	isTouringManual: false, // True when the user ever moves the map
	
	/*
	 * Gets a chain from its alias.
	 * @param string pAlias.
	 * @returns object chain.
	 * @pre ChainAssociation object has the requested chain.
	 */
	getChainByAlias: function(pAlias)
	{
		return C.Chains[C.ChainAssociation[pAlias.toLowerCase()]];
	},
	getChainRegion: function(pChain)
	{
		if (pChain && pChain.zone)
		{
			return M.getZoneRegion(pChain.zone);
		}
		return null;
	},
	
	/*
	 * Gets the coordinate of the final event in the chain.
	 * @param object pChain.
	 * @returns GW2 coordinates.
	 */
	viewChainFinale: function(pChain)
	{
		if (I.isMapEnabled)
		{
			M.goToView(pChain.finalCoord, M.ZoomEnum.Ground, M.Pin.Event);
			C.isTouringManual = false;
		}
	},
	
	/*
	 * Tells if specified chain is today's daily world boss.
	 * @param object pChain to compare.
	 * @returns true if daily.
	 */
	isChainToday: function(pChain)
	{
		if (C.ChainToday && pChain.nexus === C.ChainToday.nexus)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Shows or hides the daily icon for today's boss depending on availability.
	 * @pre Used variables has been reinitialized.
	 */
	refreshChainDailyIcon: function()
	{
		// Reimage the waypoint icon if boss on clock is daily
		for (var i = 0; i < T.cNUM_TIMEFRAMES_IN_HOUR; i++)
		{
			if (C.isChainToday(C.CurrentChainsSD[i]))
			{
				(K["WpChain" + i]).addClass("clkWaypointDaily");
			}
			else
			{
				(K["WpChain" + i]).removeClass("clkWaypointDaily");
			}
		}

		// Chain bar
		$(".chnDaily").hide();
		if (C.ChainToday)
		{
			$(".chnDaily_" + C.ChainToday.nexus).show();
		}
		// Restyle timetable
		C.updateTimetable();
	},
	
	/*
	 * Tells if a chain is timed by the schedule.
	 * @param object pChain to check.
	 * @returns boolean true if scheduled else false.
	 */
	isChainScheduled: function(pChain)
	{
		if (pChain.series >= C.ChainSeriesEnum.ScheduledCutoff)
		{
			return true;
		}
		return false;
	},
	isChainWorldBoss: function(pChain)
	{
		if (pChain.series <= C.ChainSeriesEnum.WorldBossCuttoff)
		{
			return true;
		}
		return false;
	},
	isChainRegular: function(pChain)
	{
		if (pChain.series === C.ChainSeriesEnum.Standard ||
			pChain.series === C.ChainSeriesEnum.Hardcore ||
			pChain.series === C.ChainSeriesEnum.Miscellaneous ||
			pChain.series === C.ChainSeriesEnum.LivingStory)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Returns the substring before the delimiter in a chain alias.
	 * Used for reusing chain icons of different chains.
	 * @param string pAlias of the chain.
	 * @returns string common alias of the chain.
	 */
	parseChainAlias: function(pAlias)
	{
		if (pAlias.indexOf("_") !== -1)
		{
			return pAlias.split("_")[0];
		}
		return pAlias;
	},
	
	/*
	 * Gets the integer part of an event number, for example: "10A2" returns "10".
	 * @param string pNumber of the event.
	 * @returns string integer of the event.
	 */
	getEventStepNumber: function(pNumber)
	{
		if (pNumber.length === 1)
		{
			return pNumber;
		}
		else
		{
			var i;
			var integer = "";
			for (i = 0; i < pNumber.length; i++)
			{
				if (isFinite(pNumber.charAt(i)))
				{
					integer += pNumber.charAt(i);
				}
				else
				{
					return integer;
				}
			}
			return integer;
		}
	},
	
	/*
	 * Gets URL to wiki of an event.
	 * @param string pName of event.
	 * @param boolean pWantDefault
	 * @returns string.
	 */
	getEventWiki: function(pName, pWantDefault)
	{
		if (pName.indexOf(".") === pName.length - 1)
		{
			pName = pName.slice(0, -1);
		}
		return (pWantDefault) ? U.getWikiLinkDefault(pName) : U.getWikiLinkLanguage(pName);
	},

	/*
	 * Initializes the chain HTML plate with chains and their individual events.
	 * Calculates time sums for chains and pushes to array for later accessing by the ticker.
	 * @param object pChain chain to initialize.
	 * @pre Event number can only go from 1-9.
	 */
	initializeChain: function(pChain)
	{
		var i, ii;
		var event;
		var chainextra = "";
		var chainextrastr = "";
		var chainname = U.escapeHTML(D.getObjectName(pChain));
		pChain.waypointText = pChain.waypoint + " " + chainname;
		pChain.iconSrc = "img/chain/" + C.parseChainAlias(pChain.alias).toLowerCase() + I.cPNG;
		
		/*
		 * Initialize step attribute (the first number in an event
		 * number, as in "2" in "2A1"), will be used to access events HTML.
		 */
		for (i in pChain.events)
		{
			// Minus 1 because the event numbers are 1 indexed
			pChain.events[i].step = parseInt(C.getEventStepNumber(pChain.events[i].num)) - 1;
		}
		pChain.isSorted = false;
		pChain.primaryEvents = [];
		pChain.scheduleKeys = [];
		
		if (pChain.waypoint)
		{
			chainextra = "<input id='chnWaypoint_" + pChain.nexus + "' class='chnWaypoint' type='text' value='"
					+ pChain.waypointText + "' title='In-game waypoint chatcode.' />"
				+ "<a" + U.convertExternalAnchor(U.getWikiSearchDefault(pChain.title)) + ">"
					+ "<ins class='s16 s16_wiki' title='Click for Wiki guide.'></ins></a> "
				+ " (" + pChain.level + ")"
					+ "<a" + U.convertExternalAnchor(U.getYouTubeLink(D.getObjectDefaultName(pChain))) + ">"
					+ "<ins class='s16 s16_youtube' title='Recommended level. Click for YouTube videos.'></ins></a> ";
		}
		if (pChain.reward)
		{
			for (i in pChain.reward)
			{
				if (i === "coin")
				{
					chainextra += E.formatCoinStringShort(pChain.reward[i]);
				}
				else
				{
					chainextra += pChain.reward[i] + "<ins class='s16 s16_" + i + "' title='" + i + "'></ins> ";
				}
			}
		}
		if (chainextra.length)
		{
			chainextrastr = "<div class='chnDetailsExtra'>"
				+ chainextra
				+ "<kbd id='chnDelete_" + pChain.nexus + "' class='chnDelete' "
					+ "title='Permanently hide this event chain (can undo in <img src=img/ui/menu/alarm.png /> menu above).'></kbd>"
			+ "</div>";
		}
		
		/*
		 * A chain bar (HTML) is a rectangle that contains the event chain icon,
		 * chain title, time, individual events listed, and other elements.
		 * Lots of CSS IDs and classes here, so update if the CSS changed.
		 */
		$(pChain.htmllist).append(
		"<div id='chnBar_" + pChain.nexus + "' class='chnBar'>"
			+ "<div class='chnTitle'>"
				+ "<img id='chnIcon_" + pChain.nexus + "' src='" + pChain.iconSrc + "' />"
				+ "<kbd id='chnCheck_" + pChain.nexus + "' class='chnCheck'></kbd>"
				+ "<h1 id='chnTitle_" + pChain.nexus + "'>" + chainname + "</h1>"
				+ "<time id='chnTime_" + pChain.nexus + "' class='chnTimeFutureFar'></time>"
				+ "<aside><img class='chnDaily chnDaily_" + pChain.nexus + "' src='img/ui/daily.png' /></aside>"
			+ "</div>"
			+ "<div id='chnDetails_" + pChain.nexus + "' class='chnDetails'>"
				+ "<ol id='chnEvents_" + pChain.nexus + "' class='chnEvents'></ol>"
				+ chainextrastr
			+ "</div>"
		+ "</div>");

		/*
		 * Inserts an event with icon and necessary indentation into the ol.
		 * @param object pChain to get chain info.
		 * @param object pEvent to extract information.
		 */
		var insertEventToBarHTML = function(pChain, pEvent)
		{
			var e = pEvent;
			var b = "&lt;br /&gt;";
			var w = function(pS)
			{
				return "&lt;dfn&gt;" + pS + "&lt;/dfn&gt;";
			};
			// Tooltip when user hovers over the tiny orange event icon
			var eventhtmltitle = "";
			if (pChain.series === C.ChainSeriesEnum.DryTop)
			{
				eventhtmltitle = w("Event Number: ") + e.num + b
					+ w("Start Time: ") + e.lim + b
					+ b + "&amp;quot;" + D.getObjectName(e).replace(/["']/g, "") + "&amp;quot;";
			}
			else
			{
				eventhtmltitle = w("Event Number: ") + e.num + b
					+ w("If Success Go To: ") + e.sGotoNum + b
					+ w("If Failure Go To: ") + e.fGotoNum + b
					+ w("If Success Wait: ") + e.sInterim + b
					+ w("If Failure Wait: ") + e.fInterim + b
					+ w("Time Limit: ") + e.lim + b
					+ w("Avg to Complete: ") + e.avg + b
					+ w("Min to Complete: ") + e.min + b
					+ w("Max to Complete: ") + e.max + b
					+ b + "&amp;quot;" + D.getObjectName(e).replace(/["']/g, "") + "&amp;quot;";
			}
			
			var classsubstep = "";
			var eventnamelimit = C.cEventCharLimit;
			var indentEvent = function()
			{
				classsubstep = "chnSubstep";
				eventnamelimit = C.cEventCharLimit - 4;
			};
			
			/*
			 * Indent concurrent events, except the first one in the step.
			 * For example: events numbered 1A1 1A2 1B1 1B2; 1A1 and 1B1 happens
			 * at the same time. For simplicity, indent all events starting with
			 * "1" except 1A1. Events numbered like 1A 1B are short for 1A1 1B1.
			 */
			// If the event number is an integer without concurrent letters
			var step = C.getEventStepNumber(e.num);
			if (step.length !== e.num.length)
			{
				var subnum = e.num.slice(step.length);
				if (e.num.indexOf(".") !== -1) // Always indent failure events
				{
					indentEvent();
				}
				else if (e.num.length === 2)
				{
					if (subnum.indexOf("A") === -1 && subnum.indexOf("a") === -1)
					{
						indentEvent();
					}
				}
				else if (subnum.indexOf("A1") === -1 && subnum.indexOf("a1") === -1)
				{
					indentEvent();
				}
			}
			$("#chnEvents_" + pChain.nexus).append(
			"<li id='chnEvent_" + pChain.nexus + "_" + e.num + "' class='chnStep_" + pChain.nexus + "_" + e.step + " " + classsubstep + "'>"
				+ "<ins class='evt_" + e.icon + "' title='" + eventhtmltitle + "'></ins>"
				+ "<span>" + U.truncateString(D.getObjectName(e), eventnamelimit, "..") + "</span>"
			+ "</li>");
		};

		/*
		 * Initialize the chain by summing its events' min/avg/max times.
		 * The primary event array holds events temporally significant to the chain.
		 * For example: the "1A destroy chaotic materials" and "1B escort Rooba"
		 * events happen at the same time so they share the same first event
		 * number (the "step" number), but "escort Rooba" is considered primary
		 * because it takes the longest. Each event gets the three new time
		 * variables equalling how far into the chain they are.
		 */
		for (i in pChain.events)
		{
			event = pChain.events[i];
			if (event.primacy === C.EventPrimacyEnum.Primary)
			{
				pChain.primaryEvents.push(event);
			}
			else if (event.primacy === C.EventPrimacyEnum.Boss)
			{
				pChain.primaryEvents.push(event);
				// 0 because the first primary event does not have precedents
				pChain.primaryEvents[0].minSum = 0;
				pChain.primaryEvents[0].avgSum = 0;
				pChain.primaryEvents[0].minavgSum = 0;
				break;
			}
		}
		for (i = 1; i < pChain.primaryEvents.length; i++)
		{
			/*
			 * iterated event's xxxSum = the previous primary event's xxx time
			 *		+ the previous primary event's success interim
			 *		+ the previous primary event's xxxSum;
			 */
			var previoussuccessinterim = T.parseEventTime(pChain.primaryEvents[i-1].sInterim[0]);

			pChain.primaryEvents[i].minSum = T.parseEventTime(pChain.primaryEvents[i-1].min)
				+ previoussuccessinterim + pChain.primaryEvents[i-1].minSum;
			pChain.primaryEvents[i].avgSum = T.parseEventTime(pChain.primaryEvents[i-1].avg)
				+ previoussuccessinterim + pChain.primaryEvents[i-1].avgSum;
			// minavgSum = minSum + (avgSum - minSum)/2;
			pChain.primaryEvents[i].minavgSum = pChain.primaryEvents[i].minSum
				+ ~~(Math.abs(pChain.primaryEvents[i].avgSum - pChain.primaryEvents[i].minSum) / 2);
		}
		/*
		 * min time for the entire chain to finish is the final primary event's
		 * minSum plus the final primary event's min.
		 * Note that i was post-incremented in the for loop after exiting.
		 */
		i--;
		pChain.minFinish = pChain.primaryEvents[i].minSum
			+ T.parseEventTime(pChain.primaryEvents[i].min);
		pChain.avgFinish = pChain.primaryEvents[i].avgSum
			+ T.parseEventTime(pChain.primaryEvents[i].avg);
		pChain.minavgFinish = pChain.minFinish + ~~(Math.abs(pChain.avgFinish - pChain.minFinish)/2);
		
		/*
		 * Now with an array of primary events created, link the non-primary
		 * events and create HTML elements so they can be displayed in totality.
		 */
		ii = 0;
		// Unscheduled events don't need queued accessing
		if ( ! C.isChainScheduled(pChain))
		{
			for (i in pChain.events)
			{
				insertEventToBarHTML(pChain, pChain.events[i]);
			}
		}
		else // Scheduled events need to remember concurrent events
		{
			for (i in pChain.events)
			{
				// Ignore failure events and optional defense events
				if (pChain.events[i].primacy !== C.EventPrimacyEnum.Optional)
				{
					// Compare the first character of their event number
					if (C.getEventStepNumber(pChain.events[i].num)
						!== C.getEventStepNumber(pChain.primaryEvents[ii].num))
					{
						ii++;
					}
					/*
					 * Each primary event has references to their concurrent
					 * events, which will later be used to highlight them.
					 */ 
					insertEventToBarHTML(pChain, pChain.events[i]);
				}
				// If reached the boss event (which has been added), then stop looping
				if (pChain.events[i].primacy === C.EventPrimacyEnum.Boss)
				{
					break;
				}
			}
		}
		
		// Toggles the chain details when clicked on the chain title
		if (I.ModeCurrent !== I.ModeEnum.Tile)
		{
			$("#chnTitle_" + pChain.nexus).click(function(pEvent)
			{
				if (pEvent.which === I.ClickEnum.Left)
				{
					$(this).parent().next().slideToggle(100, function()
					{
						I.updateScrollbar($(this));
					});
				}
			});
			$("#chnDetails_" + pChain.nexus).hide();
		}
		// Clipboard behavior
		$("#chnDetails_" + pChain.nexus + " .chnWaypoint").each(function()
		{
			I.bindClipboard($(this), $(this).val());
		}).click(function()
		{
			$(this).select();
		});
		
		// Initialize tooltips
		I.qTip.init($("#chnDetails_" + pChain.nexus + " ins"));
		I.qTip.init($("#chnDetails_" + pChain.nexus + " kbd"));
		
		// Finally intialize its checklist state
		X.initializeChainChecklist(pChain);
		
	}, // End of initializeChain()

	/*
	 * Categorizes and initializes scheduled chains, which are already in the
	 * main chains array.
	 */
	initializeScheduledChains: function()
	{
		var chain;
		var length = C.Chains.length;
		for (var i = 0; i < length; i++)
		{
			// Unschedule chains will be initialized when their headers are clicked on
			chain = C.Chains[i];
			chain.nexus = i;
			C.ChainAssociation[(chain.alias.toLowerCase())] = chain.nexus;

			switch (chain.series)
			{
				case C.ChainSeriesEnum.Standard:
				{
					chain.htmllist = "#sectionChains_Scheduled";
					C.RegularChains.push(chain);
					C.ScheduledChains.push(chain);
				} break;
				case C.ChainSeriesEnum.Hardcore:
				{
					chain.htmllist = "#sectionChains_Scheduled";
					C.RegularChains.push(chain);
					C.ScheduledChains.push(chain);
				} break;
				case C.ChainSeriesEnum.DryTop:
				{
					chain.htmllist = "#sectionChains_Drytop";
					C.DryTopChains.push(chain);
					C.ScheduledChains.push(chain);
				} break;
				case C.ChainSeriesEnum.Miscellaneous:
				{
					if (chain.flags.isSpecial)
					{
						chain.htmllist = "#sectionChains_Special";
					}
					else
					{
						chain.htmllist = "#sectionChains_Scheduled";
					}
					C.MiscellaneousChains.push(chain);
					C.RegularChains.push(chain);
					C.ScheduledChains.push(chain);
				} break;
				case C.ChainSeriesEnum.LivingStory:
				{
					if (H.isStoryEnabled)
					{
						// Show Living Story events on the chains panel if the dashboard is not visible
						if (H.isStoryDashboard)
						{
							chain.htmllist = "#dsbStory";
						}
						else
						{
							chain.htmllist = "#sectionChains_Scheduled";
						}
						C.LivingStoryChains.push(chain);
						C.RegularChains.push(chain);
						C.ScheduledChains.push(chain);
					}
					else
					{
						continue;
					}
				} break;
			}
			C.initializeChain(chain);
		}
	},
	
	/*
	 * Loads the unscheduled chains data then categorizes and initializes them.
	 */
	initializeUnscheduledChains: function()
	{
		if (C.isUnscheduledChainsLoaded === false)
		{
			U.getScript(U.URL_DATA.Unscheduled, function()
			{
				if (C.isUnscheduledChainsLoaded)
				{
					return;
				}
				
				// Add them to the main chains array
				var unscheduledchains = GW2T_CHAIN_UNSCHEDULED;
				var oldlength = C.Chains.length;
				for (var i = 0; i < unscheduledchains.length; i++)
				{
					C.Chains.push(unscheduledchains[i]);
				}
				
				// Initialize them
				var chain;
				var newlength = C.Chains.length;
				for (var i = oldlength; i < newlength; i++)
				{
					chain = C.Chains[i];
					chain.nexus = i;

					switch (chain.series)
					{
						case C.ChainSeriesEnum.Temple:
						{
							chain.htmllist = "#sectionChains_Temple";
							C.TempleChains.push(chain);
							C.UnscheduledChains.push(chain);
						} break;
						case C.ChainSeriesEnum.Legacy:
						{
							chain.htmllist = "#sectionChains_Legacy";
							C.LegacyChains.push(chain);
							C.UnscheduledChains.push(chain);
						} break;
					}
					C.initializeChain(chain);
					P.drawChainPaths(chain);
				}
				C.isUnscheduledChainsLoaded = true;
			});
		}
	},
	
	/*
	 * Tells if a chain is active on the chain bars list.
	 * @param object pChain to verify.
	 * @returns boolean current or not.
	 */
	isChainCurrent: function(pChain)
	{
		for (var i in C.CurrentChains)
		{
			if (pChain.nexus === C.CurrentChains[i].nexus)
			{
				return true;
			}
		}
		return false;
	},
	
	/*
	 * Tells if a chain check state is intact (not checked off or deleted).
	 * @param object pChain to get state.
	 * @returns boolean unchecked or not.
	 */
	isChainUnchecked: function(pChain)
	{
		if (X.getChainChecklistState(pChain) === X.ChecklistEnum.Unchecked)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Tells if a chain bar is expanded by reading the details child element.
	 * @param object pChain to get the bar.
	 * @returns boolean shown or not.
	 */
	isChainSubscribed: function(pChain)
	{
		if (X.getChecklistItem(X.Checklists.ChainSubscription, pChain.nexus) ===
			X.ChecklistEnum.Checked)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Updates the time in the chain bars for all chains.
	 * @pre scheduleKeys array is sorted and first element is the soonest.
	 */
	updateChainsTimeHTML: function()
	{
		var i;
		var ithchain;
		var countdownstr, timestr;
		var delayseconds;
		
		var subscribetext = "<dfn>" + D.getPhraseTitle("click to <br/> subscribe") + "</dfn><br />";
		
		for (i in C.ScheduledChains)
		{
			ithchain = C.ScheduledChains[i];
			// Chains that don't start at the quarters of an hour can have the displayed time adjusted
			delayseconds = (ithchain.flags.minuteDelay) ? ithchain.flags.minuteDelay * T.cSECONDS_IN_MINUTE : 0;
			// Update the title tootlip with that chain's schedule
			var minischedulestring = "";
			var spacer;
			if (ithchain.series !== C.ChainSeriesEnum.DryTop)
			{
				for (var ii in ithchain.scheduleKeys)
				{
					spacer = (parseInt(ii) === 0) ? subscribetext : " <br /> ";
					minischedulestring = minischedulestring + spacer
						+ T.getTimeFormatted(
						{
							aWantSeconds: false,
							aCustomTimeInSeconds: T.convertScheduleKeyToLocalSeconds(
								ithchain.scheduleKeys[ii]) + delayseconds
						});
				}
				$("#chnTime_" + ithchain.nexus).prop("title", minischedulestring);
			}

			// Update inactive chains' displayed time
			if (C.isChainCurrent(ithchain) === false)
			{
				var symbol = "";
				var wantneg = (ithchain.flags.minuteDelay < 0) ? true : false;
				countdownstr = T.getTimeFormatted(
				{
					aWantLetters: true,
					aWantSeconds: false,
					aWantNegative: wantneg,
					aCustomTimeInSeconds: T.getSecondsUntilChainStarts(ithchain) + delayseconds
				});
				if (wantneg && countdownstr.indexOf(I.Symbol.Negative) !== -1)
				{
					symbol = I.Symbol.StateActive + " ";
				}
				timestr = T.getTimeFormatted(
				{
					aWantLetters: false,
					aWantSeconds: false,
					aCustomTimeInSeconds: T.convertScheduleKeyToLocalSeconds(ithchain.scheduleKeys[0]) + delayseconds
				});

				$("#chnTime_" + ithchain.nexus).html(
					symbol + countdownstr + "<br />" + "<sup>" + timestr + "</sup>"
				);
			}
		}
		
		// Rebind tooltips for the time elements because they were updated
		I.qTip.init(".chnTitle time");
	},
	
	/*
	 * Updates the current chain bar's time as a countdown until the chain is
	 * predicted to finish, or until the next chain starts if finished.
	 * To be called every 1 second.
	 */
	updateCurrentChainTimeHTML: function(pChain)
	{
		var elapsed = T.getCurrentTimeframeElapsedTime();
		var remaining = pChain.countdownToFinish - elapsed;
		var delayminutes = pChain.flags.minuteDelay;
		var delayremaining;
		var elm = $("#chnTime_" + pChain.nexus);
		var time = remaining;
		var timestr;
		var signstr = I.Symbol.StateActive + " ";
		
		if (pChain.series === C.ChainSeriesEnum.DryTop && C.isDryTopGenerated)
		{
			// Dry Top events
			var currentframe = T.getDryTopMinute();
			var nextframe = T.getDryTopMinute(1);
			timestr = T.getTimeFormatted(
			{
				aReference: T.ReferenceEnum.UTC,
				aWant24: true,
				aWantHours: false
			});
			
			var zerostr = (currentframe < T.cBASE_10) ? "0" : "";
			elm.html(":" + currentframe + " (:" + zerostr + timestr + ")");
			if (C.isDryTopIconsShown)
			{
				var colorprefix0 = "<var style='color:" + T.getCurrentDryTopColor() + "'>";
				var colorprefix1 = "<var style='color:" + T.getCurrentDryTopColor(1) + "'>";
				$("#mapDryTopTimer").html(
					colorprefix0 + ":" + currentframe + " (:" + zerostr + timestr + ") </var>" + colorprefix1 + ":" + nextframe + "</var><br />"
					+ colorprefix0 + D.getWord("now") + " →</var> " + colorprefix1 + D.getWord("next") + "</var>");
			}
		}
		else
		{
			// Other scheduled chains
			if (delayminutes)
			{
				delayremaining = (delayminutes * T.cSECONDS_IN_MINUTE) - elapsed;
				if (delayremaining > 0)
				{
					time = delayremaining;
					signstr = I.Symbol.StateWaiting + " ";
				}
			}
			if (remaining <= 0)
			{
				time = T.cSECONDS_IN_TIMEFRAME - elapsed;
				signstr = I.Symbol.StateInactive + " " + I.Symbol.Negative;
			}
			timestr = T.getTimeFormatted(
			{
				aWantLetters: true,
				aCustomTimeInSeconds: time
			});
			elm.html(signstr + timestr);
		}
	},
	
	/*
	 * Creates a list similar to the schedule chains HTML list but with bare
	 * chain titles and static schedule time.
	 */
	initializeTimetableHTML: function()
	{
		if (C.isTimetableGenerated === false)
		{
			return;
		}
		
		$("#sectionChains_Timetable").empty(); // This makes the function reuseable
		var i, ii;
		var chains;
		var ithchain;
		var timestring;
		for (i in T.Schedule)
		{
			chains = T.getScheduleSlotChainsByKey(i);
			for (ii in chains)
			{
				ithchain = chains[ii];
				// Only generate chain bars for these types
				if ((ithchain.series !== C.ChainSeriesEnum.Standard
					&& ithchain.series !== C.ChainSeriesEnum.Hardcore
					&& ithchain.series !== C.ChainSeriesEnum.Miscellaneous)
					|| ithchain.flags.isSpecial)
				{
					break;
				}
				
				timestring = T.getTimeFormatted(
				{
					aWantSeconds: false,
					aCustomTimeInSeconds: T.convertScheduleKeyToLocalSeconds(i)
				});

				$("#sectionChains_Timetable").append(
				"<div class='chnSlot chnSlotTime_" + i + " chnSlot_" + ithchain.nexus + "' data-" + C.cIndexSynonym + "='" + ithchain.nexus + "' data-timeframe='" + i + "'>"
					+ "<div class='chnTitle'>"
						+ "<img src='" + ithchain.iconSrc + "' />"
						+ "<kbd class='chnCheck'></kbd>"
						+ "<h1>" + D.getObjectName(ithchain) + "</h1>"
						+ "<time>" + timestring + "</time>"
						+ "<aside><img class='chnDaily chnDaily_" + ithchain.nexus + "' src='img/ui/daily.png' /></aside>"
					+ "</div>"
				+ "</div>");
			}
		}
		// Set slot visual state as stored in checklist
		for (var i in C.RegularChains)
		{
			ithchain = C.RegularChains[i];
			var slots = $(".chnSlot_" + ithchain.nexus);
			var checks = slots.find(".chnCheck");
			var times = slots.find("time");
			X.reapplyChainBarState(ithchain.nexus, slots, checks, times);
		}
		// Hover on chain slot highlight same bosses
		$(".chnTitle h1").hover(
			function() { $(".chnSlot_" + $(this).parent().parent().data(C.cIndexSynonym)).addClass("chnBarHover"); },
			function() { $(".chnSlot").removeClass("chnBarHover"); }
		);
		// Mimic check off function
		$(".chnSlot .chnCheck").click(function()
		{
			$("#chnCheck_" + C.Chains[$(this).parent().parent().data(C.cIndexSynonym)].nexus).trigger("click");
		});
		// Mimic subscription function
		$(".chnSlot time").click(function()
		{
			$("#chnTime_" + C.Chains[$(this).parent().parent().data(C.cIndexSynonym)].nexus).trigger("click");
		});
		// Special color of the reset time slot
		$(".chnSlotTime_0").addClass("chnBarReset");
		C.refreshChainDailyIcon();
	},
	
	/*
	 * Puts the past chains behind the current chain slots.
	 */
	updateTimetable: function()
	{
		if (C.isTimetableGenerated === false)
		{
			return;
		}
		
		var previousframe = T.getTimeframeKey(-1);
		var currentframe = T.getTimeframeKey();
		var nextframe = T.getTimeframeKey(1);
		// Also highlight timetable chain bar
		$(".chnSlotTime_" + previousframe)
			.removeClass("chnBarCurrent");
		$(".chnSlotTime_" + currentframe)
			.addClass("chnBarCurrent");
		// Current chain title
		$(".chnSlotTime_" + previousframe + " .chnTitle h1")
			.removeClass("chnTitleCurrent");
		$(".chnSlotTime_" + currentframe + " .chnTitle h1")
			.removeClass("chnTitleFuture").addClass("chnTitleCurrent");
		// Future chain title
		$(".chnSlotTime_" + nextframe + " .chnTitle h1")
			.addClass("chnTitleFuture");
		
		// Move the past time slots to the bottom, so the current slot(s) is always the top
		var currenttimeframe = T.getCurrentTimeframe();
		$(".chnSlot").each(function()
		{
			if (T.convertScheduleKeyToUTCMinutes($(this).data("timeframe")) < currenttimeframe)
			{
				$(this).appendTo("#sectionChains_Timetable");
			}
			else
			{
				// Break out of this each loop since the arranging is done
				return false;
			}
		});
		
		// Hide daily world boss beyond today's reset
		if (C.ChainToday)
		{
			$("#sectionChains_Timetable .chnDaily_" + C.ChainToday.nexus).each(function()
			{
				if (T.convertScheduleKeyToUTCMinutes($(this).closest(".chnSlot").data("timeframe")) < currenttimeframe)
				{
					$(this).hide();
				}
			});
		}
	},

	/*
	 * Sorts the scheduled chains list in the chains plate. This is
	 * called by the ticker every timeframe.
	 */
	sortChainsListHTML: function()
	{
		var numchainssorted = 0;
		var numchainstosort = C.ScheduledChains.length;
		var i = 0;
		var ii = 0;
		var chains;
		var ithchain;
		/*
		 * Look at the schedule and start with the current active chain; move
		 * that chain's HTML to the bottom of the HTML chains list, then look at
		 * the next (and so on), if it is not already sorted then also move it
		 * to the bottom. This loop stops when all scheduled events have been
		 * sorted as soonest at the top and latest at the bottom.
		 * Note that there will be timeframe gaps in the list because only the
		 * soonest chain will be sorted and later repeats of the chain are ignored.
		 */
		while (numchainssorted < numchainstosort)
		{
			chains = T.getTimeframeChains(i);
			for (ii in chains)
			{
				if (numchainssorted >= numchainstosort)
				{
					break;
				}
				
				ithchain = chains[ii];
				if (ithchain.isSorted === false)
				{
					$("#chnBar_" + ithchain.nexus).appendTo(ithchain.htmllist);
					
					ithchain.isSorted = true;
					ithchain.scheduleKeyImmediate = T.getTimeframeKey(i);
					numchainssorted++;
				}
			}
			i++;
		}
		
		for (i in C.ScheduledChains)
		{
			ithchain = C.ScheduledChains[i];
			// Reset the sorted boolean (important, else infinite loop)
			ithchain.isSorted = false;
			
			/*
			 * scheduleKeys is an array of keys to the schedule for when that
			 * chain starts. Circularly shift the array so that the soonest
			 * index is first--by concatenating the two slices of the array
			 * using that found index.
			 */
			for (ii in ithchain.scheduleKeys)
			{
				if (ithchain.scheduleKeys[ii] === ithchain.scheduleKeyImmediate)
				{
					ithchain.scheduleKeys = 
						(ithchain.scheduleKeys.slice(ii, ithchain.scheduleKeys.length))
							.concat(ithchain.scheduleKeys.slice(0, ii));
					break;
				}
			}
		}
		// Update chain time HTML
		C.updateChainsTimeHTML();
		
		/*
		 * Now that the chains are sorted, do cosmetic updates.
		 */
		var currentchainids = {};
		for (i in C.CurrentChains)
		{
			ithchain = C.CurrentChains[i];
			currentchainids[ithchain.nexus] = ithchain.nexus;
			// Highlight
			$("#chnBar_" + ithchain.nexus).addClass("chnBarCurrent");
			// Show the events (details)
			if (C.isChainUnchecked(ithchain))
			{
				if (O.Options.bol_expandWB && (I.ModeCurrent !== I.ModeEnum.Tile))
				{
					$("#chnDetails_" + ithchain.nexus).show("fast", function()
					{
						I.updateScrollbar();
					});
				}
			}
			
			// Style the title and time
			$("#chnBar_" + ithchain.nexus + " h1").first()
				.removeClass("chnTitleFuture chnTitleFutureFar").addClass("chnTitleCurrent");
			$("#chnBar_" + ithchain.nexus + " time").first()
				.removeClass("chnTimeFuture chnTimeFutureFar").addClass("chnTimeCurrent");
		}

		for (i in C.PreviousChains1)
		{
			ithchain = C.PreviousChains1[i];
			if (currentchainids[ithchain.nexus] === ithchain.nexus)
			{
				continue;
			}
			// Still highlight the previous chain bar but collapse it
			$("#chnBar_" + ithchain.nexus)
				.removeClass("chnBarCurrent").addClass("chnBarPrevious");
			// Hide previous chains if opted to automatically expand before
			if (O.Options.bol_collapseChains && (I.ModeCurrent !== I.ModeEnum.Tile))
			{
				$("#chnDetails_" + ithchain.nexus).hide();
			}
			
			// Style the title and time
			$("#chnBar_" + ithchain.nexus + " h1").first()
				.removeClass("chnTitleCurrent").addClass("chnTitleFutureFar");
			$("#chnBar_" + ithchain.nexus + " time").first()
				.removeClass("chnTimeCurrent").addClass("chnTimeFutureFar");
		}
		
		for (i in C.PreviousChains2)
		{
			ithchain = C.PreviousChains2[i];
			if (currentchainids[ithchain.nexus] === ithchain.nexus)
			{
				continue;
			}
			// Stop highlighting the previous previous chain bar
			$("#chnBar_" + ithchain.nexus).removeClass("chnBarPrevious");
		}
		
		for (i in C.NextChains1)
		{
			ithchain = C.NextChains1[i];
			if (currentchainids[ithchain.nexus] === ithchain.nexus)
			{
				continue;
			}
			// Style the title and time
			$("#chnBar_" + ithchain.nexus + " h1").first()
				.removeClass("chnTitleFutureFar").addClass("chnTitleFuture");
			$("#chnBar_" + ithchain.nexus + " time").first()
				.removeClass("chnTimeFutureFar").addClass("chnTimeFuture");
		}
	},
	
	/*
	 * minSum avgSum and minavgSum are the seconds since a chain began that
	 * an event of it starts. Because the time a chain starts is known, these
	 * statistical times can be used to predict when events happen and end.
	 * @param object pChainOuter to queue.
	 * @pre The sum statistics have been computed. Chains list has been sorted.
	 */
	queueEventsHighlight: function(pChainOuter)
	{
		var i;
		var chain = pChainOuter;
		var elapsed = T.getCurrentTimeframeElapsedTime();
		var wait;
		var hasfoundcurrentprimaryindex = false;
		
		/*
		 * If the user just loaded in instead of transitioning at a timeframe.
		 */
		if (elapsed > 0)
		{
			// Find the current active event and highlight it
			for (i in chain.primaryEvents)
			{
				/*
				 * For an event to be active, its start time (xxxSum) should be 
				 * <= the elapsed time, and the next event's start time
				 * should be > the elapsed time.
				 */
				wait = C.getSumBasedOnOptions(chain, i);
				if (wait >= elapsed)
				{
					if (i > 0) // Disregard the first event in the chain
					{
						C.highlightEvents(chain, parseInt(i-1));
						hasfoundcurrentprimaryindex = true;
						break;
					}
				}
			}
			/*
			 * Finished scanning the array but couldn't find active event in it,
			 * now compare with the final event's finish time.
			 */
			if (hasfoundcurrentprimaryindex === false)
			{
				wait = C.getSumBasedOnOptions(chain, -1);
				if (wait >= elapsed)
				{
					C.highlightEvents(chain, i); // Final event in progress
				}
				else
				{
					C.highlightEvents(chain, -1); // Final event finished
				}
			}
		}
		
		/*
		 * Queue the highlighting of events using setTimeout. Events that had
		 * already happened (elapsed time is greater than their start time)
		 * are ignored, and the future events are offsetted by the elapsed.
		 */
		for (i in chain.primaryEvents)
		{
			wait = C.getSumBasedOnOptions(chain, i);
			if (wait >= elapsed)
			{
				wait = wait - elapsed;
				setTimeout((function(iChain, iPrimaryEventIndex)
				{
					// Have to use this clunky nesting else the timeout gets the last iterator
					return function()
					{
						C.highlightEvents(iChain, iPrimaryEventIndex);
					};
				})(chain, parseInt(i)), wait * T.cMSECONDS_IN_SECOND);
			}
		}
		
		// Queued all the events' start, now queue when the chain finishes
		wait = C.getSumBasedOnOptions(chain, -1);
		if (wait >= elapsed)
		{
			wait = wait - elapsed;
			setTimeout((function(iChain)
			{
				return function()
				{
					C.highlightEvents(iChain, -1);
				};
			})(chain), wait * T.cMSECONDS_IN_SECOND);
		}
	},
	
	/*
	 * Does cosmestic effects to event names as they transition and view the
	 * event on the map. Also shows/hides Dry Top event icons.
	 * Also plays the alarm if it is the final event finishing.
	 * @param object pChain to read from.
	 * @param int pPrimaryEventIndex of the current active event.
	 * @pre Events HTML is generated and map is loaded.
	 */
	highlightEvents: function(pChain, pPrimaryEventIndex)
	{
		var i;
		var animationspeed = 500;
		var eventnamewidth = C.cEventNameWidth;
		var finalstep = pChain.primaryEvents.length - 1;
		var event;
		var isregularchain = C.isChainRegular(pChain);
		
		// Hide past events' markers
		if (pChain.series === C.ChainSeriesEnum.DryTop && C.isDryTopGenerated)
		{
			P.LayerArray.DryTopActive = null;
			P.LayerArray.DryTopActive = [];
			if (C.isDryTopIconsShown)
			{
				for (i in pChain.events)
				{
					event = pChain.events[i];
					M.toggleLayer(event.eventicon, false);
					M.toggleLayer(event.eventring, false);
				}
			}
		}
		
		// Do event highlights, -1 means the final event's finish time
		if (pPrimaryEventIndex > -1)
		{
			pChain.CurrentPrimaryEvent = pChain.primaryEvents[pPrimaryEventIndex];
			
			// Recolor past events
			for (i = 0; i < pPrimaryEventIndex; i++)
			{
				$(".chnStep_" + pChain.nexus + "_" + i)
					.removeClass("chnEventCurrent");
			}
			$(".chnStep_" + pChain.nexus + "_" + (pPrimaryEventIndex - 1))
				.css({opacity: 1}).animate({opacity: 0.5}, animationspeed,
				function()
				{
					if (pChain.series === C.ChainSeriesEnum.DryTop)
					{
						// Also hide the past events after fading if it is Dry Top events
						$(this).hide();
					}
				});
			
			// Recolor current events and animate transition
			$(".chnStep_" + pChain.nexus + "_" + pPrimaryEventIndex).each(function()
			{
				$(this).removeClass("chnEventFuture").addClass("chnEventCurrent").show()
					.css({width: 0, opacity: 0.5}).animate({width: eventnamewidth, opacity: 1}, animationspeed)
					.css({width: "auto"});
				// Also show current events' markers
				if (pChain.series === C.ChainSeriesEnum.DryTop && C.isDryTopGenerated)
				{
					event = pChain.events[$(this).attr("data-eventindex")];
					if (I.isMapEnabled)
					{
						// Add active events to iterable array
						P.LayerArray.DryTopActive.push(event.eventicon);
						P.LayerArray.DryTopActive.push(event.eventring);
						// Show active Dry Top events
						if (C.isDryTopIconsShown)
						{
							M.toggleLayerArray(P.LayerArray.DryTopActive, true);
						}
						P.rebindMarkerTooltips();
					}
				}
			});
		
			// Recolor future events
			if (pPrimaryEventIndex < pChain.primaryEvents.length)
			{
				for (i = (pPrimaryEventIndex + 1); i < pChain.primaryEvents.length; i++)
				{
					$(".chnStep_" + pChain.nexus + "_" + i).show()
						.removeClass("chnEventCurrent").addClass("chnEventFuture");
				}
			}
			
			// Tour to the event on the map if opted
			if (P.wantTourPrediction() && M.isMapAJAXDone
				&& C.isChainUnchecked(pChain) && isregularchain && !pChain.flags.isSpecial)
			{
				if (C.isTouringAuto && C.isTouringManual === false)
				{
					C.isTouringAuto = false;
					$("#chnEvent_" + pChain.nexus + "_" + pChain.CurrentPrimaryEvent.num).trigger("click");
					// Prevent simultaneous touring, which would waste bandwidth from downloading unseen map tiles
					setTimeout(function()
					{
						C.isTouringAuto = true;
					}, 1000);
				}
			}
			
			// If the final event is just starting, alert if opted
			if (pPrimaryEventIndex === finalstep && O.Options.bol_alertArrival && isregularchain)
			{
				if ((O.Options.int_setAlarm === O.IntEnum.Alarm.Checklist
						&& C.isChainUnchecked(pChain) && !pChain.flags.isSpecial)
					|| (O.Options.int_setAlarm === O.IntEnum.Alarm.Subscription
						&& C.isChainSubscribed(pChain) && C.isChainUnchecked(pChain)))
				{
					D.speak(D.getChainPronunciation(pChain) + " " + D.getSpeechWord("arrival predicted"));
				}
			}
		}
		else // Finish time
		{
			pChain.CurrentPrimaryEvent = pChain.primaryEvents[finalstep];
			
			// Recolor all events
			$("#chnEvents_" + pChain.nexus + " li").show()
				.removeClass("chnEventCurrent");
			// Recolor current (final) events as past
			$(".chnStep_" + pChain.nexus + "_" + finalstep)
				.css({opacity: 1}).animate({opacity: 0.5}, animationspeed);
			
			/*
			 * Announce the next world boss and the time until it, only if it's
			 * not past the timeframe, and the subscription option is off.
			 */
			if (O.Options.int_setAlarm === O.IntEnum.Alarm.Checklist
				&& O.Options.bol_alertAtEnd && I.isProgramLoaded
				&& pChain.nexus === C.CurrentChainSD.nexus
				&& isregularchain)
			{
				var checked = ", " + D.getSpeechWord("checked");
				var checkedsd = "";
				var checkedhc = "";
				var wantsd = U.objToBool(C.NextChainSD1);
				var wanthc = U.objToBool(C.NextChainHC1);
				var speech = D.getSpeechWord("next " + D.orderModifier("boss", "world") + " is") + " ";
				
				if (C.NextChainSD1 && ( ! C.isChainUnchecked(C.NextChainSD1)))
				{
					checkedsd = checked;
				}
				if (C.NextChainHC1 && ( ! C.isChainUnchecked(C.NextChainHC1)))
				{
					checkedhc = checked;
				}
				// Don't alert if next boss is checked off and user opted not to hear
				if (O.Options.bol_alertChecked === false)
				{
					if (checkedsd.length > 0) { wantsd = false; }
					if (checkedhc.length > 0) { wanthc = false; }
				}
				
				if (wantsd && wanthc)
				{
					D.speak(speech + D.getChainPronunciation(C.NextChainSD1) + checkedsd, 5);
					D.speak(D.getSpeechWord("also") + ", " + D.getChainPronunciation(C.NextChainHC1) + checkedhc, 3);
				}
				else if (wantsd)
				{
					D.speak(speech + D.getChainPronunciation(C.NextChainSD1) + checkedsd, 5);
				}
				else if (wanthc)
				{
					D.speak(speech + D.getChainPronunciation(C.NextChainHC1) + checkedhc, 5);
				}
				
				if (wantsd || wanthc)
				{
					D.speak(T.getTimeTillChainFormatted(C.NextChainSD1, "speech"), 3);
				}
			}
			
			// Also unsubscribe from world boss chains if opted
			if (O.Options.int_setAlarm === O.IntEnum.Alarm.Subscription && O.Options.bol_alertUnsubscribe && I.isProgramLoaded
				&& C.isChainWorldBoss(pChain) && C.isChainSubscribed(pChain))
			{
				$("#chnTime_" + pChain.nexus).trigger("click");
			}
		}
	},
	
	/*
	 * Gets the time an event start or a chain finishes based on user option.
	 * @param object pChain to read from.
	 * @param int pIndex of a primary event. -1 if want finish.
	 * @returns int sum statistics for that event/step.
	 */
	getSumBasedOnOptions: function(pChain, pIndex)
	{
		// Daily chain will always use min time because more players will do these
		if (C.isChainToday(pChain))
		{
			if (pIndex > -1)
			{
				return pChain.primaryEvents[pIndex].minSum;
			}
			else
			{
				pChain.countdownToFinish = pChain.minFinish;
				return pChain.minFinish;
			}
		}
		
		// Else for non daily chains use chosen statistical time
		var hour = T.getTimeSinceMidnight(T.ReferenceEnum.Local, T.UnitEnum.Hours);
		
		if (pIndex > -1)
		{
			switch (O.Options.int_setPredictor)
			{
				case O.IntEnum.Predictor.Auto:
				{
					if (hour >= 12 && hour < 18)
					{
						return pChain.primaryEvents[pIndex].minSum;
					}
					if (hour >= 18)
					{
						return pChain.primaryEvents[pIndex].minavgSum;
					}
					if (hour >= 0 && hour < 6)
					{
						return pChain.primaryEvents[pIndex].avgSum;
					}
					if (hour >= 6 && hour < 12)
					{
						return pChain.primaryEvents[pIndex].minavgSum;
					}
				} break;
				case O.IntEnum.Predictor.Min:
				{
					return pChain.primaryEvents[pIndex].minSum;
				} break;
				case O.IntEnum.Predictor.MinAvg:
				{
					return pChain.primaryEvents[pIndex].minavgSum;
				} break;
				case O.IntEnum.Predictor.Avg:
				{
					return pChain.primaryEvents[pIndex].avgSum;
				} break;
			}
			// Failsafe
			return pChain.primaryEvents[pIndex].minavgSum;
		}
		else
		{
			switch (O.Options.int_setPredictor)
			{
				case O.IntEnum.Predictor.Auto:
				{
					if (hour >= 12 && hour < 18)
					{
						pChain.countdownToFinish = pChain.minFinish;
						return pChain.minFinish;
					}
					if (hour >= 18)
					{
						pChain.countdownToFinish = pChain.minavgFinish;
						return pChain.minavgFinish;
					}
					if (hour >= 0 && hour < 6)
					{
						pChain.countdownToFinish = pChain.avgFinish;
						return pChain.avgFinish;
					}
					if (hour >= 6 && hour < 12)
					{
						pChain.countdownToFinish = pChain.minavgFinish;
						return pChain.minavgFinish;
					}
				} break;
				case O.IntEnum.Predictor.Min:
				{
					pChain.countdownToFinish = pChain.minFinish;
					return pChain.minFinish;
				} break;
				case O.IntEnum.Predictor.MinAvg:
				{
					pChain.countdownToFinish = pChain.minavgFinish;
					return pChain.minavgFinish;
				} break;
				case O.IntEnum.Predictor.Avg:
				{
					pChain.countdownToFinish = pChain.avgFinish;
					return pChain.avgFinish;
				} break;
			}
			// Failsafe
			pChain.countdownToFinish = pChain.minavgFinish;
			return pChain.minavgFinish;
		}
	}
};
M = {
/* =============================================================================
 * @@Map and map control template object
 * ========================================================================== */

	/*
	 * http://gw2timer.com/data/general.js contains zone (e.g. Queensdale, LA)
	 * objects with their rectangular coordinates.
	 * This is referred to by the variable "Zones".
	 * Each zone will be assigned with LayerGroup of world completion markers,
	 * they can be accessed by the format: zonevariable.Layers.LandmarkType
	 * where LandmarkType may be Waypoint, Vista, or others.
	 */
	MapEnum: "map", // Type of map this map is
	OptionSuffix: "", // Tyria map has unsuffixed option variable names
	Continent: GW2T_CONTINENT_DATA["map"],
	Zones: GW2T_ZONE_DATA,
	ZoneAssociation: GW2T_ZONE_ASSOCIATION, // This contains API zone IDs that associates with regular world zones
	Subzones: {},
	Regions: GW2T_REGION_DATA,
	Submaps: GW2T_SUBMAP_DATA,
	Compasses: GW2T_COMPASS_DATA,
	cInitialZone: "lion",
	Map: {},
	FloorCurrent: {},
	ZoneCurrent: {},
	numPins: 0,
	numPinsSlots: 32,
	numCompassesSlots: 32,
	cICON_SIZE_STANDARD: 32,
	cRING_SIZE_MAX: 256,
	isMapInitialized: false,
	isMouseOnHUD: false,
	isMenuOnHUD: false,
	isUserDragging: false,
	isZoneLocked: false,
	isFloorShown: true,
	isMapAJAXDone: false,
	isAPIRetrieved_MAPFLOOR: false,
	isItineraryRetrieved: false,
	isMappingIconsGenerated: false,
	isEventIconsGenerated: false,
	ContextLatLng: null, // Coordinates to store when user right clicks on the map
	cMAP_MOUSEMOVE_RATE: 100,
	cInertiaThreshold: 100, // Milliseconds between drag and release to flick pan
	cZoomFactor: 2,
	ZoomEnum:
	{
		Adaptive: -2,
		Same: -1,
		Min: 0,
		Overview: 3,
		Default: 3,
		Space: 3,
		Sky: 5,
		Bird: 6,
		Ground: 7,
		Max: 7
	},
	cZIndexRaise: 999999,
	cZIndexBury: -999999,
	
	// MumbleLink data assigned by overlay program
	GPSPreviousZoneID: "",
	GPSPreviousCoord: [],
	GPSPreviousAngleCharacter: 0,
	GPSPreviousAngleCamera: 0,
	GPSisInstance: false,
	
	/*
	 * All objects in the map are called "markers". Some markers are grouped into iterable "layers".
	 * Markers in layers are destroyed and recreated into the map using the toggleLayer function.
	 * This is to reduce CPU usage when these markers are not displayed.
	 * To iterate layers: LAYER.eachLayer(function(MARKER) { MARKER.dostuff });
	 * To assign marker properties: MARKER.options.PROPERTY
	 */
	Layer: {
		Overview: new L.layerGroup(), // Stats of zone's number of world completion icons
		Pin: new L.layerGroup(), // Utility pin markers, looks like GW2 personal waypoints
		PersonalPin: new L.layerGroup(),
		PersonalPath: new L.layerGroup(), // Path drawn from connecting player-laid pins
		CompassIcon: new L.layerGroup(), // A compass icon with its radius circle
		CompassCircle: new L.layerGroup()
	},
	Pin: {
		Program: {},
		Event: {},
		Over: {},
		Character: {},
		Camera: {}
	},
	MappingEnum:
	{
		Sector: 0,
		Waypoint: 1,
		Landmark: 2,
		Vista: 3,
		Challenge: 4,
		Heart: 5,
		EventIcon: 6,
		EventCircle: 7,
		EventLabel: 8
	},
	APIPOIEnum:
	{
		Sector: "sectors",
		Waypoint: "waypoint",
		Landmark: "landmark",
		Vista: "vista",
		Challenge: "skill_challenges",
		Heart: "tasks"
	},
	
	/*
	 * Initializes the Leaflet map, adds markers, and binds events.
	 */
	initializeMap: function()
	{
		var that = this;
		var htmlidprefix = "#" + this.MapEnum;
		var initialzoom = O.Options["int_setInitialZoom" + P.MapSwitchSuffix];
		
		// ?.Map is the actual Leaflet map object, initialize it
		this.Map = L.map(this.MapEnum + "Pane", {
			minZoom: this.ZoomEnum.Min,
			maxZoom: this.ZoomEnum.Max,
			inertiaThreshold: this.cInertiaThreshold,
			doubleClickZoom: false,
			touchZoom: false, // Disable pinch to zoom
			zoomControl: false, // Hide the zoom UI
			attributionControl: false, // Hide the Leaflet link UI
			crs: L.CRS.Simple
		}).setView(this.Continent.CenterInitial, initialzoom); // Out of map boundary so browser doesn't download tiles yet
		// Because the map will interfere with scrolling the website on touch devices
		if (I.isTouchEnabled)
		{
			this.Map.touchZoom.disable();
			if (this.Map.tap)
			{
				this.Map.tap.disable();
			}
		}
		
		// Initialize LayerGroup in zones to later hold world completion and dynamic event icons
		var zone;
		for (var i in this.Zones)
		{
			zone = this.Zones[i];
			zone.center = this.computeZoneCenter(zone);
			zone.nick = i;
			zone.Layers = {
				Path: new L.layerGroup(),
				Waypoint: new L.layerGroup(),
				Landmark: new L.layerGroup(),
				Vista: new L.layerGroup(),
				Mastery: new L.layerGroup(),
				Challenge: new L.layerGroup(),
				Heart: new L.layerGroup(),
				Sector: new L.layerGroup(),
				HeartArea: new L.layerGroup(),
				SectorArea: new L.layerGroup(),
				EventIcon: new L.layerGroup(),
				EventCircle: new L.layerGroup(),
				EventArea: new L.layerGroup(),
				EventLabel: new L.layerGroup()
			};
			if (that.MapEnum === P.MapEnum.Tyria)
			{
				P.LayerArray.ChainPath.push(zone.Layers.Path);
			}
		}
		this.ZoneCurrent = this.Zones[this.cInitialZone];
		
		// Do other initialization functions
		switch (this.MapEnum)
		{
			case P.MapEnum.Tyria: {
				this.createStandardPins();
				P.populateMap(M);
				P.drawZoneBorders();
				P.drawZoneGateways();
				C.ScheduledChains.forEach(P.drawChainPaths);
				H.getUrgent(H.Announcement.UrgentPVE);
			} break;
			
			case P.MapEnum.Mists: {
				this.createStandardPins();
				P.populateMap(W);
				H.getUrgent(H.Announcement.UrgentWVW);
			} break;
		}
		
		// Bind map click functions for non-touch devices
		if (I.isTouchEnabled)
		{
			this.createTouchMenu();
		}
		else
		{
			this.bindMapClicks();
		}
		
		/*
		 * Go to the coordinates in the bar when user presses enter.
		 */
		$(htmlidprefix + "CoordinatesCopy").onEnterKey(function()
		{
			var val = $(this).val();
			Z.interpretCommand(val, that, that.ZoomEnum.Ground, that.Pin.Program);
		});
		
		/*
		 * Bind map HUD buttons functions.
		 */
		$(htmlidprefix + "GPSButton").click(function()
		{
			// Go to character if cliked on GPS button
			P.updateCharacter(1);
		}).dblclick(function()
		{
			if (that.Map.getZoom() !== that.ZoomEnum.Ground)
			{
				that.Map.setZoom(that.ZoomEnum.Ground);
			}
			else
			{
				that.Map.setZoom(that.ZoomEnum.Default);
			}
		});
		// Translate and bind map zones list
		$(htmlidprefix + "ZoneButton").one("mouseenter", that.bindZoneList(that))
		.dblclick(function()
		{
			that.goToDefault();
		}).contextmenu(function(pEvent)
		{
			pEvent.preventDefault();
			that.Map.setZoom(that.Map.getZoom() - 1); // Zoom out one level
		});
		
		// Finally
		this.isMapInitialized = true;
	},
	
	/*
	 * Create pin markers that can be moved by user or program.
	 */
	createStandardPins: function()
	{
		if ( ! I.isMapEnabled)
		{
			return;
		}
		var that = this;
		this.Pin.Program = this.createPin("img/map/pin_blue.png");
		this.Pin.Event = this.createPin("img/map/pin_green.png");
		this.Pin.Over = this.createPin("img/map/pin_over.png", [128,128]);
		this.Pin.Character = this.createPin("img/map/pin_character.png", [40,40]);
		this.Pin.Camera = this.createPin("img/map/pin_camera.png", [256,256], {clickable: false});
		
		// Bind pin click event to get coordinates in the coordinates bar
		this.Layer.Pin.eachLayer(function(iMarker)
		{
			that.bindMarkerCoordBehavior(iMarker, "click");
			that.bindMarkerZoomBehavior(iMarker, "contextmenu");
			iMarker.on("dblclick", function()
			{
				that.movePin(this);
			});
		});
		// Double clicking on the character pin hides it
		this.Pin.Character.on("dblclick", function()
		{
			that.movePin(this);
			that.movePin(that.Pin.Camera);
		});
		// Hide the pins, they will be shown when they are moved
		this.toggleLayer(this.Layer.Pin, false);
	},
	
	/*
	 * Creates a large menu with map controls for touch devices.
	 */
	createTouchMenu: function()
	{
		var that = this;
		var htmlidprefix = "#" + that.MapEnum;
		var menu = $("<div class='tchMenu'></div>").prependTo(htmlidprefix + "Pane");
		I.preventMapPropagation(menu);
		$("<kbd class='tchTogglePanel tchButton'></kbd>").appendTo(menu).click(function()
		{
			$("#opt_bol_showPanel").trigger("click");
		});
		$("<kbd class='tchToggleMap tchButton'></kbd>").appendTo(menu).click(function()
		{
			I.switchMap();
		});
		$("<kbd class='tchZoomIn tchButton'></kbd>").appendTo(menu).click(function()
		{
			that.Map.zoomIn();
		});
		$("<kbd class='tchZoomOut tchButton'></kbd>").appendTo(menu).click(function()
		{
			that.Map.zoomOut();
		});
		
		menu.css({top: "calc(50% - " + menu.height() + "px)"});
	},
	
	/*
	 * Bind mouse button functions for the map. Also binds the map custom context menu.
	 * @param enum pMapEnum.
	 */
	bindMapClicks: function()
	{
		var that = this;
		var htmlidprefix = "#" + that.MapEnum;
		
		/*
		 * Emulate the click behavior of OS window menus to the HUD buttons.
		 */
		var peripheral = $(htmlidprefix + "Peripheral");
		var peripheralselects = peripheral.find(".hudSelect");
		var peripheralitems = peripheral.find(".hudItem");
		var hudpericlass = "hudPeripheralActive";
		var huditemclass = "hudItemActive";
		peripheralselects.click(function()
		{
			peripheralitems.removeClass(huditemclass);
			if (that.isMenuOnHUD)
			{
				peripheral.removeClass(hudpericlass);
			}
			else
			{
				peripheral.addClass(hudpericlass);
				$(this).parent().addClass(huditemclass);
			}
			that.isMenuOnHUD = !that.isMenuOnHUD;
		}).mouseenter(function()
		{
			if (that.isMenuOnHUD)
			{
				peripheralitems.removeClass(huditemclass);
				$(this).parent().addClass(huditemclass);
			}
		});
		peripheral.mouseleave(function()
		{
			peripheral.removeClass(hudpericlass);
			if (that.isMenuOnHUD)
			{
				peripheralitems.removeClass(huditemclass);
				that.isMenuOnHUD = false;
			}
		});
		
		/*
		 * Shows or hides coordinates bar.
		 */
		I.preventMapPropagation(htmlidprefix + "CoordinatesBar");
		this.toggleCoordinatesBar(); // Apply initial appearance
		$(htmlidprefix + "CoordinatesToggle").click(function()
		{
			$("#opt_bol_showCoordinatesBar").trigger("click");
		});
		
		/*
		 * Clicking an empty place on the map highlight its coordinate.
		 */
		this.Map.on("click", function(pEvent)
		{
			if (that.isMouseOnHUD) { return; }
			var coord = that.convertLCtoGC(pEvent.latlng);
			that.outputCoordinatesCopy(P.formatCoord(coord));
		});

		/*
		 * Create a personal pin marker to where the user double clicks.
		 */
		this.Map.on("dblclick", function(pEvent)
		{
			if (that.isMouseOnHUD) { return; }
			that.saveBackupPins();
			that.createPersonalPin(pEvent.latlng, true);
		});

		/*
		 * Right clicking the map shows a custom context menu.
		 */
		this.Map.on("contextmenu", function(pEvent)
		{
			that.ContextLatLng = pEvent.latlng;
			I.showContextMenu(htmlidprefix + "Context");
		});
		
		/*
		 * Bind context menu functions.
		 */
		$(htmlidprefix + "Context").click(function()
		{
			$(this).hide();
		});
		$(htmlidprefix + "ContextCenter").click(function()
		{
			that.goToDefault();
		});
		$(htmlidprefix + "ContextToggleHUD").click(function()
		{
			$("#opt_bol_showHUD" + that.OptionSuffix).trigger("click");
		});
		$(htmlidprefix + "ContextCompass").one("mouseenter", function()
		{
			U.getScript(U.URL_DATA.Resource, function()
			{
				that.initializeCompassPlacer(that);
			});
		});
		$(htmlidprefix + "ContextPins").one("mouseenter", function()
		{
			that.initializePinStorage(that);
		});
		$(htmlidprefix + "ContextHelpPins").click(function()
		{
			that.printPinHelp();
		});
		$(htmlidprefix + "ContextUndoPins").click(function()
		{
			that.loadBackupPins();
		});
		$(htmlidprefix + "ContextClearPins").click(function()
		{
			that.clearPersonalPins();
		});
		$(htmlidprefix + "ContextChatlinkPins").click(function()
		{
			if (that.isPersonalPinsLaid(true))
			{
				P.printClosestWaypoints();
			}
		});
		$(htmlidprefix + "ContextOptimizePins").click(function()
		{
			if (that.isPersonalPinsLaid(true))
			{
				that.optimizePersonalPath();
			}
		});
		$(htmlidprefix + "ContextURLPins").click(function()
		{
			if (that.isPersonalPinsLaid(true))
			{
				var urlmod = (P.MapSwitchWebsite === P.MapEnum.Mists) ? "wvw/" : "";
				I.paste(I.cSiteURL + urlmod + that.getPersonalString());
			}
		});
		$(htmlidprefix + "ContextURLCoord").click(function()
		{
			if (that.ContextLatLng)
			{
				I.paste(I.cSiteURL + that.convertLCtoGC(that.ContextLatLng));
			}
		});
		$(htmlidprefix + "ContextToggleFloor").click(function()
		{
			that.toggleFloor();
		});
		$(htmlidprefix + "ContextToggleLock").click(function()
		{
			that.toggleZoneLock();
		});
		$(htmlidprefix + "ContextToggleCompletion").click(function()
		{
			$("#opt_bol_showWorldCompletion" + that.OptionSuffix).trigger("click");
		});
		
		// Map exclusive functions
		switch (that.MapEnum)
		{
			case P.MapEnum.Tyria:
			{
				$(htmlidprefix + "ContextDrawCompletion").click(function()
				{
					P.drawCompletionRoute();
				});
				$(htmlidprefix + "ContextDrawResource").click(function()
				{
					G.drawResourceRoute();
				});
			} break;
			case P.MapEnum.Mists:
			{
				
			} break;
		}
	},
	
	/*
	 * Toggles both the Tyria and Mists map's coordinates bars.
	 */
	toggleCoordinatesBar: function()
	{
		var bool = O.Options.bol_showCoordinatesBar;
		$(".mapCoordinatesBar input").toggle(bool);
		if (I.ModeCurrent === I.ModeEnum.Overlay)
		{
			$(".mapTime").toggle(bool);
		}
	},
	
	/*
	 * Sets the value provided to the coordinates bar.
	 * @param string pText to output.
	 */
	outputCoordinatesCopy: function(pText)
	{
		var htmlidprefix = "#" + this.MapEnum;
		$(htmlidprefix + "CoordinatesCopy").val(pText).select();
	},
	outputCoordinatesName: function(pText)
	{
		var htmlidprefix = "#" + this.MapEnum;
		$(htmlidprefix + "CoordinatesName").val(pText);
	},
	
	/*
	 * Bindings for map events that need to be done after AJAX has loaded the
	 * API-generated markers.
	 */
	bindMapVisualChanges: function()
	{
		var that = this;
		var htmlidprefix = "#" + that.MapEnum;
		/*
		 * Booleans to stop some map functions from activating.
		 */
		$(htmlidprefix + "HUDPane").hover(
			function() { that.isMouseOnHUD = true; },
			function() { that.isMouseOnHUD = false; }
		);
		$(htmlidprefix + "Context").hover(
			function() { that.isMouseOnHUD = true; },
			function() { that.isMouseOnHUD = false; }
		);
		this.Map.on("dragstart", function()
		{
			that.isUserDragging = true;
			C.isTouringManual = true;
		});
		this.Map.on("dragend", function()
		{
			that.isUserDragging = false;
		});
		
		/*
		 * Bind the mousemove event to update the map coordinate bar.
		 * Note that the throttle function is from a separate script. It permits
		 * the event handler to only run once every so specified milliseconds.
		 */
		this.Map.on("mousemove", $.throttle(that.cMAP_MOUSEMOVE_RATE, function(pEvent)
		{
			if (that.isMouseOnHUD || that.isUserDragging) { return; }
			that.showCurrentZone(that.convertLCtoGC(pEvent.latlng));
		}));

		/*
		 * At the end of a zoom animation, resize the map icons depending on
		 * zoom level. Hide if zoomed too far.
		 */
		this.Map.on("zoomend", function(pEvent)
		{
			that.adjustZoomMapping();
			if (that.MapEnum === P.MapEnum.Tyria)
			{
				P.adjustZoomDryTop();
			}
		});
	},
	
	/*
	 * Changes the floor tile layer.
	 * @param int pFloor number.
	 * If "true" or undefined then will reset to default floor, if "false" then will hide the map tiles.
	 */
	changeFloor: function(pFloor)
	{
		this.Map.removeLayer(this.FloorCurrent);
		if (pFloor === undefined || pFloor === true)
		{
			pFloor = O.Options["int_setFloor" + this.OptionSuffix];
		}
		if (pFloor !== false)
		{
			this.FloorCurrent = L.tileLayer("https://tiles.guildwars2.com/" + this.Continent.id + "/" + pFloor + "/{z}/{x}/{y}.jpg",
			{
				continuousWorld: true
			});
			this.FloorCurrent.addTo(this.Map);
		}
	},
	
	/*
	 * Shows or hides the map tiles and map background.
	 */
	toggleFloor: function(pBoolean)
	{
		var that = this;
		var htmlidprefix = "#" + that.MapEnum;
		var mappane = $(htmlidprefix + "Pane");
		that.isFloorShown = (pBoolean === undefined) ? !that.isFloorShown : pBoolean;
		
		mappane.toggleClass("mapPaneOff", !that.isFloorShown);
		if (that.isFloorShown)
		{
			that.changeFloor();
		}
		else if (I.ModeCurrent === I.ModeEnum.Overlay)
		{
			that.changeFloor(false);
		}
	},
	
	/*
	 * Prevents the zone change function, which shows zone specific icons, from triggering.
	 */
	toggleZoneLock: function()
	{
		this.isZoneLocked = !this.isZoneLocked;
		if (this.isZoneLocked)
		{
			I.write("Map locked to zone: " + D.getObjectName(this.ZoneCurrent));
		}
		else
		{
			I.write("Map zoning unlocked.");
		}
	},
	
	/*
	 * Informs Leaflet that the map pane was resized so it can load tiles properly.
	 */
	refreshMap: function()
	{
		if (this.isMapInitialized)
		{
			this.Map.invalidateSize();
			this.refreshView();
		}
	},
	
	/*
	 * Tells if the specified zone exists within the listing.
	 * @param string pZoneID to look up.
	 * @returns true if exists.
	 */
	isZoneValid: function(pZoneID)
	{
		if (this.ZoneAssociation[pZoneID] === undefined)
		{
			return false;
		}
		return true;
	},
	isSubzoneValid: function(pZoneID)
	{
		if (this.Subzones[pZoneID] === undefined || this.Subzones[pZoneID].map_rect === undefined)
		{
			return false;
		}
		return true;
	},
	
	/*
	 * Gets a GW2T zone object from an API zone ID.
	 * @param string pZoneID to look up.
	 * @returns object zone.
	 */
	getZoneFromID: function(pZoneID)
	{
		var zonenick = this.ZoneAssociation[pZoneID];
		if (zonenick)
		{
			return this.Zones[zonenick];
		}
		return null;
	},
	getZoneFromString: function(pString)
	{
		// Returns zone if string contains a zone's nick
		var nick = pString.toLowerCase();
		for (var i in this.Zones)
		{
			if (nick.indexOf(i) !== -1)
			{
				return this.Zones[i];
			}
		}
		return null;
	},
	
	/*
	 * Gets a zone's translated name if available.
	 * @param string pNick name of the zone to retrieve, or a zone object itself.
	 * @returns string zone name.
	 */
	getZoneName: function(pNick)
	{
		// If pNick is an alias of a zone
		var zone;
		if (typeof pNick === "string" && this.Zones[pNick])
		{
			zone = this.Zones[pNick];
		}
		// If pNick is a zone that has the property
		else if (typeof pNick === "object")
		{
			zone = pNick;
		}
		else
		{
			return "nozonename";
		}
		
		// Now get the name
		return D.getObjectName(zone);
	},
	getZoneNick: function(pZone)
	{
		return this.ZoneAssociation[pZone.id];
	},
	
	/*
	 * Gets the region nick of a zone.
	 * @param string pNick of the zone.
	 * @returns string region nick.
	 */
	getZoneRegion: function(pNick)
	{
		var zone = this.Zones[(pNick.toLowerCase())];
		if (zone)
		{
			return zone.region;
		}
		return null;
	},
	
	/*
	 * Tells if the provided coordinates is within the provided zone.
	 * @param object pZone for getting bounds.
	 * @param 2D array pCoord GW2 coordinates.
	 * @returns boolean
	 */
	isWithinZone: function(pZone, pCoord)
	{
		var rect = pZone.continent_rect;
		if (pCoord[0] >= rect[0][0]
			&& pCoord[1] >= rect[0][1]
			&& pCoord[0] <= rect[1][0]
			&& pCoord[1] <= rect[1][1])
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Gets the zone a coordinates reside in.
	 * @param array pCoord.
	 * @returns object zone if found else null.
	 */
	getZoneFromCoord: function(pCoord)
	{
		for (var i in this.Zones) // i is the index and nickname of the zone
		{
			if (this.isWithinZone(this.Zones[i], pCoord))
			{
				return this.Zones[i];
			}
		}
		return null;
	},
	
	/*
	 * Finds what zone the specified point is in by comparing it to the top left
	 * and bottom right coordinates of the zones, then show the zone's visuals.
	 * @param array pCoord containing x and y coordinates.
	 * @pre Zone perimeters do not intersect.
	 */
	showCurrentZone: function(pCoord)
	{
		var that = this;
		var htmlidprefix = that.MapEnum;
		
		document.getElementById(htmlidprefix + "CoordinatesMouse")
			.value = pCoord[0] + ", " + pCoord[1];
	
		// Don't continue if mouse is still in the same zone
		if (pCoord[0] >= this.ZoneCurrent.continent_rect[0][0] // x1
			&& pCoord[1] >= this.ZoneCurrent.continent_rect[0][1] // y1
			&& pCoord[0] <= this.ZoneCurrent.continent_rect[1][0] // x2
			&& pCoord[1] <= this.ZoneCurrent.continent_rect[1][1] // y2
			|| this.isZoneLocked === true)
		{
			return;
		}
		
		// Else search for new moused zone
		var zonename = "";
		var previouszone;
		var testzone = this.getZoneFromCoord(pCoord); // Search for the zone
		
		if (testzone !== null)
		{
			// Hide the icons of the previously moused zone
			previouszone = this.Zones[this.ZoneCurrent.nick];
			for (var i in previouszone.Layers)
			{
				this.Map.removeLayer(previouszone.Layers[i]);
			}
			// Update current zone object
			this.ZoneCurrent = testzone;
			zonename = this.getZoneName(this.ZoneCurrent);
			document.getElementById(htmlidprefix + "CoordinatesName").value = zonename;

			// Reveal moused zone's icons
			switch (that.MapEnum)
			{
				case P.MapEnum.Tyria:
				{
					if (P.isChainPathsAllowed()) { this.ZoneCurrent.Layers.Path.addTo(this.Map); }
					if (O.Options.bol_displayWaypoints) { this.ZoneCurrent.Layers.Waypoint.addTo(this.Map); }
					if (O.Options.bol_displayPOIs) { this.ZoneCurrent.Layers.Landmark.addTo(this.Map); }
					if (O.Options.bol_displayVistas) { this.ZoneCurrent.Layers.Vista.addTo(this.Map); }
					if (O.Options.bol_displayMasteries) { this.ZoneCurrent.Layers.Mastery.addTo(this.Map); }
					if (O.Options.bol_displayChallenges) { this.ZoneCurrent.Layers.Challenge.addTo(this.Map); }
					if (O.Options.bol_displayHearts) { this.ZoneCurrent.Layers.Heart.addTo(this.Map); }
					if (O.Options.bol_displaySectors) { this.ZoneCurrent.Layers.Sector.addTo(this.Map); }
					if (O.Options.bol_displayHeartsArea) { this.ZoneCurrent.Layers.HeartArea.addTo(this.Map); }
					if (O.Options.bol_displaySectorsArea) { this.ZoneCurrent.Layers.SectorArea.addTo(this.Map); }
					if (O.Options.bol_displayEvents) {
						this.ZoneCurrent.Layers.EventIcon.addTo(this.Map);
						this.ZoneCurrent.Layers.EventCircle.addTo(this.Map);
						this.ZoneCurrent.Layers.EventArea.addTo(this.Map);
						this.ZoneCurrent.Layers.EventLabel.addTo(this.Map);
					}
				} break;
				case P.MapEnum.Mists:
				{
					if (O.Options.bol_displayWaypointsWvW) { this.ZoneCurrent.Layers.Waypoint.addTo(this.Map); }
					if (O.Options.bol_displayPOIsWvW) { this.ZoneCurrent.Layers.Landmark.addTo(this.Map); }
					if (O.Options.bol_displayVistasWvW) { this.ZoneCurrent.Layers.Vista.addTo(this.Map); }
					if (O.Options.bol_displayChallengesWvW) { this.ZoneCurrent.Layers.Challenge.addTo(this.Map); }
					if (O.Options.bol_displaySectorsWvW) { this.ZoneCurrent.Layers.Sector.addTo(this.Map); }
				} break;
			}

			// Re-tooltip
			P.rebindMarkerTooltips();
			// Rescale current moused mapping markers
			this.adjustZoomMapping();
			
			// Temporary submaps for new zones if needed
			/*if (testzone.id === "1178" && P.TempSubmap.iscreated !== true)
			{
				P.TempSubmap.iscreated = true;
				this.createSubmap(P.TempSubmap, true);
			}*/
		}
	},
	
	/*
	 * Simulates the action of moving the mouse outside the current zone to
	 * another and back again, so as to trigger the icon adjustment functions.
	 */
	refreshCurrentZone: function()
	{
		var currentcoord = this.ZoneCurrent.center;
		switch (this.MapEnum)
		{
			case P.MapEnum.Tyria:
			{
				// These specimen zone are chosen because they are the top of the array
				this.showCurrentZone(this.getZoneCenter("verdant"));
				this.showCurrentZone(this.getZoneCenter("auric"));
			} break;
			case P.MapEnum.Mists:
			{
				this.showCurrentZone(this.getZoneCenter("edge"));
				this.showCurrentZone(this.getZoneCenter("eternal"));
			} break;
		}
		this.showCurrentZone(currentcoord);
	},
	
	/*
	 * Gets the center coordinates of a zone.
	 * @param object pZone
	 * @returns array of x and y coordinates.
	 */
	computeZoneCenter: function(pZone)
	{
		var rect = pZone.continent_rect;
		// x = OffsetX + (WidthOfZone/2), y = OffsetY + (HeightOfZone/2)
		var x = rect[0][0] + ~~((rect[1][0] - rect[0][0]) / 2);
		var y = rect[0][1] + ~~((rect[1][1] - rect[0][1]) / 2);
		return [x, y];
	},
	getZoneCenter: function(pNick)
	{
		if (this.Zones[pNick])
		{
			return this.Zones[pNick].center;
		}
		return [0,0];
	},
	
	/*
	 * Gets the center coordinates of an event.
	 * @param object pEvent an event from event_details.json
	 * @returns array of x and y coordinates.
	 * @pre map_floor.json was extracted to the this.Zones object.
	 */
	getEventCenter: function(pEvent)
	{
		var zone = this.getZoneFromID(pEvent.map_id);
		var p = pEvent.location.center; // 2D float array

		return this.convertEventCoord(p, zone);
	},
	
	/*
	 * Gets the dimension (of say a marker) adjusted to the specified zoom level.
	 * For example, a submap must be resized so that it is the same scale as
	 * the map's tileset. It is known that every zoom down doubles the size of
	 * the map, and vice versa. The formula below is:
	 * maxdimension / (2 ^ (maxzoomlevel - currentzoomlevel))
	 * Each zoom down increases the dimension toward the maxdimension, so when
	 * it's at maxzoomlevel, the returned dimension equals maxdimension.
	 * @param int pMaxDimension to rescale.
	 * @param int or enum pZoomLevel for adjustment.
	 */
	scaleDimension: function(pMaxDimension, pZoomLevel)
	{
		pZoomLevel = pZoomLevel || this.Map.getZoom();
		return parseInt(pMaxDimension / (Math.pow(this.cZoomFactor, (this.ZoomEnum.Max) - pZoomLevel)));
	},
	
	/*
	 * Converts a zoom level where 0 is ground level to proper level.
	 * @param int zoom level inverted.
	 * @returns int zoom level proper.
	 */
	invertZoomLevel: function(pZoomLevel)
	{
		return this.ZoomEnum.Max - pZoomLevel;
	},
	
	/*
	 * Resizes mapping markers so they scale with the current zoom level.
	 */
	adjustZoomMapping: function()
	{
		var that = this;
		var currentzoom = this.Map.getZoom();
		var zoomindex = this.invertZoomLevel(currentzoom);
		
		var ZoomValues = {
			// The first index is the max zoom-in level
			waypoint: [40, 32, 26, 20, 16, 12, 0, 0],
			landmark: [32, 24, 16, 12, 0, 0, 0, 0],
			eventicon: [32, 24, 16, 12, 0, 0, 0, 0],
			eventlabelfont: [14, 0, 0, 0, 0, 0, 0, 0],
			sectorfont: [28, 20, 16, 0, 0, 0, 0, 0],
			sectoropacity: [0.9, 0.6, 0.3, 0, 0, 0, 0, 0],
			objicon: [38, 38, 38, 38, 32, 24, 16, 0],
			objtimerfont: [18, 17, 16, 15, 14, 13, 12, 0],
			objinfofont: [14, 13, 12, 11, 10, 9, 0, 0],
			objumbrella: [96, 96, 96, 96, 64, 32, 24, 0],
			spawnfont: [28, 24, 20, 16, 12, 8, 0, 0],
			spawnopacity: [0.9, 0.9, 0.8, 0.7, 0.6, 0.5, 0, 0],
			wallweight: [10, 8, 6, 4, 2, 0, 0, 0]
		};
		var getZoomValue = function(pKey)
		{
			return (ZoomValues[pKey])[zoomindex];
		};
		var waypointsize = getZoomValue("waypoint");
		var landmarksize = getZoomValue("landmark");
		var eventiconsize = getZoomValue("eventicon");
		var eventlabelfont = getZoomValue("eventlabelfont");
		var sectorfont = getZoomValue("sectorfont");
		var sectoropacity = getZoomValue("sectoropacity");
		var objiconsize = getZoomValue("objicon");
		var objtimerfont = getZoomValue("objtimerfont");
		var objinfofont = getZoomValue("objinfofont");
		var objumbrella = getZoomValue("objumbrella");
		var spawnfont = getZoomValue("spawnfont");
		var spawnopacity = getZoomValue("spawnopacity");
		var wallweight = getZoomValue("wallweight");
		
		var completionboolean;
		var overviewboolean;
		var sectorboolean;
		
		switch (this.MapEnum)
		{
			case P.MapEnum.Tyria:
			{
				if (O.Options.bol_displayEvents)
				{
					// Event Icon
					this.ZoneCurrent.Layers.EventIcon.eachLayer(function(iLayer)
					{
						that.resizeMarkerIcon(iLayer, eventiconsize);
						if (iLayer._icon)
						{
							iLayer._icon.style.zIndex = M.cZIndexRaise;
						}
					});
					
					// Event Circle
					this.ZoneCurrent.Layers.EventCircle.eachLayer(function(iLayer)
					{
						iLayer.setRadius(that.getZoomedDistance(iLayer.options.trueradius));
					});
					
					// Event Label
					this.ZoneCurrent.Layers.EventLabel.eachLayer(function(iLayer)
					{
						if (iLayer._icon)
						{
							iLayer._icon.style.fontSize = eventlabelfont + "px";
							iLayer._icon.style.zIndex = that.cZIndexBury + 1; // Don't cover other icons
							iLayer._icon.style.display = "table"; // For middle vertical alignment
						}
					});
				}
				overviewboolean = O.Options.bol_showZoneOverview;
				completionboolean = O.Options.bol_showWorldCompletion;
				sectorboolean = O.Options.bol_displaySectors;
			} break;
			case P.MapEnum.Mists:
			{
				// Objective
				$(".objIcon").css({width: objiconsize, height: objiconsize});
				$(".objProgressBar").css({width: objiconsize});
				$(".objTimer").css({fontSize: objtimerfont});
				$(".objInfo").css({fontSize: objinfofont});
				$(".objUmbrella").css({width: objumbrella, height: objumbrella});
				// World Completion
				overviewboolean = O.Options.bol_showZoneOverviewWvW;
				completionboolean = O.Options.bol_showWorldCompletionWvW;
				sectorboolean = O.Options.bol_displaySectorsWvW;
				// Server spawn area labels
				this.Layer.SpawnLabel.eachLayer(function(iLayer)
				{
					iLayer._icon.style.fontSize = spawnfont + "px";
					iLayer._icon.style.opacity = spawnopacity;
					iLayer._icon.style.zIndex = that.cZIndexBury + 1;
					iLayer._icon.style.display = "table";
				});
				// Secondary objectives
				this.Layer.Secondaries.eachLayer(function(iLayer)
				{
					that.resizeMarkerIcon(iLayer, landmarksize);
				});
				// Destructible walls and gates paths
				this.Layer.Destructible.eachLayer(function(iLayer)
				{
					iLayer.setStyle({weight: wallweight});
				});
			} break;
		}
		
		// Adjust compass circles
		this.Layer.CompassCircle.eachLayer(function(iLayer)
		{
			iLayer.setRadius(that.getZoomedDistance(iLayer.options.trueradius));
		});
		
		// Overview on the zones
		if (completionboolean && overviewboolean)
		{
			if (currentzoom === this.ZoomEnum.Overview)
			{
				this.toggleLayer(this.Layer.Overview, true);
				this.Layer.Overview.eachLayer(function(iLayer)
				{
					iLayer._icon.style.display = "table";
				});
			}
			else
			{
				this.toggleLayer(this.Layer.Overview, false);
			}
		}
		else
		{
			this.toggleLayer(this.Layer.Overview, false);
		}

		// Waypoints
		this.ZoneCurrent.Layers.Waypoint.eachLayer(function(iLayer)
		{
			that.resizeMarkerIcon(iLayer, waypointsize);
		});
		
		// Landmarks
		this.ZoneCurrent.Layers.Landmark.eachLayer(function(iLayer)
		{
			that.resizeMarkerIcon(iLayer, landmarksize);
			if (iLayer._icon)
			{
				iLayer._icon.style.opacity = (currentzoom < that.ZoomEnum.Max) ? 0.6 : 0.8;
			}
		});
		
		// Vista
		this.ZoneCurrent.Layers.Vista.eachLayer(function(iLayer)
		{
			that.resizeMarkerIcon(iLayer, landmarksize);
		});
		
		// Mastery
		this.ZoneCurrent.Layers.Mastery.eachLayer(function(iLayer)
		{
			that.resizeMarkerIcon(iLayer, landmarksize);
		});
		
		// Challenge
		this.ZoneCurrent.Layers.Challenge.eachLayer(function(iLayer)
		{
			that.resizeMarkerIcon(iLayer, landmarksize);
		});
		
		// Heart
		this.ZoneCurrent.Layers.Heart.eachLayer(function(iLayer)
		{
			that.resizeMarkerIcon(iLayer, landmarksize);
		});
		
		// Sector
		this.ZoneCurrent.Layers.Sector.eachLayer(function(iLayer)
		{
			if (iLayer._icon)
			{
				iLayer._icon.style.fontSize = sectorfont + "px";
				iLayer._icon.style.opacity = sectoropacity;
				iLayer._icon.style.zIndex = that.cZIndexBury + 1; // Don't cover other icons
				if (sectorboolean)
				{
					iLayer._icon.style.display = "table"; // For middle vertical alignment
				}
			}
		});
		
		// Character pin and camera FOV
		P.updateCharacter(-1);
	},
	
	/*
	 * Calculates a new distance from an inherent distance based on current map zoom level.
	 */
	getZoomedDistance: function(pDistance)
	{
		return pDistance / Math.pow(2, this.ZoomEnum.Max - this.Map.getZoom());
	},
	
	/*
	 * Returns a common sized Leafet icon.
	 * @param string pIconURL of the icon image.
	 * @returns object Leaflet icon.
	 */
	createStandardIcon: function(pIconURL)
	{
		return L.icon({
			iconUrl: pIconURL,
			iconSize: [32, 32],
			iconAnchor: [16, 16]
		});
	},
	
	/*
	 * Creates a pin in the map to be assigned to a reference object.
	 * @param string pIconURL image of the marker.
	 * @param 2D array pDimension width and height of pin.
	 * @param object pOptions additional marker options.
	 * @returns object Leaflet marker.
	 */
	createPin: function(pIconURL, pDimension, pOptions)
	{
		if (pDimension === undefined)
		{
			pDimension = [32, 32];
		}
		// Default pin options
		var options = {
			icon: L.icon(
			{
				iconUrl: pIconURL,
				iconSize: pDimension,
				iconAnchor: [(pDimension[0])/2, (pDimension[1])/2]
			}),
			draggable: true
		};
		// If additional options was provided then override the default
		if (pOptions !== undefined)
		{
			for (var i in pOptions)
			{
				options[i] = pOptions[i];
			}
		}
		var marker = L.marker(this.convertGCtoLC([0,0]), options);
		this.Layer.Pin.addLayer(marker);
		return marker;
	},
	
	/*
	 * Generates a save/load list in the map context menu.
	 * @param string pName of the list.
	 * @param int pNumSlots to generate.
	 * @param object pMapObject
	 * @param function pSaveFunction
	 * @param function pLoadFunction
	 */
	initializeContextSlots: function(pName, pNumSlots, pMapObject, pSaveFunction, pLoadFunction)
	{
		var that = pMapObject;
		var htmlidprefix = "#" + that.MapEnum;
		var wordload = D.getWordCapital("load");
		var wordsave = D.getWordCapital("save");
		var wordslot = D.getWordCapital("slot");
		var listload = $(htmlidprefix + "ContextLoad" + pName);
		var listsave = $(htmlidprefix + "ContextSave" + pName);
		var htmlsuffix;
		for (var i = 0; i < pNumSlots; i++)
		{
			htmlsuffix = " " + wordslot + ": <input class='cssInputText mapContextSlot' type='text' value='" + "#" + (i+1) + "' /></li>";
			listload.append("<li data-index='" + i + "' class='mapContextLine'>" + wordload + htmlsuffix);
			listsave.append("<li data-index='" + i + "' class='mapContextLine'>" + wordsave + htmlsuffix);
		}
		X.initializeTextlist(X.Textlists["Slot" + pName + that.OptionSuffix], listload.find(".mapContextSlot"), null, 64);
		X.initializeTextlist(X.Textlists["Slot" + pName + that.OptionSuffix], listsave.find(".mapContextSlot"), null, 64);
		$([listload, listsave]).each(function()
		{
			$(this).find(".mapContextSlot").click(function(pEvent)
			{
				pEvent.stopPropagation();
				$(this).select();
			});
		});
		// Bind behavior for the created list items
		$(htmlidprefix + "ContextSave" + pName + " li").click(function()
		{
			// Click list item to save
			pSaveFunction($(this).attr("data-index"));
		}).find(".mapContextSlot").onEnterKey(function()
		{
			// Pressing Enter on the list item's name input box triggers the save
			$(this).parent().trigger("click");
		});
		$(htmlidprefix + "ContextLoad" + pName + " li").click(function()
		{
			pLoadFunction($(this).attr("data-index"));
		}).find(".mapContextSlot").onEnterKey(function()
		{
			$(this).parent().trigger("click");
		});;
		// Create server bar
		I.createFilterBar($("<div class='mapContextSearch'></div>").prependTo(listload), listload.find(".mapContextSlot"), ".mapContextLine");
		I.createFilterBar($("<div class='mapContextSearch'></div>").prependTo(listsave), listsave.find(".mapContextSlot"), ".mapContextLine");
		I.bindScrollbar(listload);
		I.bindScrollbar(listsave);
	},
	
	/*
	 * Initializes the personal pin storage system.
	 */
	initializePinStorage: function(pMapObject)
	{
		var that = pMapObject;
		var initializeStoredPins = function(pQuantity)
		{
			var obj = O.Utilities["StoredPins" + that.OptionSuffix];
			// First make a new array with desired length
			obj.value = new Array(pQuantity);
			var key = obj.key;
			// Try to overwrite it with the stored arrays, if this fails then the value property is unchanged (a blank array)
			try
			{
				obj.value = JSON.parse(localStorage[key]);
			}
			catch (e) {}
		};
		var saveStoredPins = function(pIndex)
		{
			var obj = O.Utilities["StoredPins" + that.OptionSuffix];
			var coords = that.getPersonalCoords();
			if (coords.length > 0)
			{
				obj.value[pIndex] = coords;
				localStorage[obj.key] = JSON.stringify(obj.value);
				I.write(coords.length + " pins saved.");
			}
			else
			{
				that.isPersonalPinsLaid(true);
			}
		};
		var loadStoredPins = function(pIndex)
		{
			var obj = O.Utilities["StoredPins" + that.OptionSuffix];
			that.redrawPersonalPath(obj.value[pIndex]);
		};
		
		// Generate the load/save items when user opens the Pins context menu for the first time
		var numslots = that.numPinsSlots;
		initializeStoredPins(numslots);
		that.initializeContextSlots("Pins", numslots, that, saveStoredPins, loadStoredPins);
	},
	
	/*
	 * Saves the current personal pins as backup. This is to be called before the
	 * user manually adds and inserts a pin.
	 */
	saveBackupPins: function()
	{
		var obj = O.Utilities["BackupPins" + this.OptionSuffix];
		localStorage[obj.key] = JSON.stringify(this.getPersonalCoords());
	},
	loadBackupPins: function()
	{
		var obj = O.Utilities["BackupPins" + this.OptionSuffix];
		try
		{
			obj.value = JSON.parse(localStorage[obj.key]);
		}
		catch (e) {}
		this.redrawPersonalPath(obj.value, null);
	},
	
	/*
	 * Prints help message for using pins.
	 */
	printPinHelp: function()
	{
		var str = "<h2>Path Pins Interactions</h2>"
			+ "<ul>"
			+ "<li><b>Create a pin:</b> double click an empty area on the map (multiple pins creates a path).</li>"
			+ "<li><b>Insert a pin between a path:</b> double click a part of the path.</li>"
			+ "<li><b>Delete a pin:</b> double click that pin.</li>"
			+ "<li><b>Delete all pins:</b> choose Clear from the Path context menu.</li>"
			+ "<li><b>Move a pin:</b> hold click and drag that pin.</li>"
			+ "<li><b>Move a pin to center:</b> right click that pin.</li>"
			+ "<li><b>Zoom to a pin:</b> right click that pin when not in max zoom.</li>"
			+ "</ul>"
			+ "<h2>Path Pins Features</h2>"
			+ "<ul>"
			+ "<li><b>Check off a pin:</b> single click that pin.</li>"
			+ "<li><b>Get coordinates of a pin:</b> single click that pin.</li>"
			+ "<li><b>Get coordinates of a path:</b> single click on the path.</li>"
			+ "<li><b>Generate a path:</b> paste the path coordinates into the coordinates bar and press Enter.</li>"
			+ "<li><b>Optimize a path:</b> middle click that pin, it will become the starting pin.</li>"
			+ "<li><b>Save/Load pins:</b> the save slots can be named, which can be filtered by the search bar.</li>"
			+ "</ul>";
		I.help(str);
	},
	printCompassHelp: function()
	{
		var str = "<h2>Compass Pins Interactions</h2>"
			+ "<ul>"
			+ "<li><b>Create a pin:</b> select an icon from the context menu gallery.</li>"
			+ "<li><b>Create a custom pin:</b> checkmark the checkbox by the custom input boxes then enter your own range, color, and comment.</li>"
			+ "<li><b>Delete a pin:</b> double click that pin.</li>"
			+ "<li><b>Delete all pins:</b> choose Clear from the Compass context menu.</li>"
			+ "<li><b>Move a pin:</b> hold click and drag that pin.</li>"
			+ "<li><b>Move a pin to center:</b> right click that pin.</li>"
			+ "<li><b>Zoom to a pin:</b> right click that pin when not in max zoom.</li>"
			+ "</ul>"
			+ "<h2>Compass Pins Features</h2>"
			+ "<ul>"
			+ "<li><b>Get coordinates of a pin:</b> single click that pin.</li>"
			+ "<li><b>Draw a path connecting all compasses of a type: middle click that pin.</li>"
			+ "<li><b>Export pins for sharing:</b> use the compass export function and copy and output text.</li>"
			+ "<li><b>Import pins from text:</b> use the compass import function, then paste the compass data text into the adjacent input box.</li>"
			+ "<li><b>Save/Load pins:</b> the save slots can be named, which can be filtered by the search bar.</li>"
			+ "</ul>";
		I.help(str);
	},
	
	/*
	 * Creates a personal pin.
	 * @param object pLatLng coordinates.
	 * @param boolean pWantDraw to redraw the paths (shouldn't redraw when
	 * looping this function because that's inefficient).
	 */
	createPersonalPin: function(pLatLng, pWantDraw)
	{
		var that = this;
		var index = this.numPins;
		var coord = this.convertLCtoGC(pLatLng);
		var angle = (this.coordPreviousPin) ? this.convertDirectionAngle(this.coordPreviousPin, coord) : 0;
		this.coordPreviousPin = coord;
		
		// Create a pin at double click location
		var url = (this.numPins === 0) ? "img/map/pin_red.png" : "img/map/pin_directed.png";
		var marker = L.marker(pLatLng,
		{
			icon: L.icon(
			{
				iconUrl: url,
				iconSize: [32, 32],
				iconAnchor: [16, 16]
			}),
			draggable: true,
			opacity: 0.9,
			rotationAngle: angle
		});
		this.toggleLayer(marker, true);
		this.Layer.PersonalPin.addLayer(marker);
		this.numPins++;
		if (pWantDraw)
		{
			this.drawPersonalPath();
		}
		
		// Single click pin: get its coordinates and toggle its opacity
		this.bindMarkerCoordBehavior(marker, "click");
		marker.on("mousedown", function(pEvent)
		{
			switch (pEvent.originalEvent.which)
			{
				case I.ClickEnum.Left:
				{
					if (this.options.isMarked === undefined || this.options.isMarked === false)
					{
						this.options.isMarked = true;
						this.setOpacity(0.3);
					}
					else
					{
						this.options.isMarked = false;
						this.setOpacity(1);
					}
				} break;
				case I.ClickEnum.Middle:
				{
					// If middle click then set as starting pin
					that.optimizePersonalPath(index);
				} break;
			}
		});
		// Double click pin: remove itself from map
		marker.on("dblclick", function()
		{
			that.removePersonalPin(this);
		});
		// Right click pin: centers the pin on GPS character
		marker.on("contextmenu", function(pEvent)
		{
			if (that.Map.getZoom() === that.ZoomEnum.Max)
			{
				if (that.GPSPreviousCoord.length > 0)
				{
					that.movePin(this, that.GPSPreviousCoord);
				}
				else
				{
					that.movePin(this, that.Map.getCenter());
				}
				that.drawPersonalPath();
			}
			else
			{
				that.Map.setView(pEvent.latlng, that.ZoomEnum.Max);
			}
			
		});
		// Drag pin: redraw the personal path
		marker.on("dragend", function()
		{
			that.drawPersonalPath();
		});
	},
	
	/*
	 * Removes a personal pin from the map.
	 * @param object pPin
	 */
	removePersonalPin: function(pPin)
	{
		this.toggleLayer(pPin, false);
		this.Layer.PersonalPin.removeLayer(pPin);
		this.drawPersonalPath();
		this.numPins--;
	},
	
	/*
	 * Inserts a personal pin between a group of pins.
	 * @param int pPrecede index of the preceding pin.
	 * @param object pLatLng of the inserted pin.
	 */
	insertPersonalPin: function(pPrecede, pLatLng)
	{
		var latlngs = [];
		var i = 0;
		// Recompile pin coordinates for recreation
		this.Layer.PersonalPin.eachLayer(function(iPin)
		{
			latlngs.push(iPin.getLatLng());
			if (i === pPrecede)
			{
				// When at the index to insert, push the provided coordinates of the new pin
				latlngs.push(pLatLng);
			}
			i++;
		});
		// Redraw the entire series of pins
		this.clearPersonalPins();
		for (i in latlngs)
		{
			this.createPersonalPin(latlngs[i]);
		}
		this.drawPersonalPath();
	},
	
	/*
	 * Removes all personal pins from the map.
	 */
	clearPersonalPins: function()
	{
		var that = this;
		this.Layer.PersonalPin.eachLayer(function(iPin)
		{
			that.toggleLayer(iPin, false);
		});
		this.Layer.PersonalPin.clearLayers();
		this.drawPersonalPath();
		this.numPins = 0;
		this.coordPreviousPin = null;
	},
	
	/*
	 * Draws a path from the group of personal pins the user laid.
	 */
	drawPersonalPath: function()
	{
		var that = this;
		var path;
		var latlngs = [];
		var pinids = [];
		var length = 0;
		this.Layer.PersonalPin.eachLayer(function(iPin)
		{
			latlngs.push(iPin.getLatLng());
			pinids.push(P.getLayerId(iPin));
			length++;
		});
		
		var pathcolor = P.getUserPathColor();
		var pathopacity = P.getUserPathOpacity();
		if (length > 1)
		{
			this.Layer.PersonalPath.clearLayers();
			for (var i = 0; i < length - 1; i++)
			{
				// Create a single line connecting next two pins
				path = L.polyline([latlngs[i], latlngs[i+1]], {
					color: pathcolor,
					opacity: pathopacity,
					precede: i // Store the index of the preceding pin that connects the path
				});
				// Single click path: get the coordinates of all pins
				path.on("click", function()
				{
					that.outputCoordinatesCopy(that.getPersonalString());
					that.outputPinsDistance();
				});
				// Double click path: insert a pin between the two pins that connect the path
				path.on("dblclick", function(pEvent)
				{
					that.saveBackupPins();
					that.insertPersonalPin(this.options.precede, pEvent.latlng);
				});
				this.Layer.PersonalPath.addLayer(path);
			}
			this.toggleLayer(this.Layer.PersonalPath, true);
			that.outputPinsDistance();
		}
		else
		{
			this.toggleLayer(this.Layer.PersonalPath, false);
			this.Layer.PersonalPath.clearLayers();
		}
	},
	
	/*
	 * Parses a personal path string then draw it if valid.
	 * @param string pString of coordinates.
	 * @returns boolean true if valid.
	 */
	parsePersonalPath: function(pString)
	{
		var coords = this.parseCoordinatesMulti(pString);
		if (coords !== null)
		{
			this.redrawPersonalPath(coords);
			return true;
		}
		return false;
	},
	
	/*
	 * Draws a path from a given set of coordinates.
	 * @param 2D array pCoords of x y coordinates.
	 * @param string pZoomArgs for map view.
	 */
	redrawPersonalPath: function(pCoords, pZoomArgs)
	{
		var coords = (pCoords !== undefined) ? pCoords : this.getPersonalCoords();
		if (coords !== undefined && coords !== null && coords.length > 0)
		{
			this.clearPersonalPins();
			for (var i in coords)
			{
				this.createPersonalPin(this.convertGCtoLC(coords[i]));
			}
			this.drawPersonalPath();
			// View the first point in the generated path
			if (pZoomArgs !== null)
			{
				if (pZoomArgs === undefined)
				{
					this.goToArguments(coords[0]);
				}
				else
				{
					this.goToArguments(pZoomArgs);
				}
			}
		}
		else
		{
			I.write(D.getPhraseOriginal("Path not available for this") + ".");
		}
	},
	
	/*
	 * Outputs the total game "unit" distance for the pins.
	 */
	outputPinsDistance: function()
	{
		var distance = 0;
		var markers = this.Layer.PersonalPin.getLayers();
		var length = markers.length - 1;
		
		for (var i = 0; i < length; i++)
		{
			distance += P.getDistanceBetweenCoords(
				this.convertLCtoGC(markers[i].getLatLng()),
				this.convertLCtoGC(markers[i+1].getLatLng())
			);
		}
		var units = ~~(distance * T.cPOINTS_TO_UNITS);
		var time = T.formatTimeLetter(Math.ceil(units / T.cUNITS_PER_SECOND), true);
		this.outputCoordinatesName(units + " " + D.getWord("range") + " (" + time + ")");
	},
	
	/*
	 * Tells if there is at least one personal pin laid on the map.
	 * @returns boolean.
	 */
	isPersonalPinsLaid: function(pWantMessage)
	{
		if (this.numPins === 0)
		{
			if (pWantMessage)
			{
				I.write("No path pins to work with. Double click on the map to lay pins.");
			}
			return false;
		}
		return true;
	},
	
	/*
	 * Redraws the path with a shorter distance, only the starting point is not changed.
	 */
	optimizePersonalPath: function(pStart)
	{
		this.redrawPersonalPath(P.getGreedyPath(this.getPersonalCoords(), pStart));
	},
	
	/*
	 * Draw pins in random coordinates.
	 * @param pQuantity pins to draw.
	 */
	drawRandom: function(pQuantity)
	{
		var qty = parseInt(pQuantity);
		if (qty === 0 || qty > 1000 || this.numPins > 1000 || qty === undefined)
		{
			return;
		}
		
		var x, y;
		for (var i = 0; i < qty; i++)
		{
			x = T.getRandomIntRange(0, this.Continent.Dimensions[0]);
			y = T.getRandomIntRange(0, this.Continent.Dimensions[1]);
			this.createPersonalPin(this.convertGCtoLC([x, y]));
		}
		this.drawPersonalPath();
	},
	
	/*
	 * Gets the personal pins' coordinates.
	 * @returns string of the 2D array.
	 */
	getPersonalCoords: function()
	{
		var that = this;
		var coords = [];
		this.Layer.PersonalPin.eachLayer(function(iPin)
		{
			coords.push(that.convertLCtoGC(iPin.getLatLng()));
		});
		return coords;
	},
	getPersonalString: function()
	{
		return JSON.stringify(this.getPersonalCoords());
	},
	
	/*
	 * Gets the closest marker to the specified coordinates.
	 * @param array pCoord.
	 * @param object pLayerGroup markers to scan.
	 * @param boolean wantCoord to return coordinate instead of the marker object.
	 * @returns object Leaflet marker.
	 * @pre Coordinates must be inside a zone.
	 */
	getClosestLocation: function(pCoord, pLayerGroup)
	{
		var that = this;
		var distance;
		var mindistance = Number.POSITIVE_INFINITY;
		var minmarker = null;
		
		pLayerGroup.eachLayer(function(iLayer)
		{
			distance = P.getDistanceBetweenCoords(pCoord, that.convertLCtoGC(iLayer.getLatLng()));
			if (distance < mindistance)
			{
				mindistance = distance;
				minmarker = iLayer;
			}
		});
		return minmarker;
	},
	
	/*
	 * Writes context menu elements for placing compasses with compass circles on the map.
	 */
	initializeCompassPlacer: function(pMapObject)
	{
		var that = pMapObject;
		var htmlidprefix = "#" + that.MapEnum;
		var iconsperline = 8;
		var nodeiconsperline = 4;
		var rangemaxvalue = 1000000;
		var colormaxlength = 32;
		var commentmaxlength = 256;
		var importmaxlength = 65536;
		
		var compasscontext = $(htmlidprefix + "ContextCompass");
		var compassgallery = $(htmlidprefix + "ContextCompassList");
		I.preventMapPropagation(compassgallery);
		var counter = 0;
		var nodecounter = 0;
		var nodetypeprev = null;
		var compassprev = null;
		
		// Entry: Lay another of the previously laid compass
		var addbutton = $(htmlidprefix + "ContextAddCompass");
		addbutton.click(function()
		{
			if (compassprev)
			{
				that.saveBackupCompasses();
				that.createCompass(compassprev, that.ContextLatLng);
			}
			else
			{
				I.write("Please select a compass pin first.");
			}
		});
		
		// Inputs: Custom compass properties
		var customcheck = $("<input type='checkbox' />");
		var customchecklabel = $("<label title='" + D.getPhraseOriginal("Enable custom range and comment") + ".'></label>").append(customcheck);
		var customrange = $("<input type='number' value='1200' min='0' max='" + rangemaxvalue
			+ "' step='100' style='width:48px' title='" + D.getWordCapital("range") + "' />");
		var customcolor = $("<input type='text' value='#ffffff' maxlength='" + colormaxlength
			+ "' style='width:48px' class='cssInputText' title='" + D.getWordCapital("color") + "' />");
		var customcomment = $("<input type='text' value='" + D.getWordCapital("comment") + "...' maxlength='" + commentmaxlength
				+ "' style='width:" + ((I.ModeCurrent === I.ModeEnum.Overlay) ? 64 : 128)
				+ "px; margin-left:4px;' class='cssInputText' title='" + D.getWordCapital("comment") + "' />");
		
		// Add resource node compasses if is this map
		if (that.MapEnum === P.MapEnum.Tyria)
		{
			var nodes = GW2T_RESOURCE_DATA;
			for (var i in nodes)
			{
				var nodename = i.toLowerCase();
				that.Compasses["node_" + nodename] = {
					nodetype: nodes[i].type,
					icon: "img/node/" + nodename + I.cPNG
				};
			}
		}
		// Add compass buttons into the gallery
		for (var i in that.Compasses)
		{
			var compass = that.Compasses[i];
			compass.id = i;
			if (compass.isPlaceable === false)
			{
				continue;
			}
			counter++;
			
			// Icon
			compass.icon = compass.icon || "img/compass/" + compass.id + I.cPNG;
			var compassbutton = $("<img src='" + compass.icon + "' />");
			// Button tooltip
			var title = (compass.tooltip !== undefined) ? compass.tooltip : ((compass.range) ? D.getWordCapital("range") + " " + compass.range : "");
			if (title.length)
			{
				compassbutton.attr("title", title);
			}
			
			if (compass.nodetype)
			{
				// Add resource node compass button to its specific menu
				if (nodetypeprev !== compass.nodetype)
				{
					nodetypeprev = compass.nodetype;
					nodecounter = 0;
				}
				nodecounter++;
				var nodecompassgallery = $("#mapContextNodeList_" + compass.nodetype);
				nodecompassgallery.append(compassbutton);
				if (nodecounter % nodeiconsperline === 0)
				{
					nodecompassgallery.append("<br />");
				}
			}
			else
			{
				// Add standard compass button to regular menu
				compassgallery.append(compassbutton);
				if (counter % iconsperline === 0)
				{
					compassgallery.append("<br />");
				}
			}
			(function(iCompass)
			{
				compassbutton.click(function()
				{
					var outputcompass = (customcheck.is(":checked")) ? $.extend({}, iCompass, {
						range: parseInt(customrange.val()),
						color: U.stripToColorString(customcolor.val()),
						comment: U.escapeHTML(customcomment.val())
					}) : iCompass;
					compassprev = outputcompass;
					that.saveBackupCompasses();
					that.createCompass(outputcompass, that.ContextLatLng);
				});
			})(compass);
		}
		
		// Insert the custom inputs at the bottom of the gallery
		$("<span id='" + that.MapEnum + "CompassCustom' style='display:block;' class='mapCompassCustom'></span>")
			.prependTo(compassgallery).append([customchecklabel, customrange, customcolor, customcomment]).find("input").onEnterKey(function()
		{
			addbutton.trigger("click");
		});
		
		// Entry: Clear all compasses
		$(htmlidprefix + "ContextClearCompasses").click(function()
		{
			that.clearCompasses();
		});
		
		// Entry: Import compass data
		var importbutton = $(htmlidprefix + "ContextImportCompasses");
		importbutton.click(function()
		{
			var str = $(htmlidprefix + "CompassImportText").val();
			that.parseCompasses(str);
		});
		var importfile = $("<input type='file' style='width:128px' />").insertBefore(importbutton);
		Z.bindFileInput(importfile, function(pString)
		{
			that.parseCompasses(pString);
		});
		// Input: Import input box
		$("<input id='" + that.MapEnum + "CompassImportText' type='text' value='' maxlength='"
			+ importmaxlength + "' style='width:96px; margin-left:4px;' class='cssInputText' title='"
			+ "<dfn>Export</dfn> to get the textual copy of laid compasses.<br />"
			+ "Paste that text in this box and <dfn>Import</dfn> to reconstruct the compasses.' />")
		.onEnterKey(function()
		{
			importbutton.trigger("click");
		}).appendTo(importbutton);
		// Entry: Export current compasses
		$(htmlidprefix + "ContextExportCompasses").click(function()
		{
			if (that.isCompassesLaid())
			{
				var outputstr = JSON.stringify(that.serializeCompasses());
				I.print("Saveable File:");
				Z.createFile(outputstr, "gw2t_compasses.json");
				I.print("<br />Copyable Text:");
				I.paste(outputstr);
			}
		});
		
		// Entry: Draw standard siege placement for WvW
		$("#wvwContextDrawCompasses").click(function()
		{
			W.redrawDefaultCompasses();
		});
		
		// Entry: Help message
		$(htmlidprefix + "ContextHelpCompasses").click(function()
		{
			that.printCompassHelp();
		});
		
		// Entry: Undo by loading backup
		$(htmlidprefix + "ContextUndoCompasses").click(function()
		{
			that.loadBackupCompasses();
		});
		
		// Allow interaction with the inputs within the context menu
		compasscontext.find("input").click(function(pEvent)
		{
			pEvent.stopPropagation();
			$(this).select();
		}).trigger("mouseenter"); // Trigger the context menu positioning function after generating the menu
		customchecklabel.click(function(pEvent)
		{
			pEvent.stopPropagation();
		});
		
		// Finally
		I.qTip.init(compasscontext.find("label, input, img"));
		X.rewrapCheckboxes();
		that.initializeCompassStorage();
	},
	
	/*
	 * Initializes the compass storage system.
	 */
	initializeCompassStorage: function()
	{
		var that = this;
		var initializeStoredCompasses = function(pQuantity)
		{
			var obj = O.Utilities["StoredCompasses" + that.OptionSuffix];
			// First make a new array with desired length
			obj.value = new Array(pQuantity);
			// Try to overwrite it with the stored arrays, if this fails then the value property is unchanged (a blank array)
			obj.value = O.loadCompressedObject(obj.key) || new Array(pQuantity);
		};
		var saveStoredCompasses = function(pIndex)
		{
			var obj = O.Utilities["StoredCompasses" + that.OptionSuffix];
			var compasses = that.serializeCompasses();
			if (compasses.length > 0)
			{
				obj.value[pIndex] = compasses;
				O.saveCompressedObject(obj.key, obj.value);
				I.write(compasses.length + " compasses saved.");
			}
			else
			{
				that.isCompassesLaid();
			}
		};
		var loadStoredCompasses = function(pIndex)
		{
			var obj = O.Utilities["StoredCompasses" + that.OptionSuffix];
			that.redrawCompasses(obj.value[pIndex]);
		};
		
		var numslots = that.numCompassesSlots;
		initializeStoredCompasses(numslots);
		that.initializeContextSlots("Compasses", numslots, that, saveStoredCompasses, loadStoredCompasses);
	},
	
	/*
	 * Saves the current compass pins as backup. This is to be called before the
	 * user manually adds a compass.
	 */
	saveBackupCompasses: function()
	{
		var obj = O.Utilities["BackupCompasses" + this.OptionSuffix];
		localStorage[obj.key] = JSON.stringify(this.serializeCompasses());
	},
	loadBackupCompasses: function()
	{
		var obj = O.Utilities["BackupCompasses" + this.OptionSuffix];
		try
		{
			obj.value = JSON.parse(localStorage[obj.key]);
		}
		catch (e) {}
		this.redrawCompasses(obj.value);
	},
	
	/*
	 * Gets an array of objects with properties needed to reconstruct the compasses on the map.
	 * @returns array of objects.
	 */
	serializeCompasses: function()
	{
		var that = this;
		var company = [];
		that.Layer.CompassCircle.eachLayer(function(iLayer)
		{
			var opt = iLayer.options;
			// Store only the compass ID and location
			var compass = {
				id: opt.compassid,
				coord: that.convertLCtoGC(iLayer.getLatLng())
			};
			// If compass has custom properties then save them too
			if (opt.color)
			{
				compass.color = (opt.color).toLowerCase();
			}
			if (opt.compassrange)
			{
				compass.range = parseInt(opt.compassrange);
			}
			if (opt.compasscomment)
			{
				compass.comment = opt.compasscomment;
			}
			company.push(compass);
		});
		U.sortObjects(company, {aKeyName: "id"});
		return company;
	},
	
	/*
	 * Draws a path between a specific type of compass pins.
	 * @param object pCompass to get its type.
	 */
	pathCompasses: function(pCompass)
	{
		var that = this;
		var type = pCompass.options.compassid;
		var coords = [];
		that.Layer.CompassCircle.eachLayer(function(iLayer)
		{
			var opt = iLayer.options;
			if (opt.compassid === type)
			{
				coords.push(that.convertLCtoGC(iLayer.getLatLng()));
			}
		});
		that.redrawPersonalPath(coords);
	},
	
	/*
	 * Reconstructs a placement of compasses on the map.
	 * @param array pCompany of compasses and their location.
	 * @param array pOffset x and y coordinates offset, optional.
	 * @pre Compasses' placement was stored as game coordinates, not LatLng.
	 */
	redrawCompasses: function(pCompany, pOffset)
	{
		if (pCompany !== undefined && pCompany !== null && pCompany.length > 0)
		{
			this.clearCompasses();
			var counter = 0;
			var coords = [];
			for (var i in pCompany)
			{
				var compass = pCompany[i];
				var coord = (pOffset !== undefined) ? [compass.coord[0] + pOffset[0], compass.coord[1] + pOffset[1]] : compass.coord;
				// If it is not a custom compass, then use the default properties via that compass ID
				var compasstomake = null;
				if (this.Compasses[compass.id])
				{
					compasstomake = $.extend({}, this.Compasses[compass.id], compass);
				}
				else if (compass.coord && coord)
				{
					// For unrecognized compasses (deprecated compass IDs, but still have a valid properties)
					compasstomake = {
						id: "custom",
						icon: "img/compass/custom.png",
						range: compass.range,
						color: compass.color,
						comment: compass.comment
					};
				}
				
				// Only draw if it is a valid compass object
				if (compasstomake !== null)
				{
					counter++;
					coords.push(coord);
					this.createCompass(compasstomake, this.convertGCtoLC(coord));
				}
				else
				{
					I.write("Failed parsing a compass: " + compass.id);
				}
			}
			// After success
			if (counter > 0)
			{
				this.goToView(U.getRandomElement(coords));
				I.write(counter + " compasses reconstructed.");
			}
		}
		else
		{
			I.write(D.getPhraseOriginal("Compass not available for this" + "."));
		}
	},
	parseCompasses: function(pString)
	{
		try
		{
			var company = JSON.parse(pString);
			if (Array.isArray(company))
			{
				this.redrawCompasses(company);
			}
		}
		catch (e)
		{
			I.write("Invalid data string for importing Compasses.");
		};
	},
	
	/*
	 * Draws the standard siege placement for the current zone.
	 */
	redrawDefaultCompasses: function()
	{
		var placementname = W.Metadata.PlacementAssociation[W.ZoneCurrent.nick];
		var placement = W.Placement[placementname];
		var offset = W.Metadata.Offsets[W.ZoneCurrent.nick];
		if (offset !== undefined && placement)
		{
			var arsenal = placement.Company;
			W.redrawCompasses(arsenal, offset);
		}
	},
	
	/*
	 * Tells if there is at least one personal pin laid on the map.
	 * @returns boolean.
	 */
	isCompassesLaid: function()
	{
		if (this.Layer.CompassIcon.getLayers().length === 0)
		{
			I.write("No compass pins to work with. Lay compasses from the map's &quot;Compass&quot; context menu.");
			return false;
		}
		return true;
	},
	
	/*
	 * Places a range marker icon and circle circumference on the map.
	 * @param object pCompass.
	 * @param object pLatLng location of the compass.
	 * @pre LatLng variable was assigned when the user right clicked on the map.
	 */
	createCompass: function(pCompass, pLatLng)
	{
		var that = this;
		// The circle indicating the range
		var trueradius = pCompass.range * T.cUNITS_TO_POINTS;
		var radius = this.getZoomedDistance(trueradius);
		var circle = L.circleMarker(pLatLng, {
			clickable: false,
			compassid: pCompass.id,
			compassrange: pCompass.range,
			compasscomment: pCompass.comment,
			trueradius: trueradius,
			radius: radius,
			color: pCompass.color,
			weight: 2,
			opacity: pCompass.opacity || 0.8,
			fillOpacity: pCompass.fillOpacity || 0.1
		});
		this.Layer.CompassCircle.addLayer(circle);
		this.toggleLayer(circle);
		
		// The interactive icon allowing the user to relocate the circle
		var width = (pCompass.range) ? 24 : 32;
		var height = (pCompass.range) ? 24 : 32;
		var compass = L.marker(pLatLng,
		{
			circle: circle,
			icon: L.icon(
			{
				className: "mapCompass",
				iconUrl: pCompass.icon,
				iconSize: [width, height],
				iconAnchor: [width / 2, height / 2]
			}),
			title: pCompass.comment,
			draggable: true,
			opacity: 0.9
		});
		that.bindMarkerCoordBehavior(compass, "click");
		
		// Bind placed marker behavior
		compass.on("drag", function()
		{
			this.options.circle.setLatLng(this.getLatLng());
		});
		compass.on("dblclick", function()
		{
			that.removeCompass(this);
			I.qTip.hide();
		});
		compass.on("contextmenu", function()
		{
			if (that.Map.getZoom() !== that.ZoomEnum.Ground)
			{
				that.Map.setView(this.getLatLng(), that.ZoomEnum.Ground);
			}
			else
			{
				if (that.GPSPreviousCoord.length > 0)
				{
					that.movePin(this, that.GPSPreviousCoord);
				}
				else
				{
					that.movePin(this, that.Map.getCenter());
				}
				this.options.circle.setLatLng(this.getLatLng());
			}
		});
		compass.on("mousedown", function(pEvent)
		{
			if (pEvent.originalEvent.which === I.ClickEnum.Middle)
			{
				that.pathCompasses(this.options.circle);
			}
		});
		this.Layer.CompassIcon.addLayer(compass);
		this.toggleLayer(compass);
		
		// Bind tooltip if compass is commented
		if (pCompass.comment)
		{
			I.qTip.init(".mapCompass");
		}
	},
	
	/*
	 * Removes a placed compass from the map and associated container objects.
	 * @param object pMarker.
	 */
	removeCompass: function(pMarker)
	{
		// Remove its range circle before removing the compass
		this.toggleLayer(pMarker.options.circle, false);
		this.Layer.CompassCircle.removeLayer(pMarker.options.circle);
		// Remove the compass itself
		this.toggleLayer(pMarker, false);
		this.Layer.CompassIcon.removeLayer(pMarker);
	},
	
	/*
	 * Removes all compasses from the map.
	 */
	clearCompasses: function()
	{
		var that = this;
		this.Layer.CompassIcon.eachLayer(function(iLayer)
		{
			that.removeCompass(iLayer);
		});
		this.Layer.CompassCircle.clearLayers();
		this.Layer.CompassIcon.clearLayers();
	},
	
	/*
	 * Changes the marker icon's image and size (Leaflet does not have this method).
	 * @param object pMarker Leaflet marker.
	 * @param string pIconURL of the icon image.
	 * @param int pSize of icon.
	 */
	resizeMarkerIcon: function(pMarker, pSize)
	{
		if (pSize === undefined)
		{
			pSize = this.cICON_SIZE_STANDARD;
		}
		
		pMarker.setIcon(new L.icon(
		{
			iconUrl: pMarker.options.icon.options.iconUrl,
			iconSize: [pSize, pSize],
			iconAnchor: [pSize/2, pSize/2]
		}));
	},
	
	/*
	 * Toggles recreation/destruction of layers (a group of markers).
	 * @param object pLayer of markers.
	 * @param boolean pBoolean to show or hide.
	 */
	toggleLayer: function(pLayer, pBoolean)
	{
		if ( ! pLayer)
		{
			return;
		}
		// No boolean provided so assumes toggle
		if (pBoolean === undefined)
		{
			pBoolean = !(this.Map.hasLayer(pLayer));
		}
		
		// Show if true, hide if false
		if (pBoolean)
		{
			pLayer.addTo(this.Map);
		}
		else
		{
			this.Map.removeLayer(pLayer);
		}
	},
	toggleLayerArray: function(pLayerArray, pBoolean)
	{
		for (var i in pLayerArray)
		{
			this.toggleLayer(pLayerArray[i], pBoolean);
		}
	},
	
	/*
	 * Initializes or toggle a submap, which is a Leaflet ImageOverlay over the map.
	 * Look at general.js for submap declarations.
	 * @param string pName of the submap.
	 * @param boolean pBoolean to show or hide.
	 */
	toggleSubmap: function(pName, pBoolean)
	{
		var submap = this.Submaps[pName];
		if (submap.ImageOverlay === undefined)
		{
			submap.ImageOverlay = this.createSubmap(submap);
			this.toggleSubmap(pName, pBoolean);
		}
		else
		{
			// No boolean provided so assumes toggle
			if (pBoolean === undefined)
			{
				pBoolean = !(this.Map.hasLayer(submap.ImageOverlay));
			}

			// Show if true, hide if false
			if (pBoolean)
			{
				submap.ImageOverlay.addTo(this.Map).bringToBack();
			}
			else
			{
				this.Map.removeLayer(submap.ImageOverlay);
			}
		}
	},
	toggleSubmapArray: function(pNames, pBoolean)
	{
		for (var i in pNames)
		{
			this.toggleSubmap(pNames[i], pBoolean);
		}
	},
	createSubmap: function(pSubmapData, pWantShow)
	{
		var submap = L.imageOverlay(pSubmapData.img, this.convertGCtoLCMulti(pSubmapData.bounds));
		if (pWantShow)
		{
			submap.addTo(this.Map).bringToBack();
		}
		return submap;
	},
	
	/*
	 * Moves a pin to a map coordinate.
	 * @param object pPin to move.
	 * @param 2D array or Leaflet latlng object pCoord coordinates.
	 */
	movePin: function(pPin, pCoord)
	{
		if (pCoord === undefined)
		{
			// No coordinates given means hide the pin
			this.toggleLayer(pPin, false);
		}
		else
		{
			this.toggleLayer(pPin, true);
			if (Array.isArray(pCoord))
			{
				pPin.setLatLng(this.convertGCtoLC(pCoord));
			}
			else
			{
				pPin.setLatLng(pCoord);
			}
			pPin._icon.style.zIndex = this.cZIndexRaise;
		}
	},
	
	/*
	 * Views the map at the specifications.
	 * @param 2D array pCoord coordinates.
	 * @param object pPin which to move to coordinate.
	 * @param enum pZoom level or object with integer "offset" key.
	 */
	goToView: function(pCoord, pZoom, pPin)
	{
		if (pPin !== undefined)
		{
			this.movePin(pPin, pCoord);
		}
		
		if (pZoom === undefined)
		{
			pZoom = this.ZoomEnum.Ground;
		}
		else if (pZoom === this.ZoomEnum.Same)
		{
			pZoom = this.Map.getZoom();
		}
		else if (pZoom === this.ZoomEnum.Adaptive)
		{
			pZoom = this.getAdaptiveZoom();
		}
		else if (typeof pZoom === "object" && pZoom.offset !== undefined)
		{
			pZoom = this.getAdaptiveZoom(pZoom.offset);
		}
		this.Map.setView(this.convertGCtoLC(pCoord), pZoom);
		this.showCurrentZone(pCoord);
	},
	
	/*
	 * Views the map outside of bounds then instantly back at original view,
	 * to workaround the unresponsive map bug when the map was previously hidden.
	 */
	refreshView: function(pCoord)
	{
		var latlng = (pCoord) ? this.convertGCtoLC(pCoord) : this.Map.getCenter();
		this.Map.setView(M.Continent.CenterInitial, this.Map.getZoom());
		this.Map.setView(latlng, this.Map.getZoom());
	},
	
	/*
	 * Views the map at the zone.
	 * @param string pNick of the zone.
	 * @param enum pZoom level.
	 */
	goToZone: function(pNick, pZoom)
	{
		var coord = this.getZoneCenter(pNick);
		this.showCurrentZone(coord);
		this.goToView(coord, pZoom);
	},
	
	/*
	 * Gets a zoom level that depends on the user's screen width.
	 * @param int pOffset from the returned zoom.
	 * @returns int zoom level.
	 */
	getAdaptiveZoom: function(pOffset)
	{
		if (pOffset === undefined)
		{
			pOffset = 0;
		}
		var zoom;
		var winwidth = $(window).width();
		
		if (winwidth >= I.ScreenWidth.Huge)
		{
			zoom = this.ZoomEnum.Default + 1;
		}
		else if (winwidth >= I.ScreenWidth.Large)
		{
			zoom = this.ZoomEnum.Default;
		}
		else if (winwidth >= I.ScreenWidth.Medium)
		{
			zoom = this.ZoomEnum.Default - 1;
		}
		else
		{
			zoom = this.ZoomEnum.Default - 2;
		}
		return zoom + pOffset;
	},
	
	/*
	 * Views the default map view.
	 */
	goToDefault: function(pZoom)
	{
		if (pZoom === undefined)
		{
			pZoom = this.getAdaptiveZoom();
		}
		this.Map.setView(this.convertGCtoLC(this.Continent.Center), pZoom);
	},
	
	/*
	 * Views the map at the given URL coordinates if exist.
	 * URL should be in the form of http://gw2timer.com/?go=4874,16436,1
	 * @param string pArguments of location to view.
	 * @param enum pZoom level, optional.
	 * @param object pPin pin, optional.
	 * coords[0] = x coordinate.
	 * coords[1] = y coordinate.
	 * coords[2] = z coordinate (zoom level, lower value equals greater zoom-in).
	 */
	goToArguments: function(pArguments, pZoom, pPin)
	{
		var i;
		var coords = [];
		var zone;
		if (pArguments)
		{
			coords = this.parseCoordinates(pArguments);
			if (coords.length === 2)
			{
				if (isFinite(coords[0]) && isFinite(coords[1]))
				{
					this.goToView(coords, pZoom, pPin);
				}
			}
			else if (coords.length >= 3)
			{
				if (isFinite(coords[0]) && isFinite(coords[1]) && isFinite(coords[2]))
				{
					// Zoom level 0 is ground level (opposite the enum)
					var zoomlevel = this.invertZoomLevel(coords[2]);
					this.goToView([coords[0], coords[1]], zoomlevel, pPin);
				}
			}
			else
			{
				// Else assume the argument is a short name for the zone
				zone = pArguments.toLowerCase();
				if (zone === "default")
				{
					this.goToDefault();
				}
				else
				{
					for (i in this.Zones)
					{
						if (zone.indexOf(i) !== -1)
						{
							this.goToView(this.getZoneCenter(i), this.ZoomEnum.Sky);
							break;
						}
					}
				}
			}
		}
	},
	
	/*
	 * Executes map commands in URL query string if available. Also starts GPS.
	 */
	executeURLCommands: function()
	{
		var qsgo = U.Args[U.KeyEnum.Go];
		var qsdraw = U.Args[U.KeyEnum.Draw];
		var arr;
		var goPage = function()
		{
			// Go to map page if go or draw commanded is provided and page is not
			if (U.Args[U.KeyEnum.Page] === undefined)
			{
				$("#plateMenu_Map").trigger("click");
			}
		};
		try { arr = JSON.parse(qsgo); } catch (e) {}
		if (arr && Array.isArray(arr) && arr.length && Array.isArray(arr[0]))
		{
			// If is draw command, array of coordinates
			this.parsePersonalPath(qsgo);
			U.Args[U.KeyEnum.Go] = null;
			goPage();
		}
		else if (qsgo)
		{
			// If is go command, just a coordinates
			this.goToArguments(qsgo, this.ZoomEnum.Ground, this.Pin.Program);
			U.Args[U.KeyEnum.Go] = null;
			goPage();
		}
		if (qsdraw)
		{
			var drawzone = this.getZoneFromString(qsdraw);
			if (drawzone)
			{
				P.drawCompletionRoute(drawzone);
			}
			else
			{
				this.parsePersonalPath(qsdraw);
			}
			U.Args[U.KeyEnum.Draw] = null;
			goPage();
		}
		
		// Start GPS if on overlay
		if (I.ModeCurrent === I.ModeEnum.Overlay && I.isProgramEmbedded === false)
		{
			P.tickGPS();
		}
	},
	
	/*
	 * Converts GW2's coordinates XXXXX,XXXXX to Leaflet LatLng coordinates XXX,XXX.
	 * @param array pCoord array of two numbers.
	 * @returns LatLng Leaflet object.
	 */
	convertGCtoLC: function(pCoord)
	{
		return this.Map.unproject(pCoord, this.Map.getMaxZoom());
	},
	
	/*
	 * Converts multiple GW2 coordinates to multiple LatLng.
	 * @param array of arrays pCoordArrays to convert.
	 * @param int pIndexStart starting index.
	 * @returns array of LatLng.
	 */
	convertGCtoLCMulti: function(pCoordArray, pIndexStart)
	{
		pIndexStart = pIndexStart || 0;
		var i;
		var latlngs = [];
		for (i = pIndexStart; i < pCoordArray.length; i++)
		{
			latlngs.push(this.convertGCtoLC(pCoordArray[i]));
		}
		return latlngs;
	},
	
	/*
	 * Converts two coordinates [[X1, Y2], [X2, Y2]] to two LatLng's.
	 * @param 2D array pSegmentArray.
	 * @returns array.
	 */
	convertGCtoLCDual: function(pSegmentArray)
	{
		return [this.convertGCtoLC(pSegmentArray[0]), this.convertGCtoLC(pSegmentArray[1])];
	},
	
	/*
	 * Converts Leaflet LatLng to GW2's 2 unit array coordinates.
	 * @param object pLatLng from Leaflet.
	 * @returns array of x and y coordinates.
	 */
	convertLCtoGC: function(pLatLng)
	{
		var coord = this.Map.project(pLatLng, this.ZoomEnum.Max);
		return [Math.round(coord.x), Math.round(coord.y)];
	},
	convertLCtoGCMulti: function(pCoordArray)
	{
		var coords = [];
		for (var i = 0; i < pCoordArray.length; i++)
		{
			coords.push(this.convertLCtoGC(pCoordArray[i]));
		}
		return coords;
	},
	
	/*
	 * Converts a map_floor.json event coordinates to the map coordinates system.
	 * @param 2D float array pPos event center. Only uses [0] and [1] values.
	 * @param object pZone to translate coordinates.
	 * @returns 2D int array map coordinates.
	 * @pre pZone was initialized (this is asynchronous).
	 */
	convertEventCoord: function(pPos, pZone)
	{
		var cr = pZone.continent_rect_actual || pZone.continent_rect; // 2D float array
		var mr = pZone.map_rect; // 2D float array
		
		// Code from http://gw2.chillerlan.net/examples/gw2maps-jquery.html
		return [
			~~(cr[0][0]+(cr[1][0]-cr[0][0])*(pPos[0]-mr[0][0])/(mr[1][0]-mr[0][0])),
			~~(cr[0][1]+(cr[1][1]-cr[0][1])*(1-(pPos[1]-mr[0][1])/(mr[1][1]-mr[0][1])))
		];
	},
	convertEventCoordMulti: function(pPosArray, pZone)
	{
		var coords = [];
		for (var i = 0; i < pPosArray.length; i++)
		{
			coords.push(this.convertEventCoord(pPosArray[i], pZone));
		}
		return coords;
	},
	
	/*
	 * Converts a MumbleLink player coordinates to the map coordinates system.
	 * @param 2D float array pPos [latitude altitude longitude] player position.
	 * @param object pZone the player is in.
	 * @returns 2D int array map coordinates.
	 */
	convertGPSCoord: function(pPos, pZone)
	{
		var coord = new Array(3);
		coord[0] = pPos[0] * T.cMETERS_TO_UNITS; // x coordinate
		coord[1] = pPos[2] * T.cMETERS_TO_UNITS; // y coordinate
		coord[2] = pPos[1] * T.cMETERS_TO_UNITS; // z coordinate
		return this.convertEventCoord(coord, pZone);
	},
	
	/*
	 * Converts a MumbleLink 3D vector values to degrees of 2D rotation.
	 * @param 2D array pVector [x, z, y].
	 * @returns float degrees.
	 */
	convertGPSAngle: function(pVector)
	{
		return Math.atan2(pVector[2], pVector[0]) * T.cRADIAN_TO_DEGREE;
	},
	
	/*
	 * Gets the angle between two map coordinates.
	 * @param array pCoordA game coordinates.
	 * @param array pCoordB game coordinates.
	 * @returns float degree.
	 */
	convertDirectionAngle: function(pCoordA, pCoordB)
	{
		return Math.atan2(pCoordB[1] - pCoordA[1], pCoordB[0] - pCoordA[0]) * T.cRADIAN_TO_DEGREE;
	},
	
	/*
	 * Converts a coordinate string to array coordinates.
	 * @param string pString coordinates in the form of "[X, Y]" GW2 coords.
	 * @returns array of numbers.
	 */
	parseCoordinates: function(pString)
	{
		// The regex strips all characters except digits, commas, periods, and minus sign
		var coord = pString.toString().replace(/[^\d,-.]/g, "");
		return coord.split(",");
	},
	
	/*
	 * Converts a string of coordinates to a 2D array.
	 * @param string pString array in the form of "[[X1,Y1],[X2,Y2]]" GW2 coords.
	 * @returns 2D array of coordinates. null if unable to parse.
	 */
	parseCoordinatesMulti: function(pString)
	{
		var arraylengthlimit = 13;
		var s = pString.replace(/\s/g, "");
		var sarray = [];
		var narray = [];
		var coord;
		
		if (s.length >= arraylengthlimit &&
			(s.charAt(0) === "["
			&& s.charAt(1) === "["
			&& s.charAt(s.length - 1) === "]"
			&& s.charAt(s.length - 2) === "]"))
		{
			s = s.substring(2, s.length-2); // Trim the [[ and ]]
			sarray = s.split("],["); // Create array from assumed "separator"
			for (var i in sarray)
			{
				coord = sarray[i].split(",");
				if (coord.length === 2)
				{
					coord[0] = Math.round(coord[0]);
					coord[1] = Math.round(coord[1]);
					narray.push(coord);
				}
			}
			return narray;
		}
		return null;
	},
	
	/*
	 * Converts and prints an array of LatLngs to GW2 coordinates.
	 * @param 2D array pArray.
	 * @returns 2D array.
	 */
	convertLatLngs: function(pArray)
	{
		if (Array.isArray(pArray))
		{
			var coords = this.convertLCtoGCMulti(pArray);
			P.printCoordinates(coords);
		}
	},
	
	/*
	 * Gets the coordinates from the data attribute of an HTML element.
	 * @param jqobject pElement to extract from.
	 * @returns array of GW2 coordinates.
	 */
	getElementCoordinates: function(pElement)
	{
		var coordstring = pElement.attr("data-coord");
		if (this.Zones[coordstring])
		{
			return this.getZoneCenter(coordstring);
		}
		return this.parseCoordinates(coordstring);
	},
	
	/*
	 * Binds map view event handlers to all map links (dfn tag reserved) in the
	 * specified container.
	 * @param string pContainer element ID.
	 * @param enum pZoom level.
	 */
	bindMapLinks: function(pContainer, pZoom)
	{
		if (I.isMapEnabled === false) { return; }
		var that = this;
		$(pContainer + " dfn").each(function()
		{
			$(this).text("[" + $(this).text() + "]");
			that.bindMapLinkBehavior($(this), pZoom, that.Pin.Program);
		});
	},
	
	/*
	 * Binds specified link to move a pinpoint to the location when hovered, and
	 * to view the map location when clicked.
	 * @param jqobject pLink to bind.
	 * @param object pPin marker to move.
	 * @param enum pZoom level when viewed location.
	 */
	bindMapLinkBehavior: function(pLink, pZoom, pPin)
	{
		if (I.isMapEnabled === false || pLink === undefined || pLink === null) { return; }
		var that = this;
		pLink.click(function()
		{
			var command = $(this).attr("data-coord");
			Z.interpretCommand(command, that, pZoom, pPin);
			C.isTouringManual = false;
		});
		
		pLink.dblclick(function()
		{
			var thiscoord = that.getElementCoordinates($(this));
			if (thiscoord.length > 1)
			{
				if (that.Map.getZoom() === that.ZoomEnum.Max)
				{
					that.goToView(thiscoord, that.ZoomEnum.Default, pPin);
				}
				else
				{
					that.Map.zoomIn();
				}
			}
		});
		
		pLink.contextmenu(function(pEvent)
		{
			pEvent.preventDefault();
			var thislatlng = that.convertGCtoLC(that.getElementCoordinates($(this)));
			if (that.Map.getZoom() === that.ZoomEnum.Max)
			{
				var center = that.Map.getCenter();
				if (~~(center.lat) === ~~(thislatlng.lat)
					&& ~~(center.lng) === ~~(thislatlng.lng))
				{
					// If maxed zoom and centered on the marker, then zoom out
					that.Map.setZoom(that.ZoomEnum.Default);
				}
				else
				{
					// If maxed zoom and not centered on the marker, then center on the marker
					that.Map.setView(thislatlng, that.Map.getZoom());
				}
			}
			else
			{
				// All other cases zoom and center on the marker
				that.Map.setView(thislatlng, that.ZoomEnum.Max);
			}
		});
		
		// Move a point pin to that location as a preview
		pLink.mouseover(function()
		{
			var thiscoord = that.getElementCoordinates($(this));
			if (thiscoord.length > 1)
			{
				that.movePin(that.Pin.Over, thiscoord);
			}
		});
		pLink.mouseout(function()
		{
			that.movePin(that.Pin.Over);
		});
	},
	
	/*
	 * Binds standard behavior when user do something to an icon on the map.
	 * @param object pMarker to bind.
	 * @param string pEventType like "click" or "dblclick".
	 */
	bindOverviewBehavior: function(pMarker, pEventType)
	{
		var that = this;
		pMarker.on(pEventType, function(pEvent)
		{
			that.goToZone(pMarker.options.mappingzone, that.ZoomEnum.Sky);
		});
	},
	bindMarkerZoomBehavior: function(pMarker, pEventType, pZoomOut)
	{
		if (I.isTouchEnabled)
		{
			return;
		}
		var that = this;
		if (pZoomOut === undefined)
		{
			pZoomOut = that.ZoomEnum.Default;
		}
		
		pMarker.on(pEventType, function(pEvent)
		{
			if (that.Map.getZoom() === that.ZoomEnum.Max)
			{
				var center = that.Map.getCenter();
				if (~~(center.lat) === ~~(pEvent.latlng.lat)
					&& ~~(center.lng) === ~~(pEvent.latlng.lng))
				{
					// If maxed zoom and centered on the marker, then zoom out
					that.Map.setZoom(pZoomOut);
				}
				else
				{
					// If maxed zoom and not centered on the marker, then center on the marker
					that.Map.setView(pEvent.latlng, that.Map.getZoom());
				}
			}
			else
			{
				// All other cases zoom and center on the marker
				that.Map.setView(pEvent.latlng, that.ZoomEnum.Max);
			}
		});
	},
	bindMarkerCoordBehavior: function(pMarker, pEventType)
	{
		if (I.isTouchEnabled)
		{
			return;
		}
		var that = this;
		pMarker.on(pEventType, function()
		{
			var coord = that.convertLCtoGC(this.getLatLng());
			that.outputCoordinatesCopy(P.formatCoord(coord));
		});
	},
	bindMarkerWikiBehavior: function(pMarker, pEventType, pWantDefault)
	{
		if (I.isTouchEnabled)
		{
			return;
		}
		pMarker.on(pEventType, function(pEvent)
		{
			U.openExternalURL(C.getEventWiki(this.options.wiki, pWantDefault));
		});
	},
	
	/*
	 * Translates the zones list in the Map page and bind click zoom behavior.
	 * @pre The translated names from the API was retrieved.
	 */
	bindZoneList: function(pMapObject)
	{
		var that = pMapObject;
		var htmlidprefix = "#" + that.MapEnum;
		$(htmlidprefix + "ZoneList li").each(function()
		{
			var zonenick = $(this).attr("data-zone");
			$(this).text(that.getZoneName(zonenick));
			$(this).attr("data-coord", that.getZoneCenter(zonenick).toString());
			that.bindMapLinkBehavior($(this), {offset: 1});
		});
		$(htmlidprefix + "ZoneList h2").each(function()
		{
			var regionnick = $(this).attr("data-region");
			$(this).text(D.getObjectName(that.Regions[regionnick]));
		});
	}	
};
P = {
/* =============================================================================
 * @@Populate GPS shared and independent map properties and functions
 * ========================================================================== */

	MapSwitchObject: M, // Reference to the map superobject
	MapSwitchSuffix: "", // Map options with suffix to differentiate for which map
	MapSwitchWebsite: "map", // The map currently displayed on the website
	MapSwitchGPS: null, // The map which the player resides in game
	MapEnum:
	{
		Tyria: "map",
		Mists: "wvw"
	},
	TempSubmap: {
		submap: {},
		img: "http://i.imgur.com/cTSJUvZ.jpg", 
		bounds: [[20736, 6656], [23808, 8192]]
	},
	
	Layer: {
		ZoneBorder: new L.layerGroup(), // Rectangles colored specific to the zones' region
		ZoneGateway: new L.layerGroup(), // Interzone and intergate connections
		ZonePowerup: new L.layerGroup(), // Pick up mobility skills
		ZoneLaunchpad: new L.layerGroup(), // One direction transports
		DryTopNicks: new L.layerGroup(), // Dry Top event names and timestamps
		Chest: new L.layerGroup()
	},
	NodeArray: { // An ordered array of markers and associated path
		JP: []
	},
	LayerArray: {
		ChainPath: [],
		Resource: [],
		JP: [],
		Guild_Bounty: [],
		Guild_Trek: [],
		Guild_Challenge: [],
		Guild_Rush: [],
		Guild_Puzzle: [],
		DryTopIcons: [],
		DryTopRings: [],
		DryTopActive: []
	},
	LocationsDatabase: [], // A searchable array of API markers like POIs, hearts, events
	
	Events: {},
	DryTopTimer: {},
	Resources: {},
	JPs: {},
	Chests: {},
	Collectibles: {},
	Guild: {},
	GPSTimeout: {},
	isGPSPrinting: false,
	
	/*
	 * Initializes the map only if the boolean set by specific modes is on.
	 */
	initializeMap: function()
	{
		if (I.isMapEnabled)
		{
			M.initializeMap();
		}
	},
	rebindMarkerTooltips: function()
	{
		I.qTip.init(".leaflet-marker-icon");
	},
	
	/*
	 * Adds an API map location to the searchable database array.
	 * @param array pCoord of the location.
	 * @param string pName of the location.
	 * @param string pIcon URL of the type of location.
	 * @param string pKeywords additional words for the search string.
	 */
	addMapLocation: function(pCoord, pName, pIcon, pKeywords)
	{
		var object = {
			name: pName,
			icon: pIcon,
			coord: pCoord,
			keywords: (pName + " " + pKeywords).toLowerCase()
		};
		P.LocationsDatabase.push(object);
	},
		
	/*
	 * Generates map waypoints and other markers from the GW2 server API files.
	 */
	populateMap: function(pMapObject)
	{
		if (I.isMapEnabled === false)
		{
			return;
		}
		var that = pMapObject;
		var url;
		var completionboolean = O.Options["bol_showWorldCompletion" + that.OptionSuffix];
		switch (that.MapEnum)
		{
			case P.MapEnum.Tyria: {
				url = U.getLangURL(U.URL_API.MapFloorTyria);
			} break;
			
			case P.MapEnum.Mists: {
				url = U.getLangURL(U.URL_API.MapFloorMists);
				// Exit this entire function if using the Mists map but have completion option off
				if (completionboolean === false)
				{
					return;
				}
			} break;
		}
		
		// Switches and functions to execute after population
		var finalizePopulate = function(pIsSuccess)
		{
			if (pIsSuccess)
			{
				that.isAPIRetrieved_MAPFLOOR = true;
			}
			/*
			 * AJAX takes a while so can use this to advantage to delay graphics
			 * that seem out of place without a map loaded.
			 */
			if (that.MapEnum === P.MapEnum.Tyria && O.Options.bol_displayEvents === false)
			{
				P.donePopulation();
			}
			
			switch (that.MapEnum)
			{
				case P.MapEnum.Tyria: {
					if (O.Options.bol_displayEvents === true)
					{
						P.populateEvents();
					}
					else
					{
						P.finishPopulation();
					}
				} break;

				case P.MapEnum.Mists: {
					W.finishPopulation();
				} break;
			}
		};
		
		/*
		 * map_floor.json sample structure of desired data
		 * Code based on API documentation.
		{
			"regions":
			{
				"1":
				{
					"name": "Shiverpeak Mountains"
					"maps":
					{
						"26":
						{
							"name": "Dredgehaunt Cliffs",
							"continent_rect": [[19456, 14976], [21760, 18176]],
							"points_of_interest":
							[{
								"poi_id": 602,
								"name": "Grey Road Waypoint",
								"type": "waypoint",
								"coord": [20684.6, 17105.3]
							},
							...
							]
						}
					}
				}
			}
		}*/	
		var doPopulate = function(pData)
		{
			var i;
			var numofpois;
			var regionid, region, zoneid, apizone, poi, zoneobj;
			var marker, icon, area, cssclass, tooltip;
			var translationsector = D.getTranslation("Sector");
			var translationpoi = D.getTranslation("Point of Interest");
			var translationvista = D.getTranslation("Vista");
			var translationmastery = D.getTranslation("Mastery Insight");
			var translationchallenge = D.getTranslation("Hero Challenge");
			var translationheart = D.getTranslation("Heart");

			for (regionid in pData.regions)
			{
				region = pData.regions[regionid];

				for (zoneid in region.maps)
				{
					// Don't bother parsing if not a regular world zone
					zoneobj = that.getZoneFromID(zoneid);
					if ( ! zoneobj || zoneobj.ispopulated)
					{
						continue;
					}
					
					zoneobj.ispopulated = true; // Mark as populated to avoid duplicate zones
					apizone = region.maps[zoneid];
					var zonename = D.getObjectName(zoneobj);
					var numheart = 0;
					var numwaypoint = 0;
					var numlandmark = 0;
					var numvista = 0;
					var nummastery = 0;
					var numchallenge = 0;
					
					/* 
					 * For waypoints, points of interest, and vistas.
					 */
					numofpois = apizone.points_of_interest.length;
					for (i = 0; i < numofpois; i++)
					{
						poi = apizone.points_of_interest[i];

						// Properties assignment based on location's type
						switch (poi.type)
						{
							case that.APIPOIEnum.Waypoint:
							{
								// Waypoints are always created for Tyria, others are optional
								numwaypoint++;
								icon = U.URL_IMG.Waypoint;
								cssclass = "mapWp";
								tooltip = poi.name;
								P.addMapLocation(poi.coord, poi.name, icon, zonename);
							} break;
							
							case that.APIPOIEnum.Landmark:
							{
								if (completionboolean === false)
								{
									continue;
								}
								numlandmark++;
								icon = U.URL_IMG.Landmark;
								cssclass = "mapPoi";
								tooltip = poi.name;
								P.addMapLocation(poi.coord, poi.name, icon, zonename + " " + translationpoi);
							} break;
							
							case that.APIPOIEnum.Vista:
							{
								if (completionboolean === false)
								{
									continue;
								}
								numvista++;
								icon = U.URL_IMG.Vista;
								cssclass = "mapPoi";
								tooltip = translationvista;
								P.addMapLocation(poi.coord, zonename + " " + translationvista + " " + poi.poi_id, icon, zonename + " " + translationvista);
							} break;
							
							default: continue; // Don't create marker if not desired type
						}

						marker = L.marker(that.convertGCtoLC(poi.coord),
						{
							title: "<span class='" + cssclass + "'>" + tooltip + "</span>",
							markername: poi.name,
							icon: L.icon(
							{
								iconUrl: icon,
								iconSize: [16, 16], // Initial size corresponding to default zoom level
								iconAnchor: [8, 8]
							}),
							id: poi.poi_id
						});
						
						// Bind behavior
						switch (poi.type)
						{
							case that.APIPOIEnum.Waypoint:
							{
								marker.on("mouseout", function()
								{
									// Workaround a null pointer exception when changing zones
									try { this._icon.src = U.URL_IMG.Waypoint; } catch (e) {}
								});
								marker.on("mouseover", function()
								{
									this._icon.src = U.URL_IMG.WaypointOver;
								});
								zoneobj.Layers.Waypoint.addLayer(marker);
							} break;
							case that.APIPOIEnum.Landmark:
							{
								marker.on("mouseout", function()
								{
									try { this._icon.src = U.URL_IMG.Landmark; } catch (e) {}
								});
								marker.on("mouseover", function()
								{
									this._icon.src = U.URL_IMG.LandmarkOver;
								});
								zoneobj.Layers.Landmark.addLayer(marker);
							} break;
							case that.APIPOIEnum.Vista:
							{
								zoneobj.Layers.Vista.addLayer(marker);
							} break;
						}
						// Clicking on waypoints or POIs gives a chatlink
						if (I.isTouchEnabled === false)
						{
							if (poi.type === that.APIPOIEnum.Waypoint || poi.type === that.APIPOIEnum.Landmark)
							{
								marker.on("click", function()
								{
									that.outputCoordinatesCopy(U.getChatlinkFromPoiID(this.options.id));
									that.outputCoordinatesName(this.options.markername);
								});
								marker.on("dblclick", function()
								{
									if (D.isLanguageDefault)
									{
										U.openExternalURL(U.getWikiLinkLanguage(this.options.markername));
									}
									else
									{
										U.openExternalURL(U.getWikiLinkCode(this.options.id, this.options.markername));
									}
								});
								that.bindMarkerZoomBehavior(marker, "contextmenu", that.ZoomEnum.Sky);
							}
							else
							{
								that.bindMarkerZoomBehavior(marker, "click", that.ZoomEnum.Sky);
								that.bindMarkerZoomBehavior(marker, "contextmenu", that.ZoomEnum.Sky);
							}
						}
					}
					
					/*
					 * For API arrays separate from pois.
					 */
					if (completionboolean)
					{
						// Mastery Insights
						if (apizone.training_points)
						{
							numofpois = apizone.training_points.length;
							nummastery = numofpois;
							icon = U.URL_IMG.Mastery;
							for (i = 0; i < numofpois; i++)
							{
								poi = apizone.training_points[i];
								marker = L.marker(that.convertGCtoLC(poi.coord),
								{
									title: "<span class='" + "mapPoi" + "'>" + translationmastery + "</span>",
									icon: L.icon(
									{
										iconUrl: icon,
										iconSize: [16, 16],
										iconAnchor: [8, 8]
									})
								});
								that.bindMarkerZoomBehavior(marker, "click", that.ZoomEnum.Sky);
								that.bindMarkerZoomBehavior(marker, "contextmenu", that.ZoomEnum.Sky);
								zoneobj.Layers.Mastery.addLayer(marker);
								P.addMapLocation(poi.coord, zonename + " " + translationmastery + " " + poi.id, icon, zonename + " " + translationmastery);
							}
						}
						
						// Hero Challenges
						if (apizone.skill_challenges)
						{
							numofpois = apizone.skill_challenges.length;
							numchallenge = numofpois;
							icon = U.URL_IMG.Challenge;
							for (i = 0; i < numofpois; i++)
							{
								poi = apizone.skill_challenges[i];
								marker = L.marker(that.convertGCtoLC(poi.coord),
								{
									title: "<span class='" + "mapPoi" + "'>" + translationchallenge + "</span>",
									icon: L.icon(
									{
										iconUrl: icon,
										iconSize: [16, 16],
										iconAnchor: [8, 8]
									})
								});
								that.bindMarkerZoomBehavior(marker, "click", that.ZoomEnum.Sky);
								that.bindMarkerZoomBehavior(marker, "contextmenu", that.ZoomEnum.Sky);
								zoneobj.Layers.Challenge.addLayer(marker);
								P.addMapLocation(poi.coord, zonename + " " + translationchallenge + " " + poi.idx, icon, zonename + " " + translationchallenge);
							}
						}
						
						// Renown Hearts
						if (apizone.tasks)
						{
							numofpois = apizone.tasks.length;
							numheart = numofpois;
							icon = U.URL_IMG.Heart;
							for (i = 0; i < numofpois; i++)
							{
								poi = apizone.tasks[i];
								marker = L.marker(that.convertGCtoLC(poi.coord),
								{
									title: "<span class='" + "mapPoi" + "'>" + poi.objective + " (" + poi.level + ")" + "</span>",
									wiki: poi.objective,
									icon: L.icon(
									{
										iconUrl: icon,
										iconSize: [16, 16],
										iconAnchor: [8, 8]
									})
								});
								M.bindMarkerWikiBehavior(marker, "click");
								M.bindMarkerZoomBehavior(marker, "contextmenu", that.ZoomEnum.Sky);
								zoneobj.Layers.Heart.addLayer(marker);
								P.addMapLocation(poi.coord, poi.objective, icon, zonename + " " + translationheart);

								// Heart Area
								area = L.polygon(that.convertGCtoLCMulti(poi.bounds), {
									clickable: false,
									color: "#ffc321",
									weight: 2,
									opacity: 0.8,
									fillOpacity: 0.1
								});
								zoneobj.Layers.HeartArea.addLayer(area);
								
								// Highlight the heart's area when hovered over its icon
								(function(iArea)
								{
									marker.on("mouseover", function() { iArea.setStyle({ color: "lime" }); })
										.on("mouseout", function() { iArea.setStyle({ color: "#ffc321" }); });
								})(area);
							}
						}
						
						// Sector Names
						if (apizone.sectors)
						{
							numofpois = apizone.sectors.length;
							icon = U.URL_IMG.Sector;
							for (i = 0; i < numofpois; i++)
							{
								poi = apizone.sectors[i];
								marker = L.marker(that.convertGCtoLC(poi.coord),
								{
									clickable: false,
									icon: L.divIcon(
									{
										className: "mapSec",
										html: "<span class='mapSecIn'>" + poi.name + "</span>",
										iconSize: [512, 64],
										iconAnchor: [256, 32]
									})
								});
								zoneobj.Layers.Sector.addLayer(marker);
								P.addMapLocation(poi.coord, poi.name, icon, zonename + " " + translationsector);

								// Sector Area
								area = L.polyline(that.convertGCtoLCMulti(poi.bounds), {
									clickable: false,
									color: "white",
									weight: 2,
									opacity: 0.8
								});
								zoneobj.Layers.SectorArea.addLayer(area);
							}
						}
						
						that.isMappingIconsGenerated = true;
					}
					
					// Generate locations overview for this zone
					if (completionboolean)
					{
						marker = L.marker(that.convertGCtoLC(zoneobj.center),
						{
							mappingzone: zoneobj.nick,
							riseOnHover: true,
							icon: L.divIcon(
							{
								className: "mapOverview",
								html: "<span class='mapOverviewIn'>"
									+ "<var class='mapOverviewName'>" + D.getObjectName(zoneobj) + "</var>"
									+ ((apizone.min_level > 0) ? ("<var class='mapOverviewLevel'>"
										+ ((apizone.min_level === 80) ? (apizone.max_level) : (apizone.min_level + " - " + apizone.max_level))
									+ "</var>") : "")
									+ ((numheart > 0) ? ("<img src='img/map/heart.png' />" + numheart + " ") : "")
									+ ((numwaypoint > 0) ? ("<img src='img/map/waypoint.png' />" + numwaypoint + " ") : "")
									+ ((numlandmark > 0) ? ("<img src='img/map/landmark.png' />" + numlandmark + " ") : "")
									+ ((numchallenge > 0) ? ("<img src='img/map/challenge.png' />" + numchallenge + " ") : "")
									+ ((numvista > 0) ? ("<img src='img/map/vista.png' />" + numvista) : "")
									+ ((nummastery > 0) ? ("<img src='img/map/mastery.png' />" + nummastery + " ") : "")
								+ "</span>",
								iconSize: [256, 64],
								iconAnchor: [128, 32]
							})
						});
						that.bindOverviewBehavior(marker, "click");
						that.bindOverviewBehavior(marker, "contextmenu");
						that.Layer.Overview.addLayer(marker);
						that.toggleLayer(that.Layer.Overview, true);
					}
				}
			}
		};
		
		/*
		 * Retrieve map data from API.
		 */
		$.getJSON(url, function(pData)
		{
			doPopulate(pData);
			finalizePopulate(true);
		}).fail(function()
		{
			I.isAPIEnabled = false;
			// If failed to get from API then use backup cache
			if (that.MapEnum === P.MapEnum.Tyria)
			{
				if (I.ModeCurrent === I.ModeEnum.Website)
				{
					I.urge(
						"ArenaNet API server is unreachable. <a" + U.convertExternalAnchor(U.URL_API.Support + "?source=map") + ">Check status</a>.<br />"
						+ "Map will use backup cache and features will be limited.<br />");
				}
				
				$.getJSON(U.URL_DATA.Maps, function(pBackup)
				{
					doPopulate(pBackup);
					finalizePopulate(true);
				});
			}
			else
			{
				finalizePopulate(false);
			}
		});
	},
	
	/*
	 * Generates icons and rings for all dynamic events.
	 */
	populateEvents: function()
	{
		// Function to filter out unwanted events
		var isEventUnwanted = function(pName)
		{
			var blacklist = [
				"scarlet", "molten all", "overdue emi", "aetherblade", "queen's cha", "mordrem inv", "offshoot", "vigil eng", "haunted", // Obsolete events
				"stabilize the rift", // Rift events
				"guild", // Guild missions
				"subdue", // Guild bounty
				"hero cha" // Hero challenges
			];
			for (var i = 0; i < blacklist.length; i++)
			{
				if (pName.indexOf(blacklist[i]) !== -1)
				{
					return true;
				}
			}
			return false;
		};
		
		// Function to guess an event's icon (not provided by the API) based on its name
		var determineEventIcon = function(pName)
		{
			if (pName.indexOf("free") !== -1) return "release";
			if (pName.indexOf("rescue") !== -1) return "release";
			if (pName.indexOf("capture") !== -1) return "flag";
			if (pName.indexOf("retake") !== -1) return "flag";
			if (pName.indexOf("reclaim") !== -1) return "flag";
			if (pName.indexOf("liberate") !== -1) return "flag";
			if (pName.indexOf("protect") !== -1) return "shield";
			if (pName.indexOf("defend") !== -1) return "shield";
			if (pName.indexOf("escort") !== -1) return "shield";
			if (pName.indexOf("kill") !== -1) return "boss";
			if (pName.indexOf("slay") !== -1) return "boss";
			if (pName.indexOf("defeat") !== -1) return "boss";
			if (pName.indexOf("collect") !== -1) return "collect";
			if (pName.indexOf("help") !== -1) return "star";
			if (pName.indexOf("destroy") !== -1) return "cog";
			if (pName.indexOf("gather") !== -1) return "collect";
			if (pName.indexOf("bring") !== -1) return "collect";
			if (pName.indexOf("recover") !== -1) return "collect";
			if (pName.indexOf("return") !== -1) return "collect";
			if (pName.indexOf("retrieve") !== -1) return "collect";
			if (pName.indexOf("salvage") !== -1) return "collect";
			if (pName.indexOf("treasure") !== -1) return "fist";
			return "swords";
		};
		var iconURL = {
			release: "img/event/release.png",
			flag: "https://render.guildwars2.com/file/A4F01E7A5E90382F0ACFA71348E4241900529EB5/102321.png",
			shield: "https://render.guildwars2.com/file/4D52C9605D6F19D3B6FB00D39E95EC45C3FCB62C/102387.png",
			boss: "https://render.guildwars2.com/file/9C97043218F4EF1205B6FB5503CFCCA038D607E1/102392.png",
			collect: "https://render.guildwars2.com/file/7695C3055956ACCC4D7F273F59B2120B0CB123B0/102330.png",
			star: "https://render.guildwars2.com/file/F6B0F9F82D1D3A000D1827E3EA59A7D734141004/102388.png",
			cog: "https://render.guildwars2.com/file/92BC536037C0AA531E9019D7AB3A23C71805FB99/102393.png",
			fist: "https://render.guildwars2.com/file/9005555700262173FB6506A12204776AAEC6A40F/102391.png",
			swords: "https://render.guildwars2.com/file/98EB189CADF825549B187C57B551CE1AA29CA694/102320.png"
		};
		
		// Function to store event names for filtering
		var initializeEvents = function(pEventData)
		{
			var id;
			for (id in pEventData.events)
			{
				P.Events[id] = {};
				P.Events[id].name = pEventData.events[id].name;
			}
		};
		
		// Function to filter events and generate event markers
		var generateEvents = function(pData)
		{
			// Retrieve the event details in the default language for filtering events
			$.getJSON(U.URL_API.EventDetails, function(pDataInner)
			{
				var i;
				var event;
				var searchname;
				var newname;
				var marker, label, area, icon;
				var coord, coordmarker, areacoords, radius, trueradius;
				var instructionstr = D.getPhraseOriginal("Drag to separate") + ". " + D.getPhraseOriginal("Double click for wiki") + ".";

				var zoneobj, zonename;
				initializeEvents(pData || pDataInner);

				for (i in pDataInner.events)
				{
					event = pDataInner.events[i];
					searchname = event.name.toLowerCase();
					newname = (P.Events[i] !== undefined) ? P.Events[i].name : event.name;
					zoneobj = M.getZoneFromID(event.map_id);
					zonename = D.getObjectName(zoneobj);
					// Skip iterated event if...
					if ( ! zoneobj // Event is not in a world map zone
						|| isEventUnwanted(searchname) // Event is obsolete
						|| event.map_id === 50) // LA
					{
						continue;
					}
					
					coord = M.getEventCenter(event);
					coordmarker = M.convertGCtoLC(coord);

					// Create event's area if coordinates are available, otherwise create a circle
					if (event.location.points)
					{
						areacoords = M.convertEventCoordMulti(event.location.points, zoneobj);
						area = L.polygon(M.convertGCtoLCMulti(areacoords), {
							clickable: false,
							color: "#ff8844",
							weight: 2,
							opacity: 0.8,
							fillOpacity: 0.1
						});
						zoneobj.Layers.EventArea.addLayer(area);
					}
					else
					{
						trueradius = (event.location.radius || 1) * T.cUNITS_TO_POINTS;
						radius = M.getZoomedDistance(trueradius);
						area = L.circleMarker(coordmarker, {
							trueradius: trueradius,
							radius: radius,
							clickable: false,
							color: "#ff8844",
							weight: 2,
							opacity: 0.8,
							fillOpacity: 0.1
						});
						zoneobj.Layers.EventCircle.addLayer(area);
					}
					
					// Create event's label
					label = L.marker(coordmarker,
					{
						clickable: false,
						icon: L.divIcon(
						{
							className: "mapSec",
							html: "<span class='mapSecIn'>" + newname + "</span>",
							iconSize: [128, 128],
							iconAnchor: [64, 64]
						})
					});
					zoneobj.Layers.EventLabel.addLayer(label);

					// Use API's icon type if available, otherwise guess
					if (event.icon)
					{
						icon = U.getAPIImage(event.icon.signature + "/" + event.icon.file_id);
					}
					else
					{
						icon = iconURL[determineEventIcon(searchname)];
					}
					marker = L.marker(coordmarker,
					{
						title: "<span class='mapPoi'><dfn>" + newname + "</dfn> (" + event.level + ")<br /><cite>" + instructionstr + "</cite></span>",
						wiki: event.name,
						coord: coord,
						eventid: i,
						icon: L.icon(
						{
							iconUrl: icon,
							iconSize: [48, 48],
							iconAnchor: [24, 24]
						}),
						draggable: true
					});
					
					// Highlight the event's area when hovered over its icon
					(function(iLabel, iArea)
					{
						marker.on("mouseover", function() { iArea.setStyle({ color: "red" }); })
							.on("mouseout", function() { iArea.setStyle({ color: "#ff8844" }); })
							.on("drag", function()
						{
							iLabel.setLatLng(this.getLatLng());
						});
					})(label, area);
					
					// Bind standard behaviors
					M.bindMarkerCoordBehavior(marker, "click", true);
					M.bindMarkerWikiBehavior(marker, "dblclick", true);
					M.bindMarkerZoomBehavior(marker, "contextmenu");
					zoneobj.Layers.EventIcon.addLayer(marker);
					P.addMapLocation(coord, event.name, icon, zonename + " " + event.name);
				}
				M.isEventIconsGenerated = true;

			}).done(function()
			{
				P.donePopulation();
			}).always(function()
			{
				P.finishPopulation();
			});
		};
		
		/*
		 * Before generating the events, all event names must be collected first
		 * so obsolete events can be filtered. Non-default languages has to download
		 * the event data twice because the filter keywords are in the default language.
		 */
		if (D.isLanguageDefault)
		{
			generateEvents();
		}
		else
		{
			// Store the event names in user's language
			$.getJSON(U.getLangURL(U.URL_API.EventDetails), function(pData)
			{
				generateEvents(pData);
			}).fail(function()
			{
				P.finishPopulation();
			});
		}
	},
	
	/*
	 * Does final touches to the map after the icons have been generated.
	 */
	donePopulation: function()
	{
		M.refreshCurrentZone();
	},
	finishPopulation: function()
	{
		// Do visual changes
		M.isMapAJAXDone = true;
		M.bindMapVisualChanges();
		M.adjustZoomMapping();
		P.adjustZoomDryTop();
		P.initializeMapSearch();
		
		// Execute query string commands if available
		if (I.PageInitial !== "wvw")
		{
			M.executeURLCommands();
		}
	},
	
	/*
	 * Compiles a searchable database of API map locations like hearts and events.
	 * @pre Locations were completely downloaded.
	 */
	initializeMapSearch: function()
	{
		$("#mapZoneButton").one("mouseenter", function()
		{
			I.preventMapPropagation("#mapSearch");
			Q.bindItemSearch("#mapSearch", {
				aDatabase: P.LocationsDatabase,
				aResultsClass: "mapSearchResults",
				aResultsLimit: 200,
				aCallback: function(pLocation)
				{
					M.goToView(pLocation.coord, M.ZoomEnum.Same, M.Pin.Program);
				}
			});
		});
	},
	
	/*
	 * Conditions needed to do the initial zoom to event on pageload.
	 * @returns true if qualify.
	 */
	wantTourPrediction: function()
	{
		if (I.isMapEnabled
			&& O.Options.bol_tourPrediction && I.ModeCurrent !== I.ModeEnum.Overlay
			&& (I.PageCurrent === I.PlateEnum.Chains || I.PageCurrent === I.PlateEnum.Directory)
			&& C.isDryTopIconsShown === false
			&& !(U.Args[U.KeyEnum.Go]))
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Initializes an array of nodes, which is an indexed marker with an associated path.
	 * @param array pNodeArray reference to initialize.
	 * @param int length for the array.
	 * @returns array of empty nodes.
	 */
	createNodeArray: function(pLength)
	{
		var nodearray = new Array(pLength);
		for (var i = 0; i < pLength; i++)
		{
			nodearray[i] = {
				oMarker: null,
				oPath: null
			};
		}
		return nodearray;
	},
	
	/*
	 * Toggles visibility of map objects of a node.
	 * @param array pNodeArray.
	 * @param int pIndex to find node.
	 * @param boolean pBoolean to show.
	 */
	toggleNode: function(pNodeArray, pIndex, pBoolean)
	{
		if (pNodeArray[pIndex])
		{
			M.toggleLayer(pNodeArray[pIndex].oMarker, pBoolean);
			M.toggleLayer(pNodeArray[pIndex].oPath, pBoolean);
		}
	},
	toggleNodeArray: function(pNodeArray, pBoolean)
	{
		for (var i = 0; i < pNodeArray.length; i++)
		{
			M.toggleLayer(pNodeArray[i].oMarker, pBoolean);
			M.toggleLayer(pNodeArray[i].oPath, pBoolean);
		}
	},
	
	/*
	 * Gets ID of a Leaflet layer.
	 * @param object pLayer.
	 * @returns string ID number.
	 */
	getLayerId: function(pLayer)
	{
		return pLayer["_leaflet_id"];
	},
	
	/*
	 * Gets the object containing the layers.
	 * @param object pLayerGroup
	 * @returns object iterable.
	 */
	getLayerGroup: function(pLayerGroup)
	{
		return pLayerGroup["_layers"];
	},
	
	/*
	 * Sorts an array of GW2 coordinates.
	 * @param 2D array pArray to sort.
	 */
	sortCoordinates: function(pCoords, pIsNumbered)
	{
		var coord;
		// Convert to integer
		for (var i in pCoords)
		{
			coord = pCoords[i];
			coord[0] = Math.round(coord[0]);
			coord[1] = Math.round(coord[1]);
		}
		// Sort the array
		pCoords.sort(function (a, b)
		{
			if (a[0] > b[0])
			{
				return 1;
			}
			if (a[0] < b[0])
			{
				return -1;
			}
			return 0;
		});
		// Print the result formatted
		if (pIsNumbered)
		{
			for (var i in pCoords)
			{
				this.printNumberedCoordinates(pCoords[i], i);
			}
		}
		else
		{
			return pCoords;
		}
	},
	roundCoordinates: function(pCoords, pIsPair)
	{
		var coord;
		// Convert to integer
		for (var i in pCoords)
		{
			coord = pCoords[i];
			coord[0] = Math.round(coord[0]);
			coord[1] = Math.round(coord[1]);
		}
		// Print the result formatted
		this.printCoordinates(pCoords, pIsPair);
	},
	printNeedles: function(pNeedles)
	{
		for (var i in pNeedles)
		{
			this.printNumberedCoordinates((pNeedles[i]).c, i);
		}
	},
	printNodes: function(pCoords, pIsNumbered)
	{
		for (var i = 0; i < pCoords.length; i++)
		{
			var numprefix = (pIsNumbered) ? ("n: " + (i+1) + ", ") : "";
			I.print("{" + numprefix + "c: [" + (pCoords[i])[0] + ", " + (pCoords[i])[1] + "]},");
		}
	},
	printNumberedCoordinates: function(pCoord, i)
	{
		I.print("{n: " + (parseInt(i)+1) + ", c: [" + pCoord[0] + ", " + pCoord[1] + "]},");
	},
	formatCoord: function(pCoord)
	{
		return "[" + pCoord[0] + ", " + pCoord[1] + "]";
	},
	compileCoordinates: function(pCoords, pIsPair)
	{
		var output = "";
		var spacing = (pIsPair) ? " " : "";
		var sepstr;
		for (var i = 0; i < pCoords.length; i++)
		{
			sepstr = (i < pCoords.length - 1) ? ((pIsPair && ((i+1) % 2 === 0)) ? ("]],<br />") : ((pIsPair && (i % 2 === 0)) ? "], " : "],")) : "]";
			output += (pCoords[i] === null) ? "null," : "[" + ((pIsPair && (i % 2 === 0)) ? "[" : "") + (pCoords[i])[0] + "," + spacing + (pCoords[i])[1] + sepstr;
		}
		return (pIsPair ? "[<br />" : "[") + output + (pIsPair ? "]<br />]" : "]");
	},
	printCoordinates: function(pCoords, pIsPair)
	{
		I.print(this.compileCoordinates(pCoords, pIsPair));
	},
	
	/*
	 * Prints a series of text inputs for the user to copy waypoint chatlinks
	 * that are closest to each personal pins.
	 * @returns int number of waypoints to be used.
	 */
	printClosestWaypoints: function()
	{
		var CHATLINKS_PER_MESSAGE = 12; // Maximum to fit chat message limit
		var DISTANCE_MINIMUM = 500; // The distance between two coordinates must be greater than this to include a new waypoint
		var html = "";
		var chatlink;
		var chatlinks = [""]; // First element is a dummy for comparison
		var coordpin;
		var coordprev = [0, 0];
		var distancetoprevious = 0;
		var zone, waypoint;
		
		M.Layer.PersonalPin.eachLayer(function(iLayer)
		{
			coordpin = M.convertLCtoGC(iLayer.getLatLng());
			zone = M.getZoneFromCoord(coordpin);
			if (zone !== null)
			{
				waypoint = M.getClosestLocation(coordpin, zone.Layers.Waypoint);
				chatlink = "";
				if (waypoint !== null)
				{
					chatlink = U.getChatlinkFromPoiID(waypoint.options.id);
					distancetoprevious = P.getDistanceBetweenCoords(coordpin, coordprev);
					// Don't append consecutively duplicate waypoints or if distance between is too short
					if (chatlinks[chatlinks.length - 1] !== chatlink && distancetoprevious > DISTANCE_MINIMUM)
					{
						chatlinks.push(chatlink);
					}
					coordprev = coordpin;
				}
			}
		});
		chatlinks.shift(); // Remove the first dummy element
		
		if (chatlinks.length > 0)
		{
			// A message contains a limited quantity of chatlinks/waypoints
			var nummessages = Math.ceil(chatlinks.length / CHATLINKS_PER_MESSAGE);
			var numwaypoints = 0;
			var html = "<div id='jsWaypointLinks'>Copy the codes below and<br />paste them in game chat to <br />follow the route:<br />";
			for (var i = 0; i < nummessages; i++)
			{
				// Each message gets its own input box
				html += "<input type='text'  class='cssInputText' value='";
				for (var ii = CHATLINKS_PER_MESSAGE * i;
						ii < (CHATLINKS_PER_MESSAGE * (i+1));
						ii++)
				{
					if (numwaypoints >= chatlinks.length)
					{
						// If reached the end of the array
						break;
					}
					html += " " + (ii+1) + "-&gt;" + chatlinks[ii]; // Chatlinks divider
					numwaypoints++;
				}
				html += "' /> Message " + (i+1) + "<br />";
			}
			html += "</div>";
			
			// Output the input boxes containing the chatlinks
			I.print(html, true);
			I.bindInputSelect("#jsWaypointLinks .cssInputText");
			I.bindConsoleInput();
		}
		else
		{
			I.write("Pins must first be placed and be inside zones in order to create chatlinks.");
		}
		// Return the number of waypoints
		return numwaypoints;
	},
	
	/*
	 * Gets the distance between two points.
	 * @param array pCoordA.
	 * @param array pCoordB.
	 * @returns float distance.
	 */
	getDistanceBetweenCoords: function(pCoordA, pCoordB)
	{
		return Math.sqrt(Math.pow(pCoordA[0] - pCoordB[0], 2) + Math.pow(pCoordA[1] - pCoordB[1], 2));
	},
	getUnitsBetweenCoords: function(pCoordA, pCoordB)
	{
		return ~~(P.getDistanceBetweenCoords(pCoordA, pCoordB) * T.cPOINTS_TO_UNITS);
	},
	
	/*
	 * Gets a nearest neighbor path from an array of coordinates.
	 * @param 2D array pCoords of GW2 coordinates.
	 * @param int pStart index of the optional starting coordinate.
	 * @returns 2D array path.
	 */
	getGreedyPath: function(pCoords, pStart)
	{
		var array = pCoords;
		if (pStart !== undefined)
		{
			// Do initial swapping for selected starting coordinates
			var temp = array[0];
			array[0] = array[pStart];
			array[pStart] = temp;
		}
		
		var currentcoord = array[0];
		var indexofclosest = 0;
		var length = array.length;
		
		for (var i = 0; i < length; i++)
		{
			var prevmindistance = Number.POSITIVE_INFINITY;
			// Scan through coordinates and find the closest to the current point
			for (var ii = i; ii < length; ii++)
			{
				var ithdistance = P.getDistanceBetweenCoords(currentcoord, array[ii]);
				if (ithdistance <= prevmindistance)
				{
					indexofclosest = ii;
					prevmindistance = ithdistance;
				}
			}
			/*
			 * Rewrite the array with the closest adjacent points, example:
			 * [A, B, C, D, E] where B was found to be closest to A, and C was
			 * found closest to B in the order they were scanned.
			 */
			currentcoord = array[indexofclosest];
			array[indexofclosest] = array[i];
			array[i] = currentcoord;
		}
		
		return array;
	},
	
	/*
	 * Gets the user opted color for drawing generic paths.
	 */
	getUserPathColor: function()
	{
		return U.stripToColorString(O.Options.str_colorPersonalPath);
	},
	getUserPathOpacity: function()
	{
		return O.Options.int_opacityPersonalPath / 100;
	},
	refreshPersonalPath: function()
	{
		if (M.isMapInitialized)
		{
			M.drawPersonalPath();
		}
		if (W.isMapInitialized)
		{
			W.drawPersonalPath();
		}
	},
	
	/*
	 * Draws a path with each link of increasing or decreasing thickness, to
	 * simulate a worm crawling in a direction.
	 * @param array pCoords GW2 coordinates.
	 * @param boolean pIsObverse or reversed.
	 * @returns LayerGroup path.
	 * @pre Path has enough links to distinguish themselves.
	 */
	drawDirectedPath: function(pCoords, pIsObverse, pColor)
	{
		if (pIsObverse === undefined)
		{
			pIsObverse = true;
		}
		var latlngs = M.convertGCtoLCMulti(pCoords);
		var layergroup = new L.layerGroup();
		var numofsegments = 8;
		var ithickness = (pIsObverse) ? 0 : numofsegments-1;
		pColor = pColor || "lime";
		
		for (var i = 0; i < latlngs.length - 1; i++)
		{
			layergroup.addLayer(L.polyline([latlngs[i], latlngs[i+1]], {color: pColor, weight: (ithickness+2)*2}));
			ithickness = (pIsObverse) ? (ithickness+1) : (ithickness-1);
			if (pIsObverse && ithickness >= numofsegments)
			{
				ithickness = 0;
			}
			else if ( ! pIsObverse && ithickness < 0)
			{
				ithickness = numofsegments-1;
			}
		}
		return layergroup;
	},
	
	/*
	 * Draws spots representing an interactable item in the game world.
	 * @param array pCoords GW2 coordinates.
	 * @param object pOptions Leaflet marker options.
	 * @returns LayerGroup circles.
	 */
	drawSpots: function(pCoords, pOptions)
	{
		var latlngs = M.convertGCtoLCMulti(pCoords);
		var layergroup = new L.layerGroup();
		var marker;
		var Options = {radius: 10, color: "lime", weight: 4};
		if (pOptions !== undefined)
		{
			for (var i in pOptions)
			{
				Options[i] = pOptions[i];
			}
		}
		
		for (var i in latlngs)
		{
			marker = L.circleMarker(latlngs[i], Options);
			M.bindMarkerZoomBehavior(marker, "click");
			layergroup.addLayer(marker);
		}
		return layergroup;
	},
	
	/*
	 * Draws a map completion route for the current moused zone, using the
	 * personal pins system.
	 * @param object pZone
	 */
	drawCompletionRoute: function(pZone)
	{
		if (M.isItineraryRetrieved)
		{
			var path = (pZone) ? pZone.path : M.ZoneCurrent.path;
			M.redrawPersonalPath(path);
		}
		else
		{
			// If route data is not loaded, load it and execute this function again
			U.getScript(U.URL_DATA.Itinerary, function()
			{
				for (var i in GW2T_COMPLETION_DATA)
				{
					M.Zones[i].path = GW2T_COMPLETION_DATA[i].path;
				}
				M.isItineraryRetrieved = true;
				P.drawCompletionRoute(pZone);
			});
		}
	},
	
	/*
	 * Prints the current zone's event names and coordinates.
	 */
	printZoneEvents: function()
	{
		if (M.isEventIconsGenerated)
		{
			// Sort the zone events by X coordinates
			var arr = [];
			M.ZoneCurrent.Layers.EventIcon.eachLayer(function(iLayer)
			{
				iLayer.oSortableCoord = iLayer.options.coord[0];
				arr.push(iLayer);
			});
			U.sortObjects(arr, {aKeyName: "oSortableCoord"});
			// Print the coordinates and event names
			var console = I.getConsole();
			arr.forEach(function(iLayer)
			{
				var obj = iLayer.options;
				$("<div class='mapEventListEntry'><input type='text' class='cssInputText' value='" + obj.eventid + "' /> "
					+ "<input type='text' class='cssInputText' value='[" + obj.coord + "]' /> "
					+ "<a" + U.convertExternalAnchor(C.getEventWiki(obj.wiki)) + ">[W]</a> "
					+ "<dfn class='cssGameTitle' data-coord='" + obj.coord + "'>" + obj.wiki + "</dfn></div>")
				.appendTo(console).data("keywords", obj.wiki.toLowerCase());
			});
			I.print("");
			M.bindMapLinks("#itemConsole");
			I.bindConsoleInput();
			// Create search bar
			var search = $("<div class='cntSearchContainer'></div>").prependTo(console);
			I.createFilterBar(search, ".mapEventListEntry");
		}
		else
		{
			I.write("Event icons have not been generated.");
		}
	},
	
	/*
	 * Generates border rectangles on initial call. Otherwise toggle visibility.
	 */
	drawZoneBorders: function()
	{
		if (O.Options.bol_showZoneBorders
			&& P.Layer.ZoneBorder.getLayers().length === 0)
		{
			for (var i in M.Zones)
			{
				var zoneobj = M.Zones[i];
				// Cover the zone with a colored border signifying its region
				P.Layer.ZoneBorder.addLayer(L.rectangle(
					M.convertGCtoLCMulti(zoneobj.continent_rect), {
						fill: false,
						color: M.Regions[zoneobj.region].color,
						weight: 2,
						clickable: false
					}
				));
			}
		}
		M.toggleLayer(P.Layer.ZoneBorder, O.Options.bol_showZoneBorders);
	},
	
	/*
	 * Generates gateway icons on initial call. Otherwise toggle visibility.
	 */
	drawZoneGateways: function()
	{
		if (O.Options.bol_showZoneGateways
			&& P.Layer.ZoneGateway.getLayers().length === 0)
		{
			var marker, path;
			var connection = GW2T_GATEWAY_CONNECTION;
			var launchpads = connection.launchpads;
			
			// pCoord may be a single coordinate, or two coordinates 2D array
			var createGate = function(pCoord, pImage, pOpacity, pTitle)
			{
				var coordA = pCoord;
				var coordB;
				if (Array.isArray(pCoord[0]))
				{
					coordA = pCoord[0];
					coordB = pCoord[1];
				}
				var options = {
					icon: L.icon(
					{
						iconUrl: pImage,
						iconSize: [32, 32], // Initial size corresponding to default zoom level
						iconAnchor: [16, 16]
					}),
					opacity: pOpacity || 0.6,
					title: pTitle
				};
				if (coordB)
				{
					options.rotationAngle = M.convertDirectionAngle(coordA, coordB) + T.cCIRCLE_RIGHT_DEGREE;
				}
				var marker = L.marker(M.convertGCtoLC(coordA), options);
				M.bindMarkerZoomBehavior(marker, "click");
				M.bindMarkerZoomBehavior(marker, "contextmenu");
				return marker;
			};
			
			var drawGates = function(pGates, pName, pPathColor)
			{
				for (var i in pGates)
				{
					// Draw the two gates
					for (var ii in pGates[i])
					{
						marker = createGate((pGates[i])[ii], "img/map/gateway_" + pName + I.cPNG);
						P.Layer.ZoneGateway.addLayer(marker);
					}
					// Draw the line connecting the gates
					if (pPathColor)
					{
						path = L.polyline(M.convertGCtoLCDual(pGates[i]),
						{
							color: pPathColor,
							opacity: 0.2
						});
						P.Layer.ZoneGateway.addLayer(path);
					}
				}
			};
			
			var drawPowerups = function(pPowerups, pName)
			{
				for (var i in pPowerups)
				{
					marker = L.marker(M.convertGCtoLC(pPowerups[i].c), {
						icon: L.icon(
						{
							iconUrl: "img/map/" + pName + I.cPNG,
							iconSize: [32, 32], // Initial size corresponding to default zoom level
							iconAnchor: [16, 16]
						})
					});
					M.bindMarkerZoomBehavior(marker, "click");
					M.bindMarkerZoomBehavior(marker, "contextmenu");
					P.Layer.ZonePowerup.addLayer(marker);
					P.Layer.ZoneGateway.addLayer(marker);
				}
			};
			
			drawGates(connection.interborders, "interborders");
			drawGates(connection.interzones, "interzones", "purple");
			drawGates(connection.intrazones, "intrazones", "white");
			drawPowerups(connection.powerups, "powerup");
			// One-way "gate" special case
			launchpads.forEach(function(iLaunchpad)
			{
				var tooltip = (iLaunchpad.i) ? "<div class='mapLoc'><img src='" + iLaunchpad.i + "' /></div>" : null;
				// Draw the launchpad (first inner coordinates)
				marker = createGate(iLaunchpad.c, "img/map/launchpad.png", 1, tooltip);
				P.Layer.ZoneLaunchpad.addLayer(marker);
				P.Layer.ZoneGateway.addLayer(marker);
				// Draw the line trajectory
				path = L.polyline(M.convertGCtoLCDual(iLaunchpad.c),
				{
					color: "gold",
					opacity: 0.2
				});
				P.Layer.ZoneGateway.addLayer(path);
			});
			P.rebindMarkerTooltips();
		}
		M.toggleLayer(P.Layer.ZoneGateway, O.Options.bol_showZoneGateways);
		M.adjustZoomMapping();
	},
	
	/*
	 * Creates polylines for the map based on event's path data, then add event
	 * coordinates to the event names HTML so the map views the location when
	 * user clicks on it.
	 */
	drawChainPaths: function(pChain)
	{
		if (I.isMapEnabled === false) { return; }
		var i;
		var event, primaryevent;
		var color;
		var coords;
		var pathline;
		
		if (pChain.series !== C.ChainSeriesEnum.DryTop)
		{
			for (i = 0; i < pChain.primaryEvents.length; i++)
			{
				primaryevent = pChain.primaryEvents[i];

				switch (i)
				{
					case 0: color = "red"; break;
					case 1: color = "orange"; break;
					case 2: color = "yellow"; break;
					case 3: color = "lime"; break;
					case 4: color = "cyan"; break;
					case 5: color = "blue"; break;
					case 6: color = "violet"; break;
					case 7: color = "purple"; break;
					default: color = "white";
				}

				/*
				 * An event's path in the Chains object is an array of coordinates
				 * (which are themselves array of two numbers x and y). For primary
				 * events: the first entry is the event's location, the rest is
				 * the visual path of the step. Nonprimary events contain
				 * only a single entry, that is, their location.
				 */
				if ((primaryevent.path[0])[0] < 0) // If the first entry has negative coordinates, then the paths are meant to be points rather than connected lines
				{
					for (var ii = 1; ii < primaryevent.path.length; ii++)
					{
						pathline = L.circleMarker(M.convertGCtoLC(primaryevent.path[ii]), {
							clickable: false,
							radius: 8,
							color: "red",
							weight: 2,
							opacity: 0.8,
							fillOpacity: 0.1
						});
						M.Zones[(pChain.zone)].Layers.Path.addLayer(pathline);
					}
				}
				else // Draw a connected path
				{
					coords = M.convertGCtoLCMulti(primaryevent.path, 1);
					pathline = L.polyline(coords, {color: color});
					M.Zones[(pChain.zone)].Layers.Path.addLayer(pathline);
				}
			}
		}
		// Remember final event coordinate
		// Remember primary event coordinate
		var prim = pChain.primaryEvents;
		pChain.finalCoord = prim[(prim.length - 1)].path[0];

		/*
		 * Go to the event location when clicked on event name.
		 */
		var eventnum;
		for (i in pChain.events)
		{
			event = pChain.events[i];
			eventnum = event.num;
			if (eventnum.indexOf(".") !== -1)
			{
				// jQuery thinks the period is a class, escape it
				eventnum = eventnum.replace(".", "\\.");
			}
			$("#chnEvent_" + pChain.nexus + "_" + eventnum).each(function()
			{
				// Assign a data attribute to the event name
				var firstcoord = event.path[0];
				var coord = firstcoord;
				if (firstcoord[0] < 0)
				{
					coord = [Math.abs(firstcoord[0]), Math.abs(firstcoord[1])];
				}
				$(this).attr("data-coord", coord[0] + "," + coord[1]);
				$(this).attr("data-eventindex", i);
				// Read the attribute and use the coordinate when clicked for touring
				if (I.ModeCurrent !== I.ModeEnum.Mobile)
				{
					M.bindMapLinkBehavior($(this), M.ZoomEnum.Ground, M.Pin.Event);
				}
			});
		}
	},
	isChainPathsAllowed: function()
	{
		return (O.Options.bol_showChainPaths && I.PageCurrent !== I.PlateEnum.Map && I.ModeCurrent !== I.ModeEnum.Overlay);
	},
	
	/*
	 * Creates event icons for Dry Top chains, they will be resized by the zoomend function
	 */
	generateDryTop: function()
	{
		U.getScript(U.URL_DATA.DryTop, function()
		{
			C.DryTop = GW2T_DRYTOP_EVENTS;
			var i, ii;
			var chain, event, marker;
			
			if (I.isMapEnabled)
			{
				// Event nicks are independent of the events themselves and are always shown on the map
				for (i in C.DryTop)
				{
					event = C.DryTop[i];
					marker = L.marker(M.convertGCtoLC(event.coord),
					{
						clickable: false,
						icon: L.divIcon(
						{
							className: "mapNick",
							html: "<span class='mapNickIn'>" + D.getObjectName(event)
								+ "<br /><var class='mapDryTopTimestamp' style='color:" + event.color + "'>" + event.time + "</var></span>",
							iconSize: [512, 64],
							iconAnchor: [256, 32]
						})
					});
					P.Layer.DryTopNicks.addLayer(marker);
				}
				M.toggleLayer(P.Layer.DryTopNicks, true);

				// Timer integrated on the map
				P.DryTopTimer = L.marker(M.convertGCtoLC(M.getZoneCenter("dry")),
				{
					clickable: false,
					icon: L.divIcon(
					{
						className: "mapNick",
						html: "<div class='mapNickIn' id='mapDryTopInfo'><span id='mapDryTopTimer'></span><br />"
							+ "<input id='mapDryTopClip0' type='text' /> "
							+ "<input id='mapDryTopClip1' type='text' /></div>",
						iconSize: [512, 64],
						iconAnchor: [256, 32]
					})
				});
				M.toggleLayer(P.DryTopTimer, true);

				// Create icons
				for (i in C.DryTopChains)
				{
					chain = C.DryTopChains[i];
					for (ii in chain.events)
					{
						event = chain.events[ii];

						event.eventring = L.marker(M.convertGCtoLC(event.path[0]),
						{
							zIndexOffset: M.cZIndexBury,
							clickable: false,
							icon: L.icon(
							{
								iconUrl: "img/event/ring/" + event.ring + I.cPNG,
								iconSize: [32, 32],
								iconAnchor: [16, 16]
							})
						});
						event.eventicon = L.marker(M.convertGCtoLC(event.path[0]),
						{
							title: "<span class='mapEvent'><dfn>" + D.getObjectName(event) + "</dfn></span>",
							wiki: D.getObjectName(event),
							icon: L.icon(
							{
								iconUrl: "img/event/" + event.icon + I.cPNG,
								iconSize: [16, 16],
								iconAnchor: [8, 8]
							})
						});
						M.bindMarkerWikiBehavior(event.eventicon, "click");
						M.bindMarkerZoomBehavior(event.eventicon, "contextmenu");
						// Show only current event icons, the highlight event function will continue this
						if ($("#chnEvent_" + chain.nexus + "_" + event.num).hasClass("chnEventCurrent"))
						{
							P.LayerArray.DryTopActive.push(event.eventicon);
							P.LayerArray.DryTopActive.push(event.eventring);
							M.toggleLayer(event.eventring, true);
							M.toggleLayer(event.eventicon, true);
						}

						P.LayerArray.DryTopRings.push(event.eventring);
						P.LayerArray.DryTopIcons.push(event.eventicon);
					}
				}
				P.rebindMarkerTooltips();
			}
			I.loadImg($("#sectionChains_Drytop"));
			
			// Clipboard
			for (var i = 0; i < 2; i++)
			{
				I.bindClipboard("#chnDryTopWaypoint" + i);
				I.bindClipboard("#mapDryTopClip" + i);
			}
			
			// Finally
			C.isDryTopGenerated = true;
			T.initializeDryTopStrings();
			P.toggleDryTopIcons(true);
		});
	},
	
	/*
	 * Shows or hides Dry Top associated map markers.
	 * @param boolean pBoolean.
	 */
	toggleDryTopIcons: function(pBoolean)
	{
		if (C.isDryTopGenerated && I.isMapEnabled)
		{
			C.isDryTopIconsShown = pBoolean;
			M.toggleLayer(P.Layer.DryTopNicks, pBoolean);
			M.toggleLayer(P.DryTopTimer, pBoolean);
			if (pBoolean)
			{
				M.toggleLayerArray(P.LayerArray.DryTopActive, pBoolean);
				P.adjustZoomDryTop();
				I.qTip.init($("#mapDryTopClip0, #mapDryTopClip1").click(function()
				{
					$(this).select();
				}).hover(
					function() { M.isMouseOnHUD = true; },
					function() { M.isMouseOnHUD = false; }
				));
			}
			else
			{
				M.toggleLayerArray(P.LayerArray.DryTopIcons, pBoolean);
				M.toggleLayerArray(P.LayerArray.DryTopRings, pBoolean);
			}
		}
		K.updateDryTopClipboard();
	},
	
	/*
	 * Resizes Dry Top markers so they scale with the current zoom level.
	 */
	adjustZoomDryTop: function()
	{
		if (C.isDryTopIconsShown)
		{
			var i;
			var currentzoom = M.Map.getZoom();
			var icon, iconsize, ringsize;
			var nickfontsize, nickopacity;

			switch (currentzoom)
			{
				case 7: iconsize = 32; nickfontsize = 20; nickopacity = 0.9; break;
				case 6: iconsize = 28; nickfontsize = 16; nickopacity = 0.8; break;
				case 5: iconsize = 24; nickfontsize = 12; nickopacity = 0.8; break;
				case 4: iconsize = 20; nickfontsize = 0; nickopacity = 0; break;
				case 3: iconsize = 16; nickfontsize = 0; nickopacity = 0; break;
				default:
				{
					iconsize = 0; nickfontsize = 0; nickopacity = 0;
				}
			}
			
			// Event icons are same size as waypoints, but their rings are bigger
			ringsize = M.scaleDimension(M.cRING_SIZE_MAX);

			for (i in P.LayerArray.DryTopIcons)
			{
				// Icons
				icon = P.LayerArray.DryTopIcons[i];
				M.resizeMarkerIcon(icon, iconsize);
				// Rings
				icon = P.LayerArray.DryTopRings[i];
				M.resizeMarkerIcon(icon, ringsize);
			}
			
			P.Layer.DryTopNicks.eachLayer(function(iLayer)
			{
				if (iLayer._icon)
				{
					iLayer._icon.style.fontSize = nickfontsize + "px";
					iLayer._icon.style.opacity = nickopacity;
					iLayer._icon.style.zIndex = M.cZIndexBury + 1; // Don't cover other icons
					iLayer._icon.style.display = "table"; // For middle vertical alignment
				}
			});
			P.DryTopTimer._icon.style.fontSize = Math.ceil(nickfontsize * 1.5) + "px";
			P.DryTopTimer._icon.style.opacity = nickopacity;
			P.DryTopTimer._icon.style.zIndex = M.cZIndexRaise + 1;
			P.DryTopTimer._icon.style.display = "table";
		}
	},
	
	/*
	 * Loads a new zone (ingame map instance) if haven't already.
	 * @param int pID
	 * @param object pMapObject
	 */
	loadSubzone: function(pID, pMapObject)
	{
		var that = pMapObject;
		var subzones = that.Subzones;
		if (subzones[pID] !== undefined)
		{
			return;
		}
		subzones[pID] = {};
		$.getJSON(U.getAPIMap(pID), function(pData)
		{
			// Initialize the added zone
			subzones[pID] = {
				map_rect: pData.map_rect,
				continent_rect: pData.continent_rect,
				floors: pData.floors,
				center: that.computeZoneCenter(pData)
			};
			var namekey = "name_" + D.langPartiallySupported;
			(subzones[pID])[namekey] = pData.name;
		}).fail(function()
		{
			I.warn("zone ID: " + pID);
		});
	},
	
	/*
	 * Checks whether the player is in a Tyria or a Mists associated zone then
	 * switch the map automatically if it is not already displayed.
	 */
	switchMapCheck: function()
	{
		if (GPSIdentityJSON === undefined || GPSIdentityJSON === null)
		{
			return;
		}
		
		var previousmap = P.MapSwitchGPS;
		var currentnick = GPSIdentityJSON["map_id"];
		var htmlidprefix = "#" + P.MapSwitchWebsite;
		
		// Get the map the player is in
		if (M.ZoneAssociation[currentnick] !== undefined)
		{
			P.MapSwitchGPS = P.MapEnum.Tyria;
		}
		else if (W.ZoneAssociation[currentnick] !== undefined)
		{
			P.MapSwitchGPS = P.MapEnum.Mists;
		}
		
		// If the player has changed the map in game and the website's map is different from it, then switch the website's map
		if (P.MapSwitchGPS !== previousmap && P.MapSwitchGPS !== P.MapSwitchWebsite)
		{
			$(htmlidprefix + "SwitchButton").trigger("click");
		}
	},
	
	/*
	 * Imitates the character pin as in the game minimap, as informed by the overlay.
	 * This function is shared by the Tyria and Mists maps.
	 * @param int pForceCode 1 to force update position, -1 angle, 0 both, undefined neither.
	 */
	updateCharacter: function(pForceCode)
	{
		var that;
		var followenum = O.Options["int_setFollow" + P.MapSwitchSuffix];
		var displayboolean = O.Options["bol_displayCharacter" + P.MapSwitchSuffix];
		switch (P.MapSwitchWebsite)
		{
			case P.MapEnum.Tyria: { that = M; } break;
			case P.MapEnum.Mists: { that = W; if (W.isWvWLoaded === false) { return; } } break;
		}
		
		/*
		 * Validate the GPS data before allowing updates. Sample structure:
		 * GPSPositionArray or fAvatarPosition or "character coordinates": [-81.31199, 22.930353, 305.7106]
		 * GPSDirectionArray or fAvatarFront or "character angle": [-0.08111322, 0, 0.9967049]
		 * GPSPerspectiveArray or fCameraPosition or "camera coordinates": [-90.5499, 28.430332, 294.4064]
		 * GPSCameraArray or fCameraFront or "camera angle": [0.60616076, -0.28702924, 0.74174345]
		 * GPSIdentityJSON or identity:
		 * {"name": "Character Name","profession": 1,"race": 2,"map_id": 38,"world_id": 1234567890,"team_color_id": 9,"commander": false,"fov": 0.873}
		 */
		if (GPSPositionArray === undefined || GPSPositionArray === null || GPSPositionArray.length !== 3 || that.isUserDragging)
		{
			return;
		}
		if (GPSIdentityJSON === undefined || GPSIdentityJSON === null)
		{
			return;
		}
		if (P.MapSwitchGPS !== P.MapSwitchWebsite)
		{
			return;
		}
		var zone;
		var zoneid = GPSIdentityJSON["map_id"];
		if (that.isZoneValid(zoneid))
		{
			zone = that.getZoneFromID(zoneid);
			if (that.GPSisInstance)
			{
				that.GPSisInstance = false;
				that.changeFloor();
			}
		}
		else if (that.isSubzoneValid(zoneid))
		{
			zone = that.Subzones[zoneid];
			that.GPSisInstance = true;
		}
		else
		{
			P.loadSubzone(zoneid, that);
			that.movePin(that.Pin.Character);
			that.movePin(that.Pin.Camera);
			return;
		}
		var coord = that.convertGPSCoord(GPSPositionArray, zone);
		
		var iscoordchanged = false;
		var iszonechanged = false;
		// Character has moved
		if (that.GPSPreviousCoord[0] !== coord[0] || that.GPSPreviousCoord[1] !== coord[1])
		{
			iscoordchanged = true;
			that.GPSPreviousCoord = coord;
			document.getElementById(P.MapSwitchWebsite + "CoordinatesMouse").value = coord[0] + ", " + coord[1];
		}
		// Zone has changed
		if (that.GPSPreviousZoneID !== zoneid)
		{
			iszonechanged = true;
			that.GPSPreviousZoneID = zoneid;
			if (that.GPSisInstance)
			{
				that.changeFloor(zone.floors[0]);
			}
		}
		
		// Follow character if detected change
		if ((followenum === O.IntEnum.Follow.Character && iscoordchanged) || pForceCode >= 0)
		{
			that.Map.setView(that.convertGCtoLC(coord), that.Map.getZoom());
			that.showCurrentZone(coord);
			pForceCode = -1; // Also update pin position
		}
		if (followenum === O.IntEnum.Follow.Zone && iszonechanged && that.ZoneAssociation[zoneid])
		{
			that.refreshView(zone.center);
			that.showCurrentZone(zone.center);
			pForceCode = -1; // Also update pin position
		}
		
		// Pin character if opted and angle has changed (character turned)
		if (displayboolean)
		{
			var anglecharacter = -(that.convertGPSAngle(GPSDirectionArray));
			var anglecamera = -(that.convertGPSAngle(GPSCameraArray));
			if (that.GPSPreviousAngleCharacter !== anglecharacter
				|| that.GPSPreviousAngleCamera !== anglecamera
				|| pForceCode <= 0)
			{
				if (P.isGPSPrinting)
				{
					I.clear();
					I.print("Coord: " + P.formatCoord(coord) + "<br />"
						+ "Position: " + U.formatJSON(GPSPositionArray) + "<br />"
						+ "Direction: " + U.formatJSON(GPSDirectionArray) + "<br />"
						+ "Perspective: " + U.formatJSON(GPSPerspectiveArray) + "<br />"
						+ "Camera: " + U.formatJSON(GPSCameraArray)
					);
					I.prettyJSON(GPSIdentityJSON);
					if (J.isProjectionInitialized)
					{
						J.Camera.lookAt(new THREE.Vector3(GPSCameraArray[0], GPSCameraArray[1], GPSCameraArray[2]));
					}
				}
				that.movePin(that.Pin.Character, coord);
				that.movePin(that.Pin.Camera, coord);
				that.Pin.Camera._icon.style.zIndex = that.cZIndexBury;
				that.Pin.Camera._icon.style.pointerEvents = "none"; // Don't let this marker overlap pin
				that.Pin.Character.setRotationAngle(anglecharacter);
				that.Pin.Camera.setRotationAngle(anglecamera);
				that.GPSPreviousAngleCharacter = anglecharacter;
				that.GPSPreviousAngleCamera = anglecamera;
			}
		}
	},
	
	/*
	 * Executes GPS functions every specified milliseconds.
	 */
	tickGPS: function()
	{
		if (O.Options["int_setFollow" + P.MapSwitchSuffix]
			|| O.Options["bol_displayCharacter" + P.MapSwitchSuffix])
		{
			P.updateCharacter();
			window.clearTimeout(P.GPSTimeout);
			P.GPSTimeout = setTimeout(function()
			{
				P.tickGPS();
			}, O.Options.int_msecGPSRefresh);
		}
	}
};
G = {
/* =============================================================================
 * @@Generate content for the sections on Map page
 * ========================================================================== */

	/*
	 * Initializes or regenerates the daily achievements box.
	 */
	generateAndInitializeDailies: function()
	{
		var calendar = $("#dlyCalendar");
		var now = new Date();
		
		// Regenerate the whole section
		$("#dlyHeader, #dlyCalendar, #dlyActivity").empty();
		I.removeThrobber("#dlyContainer");
		$("#dlyHeader").html(T.formatWeektime(now));
	
		// Daily countdown
		T.isChecklistCountdownsStarted = true;
		
		// Generate daily achievement boxes
		G.fillDailyCalendar(calendar, now);
	},
	fillDailyCalendar: function(pContainer, pDate, pIsVertical)
	{
		var calendar = $(pContainer);
		var finalizeDailies = function()
		{
			calendar.find(".dlyBox:first").addClass("dlyCurrent").next().addClass("dlyNext");
			calendar.find(".dlyZoom").each(function()
			{
				M.bindMapLinkBehavior($(this), M.ZoomEnum.Sky, M.Pin.Program);
			});
			I.bindPseudoCheckbox(calendar.find("ins"));
			I.qTip.init(calendar.find("ins"));
			I.removeThrobber(calendar.parent());
			
			// Create achievement tooltips
			Q.bindAchievement(".dly");
		};
		
		G.createDailyBookmarks(calendar);
		calendar.after(I.cThrobber);
		T.getDaily().done(function()
		{
			G.insertDailyDay(calendar, T.DailyToday, pDate, pIsVertical); // Today's dailies
			T.getDaily({aWantGetTomorrow: true}).done(function() // Tomorrow's dailies
			{
				G.insertDailyDay(calendar, T.DailyTomorrow, T.addDaysToDate(pDate, 1), pIsVertical);
				finalizeDailies(calendar);
			});
		}).fail(function()
		{
			I.warn("daily achievements");
			I.removeThrobber(calendar.parent());
		});
	},
	createDailyBookmarks: function(pContainer)
	{
		if (I.isMapEnabled === false)
		{
			return;
		}
		
		I.createSearchBar(pContainer, {
			aIsSelect: true,
			aBarClass: "dlyBookmarks",
			aDatabase: T.Daily.Bookmark,
			aFillerText: D.getModifiedWord("bookmarks", "map", U.CaseEnum.Every),
			aCallback: function(pObj)
			{
				M.redrawPersonalPath(pObj.path);
			},
			aCancel: function()
			{
				M.clearPersonalPins();
			}
		});
	},
	
	/*
	 * Inserts a "day" div into the dailies calendar.
	 * @param object pDaily daily object from general.js
	 * @param object pDate of the day.
	 */
	insertDailyDay: function(pContainer, pDailyObj, pDate, pIsVertical)
	{
		var calendar = $(pContainer);
		// Daily category rows (game modes)
		var pve = pDailyObj["pve"];
		var pvp = pDailyObj["pvp"];
		var wvw = pDailyObj["wvw"];
		var fractals = pDailyObj["fractals"];
		var dayclass = "";
		var activityhtml = "";
		var dailynicks, d0, d1, d2, d3, d4;
		
		// PVE daily nicknames may be suffixed by a region, or prefixed by its daily type
		var parsePVE = function(pDaily)
		{
			dailynicks = pDaily.split(" ");
			d0 = dailynicks[0];
			d1 = dailynicks[1].toLowerCase();
			d2 = (dailynicks.length > 2) ? dailynicks[2].toLowerCase() : "";
			d3 = (dailynicks.length > 3) ? dailynicks[3].toLowerCase() : "";
			d4 = (dailynicks.length > 4) ? dailynicks[4].toLowerCase() : "";
			
			if (d1 === "misc")
			{
				return "<ins class='dly dly_pve_" + d2 + " dlyZoom curZoom' data-ach='" + d0 + "' data-coord='" + d3 + "'></ins>";
			}
			else if (d1 === "jp" || d1 === "adventure")
			{
				return "<ins class='dlyRegion dly_region_" + d3 + "'>"
					+ "<ins class='dly dly_pve_" + d1 + " dlyZoom curZoom' data-ach='" + d0 + "' data-coord='" + d4 + "'></ins>"
				+ "</ins>";
			}
			else if (d1 === "vista" || d1 === "miner" || d1 === "lumberer" || d1 === "forager")
			{
				return "<ins class='dlyRegion dly_region_" + d2 + "'>"
					+ "<ins class='dly dly_pve_" + d1 + " dlyZoom curZoom' data-ach='" + d0 + "' data-coord='" + d3 + "'></ins>"
				+ "</ins>";
			}
			else if (d1 === "dungeon")
			{
				return "<ins class='dlyRegion dly_region_" + d3 + "'>"
					+ "<ins class='dly dly_pve_dungeon_" + d2 + " dlyZoom curZoom' data-ach='" + d0 + "' data-coord='" + d4 + "'></ins>"
				+ "</ins>";
			}
			else if (d1 === "boss")
			{
				var bosschain = C.getChainByAlias(d2);
				return "<ins class='dlyRegion dly_region_" + C.getChainRegion(bosschain) + "'>"
					+ "<ins class='dly dly_pve_boss dlyZoom curZoom' data-ach='" + d0 + "' data-coord='" + bosschain.finalCoord + "'></ins>"
				+ "</ins>";
			}
			else if (d1 === "event")
			{
				return "<ins class='dlyRegion dly_region_" + M.getZoneRegion(d2) + "'>"
					+ "<ins class='dly dly_pve_event dlyZoom curZoom' data-ach='" + d0 + "' data-coord='" + d2 + "'></ins>"
				+ "</ins>";
			}
			return "";
		};
		
		// PVP daily nicknames may be 1 word long, or 2 words containing the daily professions
		var parsePVP = function(pDaily)
		{
			dailynicks = pDaily.split(" ");
			d0 = dailynicks[0];
			d1 = dailynicks[1].toLowerCase();
			if (dailynicks.length === 2)
			{
				return "<ins class='dly dly_pvp_" + d1 + "' data-ach='" + d0 + "'></ins>";
			}
			
			var dspec = dailynicks[2].toLowerCase();
			return "<ins class='dly dly_pvp_profession_" + d1 + "_0' data-ach='" + d0 + "'><ins class='dly dly_pvp_profession_" + dspec + "_1'></ins></ins>";
		};
		
		// WvW daily nicknames are always 1 word long
		var parseWVW = function(pDaily)
		{
			dailynicks = pDaily.split(" ");
			d0 = dailynicks[0];
			d1 = dailynicks[1].toLowerCase();
			return "<ins class='dly dly_wvw_" + d1 + "' data-ach='" + d0 + "'></ins>";
		};
		
		// Generate the daily icons for each game mode
		var pvestr = "";
		var pvpstr = "";
		var wvwstr = "";
		pve.forEach(function(iDaily)
		{
			pvestr += parsePVE(iDaily);
		});
		pvp.forEach(function(iDaily)
		{
			pvpstr += parsePVP(iDaily);
		});
		wvw.forEach(function(iDaily)
		{
			wvwstr += parseWVW(iDaily);
		});

		// Write the daily box containing the icons
		switch (pDate.getUTCDay())
		{
			case T.DayEnum.Sunday: dayclass = "dlySunday"; break;
			case T.DayEnum.Saturday: dayclass = "dlySaturday"; break;
		}
		var dsbclass = (pIsVertical || pIsVertical === undefined) ? "" : "dlyBoxDashboard";
		// Get daily activity
		var activity = T.Daily.Activity;
		var activityalias = activity.Schedule[pDate.getUTCDay()];
		var activityname = D.getObjectName(activity.Activities[activityalias]);
		// Generate HTML
		activityhtml = "<em class='dlyActivityIconContainer dlyMonthday' title='" + activityname + "'><img class='dlyActivityIcon' src='img/daily/activities/" + activityalias + I.cPNG + "' /></em>";
		var dailybox = $("<div class='dlyBox " + dsbclass + "'>"
			+ "<aside class='dlyMonthdayBackground dlyMonthday'></aside>" + activityhtml + "<a class='dlyMonthdayNumber dlyMonthday " + dayclass + "'"
				+ U.convertExternalAnchor(U.getWikiLinkLanguage(activityname)) + "title='" + activityname + "'>" + pDate.getUTCDate() + "</a>"
			+ "<span class='dlyMode'><ins class='dly dly_daily_pve'></ins>" + pvestr + "</span>"
			+ "<span class='dlyMode'><ins class='dly dly_daily_pvp'></ins>" + pvpstr + "</span>"
			+ "<span class='dlyMode'><ins class='dly dly_daily_wvw'></ins>" + wvwstr + "</span>"
		+ "</div>").appendTo(calendar);
		I.qTip.init(".dlyMonthdayNumber");

		// Insert fractal row
		var insertFractal = function(pIslands, pIDs, pScaleStr)
		{
			dailybox.append("<span class='dlyMode dlyModeFractal'>"
				+ "<ins class='dly dly_daily_fractal'></ins>"
				+ "<ins class='dly chl_fractal chl_" + pIslands[0].toLowerCase() + "' title='" + pIslands[0] + "' " + ((pIDs) ? ("data-ach='" + pIDs[0] + "'") : "") + "></ins>"
				+ "<ins class='dly chl_fractal chl_" + pIslands[1].toLowerCase() + "' title='" + pIslands[1] + "' " + ((pIDs) ? ("data-ach='" + pIDs[1] + "'") : "") + "></ins>"
				+ "<ins class='dly chl_fractal chl_" + pIslands[2].toLowerCase() + "' title='" + pIslands[2] + "' " + ((pIDs) ? ("data-ach='" + pIDs[2] + "'") : "") + "></ins>"
				+ (pScaleStr || "")
			+ "</span>");
			I.qTip.init(dailybox.find("ins"));
			I.qTip.init(".dlyFractalScales");
		};
		
		// Daily fractal scale numbers
		var fractalmeta = T.Daily.Fractal;
		var scaleA = T.DailyAssociation[(fractals[0])]; // The daily scales are located in these API array indexes
		var scaleB = T.DailyAssociation[(fractals[1])];
		var scaleC = T.DailyAssociation[(fractals[fractals.length - 1])];
		var scalestr = "";
		if (scaleA && scaleB && scaleC)
		{
			scalestr = "<a class='dlyFractalScales' title='" + D.getObjectName(fractalmeta.Scale) + "' "
				+ U.convertExternalAnchor(D.getObjectURL(fractalmeta)) + ">" + scaleA + " " + scaleB + " " + scaleC + "</a>";
		}

		// Daily fractal islands
		var islandids = [fractals[5], fractals[9], fractals[13]]; // The daily islands of the highest scale are located in these API array indexes
		var islandA = T.DailyAssociation[islandids[0]];
		var islandB = T.DailyAssociation[islandids[1]];
		var islandC = T.DailyAssociation[islandids[2]];
		if (islandA && islandB && islandC)
		{
			insertFractal([islandA, islandB, islandC], islandids, scalestr);
		}
		Q.bindAchievement(".chl_fractal");
	},
	
	/*
	 * Populates the map with resource node markers and create HTML checkboxes
	 * to toggle their display on the map.
	 */
	generateAndInitializeResources: function()
	{
		var priceids = [];
		var metadata;
		var opacityclicked = 0.3;
		var pathcolor = P.getUserPathColor();
		var pathopacity = P.getUserPathOpacity();
		var inputwaypoint = I.bindInputSelect("#nod_int_coinWaypointAverage");
		var inputvisit = I.bindInputSelect("#nod_int_secNodeVisitAverage");
		var getNodeState = function(pMarker)
		{
			return X.getChecklistItem(X.Checklists["Resource" + pMarker.options.grade], pMarker.options.index);
		};
		var setNodeState = function(pMarker, pState)
		{
			X.setChecklistItem(X.Checklists["Resource" + pMarker.options.grade], pMarker.options.index, pState);
		};
		var reapplyNodesState = function()
		{
			// Fade the node if state is so in checklist
			for (var i in P.LayerArray.Resource)
			{
				P.LayerArray.Resource[i].eachLayer(function(iLayer)
				{
					if (iLayer instanceof L.Marker && getNodeState(iLayer) === X.ChecklistEnum.Checked)
					{
						iLayer.setOpacity(opacityclicked);
					}
				});
			}
		};
		var bindNodeBehavior = function(pMarker)
		{
			M.bindMarkerZoomBehavior(pMarker, "contextmenu");
			M.bindMarkerCoordBehavior(pMarker, "click");
			pMarker.on("mousedown", function(pEvent)
			{
				switch (pEvent.originalEvent.which)
				{
					case I.ClickEnum.Left:
					{
						if (getNodeState(pMarker) === X.ChecklistEnum.Checked)
						{
							setNodeState(pMarker, X.ChecklistEnum.Unchecked);
							this.setOpacity(1);
						}
						else
						{
							setNodeState(pMarker, X.ChecklistEnum.Checked);
							this.setOpacity(opacityclicked);
						}
					} break;
					case I.ClickEnum.Middle:
					{
						M.createPersonalPin(this.getLatLng(), true);
					} break;
				}
			});
		};
		var refreshResourcePrices = function()
		{
			E.getPrices(priceids, function(pPriceDB)
			{
				for (var i in P.Resources)
				{
					var resource = P.Resources[i];
					var itemid = resource.item;
					if (itemid && pPriceDB[itemid])
					{
						var priceobj = pPriceDB[itemid];
						$("#nodPrice_" + i).html(E.formatCoinStringColored(priceobj.oPriceSell));
						P.Resources[i].price = priceobj.oPriceSellTaxed;
					}
					else
					{
						$("#nodPrice_" + i).html(D.getObjectName(resource));
					}
				}
			}, false);
		};
		var getNodeQuantity = function(pResource, pGrade)
		{
			return (metadata.Yield[pResource.type])[pGrade];
		};
		var initializeNodes = function(pGrade)
		{
			var i, ii;
			var counter = 0;
			var grade = pGrade;
			var resource; // A type of resource, like copper ore
			var layer, marker, path;
			var iconsize = (pGrade === "Rich") ? [32, 32] : [24, 24];
			var iconanchor = (pGrade === "Rich") ? [16, 16] : [12, 12];

			for (i in P.Resources)
			{
				resource = P.Resources[i];
				if (P.Resources[i].price === undefined)
				{
					P.Resources[i].price = 0; // Also initialize price property
				}
				var name = i.toLowerCase();
				var resourcegrade = resource[grade];

				// Permanent Rich/Farm nodes
				if (resourcegrade !== undefined && resourcegrade.length > 0)
				{
					layer = new L.layerGroup();
					for (ii in resourcegrade)
					{
						marker = L.marker(M.convertGCtoLC(resourcegrade[ii].c),
						{
							grade: grade,
							name: i,
							quantity: getNodeQuantity(resource, grade),
							index: counter,
							coord: resourcegrade[ii].c,
							icon: L.divIcon(
							{
								className: "nod" + grade,
								html: "<img src='" + "img/node/" + name + I.cPNG + "' />",
								iconSize: iconsize,
								iconAnchor: iconanchor
							}),
							isNode: true
						});
						bindNodeBehavior(marker);
						// Add to array
						layer.addLayer(marker);
						// Draw path if this node has it
						if (resourcegrade[ii].p !== undefined)
						{
							path = L.polyline(M.convertGCtoLCMulti(resourcegrade[ii].p),
							{
								color: pathcolor,
								dashArray: "5,10",
								opacity: pathopacity
							});
							layer.addLayer(path);
						}
						counter++;
					}
					M.toggleLayer(layer);
					P.Layer["Resource_" + grade + "_" + i] = layer;
					P.LayerArray.Resource.push(layer);
				}
			}
			
			// Initialize checklist for saving nodes clicked state
			X.initializeChecklist(X.Checklists["Resource" + grade], counter);
			reapplyNodesState();
		};
		var displayNodes = function(pCheckbox, pIsExclusive)
		{
			if (pIsExclusive)
			{
				// If want exclusive then hide all other node types before showing only this one
				for (var i in P.Resources)
				{
					$("#nod_" + i).prop("checked", false).trigger("change");
				}
				pCheckbox.prop("checked", true);
			}
			var thisresource = U.getSubstringFromHTMLID(pCheckbox);
			var wantshow = pCheckbox.prop("checked");
			var wantregular = $("#nodShowRegular").prop("checked");
			var wanthotspot = $("#nodShowHotspot").prop("checked");
			M.toggleLayer(P.Layer["Resource_Rich_" + thisresource], wantshow);
			M.toggleLayer(P.Layer["Resource_Permanent_" + thisresource], wantshow);
			M.toggleLayer(P.Layer["Resource_Regular_" + thisresource], (wantshow && wantregular));
			M.toggleLayer(P.Layer["Resource_Hotspot_" + thisresource], (wantshow && wanthotspot));
		};
		var drawResourceRoute = function(pZone)
		{
			var i = 0;
			var coords = [];
			var coord;
			var eastmostcoord = Number.POSITIVE_INFINITY;
			var indexofeastmostcoord;

			var WAYPOINT_COPPER_AVERAGE = inputwaypoint.val();
			var TIME_SECOND_AVERAGE = inputvisit.val();
			var waypointcost = 0;
			var timecost = 0;
			var sumprice = 0;

			// Gather the coordinates of valid resource node markers
			M.Map.eachLayer(function(iLayer)
			{
				if (iLayer instanceof L.Marker && iLayer.options.isNode
					&& getNodeState(iLayer) === X.ChecklistEnum.Unchecked)
				{
					if (pZone && M.isWithinZone(M.ZoneCurrent, iLayer.options.coord) === false)
					{
						return;
					}
					/*
					 * Sum the price with the node's single resource price times the output of the node.
					 * The price was initialized the TP refresh function.
					 * The quantity was initialized by the marker initialization function.
					 */
					sumprice += P.Resources[(iLayer.options.name)].price * iLayer.options.quantity;

					// Find eastmost coordinate to use it as the starting point
					coords.push(iLayer.options.coord);
					coord = (coords[i])[0];
					if (coord < eastmostcoord)
					{
						eastmostcoord = coord;
						indexofeastmostcoord = i;
					}
					i++;
				}
			});
			var numnodes = coords.length;

			if (numnodes > 0)
			{
				// The eastmost coordinates will be the starting point of the optimized path
				M.redrawPersonalPath(P.getGreedyPath(coords, indexofeastmostcoord));
				waypointcost = P.printClosestWaypoints() * WAYPOINT_COPPER_AVERAGE;
				timecost = numnodes * TIME_SECOND_AVERAGE;
				var summary = "Gather Profit: <span class='cssRight'>" + E.formatCoinStringColored(sumprice) + "</span><br />"
					+ "Waypoint Cost: <span class='cssRight'>" + E.formatCoinStringColored(waypointcost) + "</span><br />"
					+ "</br >"
					+ "Net Profit: <span class='cssRight'>" + E.formatCoinStringColored(sumprice - waypointcost) + "</span><br />"
					+ "<br />"
					+ "Nodes to Visit: <span class='cssRight'>" + numnodes + "</span><br />"
					+ "Estimated Time: <span class='cssRight'>" + T.getTimeFormatted({aCustomTimeInSeconds: timecost, aWantLetters: true}) + "</span>";
				I.print(summary);
			}
		};
		
		U.getScript(U.URL_DATA.Resource, function()
		{
			var i;
			var resource;
			P.Resources = GW2T_RESOURCE_DATA;
			metadata = GW2T_RESOURCE_METADATA;
			initializeNodes("Rich"); // Only create rich and permanent node markers initially
			initializeNodes("Permanent");
			
			// Create checkboxes
			for (i in P.Resources)
			{
				resource = P.Resources[i];
				$("#nodResource_" + resource.type).append(
					"<label><input id='nod_" + i + "' type='checkbox' checked='checked' /> <img src='img/node/"
					+ i.toLowerCase() + I.cPNG + "' /> <abbr>" + D.getObjectName(resource) + "</abbr><var id='nodPrice_" + i + "'></var></label>");
				if (resource.item)
				{
					priceids.push(resource.item);
				}
			}
			// Bind checkboxes
			for (i in P.Resources)
			{
				(function(iCheckbox)
				{
					iCheckbox.change(function()
					{
						displayNodes(iCheckbox);
					});
					X.getCheckboxLabel(iCheckbox).dblclick(function()
					{
						displayNodes(iCheckbox, true);
					});
				})($("#nod_" + i));
					
			}
			
			// Bind button to toggle all checkboxes
			$("#mapToggle_Resource").data("checked", true).click(function()
			{
				var bool = I.toggleButtonState($(this));
				for (i in P.Resources)
				{
					$("#nod_" + i).prop("checked", bool).trigger("change");
				}
			});
			
			// Bind button to draw a route from the currently visible and unchecked permanent nodes
			$("#nodRoute").click(function()
			{
				// Clears any pins on the map if already laid, otherwise draw the route
				if (M.isPersonalPinsLaid())
				{
					M.clearPersonalPins();
					return;
				}
				drawResourceRoute();
			}).contextmenu(function(pEvent)
			{
				pEvent.preventDefault();
				drawResourceRoute(M.ZoneCurrent);
			});
			
			// Bind buttons to toggle all checkboxes of that resource category
			$("#nodToggle_ResourceOre").click(function()
			{
				$("#nodResource_Ore input").trigger("click");
			});
			$("#nodToggle_ResourcePlant").click(function()
			{
				$("#nodResource_Plant input").trigger("click");
			});
			$("#nodToggle_ResourceWood").click(function()
			{
				$("#nodResource_Wood input").trigger("click");
			});
			
			// Bind the checkbox to show regular nodes
			$("#nodShowRegular").one("click", function()
			{
				// Only create the non-rich nodes when the user has chosen to show
				initializeNodes("Regular");
			});
			$("#nodShowHotspot").one("click", function()
			{
				initializeNodes("Hotspot");
			});
			$("#nodShowRegular").change(function()
			{
				var wantregular = $(this).prop("checked");
				for (var i in P.Resources)
				{
					var wantshow = $("#nod_" + i).prop("checked");
					M.toggleLayer(P.Layer["Resource_Regular_" + i], (wantshow && wantregular));
				}
			}).trigger("change");
			$("#nodShowHotspot").change(function()
			{
				var wanthotspot = $(this).prop("checked");
				for (var i in P.Resources)
				{
					var wantshow = $("#nod_" + i).prop("checked");
					M.toggleLayer(P.Layer["Resource_Hotspot_" + i], (wantshow && wanthotspot));
				}
			}).trigger("change");
			
			// Bind button to show the clicked map nodes again
			$("#nodUncheck").click(function()
			{
				for (var i in P.LayerArray.Resource)
				{
					P.LayerArray.Resource[i].eachLayer(function(iLayer)
					{
						if (iLayer instanceof L.Marker)
						{
							iLayer.setOpacity(1);
						}
					});
				}
				X.clearChecklist(X.Checklists.ResourceRich);
				X.clearChecklist(X.Checklists.ResourcePermanent);
				X.clearChecklist(X.Checklists.ResourceRegular);
				X.clearChecklist(X.Checklists.ResourceHotspot);
			});
			X.rewrapCheckboxes();
			
			// Bind button to refresh TP prices
			$("#nodRefresh").click(function()
			{
				refreshResourcePrices();
				I.write("Prices refreshed.");
			});
			refreshResourcePrices();
			
			// Map bookmarks
			G.createDailyBookmarks("#nodBookmarks");
			// Pre-show specific grades of nodes if requested
			U.verifyArticle("All", function()
			{
				$("#nodShowRegular, #nodShowHotspot").trigger("click");
			});
			U.verifyArticle("Regular", function()
			{
				$("#nodShowRegular").trigger("click");
			});
			U.verifyArticle("Hotspot", function()
			{
				$("#nodShowHotspot").trigger("click");
			});
		});
	},
	drawResourceRoute: function()
	{
		if ($("#nodMenu").is(":visible") === false)
		{
			I.write("Please view the <a data-page='Resource'>Resource Nodes</a> section first.");
			I.bindConsoleLink();
		}
		$("#nodRoute").trigger("contextmenu");
	},
	
	/*
	 * Populates the map with JP location markers with different color depending
	 * on the difficulty.
	 */
	generateAndInitializeJPs: function()
	{
		var jptype;
		var styleJPNode = function(pNode, pIsChecked)
		{
			var marker = pNode.oMarker;
			var difficulty = marker.options.difficulty;
			var cssclass = (pIsChecked) ? "jpzDifficulty0" : "jpzDifficulty" + difficulty;
			marker.setIcon(new L.icon(
			{
				className: cssclass,
				iconUrl: "img/map/" + (jptype[difficulty]).name + I.cPNG,
				iconSize: [32, 32],
				iconAnchor: [16, 16]
			}));
		};
		
		U.getScript(U.URL_DATA.JP, function()
		{
			jptype = GW2T_JP_DATA.Type;
			P.JPs = GW2T_JP_DATA.JP;
			X.Checklists.JP.length = U.getObjectLength(P.JPs);
			P.NodeArray.JP = P.createNodeArray(X.Checklists.JP.length);
			var jp, jplink, marker, path, translatedname, keywords;
			var pathcolor = P.getUserPathColor();
			var pathopacity = P.getUserPathOpacity();
			
			// Translate headers
			$(".jpzHeader").each(function()
			{
				$(this).text(D.getObjectName(jptype[$(this).attr("data-difficulty")]));
			});
		
			for (var i in P.JPs)
			{
				jp = P.JPs[i];
				translatedname = D.getObjectName(jp);
				/*
				 * Create JP markers.
				 */
				marker = L.marker(M.convertGCtoLC(jp.coord),
				{
					id: jp.id,
					difficulty: jp.difficulty,
					title: "<div class='mapLoc'><dfn>" + D.getObjectName(jptype[jp.difficulty]) + ":</dfn> " + translatedname
						+ "<img src='" + jp.img + "' /></div>"
				});
				P.NodeArray.JP[jp.id].oMarker = marker;
				styleJPNode(P.NodeArray.JP[jp.id]);
				/*
				 * Create JP path, if available.
				 */
				if (jp.path)
				{
					path = L.polyline(M.convertGCtoLCMulti(jp.path),
					{
						color: pathcolor,
						dashArray: "5,10",
						opacity: pathopacity
					});
					P.NodeArray.JP[jp.id].oPath = path;
				}
				
				/*
				 * Create JP HTML entries.
				 */
				keywords = (translatedname + " " + M.getZoneName(jp.zone)).toLowerCase();
				$("<aside class='jpzItem'><dt id='jpz_" + jp.id + "' data-coord='" + jp.coord + "'>" + translatedname + "</dt>"
					+ "<label><input type='checkbox' id='jpzCheck_" + jp.id + "' /></label>"
					+ "&nbsp;<cite><a href='"
					+ U.getYouTubeLink(translatedname) + "'>[Y]</a> <a href='"
					+ U.getWikiLinkObject(jp) + "'>[W]</a></cite>"
					+ "<dd>" + jp.description + "</dd></aside>").data("keywords", keywords)
					.appendTo("#jpzList_" + jp.difficulty);
				jplink = $("#jpz_" + jp.id);
				jplink.attr("title", "<div class='mapLoc'><img src='" + jp.img + "' /></div>");
				M.bindMapLinkBehavior(jplink, M.ZoomEnum.Same);
			}
			P.toggleNodeArray(P.NodeArray.JP, true);
			M.bindMapLinks(".jpzList");
			U.convertExternalLink(".jpzList a");
			I.createFilterBar("#jpzSearch", ".jpzItem");
			I.qTip.init(".jpzList dt");
			X.rewrapCheckboxes();

			// Button to toggle JP markers only
			$("#jpzToggleJP").change(function()
			{
				var state = $(this).prop("checked");
				P.toggleNodeArray(P.NodeArray.JP, state);
				if (state)
				{
					for (var i = 0; i < P.NodeArray.JP.length; i++)
					{
						var node = P.NodeArray.JP[i];
						var state = X.getChecklistItem(X.Checklists.JP, i);
						if (state === X.ChecklistEnum.Unchecked)
						{
							styleJPNode(node);
						}
						else
						{
							// Difficulty 0 is reserved for checked off JPs
							styleJPNode(node, true);
						}
					}
				}
			});
			
			// Button to toggle markers display
			$("#mapToggle_JP").data("checked", true).click(function()
			{
				var bool = I.toggleButtonState($(this));
				$("#jpzToggleJP").prop("checked", bool).trigger("change");
				// Chests are not shown by default
				if ($("#jpzToggleChest").prop("checked"))
				{
					$("#jpzToggleChest").prop("checked", bool).trigger("change");
				}
			});

			P.rebindMarkerTooltips();
			
			/*
			 * Initialize checklist and bind marker and checkboxes together.
			 */
			X.initializeChecklist(X.Checklists.JP, X.Checklists.JP.length);

			// Count completed JPs function
			var updateJPCount = function()
			{
				var completed = X.countChecklist(X.Checklists.JP, X.ChecklistEnum.Checked);
				var total = X.Checklists.JP.length;
				$("#jpzCounter").text(completed + "/" + total);
			};

			// Bind behavior
			for (var i = 0; i < X.Checklists.JP.length; i++)
			{
				$("#jpzCheck_" + i).each(function()
				{
					/*
					 * Read and enact the state of the JP checklist.
					 */
					// Convert the digit at ith position in the checklist string to boolean
					var stateinstring = X.getChecklistItem(X.Checklists.JP, i, U.TypeEnum.isBoolean);
					$(this).prop("checked", stateinstring);
					if (stateinstring === false)
					{
						X.getCheckboxLabel($(this)).prev().removeClass("jpzListNameChecked");
					}
					else
					{
						X.getCheckboxLabel($(this)).prev().addClass("jpzListNameChecked");
						styleJPNode(P.NodeArray.JP[i], true);
					}

				}).change(function()
				{
					// Get the checkbox ID that associates itself with that JP
					var checkboxstate = X.getCheckboxEnumState($(this));
					var checkboxindex = U.getSubintegerFromHTMLID($(this));
					if (checkboxstate === X.ChecklistEnum.Unchecked)
					{
						X.getCheckboxLabel($(this)).prev().removeClass("jpzListNameChecked");
						styleJPNode(P.NodeArray.JP[checkboxindex]);
					}
					else
					{
						X.getCheckboxLabel($(this)).prev().addClass("jpzListNameChecked");
						styleJPNode(P.NodeArray.JP[checkboxindex], true);
					}

					// Rewrite the checklist string by updating the digit at the ID/index
					X.setChecklistItem(X.Checklists.JP, checkboxindex, checkboxstate);
					updateJPCount();

				}).parent().hover(
					// Highlight JP name when hovered over checkbox's label
					function()
					{
						$(this).prev().css({"text-decoration": "underline"}).trigger("mouseenter");
					},
					function()
					{
						$(this).prev().css({"text-decoration": "none"}).trigger("mouseleave");
					}
				);

				/*
				 * Duplicate the behavior of JP checklist and zoom by mirroring the
				 * action of clicking on the JP icon with the associated HTML element.
				 */
				(function(iIndex)
				{
					// Click associated checkbox when clicked
					var marker = P.NodeArray.JP[iIndex].oMarker;
					marker.on("click", function()
					{
						$("#jpzCheck_" + iIndex).trigger("click");
						I.scrollToElement("#jpz_" + this.options.id, {aContainer: "#plateMap"});
					});
					M.bindMarkerZoomBehavior(marker, "contextmenu");
				})(i);
			}

			// The button to clear all JP checkboxes
			$("#jpzUncheckJP").click(function()
			{
				for (i = 0; i < X.Checklists.JP.length; i++)
				{
					$("#jpzCheck_" + i).prop("checked", false)
						.parent().prev().removeClass("jpzListNameChecked");
					styleJPNode(P.NodeArray.JP[i]);
				}
				X.clearChecklist(X.Checklists.JP);

				updateJPCount();
			});
			
			updateJPCount();
			G.generateAndInitializeChests();
		});
	},
	
	/*
	 * Populates the map with chest icons. These are found in the open world and
	 * unrelated to chests found within JPs. Should be run after the JP function.
	 */
	generateAndInitializeChests: function()
	{
		P.Chests = GW2T_JP_DATA.Chest;
		var numofchests = P.Chests.Basic.length + P.Chests.Splendid.length;
		X.initializeChecklist(X.Checklists.Chest, numofchests);
		
		var i, ii;
		var counter = 0;
		var opacityclicked = 0.3;
		var getNodeState = function(pMarker)
		{
			return X.getChecklistItem(X.Checklists.Chest, pMarker.options.index);
		};
		var setNodeState = function(pMarker, pState)
		{
			X.setChecklistItem(X.Checklists.Chest, pMarker.options.index, pState);
		};
		var refreshNodeState = function()
		{
			P.Layer.Chest.eachLayer(function(iMarker)
			{
				if (getNodeState(iMarker) === X.ChecklistEnum.Checked)
				{
					iMarker.setOpacity(opacityclicked);
				}
				else
				{
					iMarker.setOpacity(1);
				}
			});
		};
		var createChestMarker = function(pObject, pType, pID)
		{
			var newtitle = null;
			if (pObject.t)
			{
				newtitle = pObject.t;
			}
			var marker = L.marker(M.convertGCtoLC(pObject.c),
			{
				index: pID,
				icon: L.divIcon(
				{
					className: "mapChest" + pType,
					html: "<img src='" + "img/map/chest.png" + "' />",
					iconSize: [32, 32],
					iconAnchor: [16, 16]
				}),
				title: newtitle
			});
			marker.on("click", function()
			{
				if (getNodeState(this) === X.ChecklistEnum.Checked)
				{
					setNodeState(this, X.ChecklistEnum.Unchecked);
					this.setOpacity(1);
				}
				else
				{
					setNodeState(this, X.ChecklistEnum.Checked);
					this.setOpacity(opacityclicked);
				}
			});
			M.bindMarkerZoomBehavior(marker, "contextmenu");
			P.Layer.Chest.addLayer(marker);
		};
		
		// Create the chests
		for (i in P.Chests)
		{
			for (ii in P.Chests[i])
			{
				createChestMarker((P.Chests[i])[ii], i, counter);
				counter++;
			}
		}

		// Checkbox to toggle chest markers
		$("#jpzToggleChest").change(function()
		{
			M.toggleLayer(P.Layer.Chest, $(this).prop("checked"));
			refreshNodeState();
		});
		
		// The button to "uncheck" all chests
		$("#jpzUncheckChest").click(function()
		{
			X.clearChecklist(X.Checklists.Chest);
			refreshNodeState();
		});
	},
	
	/*
	 * Create list of collectibles and checkbox to toggle their display. The
	 * first checkbox click generates the icon.
	 */
	generateCollectiblesUI: function()
	{
		U.getScript(U.URL_DATA.Collectible, function()
		{
			P.Collectibles = GW2T_COLLECTIBLE_DATA;
			var metadata = GW2T_COLLECTIBLE_METADATA;
			var i;
			var collectible;
			var translatedname, defaultname, samplelink;
			var categories = {};
			
			for (i in P.Collectibles)
			{
				// Create checkboxes
				collectible = P.Collectibles[i];
				categories[collectible.category] = true;
				translatedname = D.getObjectName(collectible);
				defaultname = D.getObjectDefaultName(collectible);
				samplelink = I.cSiteLink + "<dfn>" + X.Collectibles[i].urlkey + "</dfn>";
				$("<div class='cltBox cltBox_" + collectible.category + "'>"
					+ "<label style='color:" + collectible.color + "'>"
						+ "<img id='cltPins_" + i + "' class='cltIcon' src='img/collectible/" + i.toLowerCase() + ".png' /><input id='ned_" + i + "' type='checkbox' /> " + translatedname
					+ "</label>"
					+ "<span class='cltLinks' title='" + samplelink + "' ><cite>"
						+ "<a href='" + U.getYouTubeLink(defaultname) + "'>[Y]</a>&nbsp;"//
						+ "<a href='" + collectible.wiki + "'>[W]</a>&nbsp;"
						+ "<a href='" + collectible.credit + "'>[C]</a>&nbsp;"
						+ "&nbsp;-&nbsp;&nbsp;</cite>"
						+ "<a id='nedUncheck_" + i + "'>Reset</a>"
					+ "</span>"
				+ "</div>").appendTo("#cltList").data("keywords", translatedname.toLowerCase());

				// Clicking a checkbox generates the markers for that collectible type
				$("#ned_" + i).one("click", function()
				{
					var type = U.getSubstringFromHTMLID($(this));
					G.generateCollectibles(type);
					M.goToArguments(P.Collectibles[type].view);
				});
				
				// If article URL query string exists, show collectible of specified index
				U.verifyArticle(X.Collectibles[i].urlkey, function()
				{
					var elm = $("#ned_" + i).trigger("click");
					setTimeout(function()
					{
						I.scrollToElement(elm, {aOffset: -64, aSpeed: "fast"});
					}, 2000);
				});
			}
			U.convertExternalLink("#cltList cite a");
			I.qTip.init(".cltLinks");
			I.createFilterBar("#cltSearch", ".cltBox");
			X.rewrapCheckboxes();
			
			// Create category filter
			for (var i in metadata.Categories)
			{
				(function(iCategory)
				{
					var catimg = metadata.Categories[iCategory];
					$("<button class='cltFilterButton btnTab curToggle' title='Filter: <dfn>" + iCategory + "</dfn>'><img src='" + catimg + "' /></button>")
						.appendTo("#cltFilter").click(function()
					{
						if ($(this).hasClass("btnActive"))
						{
							$(".cltFilterButton").removeClass("btnActive");
							$(".cltBox").show();
						}
						else
						{
							$(".cltFilterButton").removeClass("btnActive");
							$(this).addClass("btnActive");
							$(".cltBox").hide();
							$(".cltBox_" + iCategory).show();
						}
					});
				})(i);
			}
			I.qTip.init(".cltFilterButton");

			// Toggle button will only hide icons, by unchecking the checked boxes
			$("#mapToggle_Collectible").data("checked", false).data("hideonly", true).click(function()
			{
				for (i in P.Collectibles)
				{
					if ($("#ned_" + i).prop("checked"))
					{
						$("#ned_" + i).trigger("click");
					}
				}
			});
			// Scroll to the section now that the list is generated
			I.scrollToElement("#headerMap_Collectible", {aContainer: "#plateMap"});
		});
	},
	
	/*
	 * Generates the markers for a collectible type.
	 * @param string pType of the collectible.
	 */
	generateCollectibles: function(pType)
	{
		var i, ii, number, extreme;
		var pingsimport = U.Args[X.Collectibles[pType].urlkey];
		var collectible = P.Collectibles[pType];
		var ithneedle, markeroptions;
		var unlocktoindex, indextounlock;
		var stateinstring;
		var pathline, pathstyle;
		var markertitle;
		var translatedname = D.getObjectName(collectible);
		var directory = "img/collectible/" + pType.toLowerCase() + "/";
		/*
		 * If the collectible's indexes are associated with special unlock IDs,
		 * then use those IDs instead of the needle's index number.
		 */
		if (collectible.needles[0].u)
		{
			unlocktoindex = {};
			indextounlock = {};
			for (i = 0; i < collectible.needles.length; i++)
			{
				ithneedle = collectible.needles[i];
				unlocktoindex[ithneedle.u] = i + 1;
				indextounlock[i] = ithneedle.u;
			}
		}
		
		var styleCollectibleMarker = function(pMarker, pState)
		{
			if (collectible.iconsize)
			{
				var size = collectible.ringsize || 16;
				pMarker.setIcon(new L.divIcon(
				{
					className: "mapNeedle" + pState,
					html: "<span class='mapNeedleIcon' style='color:" + collectible.color + ";"
						+ "background-image: url(" + pMarker.options.needleLabel + ");"
						+ "background-size: " + collectible.iconsize + "px'></span>",
					iconSize: [size, size],
					iconAnchor: [size/2, size/2]
				}));
			}
			else
			{
				pMarker.setIcon(new L.divIcon(
				{
					className: "mapNeedle" + pState + " mapNeedleExtreme" + pMarker.options.needleExtreme,
					html: "<span style='color:" + collectible.color + "'>"
						+ pMarker.options.needleLabel + "</span>",
					iconSize: [16, 16],
					iconAnchor: [8, 8]
				}));
			}
			// Fade the icon if user marked it as found (clicked it enough times)
			if (pState === X.ChecklistEnum.Found)
			{
				pMarker.setOpacity(0.2);
			}
			else
			{
				pMarker.setOpacity(1);
			}
		};
		var createMarker = function(pCoord, pMarkerOptions)
		{
			var marker = L.marker(M.convertGCtoLC(pCoord), pMarkerOptions);
			styleCollectibleMarker(marker, stateinstring);

			// Bind marker behavior
			marker.on("click", function(pEvent)
			{
				var newstate = X.trackChecklistItem(X.Collectibles[this.options.needleType], this.options.needleIndex);
				var thismarker = this;
				if (collectible.iscushion)
				{
					// For needle sets, clicking one marker will also change all markers of the same set (index)
					P.LayerArray[this.options.needleType].forEach(function(iLayer)
					{
						if (iLayer.options.needleIndex === thismarker.options.needleIndex)
						{
							styleCollectibleMarker(iLayer, newstate);
						}
					});
				}
				else
				{
					styleCollectibleMarker(this, newstate);
				}

				// Update URL bar with list of numbers of checked markers
				var pingsexport = X.getCheckedIndexes(X.Collectibles[this.options.needleType], indextounlock);
				if (pingsexport.length)
				{
					U.updateAddressBar("?" + this.options.needleKey + "=" + pingsexport);
				}
				else
				{
					U.updateQueryString();
				}
			});
			M.bindMarkerCoordBehavior(marker, "click");
			M.bindMarkerZoomBehavior(marker, "contextmenu");

			// Add to array
			P.LayerArray[pType].push(marker);
		};
		
		// Initialize checklist
		X.Collectibles[pType].length = P.Collectibles[pType].needles.length;
		X.initializeChecklist(X.Collectibles[pType], X.Collectibles[pType].length, pingsimport, null, unlocktoindex);
		
		P.LayerArray[pType] = []; // Holds markers (needles)
		P.Layer[pType] = new L.layerGroup(); // Holds path connecting the markers
		
		for (i = 0; i < collectible.needles.length; i++)
		{
			// Read and enact the state of the ith collectible checklist
			number = i + 1;
			ithneedle = collectible.needles[i];
			stateinstring = X.getChecklistItem(X.Collectibles[pType], i);
			if (ithneedle.u && ithneedle.l === undefined)
			{
				ithneedle.l = ithneedle.u.toString();
			}

			markertitle = "<div class='mapLoc'><dfn>" + translatedname + ":</dfn> " + (ithneedle.l ? (ithneedle.l + " (#" + number + ")") : "#" + number)
				+ ((collectible.iscushion) ? "<br />" + D.getObjectName(ithneedle) : "");
			if (ithneedle.s)
			{
				markertitle += "<img src='" + ithneedle.s + "' />";
			}
			if (ithneedle.t)
			{
				markertitle += "<div class='mapTip'>" + ithneedle.t + "</div>";
			}
			markertitle += "</div>";

			// The "extreme" enum indicates the needle is an extremity or sub-extremity of the path
			if ((i === 0 || i === collectible.needles.length - 1))
			{
				extreme = 0;
			}
			else
			{
				extreme = ((ithneedle.e === undefined) ? "" : ithneedle.e);
			}
			// Define marker options before sending it to the create method
			markeroptions = {
				needleExtreme: extreme,
				needleIndex: i,
				needleType: pType,
				needleKey: X.Collectibles[pType].urlkey,
				needleLabel: (collectible.iconsize) ? (directory + ithneedle.i + I.cPNG)
					: ((ithneedle.l === undefined) ? number : ithneedle.l),
				title: markertitle
			};

			if (collectible.iscushion) // Special set of markers without tracing
			{
				for (ii = 0; ii < ithneedle.c.length; ii++)
				{
					createMarker(ithneedle.c[ii], markeroptions);
				}
			}
			else // Regular set of markers with tracing
			{
				createMarker(ithneedle.c, markeroptions);
				// Draw a segment from the current and next needle's coordinates
				if (i < collectible.needles.length - 1 && collectible.wantpath !== false)
				{
					pathstyle = (ithneedle.e === 2) ? "5,15" : "1";
					pathline = L.polyline(M.convertGCtoLCDual([ithneedle.c, (collectible.needles[i+1]).c]),
					{
						color: "lime",
						dashArray: pathstyle,
						opacity: 0.5
					});
					P.Layer[pType].addLayer(pathline);
				}
				// Draw path for the node itself, if provided
				if (ithneedle.p)
				{
					for (ii = 0; ii < ithneedle.p.length - 1; ii++)
					{
						pathline = L.polyline(M.convertGCtoLCDual([ithneedle.p[ii], ithneedle.p[ii+1]]),
						{
							color: "magenta",
							dashArray: "5,15",
							opacity: 0.5
						});
						P.Layer[pType].addLayer(pathline);
					}
				}
			}
		}
		
		// Draw paths from markers numbered low to high
		M.toggleLayerArray(P.LayerArray[pType], true);
		M.toggleLayer(P.Layer[pType], true);
		
		// Bind checkboxes after the markers and paths have been generated for this collectible
		$("#ned_" + pType).change(function()
		{
			var state = $(this).prop("checked");
			var type = U.getSubstringFromHTMLID($(this));
			M.toggleLayerArray(P.LayerArray[type], state);
			M.toggleLayer(P.Layer[type], state);
			// Also views the map location of the collectible if box is checked
			if (state)
			{
				M.goToArguments(P.Collectibles[type].view);
				// Rebind tooltip
				P.rebindMarkerTooltips();
				X.getCheckboxLabel($(this)).addClass("cltCheckedLabel");
			}
			else
			{
				X.getCheckboxLabel($(this)).removeClass("cltCheckedLabel");
			}
			// Special case for ranger pets
			if (pType === "RangerPets")
			{
				G.generatePetsList(collectible.needles, state);
			}
		});
		$("#nedUncheck_" + pType).click(function()
		{
			var type = U.getSubstringFromHTMLID($(this));
			var markers = P.LayerArray[type];
			for (var i in markers)
			{
				styleCollectibleMarker(markers[i], X.ChecklistEnum.Unfound);
			}
			X.clearChecklist(X.Collectibles[type]);
			U.updateQueryString();
		});
		// Clicking on the list icon will draw pins from the collectible path
		$("#cltPins_" + pType).click(function()
		{
			if (M.isPersonalPinsLaid())
			{
				M.clearPersonalPins();
				return;
			}
			var coords = [];
			var testcoord = collectible.needles[0].c;
			if (isNaN(testcoord[0]) === false) // Allow 1D arrays only
			{
				for (var i in collectible.needles)
				{
					coords.push(collectible.needles[i].c);
				}
				M.redrawPersonalPath(coords);
			}
		});
	},
	
	/*
	 * Gets a pings URL containing collectible unlock indexes.
	 * @param object pCollectible checklist.
	 * @param object pUnlockAssoc derived from API.
	 * @returns string URL
	 */
	getCollectibleURL: function(pCollectible, pUnlockAssoc)
	{
		var ids = U.convertAssocToArray(pUnlockAssoc).join(",");
		ids = (ids.length) ? ids : "null";
		return I.cSiteURL + "?" + pCollectible.urlkey + "=" + ids + "&bol_showPanel=false";
	},
	
	/*
	 * Generates a list of pets and their pet skills, on the console.
	 * @param objarray pNeedles from Collectibles object.
	 * @param boolean pState to show or hide.
	 */
	generatePetsList: function(pNeedles, pState)
	{
		var type = "RangerPets";
		var container = $("#cltSublist" + type);
		var list = container.find(".cltSublistContainer");
		container.toggle(pState);
		$(".cltPetIcon").removeClass("cltPetIconFocused");
		// Don't regenerate the list if already did
		if (list.is(":empty") === false)
		{
			I.scrollToElement(container, {aContainer: "#plateMap"});
			return;
		}
		
		var ithneedle, fact, factline;
		var name, wiki, marker, factstr, durationstr, peticon;
		var secstr = D.getWord("s");
		for (var i = 0; i < pNeedles.length; i++)
		{
			ithneedle = pNeedles[i];
			name = D.getObjectName(ithneedle);
			wiki = U.getWikiLinkDefault("Juvenile " + D.getObjectDefaultName(ithneedle));
			peticon = "img/collectible/rangerpets/" + ithneedle.i + I.cPNG;
			var str = "<div class='cltPetBox'><span class='cltPetIcon curToggle' title='" + name + "' style='background-image:url(" + peticon + ")'>" 
				+ "<var class='cltPetIconBackground'>" + I.Symbol.Filler + "</var></span><aside class='cltPetFacts'>";
			for (var ii in ithneedle.a)
			{
				fact = ithneedle.a[ii];
				if (Array.isArray(fact))
				{
					// If a fact is an array containing the buff/condition's: [stackNumber, duration]
					durationstr = "(" + fact[1] + secstr + ")"; // Include stack number if there's more than 1
					factstr = (fact[0] > 1) ? ("<var class='cltPetStack'>" + fact[0] + "</var>" + durationstr) : durationstr;
				}
				else
				{
					factstr = fact;
				}
				str += "<span class='cltPetFact'><img class='cltPetFactIcon' src='img/fact/"
					+ ii + I.cPNG + "' /><var class='cltPetFactText'>" + factstr + "</var></span>";
			}
			str += "</aside></div>";
			factline = $(str).appendTo(list).data("keywords", name.toLowerCase());
			(function(iIndex, iWiki)
			{
				factline.find(".cltPetIcon").click(function()
				{
					// Clicking on the pet icon from the list shows that pet species only
					var ischecked = $(this).hasClass("cltPetIconFocused");
					$(".cltPetIcon").removeClass("cltPetIconFocused");
					if (ischecked)
					{
						// Show all species
						M.toggleLayerArray(P.LayerArray[type], true);
					}
					else
					{
						for (var ii = 0; ii < P.LayerArray[type].length; ii++)
						{
							// Show the clicked species while hiding all others
							marker = (P.LayerArray[type])[ii];
							if (marker.options.needleIndex === iIndex)
							{
								M.toggleLayer(marker, true);
							}
							else
							{
								M.toggleLayer(marker, false);
							}
						}
						$(this).addClass("cltPetIconFocused");
					}
				}).dblclick(function()
				{
					// Double clicking on the pet icon opens the wiki
					U.openExternalURL(iWiki);
				});
			})(i, wiki);
		}
		I.qTip.init(list.find(".cltPetIcon"));
		// Create search bar
		var search = $("<div class='cntSearchContainer'></div>").insertBefore(list);
		I.createFilterBar(search, $(".cltPetBox"));
		// Scroll to the list
		setTimeout(function()
		{
			I.scrollToElement(container, {aContainer: "#plateMap"});
		}, 200);
	},
	
	/*
	 * Create list of guild mission types, and mission checkboxes for each type.
	 * First checkbox click generates the mission's data into the map.
	 */
	generateGuildUI: function()
	{
		var insertMission = function(pBookName, pMission, pIndex)
		{
			var missiontype = D.getObjectName(P.Guild[pBookName]);
			var name = D.getObjectDefaultName(pMission);
			var translatedname = D.getObjectName(pMission);
			var limitstr = (pMission.limit) ? (" - " + pMission.limit) : "";
			var elmid = "gld" + pBookName + "_" + pIndex;
			$("<div class='gld" + pBookName + "'><img class='cssWaypoint' " + I.cClipboardAttribute
				+ "='" + pMission.wp + " " + missiontype + ": " + translatedname + "' src='img/ui/placeholder.png' /> "
				+ "<dfn id='" + elmid + "' data-coord='[" + pMission.coord[0] + "," + pMission.coord[1] + "]'>" + translatedname + limitstr + "</dfn> "
				+ "<a href='" + U.getYouTubeLink(name) + "'>[Y]</a> "
				+ "<a href='" + U.getWikiLinkLanguage(translatedname) + "'>[W]</a>"
			+ "</div>").appendTo("#gldBook_" + pBookName).data("keywords", translatedname.toLowerCase());
			// Return for binding mission type specific map behavior
			return $("#" + elmid);
		};
				
		var finalizeGuildBook = function(pBookName)
		{
			var bookid = "#gldBook_" + pBookName;
			U.convertExternalLink(bookid + " a");
			I.qTip.init(bookid + " dfn");
			// Initialize clipboard for each waypoint
			$(bookid + " .cssWaypoint").each(function()
			{
				I.bindClipboard($(this));
			});
			// Search bar
			var search = $("<div class='cntSearchContainer'><div>").prependTo(bookid);
			I.createFilterBar(search, ".gld" + pBookName);
		};
		
		var hideGuildMapDrawings = function(pBook)
		{
			M.toggleLayerArray(P.LayerArray["Guild_" + pBook], false);
			$("#gldBook_" + pBook + " dfn").each(function()
			{
				I.toggleHighlight($(this), false);
			});
			if (P.Guild[pBook].usedSubmaps !== undefined)
			{
				M.toggleSubmapArray(P.Guild[pBook].usedSubmaps, false);
			}
		};
		
		U.getScript(U.URL_DATA.Guild, function()
		{
			P.Guild = GW2T_GUILD_DATA;
			var i;
			// Create buttons for each mission type, which generates content when first clicked
			for (i in P.Guild)
			{
				var missiontype = P.Guild[i];
				var translatedname = D.getObjectName(missiontype);
				$("#gldButtons").append("<div class='gldButtonContainer'>"
					+ "<button class='gldButton curToggle btnTab' id='gldButton_" + i
						+ "' style='background-size:cover; background-image:url(img/guild/" + i.toLowerCase() + I.cPNG + ")' "
						+ "title='<dfn>" + translatedname + "</dfn><br />" + I.cSiteLink + "<dfn>guild/" + i.toLowerCase() + "</dfn>'></button>"
					+ "<a class='gldLink cssButton' href='" + U.getYouTubeLink(translatedname) + "'>Y</a>&nbsp;"
					+ "<a class='gldLink cssButton' href='" + D.getObjectURL(missiontype) + "'>W</a>"
					+ "</div>");
				$("#gldBooks").append("<div class='gldBook' id='gldBook_" + i + "'></div>");
			}
			$(".gldBook").hide();
			I.qTip.init("#gldButtons button");
			U.convertExternalLink("#gldButtons a");
			
			// Bind button to show the guild mission type
			$(".gldButton").click(function()
			{
				$(".gldButton").removeClass("btnActive");
				var missiontype = U.getSubstringFromHTMLID($(this));
				var wantshow = true;
				// If current mission type is already showing
				if ($("#gldBook_" + missiontype).is(":visible"))
				{
					hideGuildMapDrawings(missiontype);
					wantshow = false;
				}
				$(".gldBook").hide();
				if (wantshow)
				{
					$(this).addClass("btnActive");
					$("#gldBook_" + missiontype).show();
				}
				I.updateScrollbar();
			});
			
			// Bind button to hide all guild map drawings
			$("#mapToggle_Guild").data("hideonly", true).click(function()
			{
				$(".gldButton").removeClass("btnActive").each(function()
				{
					hideGuildMapDrawings(U.getSubstringFromHTMLID($(this)));
					$(".gldBook").hide();
					I.updateScrollbar();
				});
				M.movePin(M.Pin.Program);
			});
			
			/*
			 * Bounty generation.
			 */
			$("#gldButton_Bounty").one("click", function()
			{
				U.sortObjects(P.Guild.Bounty.data);
				for (var i in P.Guild.Bounty.data)
				{
					var mission = P.Guild.Bounty.data[i];
					var elm = insertMission("Bounty", mission, i);
					
					var layergroup = new L.layerGroup();
					if (mission.paths !== undefined)
					{
						for (var ii in mission.paths)
						{
							layergroup.addLayer(P.drawDirectedPath(mission.paths[ii]));
						}
					}
					if (mission.spawn !== undefined)
					{
						layergroup.addLayer(P.drawSpots(mission.spawn));
					}
					P.LayerArray.Guild_Bounty.push(layergroup);
					
					// Bind this mission's behavior
					elm.attr("title", "<div class='mapLoc'><img src='" + mission.img + "' /></div>")
						.click(function()
					{
						I.toggleHighlight($(this));
						M.toggleLayer(P.LayerArray.Guild_Bounty[U.getSubintegerFromHTMLID($(this))]);
					});
					M.bindMapLinkBehavior(elm, M.invertZoomLevel(mission.coord[2]));
				}
				finalizeGuildBook("Bounty");
			});
			
			/*
			 * Trek generation.
			 */
			$("#gldButton_Trek").one("click", function()
			{
				U.sortObjects(P.Guild.Trek.data);
				for (var i in P.Guild.Trek.data)
				{
					var mission = P.Guild.Trek.data[i];
					var elm = insertMission("Trek", mission, i);
					
					var layergroup = new L.layerGroup();
					layergroup.addLayer(L.polyline(M.convertGCtoLCMulti(mission.path), {color: "gold"}));
					P.LayerArray.Guild_Trek.push(layergroup);
					
					// Bind this mission's behavior
					elm.attr("title", "<div class='mapLoc'><img src='" + mission.img + "' /></div>")
						.click(function()
					{
						I.toggleHighlight($(this));
						M.toggleLayer(P.LayerArray.Guild_Trek[U.getSubintegerFromHTMLID($(this))]);
					});
					M.bindMapLinkBehavior(elm, M.ZoomEnum.Ground, M.Pin.Program);
				}
				finalizeGuildBook("Trek");
			});
			
			/*
			 * Challenge generation.
			 */
			$("#gldButton_Challenge").one("click", function()
			{
				P.Guild.Challenge.usedSubmaps = [];
				U.sortObjects(P.Guild.Challenge.data);
				for (var i in P.Guild.Challenge.data)
				{
					var mission = P.Guild.Challenge.data[i];
					var elm = insertMission("Challenge", mission, i);
			
					// Submap image of interior map
					if (mission.submap !== undefined)
					{
						M.toggleSubmap(mission.submap, false);
						P.Guild.Challenge.usedSubmaps.push(mission.submap);
					}
					
					var layergroup = new L.layerGroup();
					layergroup.addLayer(L.polyline(M.convertGCtoLCMulti(mission.path), {color: "gold"}));
					layergroup.addLayer(P.drawSpots(mission.spawn, {color: "gold"}));
					P.LayerArray.Guild_Challenge.push(layergroup);
					
					// Bind this mission's behavior
					elm.click(function()
					{
						var index = U.getSubintegerFromHTMLID($(this));
						var submap = P.Guild.Challenge.data[index].submap;
						var state = I.toggleHighlight($(this));
						if (submap !== undefined)
						{
							M.toggleSubmap(submap, state);
						}
						M.toggleLayer(P.LayerArray.Guild_Challenge[index]);
					});
					M.bindMapLinkBehavior(elm, M.ZoomEnum.Ground, M.Pin.Program);
				}
				finalizeGuildBook("Challenge");
			});
			
			/*
			 * Rush generation.
			 */
			$("#gldButton_Rush").one("click", function()
			{
				P.Guild.Rush.usedSubmaps = [];
				U.sortObjects(P.Guild.Rush.data);
				for (var i in P.Guild.Rush.data)
				{
					var mission = P.Guild.Rush.data[i];
					var elm = insertMission("Rush", mission, i);
					
					// Submap image of interior map
					if (mission.submap !== undefined)
					{
						M.toggleSubmap(mission.submap, false);
						P.Guild.Rush.usedSubmaps.push(mission.submap);
					}
					
					var layergroup = new L.layerGroup();
					// Path from waypoint to start
					layergroup.addLayer(L.polyline(M.convertGCtoLCMulti(mission.path), {color: "gold"}));
					// Path from start to finish
					layergroup.addLayer(L.polyline(M.convertGCtoLCMulti(mission.track), {color: "lime", dashArray: "5,10"}));
					// Markers for finish chest
					layergroup.addLayer(L.marker(M.convertGCtoLC(mission.finish), {icon: M.createStandardIcon("img/map/chest.png")}));
					// Circles for small traps
					if (mission.traps0 !== undefined)
					{
						layergroup.addLayer(P.drawSpots(mission.traps0, {radius: 5, color: "red", weight: 1, opacity: 1}));
					}
					// Circles for big traps
					if (mission.traps1 !== undefined)
					{
						layergroup.addLayer(P.drawSpots(mission.traps1, {radius: 10, color: "red", weight: 1, opacity: 1}));
					}
					// Circles for flag checkpoints
					layergroup.addLayer(P.drawSpots(mission.flags, {radius: 2, color: "gold", weight: 2, opacity: 1}));
					
					P.LayerArray.Guild_Rush.push(layergroup);
					
					// Bind this mission's behavior
					elm.click(function()
					{
						var index = U.getSubintegerFromHTMLID($(this));
						var submap = P.Guild.Rush.data[index].submap;
						var state = I.toggleHighlight($(this));
						if (submap !== undefined)
						{
							M.toggleSubmap(submap, state);
						}
						M.toggleLayer(P.LayerArray.Guild_Rush[index]);
					});
					M.bindMapLinkBehavior(elm, M.ZoomEnum.Ground, M.Pin.Program);
				}
				finalizeGuildBook("Rush");
			});
			
			/*
			 * Puzzle generation.
			 */
			$("#gldButton_Puzzle").one("click", function()
			{
				P.Guild.Puzzle.usedSubmaps = [];
				U.sortObjects(P.Guild.Puzzle.data);
				for (var i in P.Guild.Puzzle.data)
				{
					var mission = P.Guild.Puzzle.data[i];
					var elm = insertMission("Puzzle", mission, i);
					
					// Submap image of interior map
					if (mission.submap !== undefined)
					{
						M.toggleSubmap(mission.submap, false);
						P.Guild.Puzzle.usedSubmaps.push(mission.submap);
					}
					
					var layergroup = new L.layerGroup();
					// Circles for interactive objects
					layergroup.addLayer(P.drawSpots(mission.interactions, {color: "gold"}));
					// Markers for finish chest
					layergroup.addLayer(L.marker(M.convertGCtoLC(mission.finish), {icon: M.createStandardIcon("img/map/chest.png")}));
					
					P.LayerArray.Guild_Puzzle.push(layergroup);
					
					// Bind this mission's behavior
					elm.click(function()
					{
						var index = U.getSubintegerFromHTMLID($(this));
						var submap = P.Guild.Puzzle.data[index].submap;
						var state = I.toggleHighlight($(this));
						if (submap !== undefined)
						{
							M.toggleSubmap(submap, state);
						}
						M.toggleLayer(P.LayerArray.Guild_Puzzle[index]);
					});
					M.bindMapLinkBehavior(elm, M.ZoomEnum.Ground, M.Pin.Program);
				}
				finalizeGuildBook("Puzzle");
			});
			
			/*
			 * Open the guild mission type if article query string is present.
			 */
			for (i in P.Guild)
			{
				U.verifyArticle(i, function()
				{
					$("#gldButton_" + i).trigger("click");
				});
			}
		});
	}
};
W = {
/* =============================================================================
 * @@World vs World Mists map and objectives, an extension of the M object
 * ========================================================================== */

	MapEnum: "wvw",
	OptionSuffix: "WvW",
	Continent: GW2T_CONTINENT_DATA["wvw"],
	ZoneAssociation: GW2T_LAND_ASSOCIATION,
	Subzones: {},
	cInitialZone: "eternal",
	Floors: [],
	isMappingIconsGenerated: false,
	ZoomEnum:
	{
		Adaptive: -2,
		Same: -1,
		Min: 0,
		Overview: 2,
		Default: 3,
		Space: 2,
		Sky: 4,
		Bird: 5,
		Ground: 6,
		Max: 6
	},
	Layer: {
		Overview: new L.layerGroup(),
		Pin: new L.layerGroup(),
		PersonalPin: new L.layerGroup(),
		PersonalPath: new L.layerGroup(),
		CompassIcon: new L.layerGroup(), // compass icon
		CompassCircle: new L.layerGroup(), // compass radius circle
		Destructible: new L.layerGroup(), // destructibles walls and gates
		Secondaries: new L.layerGroup(), // sentries, shrines, ruins, supply depots
		Objective: new L.layerGroup(), // camps, towers, keeps
		SpawnLabel: new L.layerGroup() // server name over their map spawns
	},
	LayerArray: {
		
	},
	Pin: {
		Program: {},
		Event: {},
		Over: {},
		Character: {},
		Camera: {}
	},
	
	/*
	 * WvW exclusive properties.
	 */
	LocaleThreshold:
	{
		Range: 99,
		AmericasPrefix: "1",
		Americas: 1000,
		Europe: 2000,
		EuropePrefix: "2",
		France: 2100,
		Germany: 2200,
		Spain: 2300
	},
	LocaleEnum:
	{
		Americas: "Americas",
		Europe: "Europe"
	},
	LeaderboardURL: {
		Americas: "https://leaderboards.guildwars2.com/en/na/wvw",
		Europe: "https://leaderboards.guildwars2.com/en/eu/wvw"
	},
	LocaleCurrent: null,
	Rotation: null, // Will refer to an associative array of zone nicks of the current rotation
	LandPrefix: {},
	isWvWPrepped: false,
	isWvWLoaded: false,
	isWvWPaused: false,
	Metadata: {},
	Servers: {}, // Server names and translations
	Matches: null, // For fallback API, array containing objects with same structure as "worlds" subobject in v2 API matches.json
	MatchupCurrent: null, // Formatted superobject containing teams (servers of a color) and reuseable translated strings
	Guilds: {}, // Holds retrieved API guild details objects
	Objectives: {},
	ObjectiveTimeout: {},
	ObjectiveTimestampIgnore: null,
	Compasses: {},
	Placement: {},
	MapType: {}, // Corresponds to "worlds" object from match API
	LandEnum: {}, // Corresponds to "map_type" property of objectives, example: "GreenHome"
	ObjectiveEnum: {}, // Corresponds to "type" property of objectives
	OwnerEnum: {}, // Corresponds to "owner" property from match API, example: "Green"
	MatchupIDCurrent: null,
	isObjectiveTickEnabled: false,
	isObjectiveTimerTickEnabled: false,
	isAPIFailed: false,
	isFallbackEnabled: false,
	numFailedAPICalls: 0,
	cOWNERS_PER_TIER: 3,
	cLEADERBOARD_SERVERS_CHAR_LIMIT: 32,
	cTOTAL_PPT_POSSIBLE: 0, // Will be assigned by the compute function
	cSECONDS_IMMUNITY: 300, // Righteous Indignation time
	cMSECONDS_IMMUNITY: 300000, // 5 minutes
	MatchStartTimeMS: null,
	MatchFinishTimeMS: null,
	MatchFinishTimeISO: null,
	secTillWvWReset: null,
	numSiegeSupply: 0,
	
	/*
	 * Changes variables to match the current borderlands rotation.
	 */
	initializeBorderlands: function()
	{
		// Zone Objects
		W.Rotation = W.Metadata.Rotation;
		for (var i in W.Rotation)
		{
			var landnick = W.Rotation[i];
			W.Zones[landnick] = GW2T_LAND_ADD[landnick];
			W.LandPrefix[i] = W.Zones[landnick].id + "-";
		}
		// Zone List
		$(".wvwZoneListBorderlands").each(function()
		{
			var landnick = W.Rotation[$(this).attr("data-zone")];
			$(this).attr("data-zone", landnick);
		});
	},
	
	/*
	 * Initializes the WvW map and starts the objective state and time functions.
	 */
	initializeWvW: function(pPage)
	{
		/*
		 * Merge W's unique variables and functions with M, and use that new
		 * object as W. This is a shallow copy, so objects within an object that
		 * are not shared/modified must be redeclared here in W.
		 */
		var now = new Date();
		$.extend(W, $.extend({}, M, W));
		W.Regions = GW2T_REALM_DATA;
		W.Zones = GW2T_LAND_DATA;
		W.Servers = GW2T_SERVER_DATA;
		W.Compasses = GW2T_WEAPON_DATA;
		W.Metadata = GW2T_WVW_METADATA;
		W.Placement = GW2T_PLACEMENT_DATA;
		W.MapType = W.Metadata.MapType;
		W.LandEnum = W.Metadata.LandEnum;
		W.ObjectiveEnum = W.Metadata.ObjectiveEnum;
		W.OwnerEnum = W.Metadata.OwnerEnum;
		W.initializeBorderlands();
		
		W.computeObjectivesValue();
		W.initializeObjectives();
		W.initializeMap();
		W.populateWvW();
		W.initializeLeaderboard();
		W.initializeLog();
		W.reinitializeServerChange();
		W.generateServerList();
		I.styleContextMenu("#wvwContext");
		U.convertExternalLink("#wvwHelpLinks a");
		$("#wvwToolsButton").one("mouseenter", W.initializeSupplyCalculator);
		$("#wvwHUDContainer").toggle(O.Options.bol_showHUDWvW);
		
		// Finally
		W.isWvWLoaded = true;
		
		// Show leaderboard the first time if requested by URL
		if (pPage === I.SpecialPageEnum.Leaderboard)
		{
			$("#lboRegion").trigger("click");
		}
		else
		{
			U.openSectionFromURL({aButton: "#lboRegion", aSection: "Leaderboard"});
		}
		
		// Write announcement if available
		var announcement = H.getAnnouncement(H.Announcement.NewsWVW, now);
		if (announcement)
		{
			W.addLogEntry(announcement);
		}
	},
	
	/*
	 * Initializes the objectives object to contain objectives specific to the
	 * current map rotation.
	 */
	initializeObjectives: function()
	{
		var objectivedata = GW2T_OBJECTIVE_DATA;
		for (var i in W.Rotation)
		{
			var landnick = W.Rotation[i];
			var landobjectives = objectivedata[landnick];
			for (var ii in landobjectives)
			{
				W.Objectives[ii] = landobjectives[ii];
			}
		}
	},
	
	/*
	 * Generates the WvW objectives markers and labels.
	 */
	populateWvW: function()
	{
		var obj, marker, subobjclass;
		for (var i in W.Objectives)
		{
			obj = W.Objectives[i];
			subobjclass = (obj.type === W.ObjectiveEnum.Ruins || obj.type === W.ObjectiveEnum.Bloodlust) ? "objSubobjective" : "";
			marker = L.marker(W.convertGCtoLC(obj.coord),
			{
				clickable: true,
				riseOnHover: true,
				icon: L.divIcon(
				{
					className: "",
					html: "<div id='obj_" + obj.id + "' class='objContainer " + subobjclass + "'>"
							+ "<span class='objUmbrellaContainer'><span class='objUmbrellaOuter'><span id='objUmbrella_" + obj.id + "' class='objUmbrella'></span></span></span>"
							+ "<time id='objTimer_" + obj.id + "' class='objTimer'></time>"
							+ "<span class='objProgressContainer'><span id='objProgressBar_" + obj.id
								+ "' class='objProgressBar'><var id='objProgress_" + obj.id + "' class='objProgress'></var></span></span>"
							+ "<span class='objIconContainer'><img id='objIcon_" + obj.id
								+ "' class='objIcon' src='img/ui/placeholder.png'/></span>"
							+ "<span class='objInfo'><cite id='objClaim_" + obj.id + "' class='objClaim'></cite> <cite id='objAge_" + obj.id + "' class='objAge'></cite></span>"
						+ "</div>",
					iconSize: [38, 38],
					iconAnchor: [19, 19]
				})
			});
			// Show objective's raw information when clicked
			(function(iObj)
			{
				marker.on("click", function()
				{
					if (iObj.data)
					{
						I.prettyJSON(iObj.data);
					}
				});
			})(obj);
			W.bindMarkerZoomBehavior(marker, "contextmenu");
			obj.Marker = marker;
			W.Layer.Objective.addLayer(marker);
		}
		W.toggleLayer(W.Layer.Objective, true);
		
		// Generate labels over servers' map spawn points, the names will be reassigned by the objective function
		var labels = W.Metadata.SpawnLabels;
		for (var i in W.Rotation)
		{
			var landnick = W.Rotation[i];
			var landlabel = labels[landnick];
			for (var ii in landlabel)
			{
				var coord = landlabel[ii];
				marker = L.marker(W.convertGCtoLC(coord),
				{
					icon: L.divIcon(
					{
						className: "mapSec",
						html: "<span class='mapSecIn wvwSpawnContainer wvwColor" + ii + "' id='wvwSpawn_" + i + "_" + ii + "' data-owner='" + ii + "'>"
							+ "<var class='wvwSpawnLabel'></var>"
						+ "</span>",
						iconSize: [128, 64],
						iconAnchor: [64, 32]
					})
				});
				(function(iLand, iTeam)
				{
					marker.on("click", function()
					{
						$("#wvwZoneLink" + ((iLand === "Center") ? "Center" : iTeam)).trigger("click");
					});
					marker.on("dblclick", function()
					{
						$("#wvwZoneLink" + ((iLand === "Center") ? "Center" : iTeam)).trigger("dblclick");
					});
					marker.on("contextmenu", function()
					{
						W.goToDefault();
					});
				})(i, ii);
				W.Layer.SpawnLabel.addLayer(marker);
			}
		}
		W.toggleLayer(W.Layer.SpawnLabel, true);
		
		// Hide map labels if opted
		W.toggleObjectiveLabels();
		
		// Hide floor initially for projection
		if (I.isProjectionEnabled)
		{
			W.toggleFloor(false);
		}
		else
		{
			W.toggleFloor(true);
		}
		
		// The function below would have been called already if world completion icons were generated
		if (O.Options.bol_showWorldCompletionWvW === false)
		{
			W.finishPopulation();
		}
	},
	
	/*
	 * Does final touches to the map after the icons have been generated.
	 */
	finishPopulation: function()
	{
		W.toggleSecondaries();
		W.toggleWalls();
		W.bindMapVisualChanges();
		W.adjustZoomMapping();
		W.executeURLCommands();
	},
	
	/*
	 * Creates secondary objective markers or toggle them if already created.
	 */
	toggleSecondaries: function(pWantAdjust)
	{
		if (O.Options.bol_showSecondaries
			&& W.Layer.Secondaries.getLayers().length === 0)
		{
			var drawSecondary = function(pCoords, pImage, pZoneNick)
			{
				if (pCoords === undefined)
				{
					return;
				}
				for (var i in pCoords)
				{
					var offset = W.Metadata.Offsets[pZoneNick];
					var coord = pCoords[i];
					var marker = L.marker(W.convertGCtoLC([coord[0] + offset[0], coord[1] + offset[1]]),
					{
						clickable: false,
						icon: L.icon(
						{
							iconUrl: "img/wvw/secondaries/" + pImage + I.cPNG,
							iconSize: [32, 32],
							iconAnchor: [16, 16]
						}),
						opacity: 0.9
					});
					W.Layer.Secondaries.addLayer(marker);
				}
			};
			
			for (var i in W.Rotation)
			{
				var landnick = W.Rotation[i];
				var placementname = W.Metadata.PlacementAssociation[landnick];
				var pl = W.Placement[placementname];
				drawSecondary(pl.ShrineEarth, "shrine_earth", landnick);
				drawSecondary(pl.ShrineFire, "shrine_fire", landnick);
				drawSecondary(pl.ShrineAir, "shrine_air", landnick);
				drawSecondary(pl.Sentry, "sentry", landnick);
				drawSecondary(pl.Depot, "depot", landnick);
			}
			if (pWantAdjust)
			{
				W.adjustZoomMapping();
			}
		}
		W.toggleLayer(W.Layer.Secondaries, O.Options.bol_showSecondaries);
	},
	
	/*
	 * Draws paths representing destructible walls on the map or toggle them if
	 * already drawn.
	 */
	toggleWalls: function(pWantAdjust)
	{
		var barricadecolor = "coral";
		var wallcolor = "orange";
		var gatecolor = "yellow";
		
		if (O.Options.bol_showDestructibles
			&& W.Layer.Destructible.getLayers().length === 0)
		{
			var drawWall = function(pCoords, pColor, pZoneNick)
			{
				var offset = W.Metadata.Offsets[pZoneNick];
				for (var i in pCoords)
				{
					var coord = pCoords[i];
					var coordA = [(coord[0])[0] + offset[0], (coord[0])[1] + offset[1]];
					var coordB = [(coord[1])[0] + offset[0], (coord[1])[1] + offset[1]];
					var path = L.polyline(W.convertGCtoLCDual([coordA, coordB]),
					{
						clickable: false,
						color: pColor,
						opacity: 0.8,
						weight: 10,
						lineCap: "butt"
					});
					W.Layer.Destructible.addLayer(path);
				}
			};
			
			for (var i in W.Rotation)
			{
				var landnick = W.Rotation[i];
				var placementname = W.Metadata.PlacementAssociation[landnick];
				var pl = W.Placement[placementname];
				drawWall(pl.Barricade, barricadecolor, landnick);
				drawWall(pl.Wall, wallcolor, landnick);
				drawWall(pl.Gate, gatecolor, landnick);
			}
			
			if (pWantAdjust)
			{
				W.adjustZoomMapping();
			}
		}
		W.toggleLayer(W.Layer.Destructible, O.Options.bol_showDestructibles);
	},
	
	/*
	 * Toggles display of objective labels below its icon.
	 */
	toggleObjectiveLabels: function()
	{
		$(".objInfo, .wvwSpawnContainer").toggle(O.Options.bol_showObjectiveLabels);
	},
	
	/*
	 * Gets the time for the next WvW re-linking of server alliances.
	 * @param Date pDate from matches API, the reset weekday is same as relink.
	 * @returns object Date
	 */
	getWorldRelink: function(pDate)
	{
		var inputdate = pDate;
		var outputdate = new Date(pDate);
		var month = outputdate.getUTCMonth(), year = outputdate.getUTCFullYear();
		// Last target weekday of even numbered months, but check for oddness because month is zero-indexed
		if (month % 2 === 0)
		{
			month = (month % T.cMONTHS_IN_YEAR) + 1;
			outputdate.setUTCMonth(month);
		}
		
		var daysinmonth = T.getDaysInMonth(outputdate);
		// Look from the last day of the month back for the target weekday
		for (var i = daysinmonth; i > 0; i--)
		{
			if ((new Date(year, month, i)).getDay() === inputdate.getUTCDay())
			{
				outputdate.setUTCDate(i);
				break;
			}
		}
		if (outputdate < inputdate)
		{
			// If past that day but still on the same month, then get the next
			var nextmonth = month + 1;
			outputdate.setUTCMonth(nextmonth);
			if (nextmonth >= T.cMONTHS_IN_YEAR)
			{
				outputdate.setUTCFullYear(year + 1);
				outputdate.setUTCMonth(nextmonth % T.cMONTHS_IN_YEAR);
			}
			return T.getWorldRelink(outputdate);
		}
		// If here then that day will occur in this month
		return outputdate;
	},
	
	/*
	 * Gets the WvW metadata entry translations.
	 * @param string pString.
	 */
	getName: function(pEntry)
	{
		return D.getObjectName(W.Metadata[pEntry]);
	},
	getNick: function(pEntry)
	{
		return D.getObjectNick(W.Metadata[pEntry]);
	},
	
	/*
	 * Converts the API matchup object into a custom containing teams and
	 * formatted server names. A team is a set of servers on one color.
	 * @param object pMatchData from v2 or v1 API matches.json.
	 * return object matchup.
	 */
	formatMatchup: function(pMatchData)
	{
		var maxserversbeforeabbrev = 2;
		var id = 0;
		var numteams = W.Metadata.Teams.length;
		var teamnames = W.Metadata.Teams;
		var ithteamname, ithowner, worldid, teamserverids, hostserverid;
		var servers = new Array(numteams);
		var hosts = new Array(numteams);
		var names = new Array(numteams);
		var namelines = new Array(numteams);
		var namelinks = new Array(numteams);
		var nicks = new Array(numteams);
		var colors = new Array(numteams);
		
		// Create the object
		var custommatchup = {};
		custommatchup.id = id; // Match ID
		
		if (pMatchData.wvw_match_id) // Only v1 API matches.json has this property
		{
			id = pMatchData.wvw_match_id;
			for (var i = 0; i < numteams; i++)
			{
				ithteamname = teamnames[i];
				worldid = pMatchData[(ithteamname + "_world_id")];
				servers[i] = new Array();
				servers[i].push(W.Servers[worldid]);
			}
			// Initialize the one-server-per-team object
			custommatchup.worlds = W.convertWorlds(pMatchData);
		}
		else // Else assume it is v2 API matches.json
		{
			id = pMatchData.id;
			var teams = pMatchData.all_worlds;
			for (var i = 0; i < numteams; i++)
			{
				ithteamname = teamnames[i];
				teamserverids = teams[ithteamname];
				hostserverid = pMatchData.worlds[ithteamname];
				servers[i] = new Array();
				servers[i].push(W.Servers[hostserverid]); // Host server is index 0
				for (var ii = 0; ii < teamserverids.length; ii++)
				{
					if (teamserverids[ii] !== hostserverid)
					{
						servers[i].push(W.Servers[(teamserverids[ii])]);
					}
				}
			}
			// Initialize the one-server-per-team object
			custommatchup.worlds = pMatchData.worlds;
		}
		
		// Memorize borderlands name
		var getServerNameFromColor = function(pColor)
		{
			return U.escapeHTML(D.getObjectName(W.Servers[custommatchup.worlds[pColor]]));
		};
		var blstr = W.getName("Borderlands");
		custommatchup.RedHome = D.orderModifier(blstr, getServerNameFromColor("red"));
		custommatchup.BlueHome = D.orderModifier(blstr, getServerNameFromColor("blue"));
		custommatchup.GreenHome = D.orderModifier(blstr, getServerNameFromColor("green"));
		custommatchup.Center = W.getName("Center");
		
		// Initialize reuseable formatted server names string
		for (var i = 0; i < numteams; i++)
		{
			ithteamname = teamnames[i];
			ithowner = U.toFirstUpperCase(ithteamname);
			names[i] = new Array();
			namelines[i] = new Array();
			namelinks[i] = new Array();
			nicks[i] = new Array();
			colors[i] = D.getObjectName(W.Metadata[ithowner]);
			
			for (var ii = 0; ii < servers[i].length; ii++)
			{
				var ithserver = (servers[i])[ii];
				ithserver.owner = ithowner; // Record the server's color
				var ithservername = U.escapeHTML(D.getObjectName(ithserver));
				var hostflag = "";
				if (ii === 0) // Hosts are supposed to be in the first index in the API
				{
					hosts[i] = ithserver;
					// Add a suffix next to the host server name if that server has allies
					if (servers[i].length > 1)
					{
						hostflag = "+";
					}
				}
				// Abbreviate the names if is non-host server and there are too many on one team
				if ((hostflag.length === 0 && servers[i].length >= maxserversbeforeabbrev) || servers[i].length > maxserversbeforeabbrev)
				{
					names[i] += D.getObjectNick(ithserver) + hostflag;
					namelinks[i] += "<a href='?page=WvW&enu_Server=" + ithserver.id + "' title='" + ithservername + "'>" + D.getObjectNick(ithserver) + hostflag + "</a>";
				}
				else
				{
					names[i] += ithservername + hostflag;
					namelinks[i] += "<a href='?page=WvW&enu_Server=" + ithserver.id + "'>" + ithservername + hostflag + "</a>";
				}
				namelines[i] += ithservername + hostflag;
				nicks[i] += D.getObjectNick(ithserver) + hostflag;
				if (servers[i].length > 1 && ii < servers[i].length - 1) // Spacing between server names
				{
					names[i] += " &amp; ";
					namelines[i] += "<br />";
					namelinks[i] += " &amp; ";
					nicks[i] += " ";
				}
				
				// If the iterated server is the user's home server, then assign the color/owner string
				if (ithserver.id === O.Options.enu_Server)
				{
					custommatchup.oOwnerCurrent = ithowner;
				}
			}
		}
		
		// Assign variables for all teams to the custom matchup object
		for (var i = 0; i < numteams; i++)
		{
			ithteamname = teamnames[i];
			custommatchup[ithteamname] = {
				oServers: servers[i],
				oHost: hosts[i],
				oNameStr: names[i],
				oNameLinesStr: namelines[i],
				oNameLinksStr: namelinks[i],
				oNickStr: nicks[i],
				oColor: colors[i]
			};
		}
		
		return custommatchup;
	},
	
	/*
	 * Gets the team object (of the custom matchup object) from an owner
	 * string, such as "Green".
	 * @param string pOwner.
	 * @returns object server.
	 */
	getTeamFromOwner: function(pOwner)
	{
		return W.MatchupCurrent[pOwner.toLowerCase()];
	},
	
	/*
	 * Gets a translated borderlands name.
	 * @param object pServer to get the server name, or an objective object.
	 * @param boolean pFullServer or false to get nick, optional.
	 * @param boolean pFullBorderlands or false to get nick, optional.
	 * @returns string phrase.
	 */
	getBorderlandsString: function(pServer, pSettings)
	{
		var Settings = pSettings || {};
		var server = (typeof pServer === "string") ? W.Servers[W.MatchupCurrent.worlds[pServer]] : pServer;
		var serverstr, blstr;
		
		// If the server is actually an objective object
		var maptype = pServer["map_type"];
		if (maptype !== undefined)
		{
			var land = W.MapType[maptype];
			if (land === "center")
			{
				// EBG does not include server name, so just return it here
				return W.getNick("Center");
			}
			else
			{
				server = W.Servers[(W.MatchupCurrent.worlds[land])];
			}
		}
		
		// Get the full strings abbreviated or not
		serverstr = (Settings.aWantServerNick) ? D.getObjectNick(server) : D.getObjectName(server);
		blstr = (Settings.aWantBorderlandsNick) ? W.getNick("Borderlands") : W.getName("Borderlands");
		
		// Adjust to grammar
		if (Settings.aWantPronoun && server.owner === W.MatchupCurrent.oOwnerCurrent)
		{
			return W.getName("Our") + " " + blstr;
		}
		return D.orderModifier(blstr, serverstr);
	},
	
	/*
	 * Gets an objective's nick, or generate one if it has a direction property.
	 * @param pObject pObjective.
	 * @param boolean pFullDirection or false for abbreviated compass direction.
	 */
	getObjectiveNick: function(pObjective, pFullDirection)
	{
		// Example: "Northwest Camp", "East Keep"
		if (pObjective.direction !== undefined)
		{
			var dirstr = (pFullDirection) ? W.getName(pObjective.direction) : W.getNick(pObjective.direction);
			var typestr = W.getName(pObjective.type);
			return dirstr + " " + typestr;
		}
		// Example: "Garrison"
		else if (pObjective.alias !== undefined)
		{
			return W.getName(pObjective.alias);
		}
		// Example: "Stonemist", "Umberglade"
		return D.getObjectNick(pObjective);
	},
	
	/*
	 * Gets the image source for an objective.
	 * @param object pObjective.
	 * @param string pOwner of the objective (color).
	 * @returns string URL.
	 */
	getObjectiveImage: function(pObjective, pOwner)
	{
		var owner = pOwner || pObjective.owner;
		if (pObjective.type === W.ObjectiveEnum.Ruins)
		{
			return "img/wvw/ruins/" + (pObjective.direction + "_" + owner).toLowerCase() + I.cPNG;
		}
		if (pObjective.type === W.ObjectiveEnum.Bloodlust)
		{
			return "img/wvw/ruins/" + (pObjective.alias + "_" + owner).toLowerCase() + I.cPNG;
		}
		return "img/wvw/objectives/" + (pObjective.type + "_" + owner).toLowerCase() + I.cPNG;
	},
	
	/*
	 * Computes the summed values of objectives based on their map.
	 */
	computeObjectivesValue: function()
	{
		var objs = W.Metadata.ObjectiveType;
		var objval, uniqueval;
		for (var i in objs)
		{
			objval = objs[i].Value.Each;
			objs[i].Value.Borderlands = objs[i].Quantity.Borderlands * objval;
			objs[i].Value.Battlegrounds = objs[i].Quantity.Battlegrounds * objval;
			objs[i].Value.All = (objs[i].Value.Borderlands + objs[i].Value.Battlegrounds) * W.cOWNERS_PER_TIER;
			uniqueval = (objs[i].Quantity.isUnique) ? objval : 0;
			W.cTOTAL_PPT_POSSIBLE += objs[i].Value.All + uniqueval;
		}
	},
	
	/*
	 * Gets the points worth for an objective type.
	 * @param string pObjectiveType such as "Camp".
	 * @returns int value.
	 */
	getObjectiveTypeValue: function(pObjectiveName)
	{
		return W.Metadata.ObjectiveType[pObjectiveName].Value.Each;
	},
	
	/*
	 * Gets the tier number from the match id. Example "2-5" returns 5.
	 * @param object pData matchup from API.
	 * @returns int tier.
	 */
	getMatchupTier: function(pData)
	{
		var key = (W.isFallbackEnabled) ? "match_id" : "id";
		return parseInt((pData[key].split("-"))[1]);
	},
	
	/*
	 * Generates a list of servers for the user to choose from.
	 */
	generateServerList: function()
	{
		// Put the server objects into an array so they can be alphabetized according to language
		var servers = [];
		for (var i in W.Servers)
		{
			servers.push(W.Servers[i]);
		}
		U.sortObjects(servers);
		
		// Write the list
		var container = $("#wvwServerListContainer");
		var searchdb = [];
		servers.forEach(function(iServer)
		{
			searchdb.push({
				name: D.getObjectName(iServer) + ((iServer.suffix) ? " " + iServer.suffix : ""),
				icon: "img/ui/flags/" + ((iServer.suffix) ? U.stripToAlphanumeric(iServer.suffix).toLowerCase() : "na") + I.cPNG,
				id: iServer.id
			});
		});
		I.createSearchBar(container, {
			aBarID: "wvwServerListBar",
			aResultsClass: "wvwServerListResults",
			aIsSelect: true,
			aWantClose: true,
			aDatabase: searchdb,
			aFillerText: D.getPhraseOriginal("Select Server"),
			aCallback: function(pServer)
			{
				O.Options.enu_Server = pServer.id;
				localStorage["enu_Server"] = O.Options.enu_Server;
				// Update address bar
				U.updateQueryString("enu_Server=" + pServer.id);
				// Restart the system
				W.reinitializeServerChange();
			}
		});
		
		// Prevent map scroll from interfering when using the list
		I.preventMapPropagation(container);
	},
	
	/*
	 * Generates stats of all servers in a server region.
	 */
	initializeLeaderboard: function()
	{
		// Bind the window buttons
		$("#lboToggle").click(function()
		{
			$("#opt_bol_showLeaderboard").trigger("click");
		});
		$("#lboCondense").click(function()
		{
			$("#opt_bol_condenseLeaderboard").trigger("click");
		});
		$("#lboRegion").click(function()
		{
			W.toggleRegionLeaderboard();
		});
		$("#lboStats").click(function()
		{
			W.generateStats();
		});
		$("#lboOpaque").click(function()
		{
			$("#opt_bol_opaqueLeaderboard").trigger("click");
		});
		$("#lboCountdown").click(function()
		{
			U.openExternalURL(W.LeaderboardURL[W.LocaleCurrent]);
		});
		
		// Apply the leaderboard appearance options
		W.toggleLeaderboard();
		W.opaqueLeaderboard();
		W.toggleLeaderboardWidth();
		I.bindScrollbar("#lboOther");
	},
	
	/*
	 * Retrieves data for all servers in the region and generates a scoreboard
	 * for each.
	 */
	toggleRegionLeaderboard: function()
	{
		var lb = $("#lboOther");
		// Toggle by adding or emptying content
		if (lb.is(":empty") === false || W.LocaleCurrent === null)
		{
			lb.animate({height: 0}, "fast", function()
			{
				lb.empty().css({height: "auto"});
			});
			return;
		}
		
		var matchids = W.Metadata.MatchIDs[W.LocaleCurrent];
		// Gather data for all matches for current server region
		for (var i in matchids)
		{
			var matchid = matchids[i];
			var url = (W.isFallbackEnabled) ? (U.URL_API.MatchFallback + matchid) : (U.URL_API.Matches + matchid);
			var htmlid = "lboOther_" + matchid;
			
			// Skip the current matchup because it is already shown
			if (matchid === W.MatchupIDCurrent)
			{
				continue;
			}
			lb.append("<div id='" + htmlid + "'></div>");
			(function(iID, iMatchID)
			{
				$.getJSON(url, function(pData)
				{
					var ithmatch = (W.isFallbackEnabled) ? W.formatMatchup(W.Matches[iMatchID]) : W.formatMatchup(pData);
					W.insertScoreboard(pData, ithmatch, $("#" + iID));
					W.readjustLeaderboard();
					I.updateScrollbar("#lboOther");
				});
			})(htmlid, matchid);
		}
	},
	
	/*
	 * Inserts a matchup/tier scoreboard into the leaderboard.
	 * @param object pData from matches API.
	 * @param object pMatchup custom matchup converted from matches API.
	 * @param jqobject pContainer to insert the scoreboard in, optional.
	 */
	insertScoreboard: function(pData, pMatchup, pContainer)
	{
		// Converts a v1 style "scores" array to v2 style object if using fallback
		var convertScores = function(pScores)
		{
			if (W.isFallbackEnabled)
			{
				return { red: pScores[0], blue: pScores[1], green: pScores[2] };
			}
			return pScores;
		};
		var createScores = function()
		{
			return { red: 0, blue: 0, green: 0 };
		};
		
		/*
		 * Collate objective points from each borderlands.
		 */
		var matchupdata = pMatchup || W.MatchupCurrent;
		var map, obj, apiobj, landprefix, objid;
		var land, value, nativeowner;
		var numowners = W.Metadata.Owners.length;
		var tier = W.getMatchupTier(pData);
		var scores = convertScores(pData.scores);
		var victoryscores = pData.victory_points || createScores(); // Dummy score if using fallback
		var PPT = {};
		var wantserver = true;
		// Initialize variables for the temp object
		for (var i in W.Metadata.Owners)
		{
			var owner = W.Metadata.Owners[i];
			PPT[owner] = {};
			(PPT[owner]).Total = 0;
			(PPT[owner])[W.LandEnum.RedHome] = 0;
			(PPT[owner])[W.LandEnum.BlueHome] = 0;
			(PPT[owner])[W.LandEnum.GreenHome] = 0;
			(PPT[owner])[W.LandEnum.Center] = 0;
			for (var ii in W.Metadata.Owners) // The division of "native" land in EBG
			{
				(PPT[owner])[W.LandEnum.Center + (W.Metadata.Owners[ii])] = 0;
			}
		}
		// Assign the values
		for (var i in pData.maps)
		{
			map = pData.maps[i];
			landprefix = W.LandPrefix[map.type];
			for (var ii in map.objectives)
			{
				apiobj = map.objectives[ii];
				objid = (W.isFallbackEnabled) ? landprefix + apiobj.id : apiobj.id;
				obj = W.Objectives[objid];
				if (obj === undefined) // Ignore unknown objectives
				{
					continue;
				}
				owner = apiobj.owner;
				land = obj.map_type; // Example: "RedHome"
				value = W.getObjectiveTypeValue(obj.type);
				nativeowner = obj.nativeowner;
				if (owner !== W.OwnerEnum.Neutral)
				{
					(PPT[owner]).Total += value;
					(PPT[owner])[land] += value;
					if (land === W.LandEnum.Center)
					{
						// Example: In EBG, Red took objectives that were natively owned by Green's side, such as Lowlands
						(PPT[owner])[W.LandEnum.Center + nativeowner] += value;
					}
				}
			}
		}
		
		/*
		 * Decide appropriate container to insert the scoreboard.
		 */
		var lb;
		if (pContainer === undefined)
		{
			lb = $("#lboCurrent");
			lb.empty();
			if (I.ModeCurrent === I.ModeEnum.Overlay || I.isProgramEmbedded)
			{
				wantserver = false;
			}
		}
		else
		{
			lb = pContainer;
		}
		var html = "<section>";
		for (var i = 0; i < numowners; i++)
		{
			/*
			 * Prepare variables to be inserted into the HTML.
			 */
			var owner = W.Metadata.Owners[i]; // Example: "Green" as in data
			var ownerkey = owner.toLowerCase(); // Example: "green" as in match API
			var rank = ((tier - 1) * W.cOWNERS_PER_TIER) + (i+1);
			var serverstr = (wantserver) ? "<aside class='lboRank'>" + rank + ".</aside>"
				+ "<aside class='lboName'>&nbsp;" + matchupdata[ownerkey].oNameLinksStr + "</aside>" : "";
			var scorestr = "";
			var score = scores[ownerkey];
			var scorehighest = (T.getMinMax(scores)).oMax;
			var scorepercent = (scores[ownerkey] / scorehighest) * T.cPERCENT_100;
			var victoryscore = victoryscores[ownerkey];
			var victoryscorehighest = (T.getMinMax(victoryscores)).oMax;
			var victoryscorepercent = (victoryscores[ownerkey] / victoryscorehighest) * T.cPERCENT_100;
			var ppttotal = (PPT[owner]).Total;
			var pptpercent = (ppttotal / W.cTOTAL_PPT_POSSIBLE) * T.cPERCENT_100;
			// Kills and Deaths
			var kdstr = "";
			if (pData.kills !== undefined && W.isFallbackEnabled === false)
			{
				var kills = (pData.kills !== undefined) ? pData.kills[ownerkey] : "";
				var deaths = (pData.deaths !== undefined) ? pData.deaths[ownerkey] : "";
				var kdratio = T.parseRatio((kills / deaths), 2);
				var kdbl = "";
				// This constrains the ratio between 0% and 200%, where 100% means the kills and deaths numbers are equal
				var kdpercent = T.parseRatio(T.clampCeil(kills / deaths, 2) / 2) * T.cPERCENT_100;
				var blkills, bldeaths;
				pData.maps.forEach(function(iMap)
				{
					blkills = iMap.kills[ownerkey];
					bldeaths = iMap.deaths[ownerkey];
					kdbl += "<dfn>" + blkills + " : " + bldeaths + " (" + T.parseRatio((blkills / bldeaths), 2) + ")</dfn> on " + matchupdata[iMap.type] +  "<br />";
				});
				kdstr = "<aside class='lboKD' title='<dfn>Kills to Deaths ratio: " + kdratio + "</dfn><br />" + kdbl + "'>"
					+ "<var class='lboKills'>" + kills.toLocaleString() + "</var>"
					+ "<samp><s style='width:" + kdpercent + "%'><mark></mark></s></samp>"
					+ "<var class='lboDeaths'>" + deaths.toLocaleString() + "</var>"
				+ "</aside>";
			}
			
			/*
			 * Server Focus is PPT from ownership of non-native objectives (including EBG).
			 */
			var focuses = [];
			var scoredifferences = [];
			var victoryscoredifferences = [];
			var otherservers = [];
			for (var ii = 0; ii < numowners; ii++)
			{
				var otherowner = W.Metadata.Owners[ii];
				var otherownerkey = otherowner.toLowerCase();
				if (otherowner !== owner)
				{
					var focus = (PPT[owner])[otherowner + "Home"] + (PPT[owner])[W.LandEnum.Center + otherowner];
					focuses.push(focus);
					scoredifferences.push(score - scores[otherownerkey]);
					victoryscoredifferences.push(victoryscore - victoryscores[otherownerkey]);
					var otherserver = W.Servers[(matchupdata.worlds[otherownerkey])];
					otherservers.push(U.escapeHTML(D.getObjectName(otherserver)));
				}
			}
			var totalfocus = (focuses[0] + focuses[1]);
			var focusApercent, focusBpercent;
			var focusclass = "";
			if (totalfocus > 0)
			{
				focusApercent = Math.round((focuses[0] / totalfocus) * T.cPERCENT_100);
				focusBpercent = Math.round((focuses[1] / totalfocus) * T.cPERCENT_100);
			}
			else
			{
				focusApercent = 0;
				focusBpercent = 0;
				focusclass = "lboFocusZero";
			}
			
			/*
			 * Borderlands Focus is score from non-native borderlands (excluding EBG).
			 */
			var blscoreA, blscoreB;
			for (var ii in pData.maps)
			{
				var map = pData.maps[ii];
				var mapscores = convertScores(map.scores);
				switch (map.type)
				{
					case ((W.Metadata.Opposites[owner])[0] + "Home"): blscoreA = mapscores[ownerkey]; break;
					case ((W.Metadata.Opposites[owner])[1] + "Home"): blscoreB = mapscores[ownerkey]; break;
				}
			}
			var totalblscore = blscoreA + blscoreB;
			var blscoreApercent, blscoreBpercent;
			var blscoreclass = "";
			if (totalblscore > 0)
			{
				blscoreApercent = Math.round((blscoreA / totalblscore) * T.cPERCENT_100);
				blscoreBpercent = Math.round((blscoreB / totalblscore) * T.cPERCENT_100);
			}
			else
			{
				blscoreApercent = 0;
				blscoreBpercent = 0;
				blscoreclass = "lboFocusZero";
			}
			
			/*
			 * Format the bar graph differently for v1 and v2 matches data.
			 */
			if (W.isFallbackEnabled)
			{
				scorestr = "<aside class='lboScoreLegacy' title='<dfn>" + scoredifferences[0] + " points</dfn> away from " + otherservers[0]
				+ "<br /><dfn>" + scoredifferences[1] + " points</dfn> away from " + otherservers[1] + "'>"
					+ "<var>" + score.toLocaleString() + "</var>"
					+ "<samp><s style='width:" + scorepercent + "%'></s></samp>"
				+ "</aside>"
				+ "<aside class='lboPPTLegacy' title='<dfn>Points-Per-Tick (PPT)</dfn>'>"
					+ "<samp><s style='width:" + pptpercent + "%'></s></samp>"
					+ "<var>+" + ppttotal + "</var>"
				+ "</aside>";
			}
			else
			{
				scorestr = "<aside class='lboVictory' title='<dfn>" + victoryscoredifferences[0] + " points</dfn> away from " + otherservers[0]
				+ "<br /><dfn>" + victoryscoredifferences[1] + " points</dfn> away from " + otherservers[1] + "'>"
					+ "<var><img class='lboVictoryIcon' src='img/wvw/victorypoint.png' />" + victoryscore.toLocaleString() + "</var>"
					+ "<samp><s style='width:" + victoryscorepercent + "%'></s></samp>"
				+ "</aside>"
				+ "<aside class='lboPPT' title='<dfn>Points-Per-Tick (PPT)</dfn>'>"
					+ "<samp><s style='width:" + pptpercent + "%'></s></samp>"
					+ "<var>+" + ppttotal + "</var>"
				+ "</aside>";
			}
			
			/*
			 * Write the HTML.
			 */
			html += "<article class='lboServer lboServer" + owner + "'>"
				+ serverstr
				+ scorestr
				+ "<aside class='lboLand' title='<dfn>PPT per borderlands</dfn>'>"
					+ "<var class='lboPPTGreen'>+" + (PPT[owner])[W.LandEnum.GreenHome] + "</var>"
					+ "<var class='lboPPTBlue'>+" + (PPT[owner])[W.LandEnum.BlueHome] + "</var>"
					+ "<var class='lboPPTRed'>+" + (PPT[owner])[W.LandEnum.RedHome] + "</var>"
					+ "<var class='lboPPTCenter'>+" + (PPT[owner])[W.LandEnum.Center] + "</var>"
				+ "</aside>"
				+ kdstr
				+ "<aside class='lboFocus lboFocus" + owner + "' title='<dfn>Server Focus (PPT Now)</dfn><br />"
						+ "<dfn>" + focuses[0] + " PPT</dfn> earnable from " + otherservers[0] + " native objectives<br />"
						+ "<dfn>" + focuses[1] + " PPT</dfn> earnable from " + otherservers[1] + " native objectives'>"
					+ "<var class='lboFocusA'>" + focusApercent + "%</var>"
					+ "<samp class='" + focusclass + "'><s style='width:" + focusApercent + "%'><mark></mark></s></samp>"
					+ "<var class='lboFocusB'>" + focusBpercent + "%</var>"
				+ "</aside>"
				+ "<aside class='lboFocus lboFocus" + owner + "' title='<dfn>Server Focus (Points Matchup)</dfn><br />"
						+ "<dfn>" + blscoreA + " points</dfn> earned from " + otherservers[0] + " Borderlands<br />"
						+ "<dfn>" + blscoreB + " points</dfn> earned from " + otherservers[1] + " Borderlands'>"
					+ "<var class='lboFocusA'>" + blscoreApercent + "%</var>"
					+ "<samp class='" + blscoreclass + "'><s style='width:" + blscoreApercent + "%'><mark></mark></s></samp>"
					+ "<var class='lboFocusB'>" + blscoreBpercent + "%</var>"
				+ "</aside>"
			+ "</article>";
		}
		html += "</section>";
		
		lb.append(html);
		I.qTip.init(lb.find("aside, a"));
		
		if (O.Options.bol_condenseLeaderboard)
		{
			W.toggleLeaderboardWidth();
		}
	},
	
	/*
	 * Toggles the leaderboard display.
	 */
	toggleLeaderboard: function()
	{
		if (O.Options.bol_showLeaderboard)
		{
			W.updateObjectives();
			$("#lboCurrent, #lboOther").show("fast", function()
			{
				$("#lboContainer").css({padding: ((I.ModeCurrent === I.ModeEnum.Overlay) ? 0 : 8) + "px"});
			});
			$(".lboExtra").show();
		}
		else
		{
			$("#lboCurrent, #lboOther").hide("fast", function()
			{
				$("#lboContainer").css({padding: 0});
			});
			$(".lboExtra").hide();
		}
	},
	opaqueLeaderboard: function()
	{
		I.toggleHUDOpacity("#lboContainer", "lbo", O.Options.bol_opaqueLeaderboard);
	},
	
	/*
	 * Condenses the leaderboard or revert it.
	 */
	toggleLeaderboardWidth: function(pWantAnimate)
	{
		var isshown = !O.Options.bol_condenseLeaderboard;
		var elms = $(".lboRank, .lboLand, .lboFocus");
		if (pWantAnimate)
		{
			if (isshown)
			{
				elms.show("fast");
			}
			else
			{
				elms.hide("fast");
			}
		}
		else
		{
			elms.toggle(isshown);
		}
	},
	readjustLeaderboard: function()
	{
		$("#lboOther").css({maxHeight: $(window).height() - $("#lboCurrent").height() * 2});
	},
	
	/*
	 * Binds the button to print the WvW stats of servers one by one.
	 */
	generateStats: function()
	{
		if (I.isConsoleShown())
		{
			return;
		}
		I.print(I.cThrobber, true);
		E.updateCoinInGem(function()
		{
			$.getJSON(U.getAPI("worlds", true), function(pData)
			{
				// Sort by population
				pData.forEach(function(iWorld)
				{
					iWorld.sortablePopulation = W.Metadata.PopulationPercent[iWorld.population];
				});
				U.sortObjects(pData, {aKeyName: "sortablePopulation", aIsDescending: true});
				// Generate table
				var html = "<table id='wvwStats' class='cssStats'>";
				html += "<thead><tr>"
					+ "<th>Server</th>"
					+ "<th>ID</th>"
					+ "<th>Population</th>"
					+ "<th>Transfer</th>"
					+ "<th>Conversion</th>"
				+ "</tr></thead><tbody>";
				pData.forEach(function(iWorld)
				{
					// Only insert server if it is in the same locale as the user's selected server
					if (iWorld.id.toString().charAt(0) === W.LocaleThreshold[W.LocaleCurrent + "Prefix"])
					{
						var servername = U.escapeHTML(D.getObjectName(W.Servers[iWorld.id]));
						var transfercost = W.Metadata.PopulationTransfer[iWorld.population];
						html += "<tr>"
							+ "<td><a class='wvwStatsLink wvwPopulation_" + U.escapeHTML(iWorld.population)
								+ "' href='?page=WvW&enu_Server=" + iWorld.id + "'>" + servername + "</a></td>"
							+ "<td>" + iWorld.id + "</td>"
							+ "<td>" + I.getBar(W.Metadata.PopulationPercent[iWorld.population]) + "</td>"
							+ "<td>" + E.formatGemString(transfercost, true) + "</td>"
							+ "<td>" + E.formatGemToCoin(transfercost) + "</td>"
						+ "</tr>";
					}
				});
				html += "</tbody></table>";
				I.print(html, true);
			});
		});
	},
	
	/*
	 * Writes the base HTML of the capture history log.
	 */
	initializeLog: function()
	{
		// Initialize element properties
		$("#wvwLogContainer").show();
		$("#logWindow").data("oldHeight", $("#logWindow").height());
		
		// Bind the window buttons
		$("#logToggle").click(function()
		{
			$("#opt_bol_showLog").trigger("click");
		});
		$("#logExpand").click(function()
		{
			$("#opt_bol_maximizeLog").trigger("click");
		});
		$("#logOpaque").click(function()
		{
			$("#opt_bol_opaqueLog").trigger("click");
		});
		// Apply the log appearance options
		W.toggleLog(true);
		W.opaqueLog();
		W.toggleLogHeight();
		I.bindScrollbar("#logWindow");
		I.loadImg($("#wvwLog"));
		O.mimicInput("#wvwZoomInput", "int_setInitialZoomWvW");
		
		// Bind the checkboxes to filter log entries
		for (var i in W.MapType)
		{
			(function(iFilter)
			{
				$("#opt_bol_log" + iFilter).change(function()
				{
					if (O.Options["bol_log" + iFilter])
					{
						$(".logEntry" + iFilter).show("fast", function() { I.updateScrollbar("#logWindow"); });
					}
					else
					{
						$(".logEntry" + iFilter).hide("fast", function() { I.updateScrollbar("#logWindow"); });
					}
				}).parent().dblclick(function()
				{
					// If double clicked the checkbox, then uncheck all the others except itself
					$("#logFilters input:checkbox").each(function()
					{
						X.setCheckboxEnumState($(this), X.ChecklistEnum.Unchecked);
					});
					X.setCheckboxEnumState($("#opt_bol_log" + iFilter), X.ChecklistEnum.Checked);
				});
			})(i);
		}
		
		// Label the narration filters
		var blstr = W.getName("Borderlands");
		X.relabelCheckbox("#opt_bol_narrateRedHome", D.orderModifier(blstr, W.getName("Red")));
		X.relabelCheckbox("#opt_bol_narrateBlueHome", D.orderModifier(blstr, W.getName("Blue")));
		X.relabelCheckbox("#opt_bol_narrateGreenHome", D.orderModifier(blstr, W.getName("Green")));
		X.relabelCheckbox("#opt_bol_narrateCenter", W.getName("Center"));
		X.relabelCheckbox("#opt_bol_narrateRuins", W.getName("Ruins"));
		X.relabelCheckbox("#opt_bol_narrateCamp", W.getName("Camp"));
		X.relabelCheckbox("#opt_bol_narrateTower", W.getName("Tower"));
		X.relabelCheckbox("#opt_bol_narrateKeep", W.getName("Keep"));
		X.relabelCheckbox("#opt_bol_narrateCastle", W.getName("Castle"));
		X.relabelCheckbox("#opt_bol_narrateClaimed", W.getName("Claimed"));
		
		// Mimic the master volumn slider
		I.preventMapPropagation(O.mimicInput("#logNarrateVolume", "int_setVolume"));
		O.Enact.bol_logNarrate();
		
		// Bind local time clock
		$("#logTime").click(function()
		{
			$("#opt_bol_use24Hour").trigger("click");
			// Update the timestamps of the log entries
			$("#logWindow li time").each(function()
			{
				var timestr = T.getTimeFormatted({aCustomTimeInDate: new Date($(this).attr("data-time"))}); 
				$(this).html(timestr);
			});
		});
		
		// Pause button
		$("#wvwPause").click(function()
		{
			W.isWvWPaused = !W.isWvWPaused;
			if (W.isWvWPaused)
			{
				W.addLogEntry("WvW updating paused.");
				D.stopSpeech();
			}
			else
			{
				W.addLogEntry("WvW updating resumed.");
				W.updateObjectives();
			}
		});
	},
	
	/*
	 * Toggles the log display.
	 */
	toggleLog: function(pIsInitial)
	{
		I.toggleElement("#wvwLog, .logExtra", O.Options.bol_showLog, "fast", pIsInitial);
	},
	opaqueLog: function()
	{
		I.toggleHUDOpacity("#wvwLog", "log", O.Options.bol_opaqueLog);
	},
	
	/*
	 * Adjusts the log window height.
	 */
	toggleLogHeight: function()
	{
		var log = $("#logWindow");
		var windowheight = $(window).height();
		var oldheight = log.data("oldHeight");
		var newheight = windowheight - ((I.ModeCurrent === I.ModeEnum.Overlay) ? 164 : 210); // Just enough to snap with the leaderboard

		if (O.Options.bol_maximizeLog)
		{
			log.show().animate({height: newheight}, 200, function()
			{
				I.updateScrollbar(log);
				O.Options.bol_maximizeLog = true;
			});
		}
		else
		{
			log.show().animate({height: oldheight}, 200, function()
			{
				I.updateScrollbar(log);
				O.Options.bol_maximizeLog = false;
			});
		}
	},
	
	/*
	 * Resizes the log if the browser window covers it.
	 */
	readjustLog: function()
	{
		if ($("#wvwLog").height() > $(window).height())
		{
			$("#logExpand").trigger("click").trigger("click");
		}
	},
	
	/*
	 * Adds an entry to the WvW log.
	 * @param string pString to insert.
	 * @param string pClass of the log entry, such as the map the event happened in.
	 * @param string pISOTime of the event, optional
	 * @param boolean pIsDisplayed whether shown initially.
	 */
	addLogEntry: function(pString, pClass, pISOTime, pIsDisplayed)
	{
		pString = pString || "";
		pClass = pClass || "";
		var timestr = "";
		if (pISOTime === undefined)
		{
			timestr = T.getTimeFormatted();
			pISOTime = (new Date()).toISOString();
		}
		else
		{
			timestr = T.getTimeFormatted({aCustomTimeInDate: new Date(pISOTime)});
		}
		var entry = $("<li class='logEntry " + pClass + "'><time data-time='" + pISOTime + "'>" + timestr + "</time><span>" + pString + "</span></li>")
			.prependTo("#logWindow");
		this.bindMapLinkBehavior(entry.find("dfn"));
		
		// Animate the new entry
		if (pIsDisplayed === false)
		{
			entry.hide();
		}
		else
		{
			var width = entry.width();
			entry.css({width: 0}).animate({width: width}, 400, function()
			{
				$(this).removeAttr("style");
			});
		}
		
		// Delete an old entry if over max limit
		var entries = $(".logEntry");
		if (entries.length > O.Options.int_numLogEntries)
		{
			entries.last().remove();
		}
		I.updateScrollbar("#logWindow");
	},
	
	/*
	 * Adds an entry pertaining to objectives.
	 * @param object pObjective.
	 * @param boolean pIsClaim if it is an objective claim, optional.
	 */
	addLogEntryObjective: function(pObjective, pIsClaim)
	{
		var prevobjectiveicon = "<img src='" + W.getObjectiveImage(pObjective, pObjective.prevowner) + "' />";
		var objectiveicon = "<img src='" + W.getObjectiveImage(pObjective, pObjective.owner) + "' />";
		var objectivenick = W.getObjectiveNick(pObjective, false);
		
		// Claiming shows the guild tag instead of the previous objective icon
		var isotime;
		if (pIsClaim)
		{
			prevobjectiveicon = objectiveicon;
			objectiveicon = "<cite>" + pObjective.oTag + "</cite>";
			isotime = pObjective.claimed_at;
		}
		else
		{
			isotime = pObjective.last_flipped;
		}
		var str = prevobjectiveicon + " ⇒ " + objectiveicon + " <dfn data-coord='" + pObjective.coord + "'>" + objectivenick + "</dfn>";
		var land = pObjective.map_type;
		var cssclass = "logEntry" + land;
		if ( ! pIsClaim)
		{
			pObjective.prevownerhtml = str;
		}
		
		// The entry will be added, but only shown if opted
		var isdisplayed = true;
		if ((land === W.LandEnum.RedHome && O.Options.bol_logRedHome === false)
			|| (land === W.LandEnum.BlueHome && O.Options.bol_logGreenHome === false)
			|| (land === W.LandEnum.GreenHome && O.Options.bol_logBlueHome === false)
			|| (land === W.LandEnum.Center && O.Options.bol_logCenter === false))
		{
			isdisplayed = false;
		}
		W.addLogEntry(str, cssclass, isotime, isdisplayed);
		
		// Narrate the capture event if opted
		if (O.Options.bol_logNarrate)
		{
			W.narrateLog(pObjective, pIsClaim);
		}
	},
	
	/*
	 * Speaks the objective that was captured and the capturer.
	 * @param object pObjective.
	 * @param boolean pIsClaim if it is an objective claim, optional.
	 */
	narrateLog: function(pObjective, pIsClaim)
	{
		// Do not proceed if does not pass the opted filters
		var land = pObjective.map_type;
		var type = pObjective.type;
		if ((pIsClaim && O.Options.bol_narrateClaimed === false)
			|| (land === W.LandEnum.RedHome && O.Options.bol_narrateRedHome === false)
			|| (land === W.LandEnum.BlueHome && O.Options.bol_narrateBlueHome === false)
			|| (land === W.LandEnum.GreenHome && O.Options.bol_narrateGreenHome === false)
			|| (land === W.LandEnum.Center && O.Options.bol_narrateCenter === false)
			|| (type === W.ObjectiveEnum.Bloodlust && O.Options.bol_narrateRuins === false)
			|| (type === W.ObjectiveEnum.Ruins && O.Options.bol_narrateRuins === false)
			|| (type === W.ObjectiveEnum.Camp && O.Options.bol_narrateCamp === false)
			|| (type === W.ObjectiveEnum.Tower && O.Options.bol_narrateTower === false)
			|| (type === W.ObjectiveEnum.Keep && O.Options.bol_narrateKeep === false)
			|| (type === W.ObjectiveEnum.Castle && O.Options.bol_narrateCastle === false))
		{
			return;
		}
		
		var objstr = W.getObjectiveNick(pObjective, true);
		var ownerstr;
		if (pIsClaim)
		{
			ownerstr = D.getSpeechInitials(pObjective.oTagInitial);
		}
		else if (pObjective.owner === W.MatchupCurrent.oOwnerCurrent)
		{
			ownerstr = W.getName("Us");
		}
		else
		{
			ownerstr = D.getSpeechInitials(D.getObjectNick(W.getTeamFromOwner(pObjective.owner).oHost));
		}
		// Only include the borderlands string if user opted for more than one land filter
		var blstr = ($("#logNarrateLand input:checked").length > 1) ? (W.getBorderlandsString(pObjective, {aWantPronoun: true}) + ". ") : "";
		var verbstr;
		if (pIsClaim)
		{
			verbstr = W.getName("Claimed");
		}
		else if (pObjective.owner === pObjective.nativeowner)
		{
			verbstr = W.getName("Retaken");
		}
		else
		{
			verbstr = W.getName("Captured");
		}
		
		// Separated to two speeches so the pause is longer
		var speech1 = blstr + objstr;
		var speech2 = verbstr + " " + ownerstr;
		D.speak(speech1);
		D.speak(speech2);
	},
	
	/*
	 * Generates the siege supply calculator.
	 */
	initializeSupplyCalculator: function()
	{
		var addSupply = function(pElement, pSupply)
		{
			var blcount = pElement.html();
			// Blank blueprint count means 0 blueprints requested
			blcount = (blcount === "") ? 0 : parseInt(blcount);
			if (pSupply < 0 && blcount === 0)
			{
				return;
			}
			var increment = (pSupply < 0) ? -1 : 1;

			W.numSiegeSupply += pSupply;
			$("#splNeed").html(W.numSiegeSupply);
			// If after increment the blueprint count is 0, then make it blank
			var finalblcount = blcount + increment;
			if (finalblcount === 0)
			{
				pElement.removeClass("splAdded");
				finalblcount = "";
			}
			else
			{
				pElement.addClass("splAdded");
			}
			pElement.html(finalblcount);
		};
		
		I.preventMapPropagation("#wvwSupply");
		for (var i in W.Metadata.BlueprintGrade)
		{
			for (var ii in W.Metadata.BlueprintType)
			{
				var grade = W.Metadata.BlueprintGrade[i];
				var blueprint = $("<ins class='spl spl_" + grade.toLowerCase() + "_" + ii + "'></ins>");
				var supply = (W.Metadata.BlueprintType[ii])[i];
				$("#splBlueprints" + grade).append(blueprint);
				(function(iSupply)
				{
					blueprint.click(function()
					{
						addSupply($(this), iSupply);
						$("#splHave").trigger("input");
					});
					blueprint.contextmenu(function()
					{
						addSupply($(this), -1 * iSupply);
						$("#splHave").trigger("input");
						return false; // Prevents context menu popping up
					});
				})(supply);
			}
		}
		
		// Bind reset button
		$("#splReset").click(function()
		{
			$("#splBlueprints ins").html("").removeClass("splAdded");
			$("#splNeed").html("0");
			W.numSiegeSupply = 0;
			$("#splHave").trigger("input");
		});
		
		// Bind supply have input
		$("#splHave").click(function()
		{
			$(this).select();
		}).on("input", function()
		{
			var value = T.parseQuantity($(this).val(), 0) - W.numSiegeSupply;
			var elm = $("#splRemain").html(value);
			I.colorizeValue(elm, value);
		});
	},
	
	/*
	 * Updates the server names for the current match wherever it is shown.
	 */
	updateParticipants: function()
	{
		if (W.MatchupCurrent !== null)
		{
			// Log server borderlands names
			X.relabelCheckbox("#opt_bol_logRedHome", W.MatchupCurrent["red"].oNameStr);
			X.relabelCheckbox("#opt_bol_logBlueHome", W.MatchupCurrent["blue"].oNameStr);
			X.relabelCheckbox("#opt_bol_logGreenHome", W.MatchupCurrent["green"].oNameStr);
			X.relabelCheckbox("#opt_bol_logCenter", W.getName("Center"));
			
			// Compass zone links borderlands names
			$("#wvwZoneLinkRed").html(W.MatchupCurrent["red"].oNameStr);
			$("#wvwZoneLinkBlue").html(W.MatchupCurrent["blue"].oNameStr);
			$("#wvwZoneLinkGreen").html(W.MatchupCurrent["green"].oNameStr);
			
			// Initial messages in the log window
			W.addLogEntry($("#wvwHelpLinks").html() + "<br /><br /><br />");
			W.addLogEntry(W.MatchupCurrent["green"].oNickStr + " : " + W.MatchupCurrent["blue"].oNickStr + " : " + W.MatchupCurrent["red"].oNickStr);
			
			// Update map spawn labels
			$(".wvwSpawnContainer").each(function()
			{
				var owner = $(this).attr("data-owner").toLowerCase();
				var label = W.MatchupCurrent[owner].oNameLinesStr;
				$(this).find(".wvwSpawnLabel").html(label);
			});
		}
	},
	
	/*
	 * Resets objective properties and updates the objectives.
	 * @param boolean pWipeLog;
	 */
	reinitializeServerChange: function(pWipeLog)
	{
		// Initialize properties to be later compared within the API
		for (var i in W.Objectives)
		{
			var obj = W.Objectives[i];
			obj.isImmune = false; // Boolean if is recently captured
			obj.owner = null; // String owner
			obj.last_flipped = null; // String ISO time
			obj.last_flipped_msec = null; // Integer
			obj.claimed_by = "none"; // String guild ID, the API can have actual "null" values
			obj.claimed_at = null; // String ISO time
			obj.prevownerhtml = null; // HTML created from log entry after ownership change
		}
		W.LocaleCurrent = (O.Options.enu_Server >= W.LocaleThreshold.Europe)
			? W.LocaleEnum.Europe : W.LocaleEnum.Americas;
		W.MatchupIDCurrent = null;
		W.MatchStartTimeMS = null;
		W.MatchFinishTimeMS = null;
		W.MatchFinishTimeISO = null;
		W.MatchupCurrent = null;
		$(".objUmbrellaContainer").hide();
		$(".objTimer").empty();
		$(".objProgressBar").hide();
		$("#lboCurrent").empty().append(I.cThrobber);
		$("#lboOther").empty();
		if (pWipeLog !== false)
		{
			$("#logWindow").empty();
		}
		
		// Stop the previous timeout and call the update function with initialization
		W.toggleObjectiveTick(false);
		W.toggleObjectiveTick(true);
	},
	
	/*
	 * Checks for changes in the match API data and updates objectives state.
	 */
	updateObjectives: function()
	{
		if (W.isWvWPaused)
		{
			return;
		}
		var timedb = {};
		var fliptime;
		var fliptimenumduplicate = 0;
		var fliptimeignore = null;
		var maxattemptsuntilfallback = 3;
		var maxduplicatefliptime = 18; // Number of non-neutral objectives in the borderlands during reset
		var now = new Date();
		var nowmsec = now.getTime();
		var succeedReconnection = function()
		{
			W.numFailedAPICalls = 0;
			W.isAPIFailed = false;
			W.isFallbackEnabled = false;
			I.write("WvW data connection reestablished at " + T.getTimeFormatted());
		};
		if (W.isFallbackEnabled)
		{
			W.updateObjectivesFallback();
		}
		
		// Attempt to retrieve objectives data
		U.getJSON(U.URL_API.Match + O.Options.enu_Server, function(pData)
		{
			if (W.isFallbackEnabled)
			{
				succeedReconnection();
				W.reinitializeServerChange(false);
				return;
			}
			var map, obj, apiobj;
			var numobjflipped = 0;
			var maxobjflipped = 16;
			var istoomanyflips = false;
			
			// Initialize stagnant variables once
			if (W.MatchFinishTimeISO !== pData.end_time)
			{
				var relinkdate = W.getWorldRelink(new Date(pData.end_time));
				var timetillrelink = relinkdate.getTime() - nowmsec;
				W.MatchFinishTimeISO = pData.end_time;
				W.MatchStartTimeMS = (new Date(pData.start_time)).getTime();
				W.MatchFinishTimeMS = (new Date(pData.end_time)).getTime();
				W.secTillWvWReset = ~~((W.MatchFinishTimeMS - nowmsec) / T.cMSECONDS_IN_SECOND);
				W.MatchupIDCurrent = pData.id;
				W.MatchupCurrent = W.formatMatchup(pData);
				W.updateParticipants();
				W.addLogEntry("Next server relink: " + T.formatLocal(relinkdate, {year: "numeric", month: "numeric", day: "numeric"})
					+ " (" + T.formatMilliseconds(timetillrelink) + ")");
			}
			
			// Update scoreboard
			if (O.Options.bol_showLeaderboard)
			{
				W.insertScoreboard(pData);
			}
			
			// First iteration to see if the objectives are resetted (all having the same flipped time)
			for (var i in pData.maps)
			{
				map = pData.maps[i];
				for (var ii in map.objectives)
				{
					fliptime = map.objectives[ii].last_flipped;
					if (timedb[fliptime] === undefined)
					{
						timedb[fliptime] = 0;
					}
					timedb[fliptime] += 1;
					if (timedb[fliptime] > fliptimenumduplicate)
					{
						fliptimenumduplicate = timedb[fliptime];
						if (fliptimenumduplicate > maxduplicatefliptime)
						{
							fliptimeignore = fliptime;
						}
					}
				}
			}
			
			// Update objectives
			for (var i in pData.maps)
			{
				map = pData.maps[i];
				for (var ii in map.objectives)
				{
					apiobj = map.objectives[ii];
					obj = W.Objectives[apiobj.id];
					if (obj === undefined) // Ignore unknown objectives
					{
						continue;
					}
					/*
					 * Only update the objectives if they have changed server ownership.
					 */
					if (obj.last_flipped !== apiobj.last_flipped)
					{
						if (obj.last_flipped !== null)
						{
							numobjflipped++;
						}
						// Reinitialize properties
						obj.last_flipped = apiobj.last_flipped;
						obj.last_flipped_msec = (new Date(apiobj.last_flipped)).getTime();
						obj.prevowner = obj.owner;
						obj.owner = apiobj.owner;
						obj.data = apiobj;
						W.updateObjectiveIcon(obj);
						W.updateObjectiveAge(obj);
						W.updateObjectiveTooltip(obj);

						// Mark the objective as immune if it is recently captured
						if ((nowmsec - obj.last_flipped_msec) < W.cMSECONDS_IMMUNITY
								&& obj.owner !== W.OwnerEnum.Neutral // Neutral objectives never have immunity
								&& obj.type !== W.ObjectiveEnum.Ruins) // Ruins do not have immunity
						{
							/*
							 * During reset or API server problems, numerous objectives may have the same last flipped timestamp,
							 * so ignore those objectives.
							 */
							if (fliptimeignore === null || ((fliptimeignore !== null) && (fliptimeignore !== obj.last_flipped)))
							{
								W.Objectives[obj.id].isImmune = true;
								$("#objProgressBar_" + obj.id).show().find("var").css({width: "0%"}).animate({width: "100%"}, 800);
							}
						}
					}
					/*
					 * Only update guild tag labels if claiming has changed.
					 */
					if (obj.claimed_by !== apiobj.claimed_by)
					{
						obj.prevclaimed_by = obj.claimed_by;
						obj.claimed_by = apiobj.claimed_by;
						obj.claimed_at = apiobj.claimed_at;
						W.updateObjectiveClaim(obj);
					}
					// If these many objectives flipped after an update then there might be an error with the API
					if (numobjflipped > maxobjflipped)
					{
						istoomanyflips = true;
						break;
					}
				}
				if (numobjflipped > maxobjflipped)
				{
					istoomanyflips = true;
					break;
				}
				
				// Update bloodlust, must simulate API structure of objective because bloodlust do not
				var apiobjowner = (map.bonuses && map.bonuses.length) ? map.bonuses[0].owner : W.OwnerEnum.Neutral;
				var landnick = W.Rotation[map.type];
				obj = W.Objectives[landnick + "_" + "bloodlust"];
				if (obj && obj.owner !== apiobjowner)
				{
					obj.last_flipped = nowmsec;
					obj.last_flipped_msec = nowmsec;
					obj.prevowner = obj.owner;
					obj.owner = apiobjowner;
					obj.claimed_by = null;
					W.updateObjectiveIcon(obj);
					W.updateObjectiveTooltip(obj);
				}
			}
			
			// Check for errors
			if (istoomanyflips)
			{
				D.stopSpeech();
				W.reinitializeServerChange(false);
				W.addLogEntry("Restarted due to API error.");
				I.write("Too many objectives updated. ArenaNet API server may be having problems.");
			}
			if (W.isAPIFailed)
			{
				succeedReconnection();
			}
		}, false).fail(function()
		{
			if (W.isFallbackEnabled === false)
			{
				W.numFailedAPICalls++;
				if (W.numFailedAPICalls > maxattemptsuntilfallback)
				{
					W.isFallbackEnabled = true;
					W.updateObjectives();
					I.print("<br />Too many failed API retrievals. Switched to backup API server.<br />"
						+ "If problem persists, please consult <a" + U.convertExternalAnchor(U.URL_API.Support + "?source=wvw") + ">ArenaNet API forum</a> for status updates.");
				}
				else
				{
					if (W.isAPIFailed === false)
					{
						W.isAPIFailed = true;
						// If failed near reset then tell so, otherwise generic error
						var errormessage = (W.secTillWvWReset !== null && W.secTillWvWReset < 10 * T.cSECONDS_IN_MINUTE)
							? "WvW reset is happening soon." : "The map will refresh automatically when ArenaNet servers are back online.";
						I.print("Unable to retrieve WvW data during " + T.getTimeFormatted() + ". Please wait...<br />" + errormessage);
					}
				}
			}
		});
	},
	
	/*
	 * Converts a v1 API matches.json match object to a v2 API worlds object.
	 * @param object pMatch.
	 * @returns object worlds.
	 */
	convertWorlds: function(pMatch)
	{
		return {
			red: pMatch.red_world_id,
			blue: pMatch.blue_world_id,
			green: pMatch.green_world_id
		};
	},
	
	/*
	 * Uses the v1 API to get objectives state. Reconstructs data as v2 API
	 * style objects so they can be reused.
	 */
	updateObjectivesFallback: function()
	{
		var now = new Date();
		var nowiso = now.toISOString();
		var nowmsec = now.getTime();
		// First find the matchup for the selected server
		if (W.MatchupIDCurrent === null || W.Matches === null)
		{
			U.getJSON(U.URL_API.MatchesFallback, function(pData)
			{
				if (W.isFallbackEnabled === false)
				{
					return;
				}
				W.Matches = {};
				for (var i in pData.wvw_matches)
				{
					var match = pData.wvw_matches[i];
					var serverid = parseInt(O.Options.enu_Server);
					W.Matches[match.wvw_match_id] = match;
					// Execute this function again now that the match ID is found
					if (match.red_world_id === serverid
						|| match.blue_world_id === serverid
						|| match.green_world_id === serverid)
					{
						W.MatchupIDCurrent = match.wvw_match_id;
						W.MatchStartTimeMS = (new Date(pData.start_time)).getTime();
						W.MatchFinishTimeMS = (new Date(pData.end_time)).getTime();
						W.secTillWvWReset = ~~((W.MatchFinishTimeMS - nowmsec) / T.cMSECONDS_IN_SECOND);
						// Initialize matchup data
						W.MatchupCurrent = W.formatMatchup(W.Matches[W.MatchupIDCurrent]);
						W.updateParticipants();
						W.updateObjectivesFallback();
					}
				}
			}, false);
		}
		else
		{
			U.getJSON(U.URL_API.MatchFallback + W.MatchupIDCurrent, function(pData)
			{
				if (W.isFallbackEnabled === false)
				{
					return;
				}
				var map, obj, apiobj, landprefix;
				var pastfar = new Date(nowmsec - W.cMSECONDS_IMMUNITY);
				var pastnear = new Date(nowmsec - (O.Options.int_secWvWRefresh * T.cMSECONDS_IN_SECOND));
				for (var i in pData.maps)
				{
					map = pData.maps[i];
					landprefix = W.LandPrefix[map.type];
					for (var ii in map.objectives)
					{
						apiobj = map.objectives[ii];
						obj = W.Objectives[landprefix + apiobj.id];
						if (obj === undefined) // Ignore unknown objectives
						{
							continue;
						}
						/*
						 * Only update the objectives if they have changed server ownership.
						 */
						var past = (obj.owner === null) ? pastfar : pastnear;
						if (obj.owner !== apiobj.owner)
						{
							// Reinitialize properties
							obj.last_flipped = past.toISOString();
							obj.last_flipped_msec = past.getTime();
							obj.prevowner = obj.owner;
							obj.owner = apiobj.owner;
							W.updateObjectiveIcon(obj);
							W.updateObjectiveAge(obj);
							W.updateObjectiveTooltip(obj);

							// Mark the objective as immune if it is recently captured
							if ((nowmsec - obj.last_flipped_msec) < W.cMSECONDS_IMMUNITY
									&& obj.owner !== W.OwnerEnum.Neutral) // If it is owned by Neutral (no immunity) then it is WvW reset
							{
								W.Objectives[obj.id].isImmune = true;
								$("#objProgressBar_" + obj.id).show().find("var").css({width: "0%"}).animate({width: "100%"}, 800);
							}
						}
						/*
						 * Only update guild tag labels if claiming has changed.
						 */
						if (obj.claimed_by !== apiobj.owner_guild)
						{
							obj.prevclaimed_by = obj.claimed_by;
							obj.claimed_by = apiobj.owner_guild;
							obj.claimed_at = nowiso;
							W.updateObjectiveClaim(obj);
						}
					}
				}

				// Update scoreboard
				if (O.Options.bol_showLeaderboard)
				{
					W.insertScoreboard(pData);
				}
			}, false);
		}
	},
	
	/*
	 * Refreshes the objective's icon, which is also its color, to the current owner.
	 * @param object pObjective.
	 */
	updateObjectiveIcon: function(pObjective)
	{
		// Update objective visuals
		var animationspeed = 2000;
		var objumbrella = $("#objUmbrella_" + pObjective.id); // A big circle over the objective icon
		var objicon = $("#objIcon_" + pObjective.id);
		var prevwidth = objicon.css("width");

		// If the objective is being reassigned from a known previous owner
		if (pObjective.prevowner !== null && pObjective.owner !== W.OwnerEnum.Neutral)
		{
			var prevcolor = W.Metadata[pObjective.prevowner].color;
			var color = W.Metadata[pObjective.owner].color;
			objumbrella.parent().parent().show(); // Show the umbrella container
			// Color the umbrella notification circle and blink it
			objumbrella.css({borderColor: prevcolor, boxShadow: "0px 0px 10px " + prevcolor});
			I.bloatElement(objumbrella, 1000, 100);
			// Squash the icon to 0 width, then change the icon image and stretch it back to previous width
			(function(iOwner, iUmbrella, iColor)
			{
				objicon.css({width: prevwidth}).animate({width: 0}, animationspeed, function()
				{
					iUmbrella.css({borderColor: iColor, boxShadow: "0px 0px 10px " + iColor});
					$(this).attr("src", W.getObjectiveImage(pObjective))
						.animate({width: prevwidth}, animationspeed, function()
						{
							iUmbrella.parent().parent().hide();
							W.adjustZoomMapping();
						});
				});
			})(pObjective.owner, objumbrella, color);
			// Log the change of ownership
			W.addLogEntryObjective(pObjective);
		}
		else
		{
			// If it is the first initialization (no previous known owner), then just assign the icons
			objicon.attr("src", W.getObjectiveImage(pObjective));
		}
	},
	
	/*
	 * Updates the HTML timer of recently captured objectives. To be called by
	 * the clock tick second function.
	 */
	updateObjectiveTimers: function()
	{
		var obj;
		var msec = (new Date()).getTime();
		var msecage, msecremaining, percentremaining;
		var msectolerance = 30000;
		
		for (var i in W.Objectives)
		{
			obj = W.Objectives[i];
			// Update the Righteous Indigntation timers
			if (obj.isImmune)
			{
				msecage = msec - obj.last_flipped_msec;
				msecremaining = W.cMSECONDS_IMMUNITY - msecage;
				percentremaining = (msecremaining / W.cMSECONDS_IMMUNITY) * T.cPERCENT_100;
				if (msecremaining > 0 && msecage + msectolerance > 0)
				{
					document.getElementById("objTimer_" + obj.id).innerHTML = T.formatTimeColon(msecremaining);
					document.getElementById("objProgress_" + obj.id).style.width = percentremaining + "%";
				}
				else if (msecage + msectolerance <= 0)
				{
					if (T.isTimeOutOfSync === false)
					{
						W.addLogEntry("Negative time detected. Your computer's time may be <a"
							+ U.convertExternalAnchor("https://www.google.com/search?q=synchronize+time") + ">out of sync!</a>");
						T.isTimeOutOfSync = true;
					}
				}
				else
				{
					// If the objective has become capturable
					$("#objTimer_" + obj.id).html("");
					$("#objProgressBar_" + obj.id).css({opacity: 1}).animate({opacity: 0}, 2000, function()
					{
						$(this).css({opacity: 1}).hide();
					});
					$("#objIcon_" + obj.id).css({opacity: 0}).animate({opacity: 1}, 2000);
					obj.isImmune = false;
					W.updateObjectiveAge(obj);
				}
			}
		}
	},
	
	/*
	 * Updates the label showing an objective's time since it was last captured.
	 * @param object pObjective.
	 */
	updateObjectiveAge: function(pObjective)
	{
		if (pObjective.last_flipped_msec)
		{
			var msecage = (new Date()).getTime() - pObjective.last_flipped_msec;
			// Minutely updates
			$("#objAge_" + pObjective.id).html(T.getShorthandTime(msecage));
		}
	},
	updateAllObjectiveAge: function()
	{
		// To be called minutely by the clock tick second function
		for (var i in W.Objectives)
		{
			W.updateObjectiveAge(W.Objectives[i]);
		}
	},
	
	/*
	 * Updates the label showing the guild tag of who claimed the objective.
	 * @param object pObjective.
	 */
	updateObjectiveClaim: function(pObjective)
	{
		var guildid = pObjective.claimed_by;
		var updateClaim = function()
		{
			var guild = Q.getCachedGuild(guildid);
			pObjective.oGuildName = guild.name;
			pObjective.oTagInitial = guild.tag;
			pObjective.oTag = guild.oTag;
			W.updateObjectiveTooltip(pObjective);
			var label = $("#objClaim_" + pObjective.id);
			var prevcolor = label.css("color");
			label.html(guild.oTag);
			// Also animate if guild has changed from previous known claimer
			if (pObjective.prevclaimed_by !== "none")
			{
				I.blinkElement(label, 2000, 200);
				label.css({color: "#ffffff"}).animate({color: prevcolor}, 4000);
				W.addLogEntryObjective(pObjective, true);
			}
		};
		
		// If the objective was previously claimed but has become unclaimed
		if (guildid === null || guildid === undefined)
		{
			pObjective.oGuildName = null;
			pObjective.oTag = null;
			W.updateObjectiveTooltip(pObjective);
			$("#objClaim_" + pObjective.id).empty();
		}
		// If the objective changed claimers, update and use cached guild if available
		else
		{
			Q.getGuilds(guildid, function()
			{
				updateClaim();
			});
		}
	},
	
	/*
	 * Rewrites the objective marker's HTML tooltip with the current objective's
	 * properties data. To be called when objective changed owner or claim.
	 * @param object pObjective.
	 */
	updateObjectiveTooltip: function(pObjective)
	{
		// Initialize tooltip behavior for ith icon
		var obj = pObjective;
		var icon = $("#objIcon_" + obj.id);
		var claim = "";
		if (obj.claimed_by)
		{
			claim = "<aside><dfn>Claim:</dfn> " + (new Date(obj.claimed_at)).toLocaleString() + "</aside>"
				+ "<aside><dfn>Guild:</dfn> " + U.escapeHTML(obj.oGuildName + " " + obj.oTag) + "</aside>"
				+ "<aside class='cssCenter'><img class='objTooltipBanner' src='" + U.getGuildBannerURL(obj.oGuildName) + "' /></aside>";
		}
		
		var title = "<div class='objTooltip'>"
			+ "<aside><dfn class='objTooltipName'>" + D.getObjectName(obj) + "</dfn></aside>"
			+ "<aside class='cntDivider objTooltipDivider'></aside>"
			+ "<aside><dfn>Owner:</dfn> " + (new Date(obj.last_flipped)).toLocaleString() + "</aside>"
			+ ((pObjective.prevownerhtml) ? "<aside class='cssCenter'>" + pObjective.prevownerhtml + "</aside>" : "")
			+ claim
		+ "</div>";
		I.qTip.init(icon.attr("title", title));
	},
	
	/*
	 * Starts or stops the objectives tick function and sets associated variables.
	 * @param boolean pBoolean true to start.
	 */
	toggleObjectiveTick: function(pBoolean)
	{
		if (pBoolean)
		{
			W.isObjectiveTickEnabled = pBoolean;
			W.tickObjectives();
			W.isObjectiveTimerTickEnabled = pBoolean;
		}
		else
		{
			window.clearTimeout(W.ObjectiveTimeout);
			W.isObjectiveTickEnabled = pBoolean;
			W.isObjectiveTimerTickEnabled = pBoolean;
		}
	},
	
	/*
	 * Executes the update objectives function every few seconds.
	 */
	tickObjectives: function()
	{
		if (W.isObjectiveTickEnabled)
		{
			W.updateObjectives();
			window.clearTimeout(W.ObjectiveTimeout);
			W.ObjectiveTimeout = setTimeout(function()
			{
				W.tickObjectives();
			}, O.Options.int_secWvWRefresh * T.cMSECONDS_IN_SECOND);
		}
	}
};
J = {
/* =============================================================================
 * @@J Projection 3D display for overlay.
 * ========================================================================== */

	Renderer: {},
	Scene: {},
	Camera: {},
	isProjectionInitialized: false,

	initializeProjection: function()
	{
		J.Scene = new THREE.Scene();
		J.Camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

		J.Renderer = new THREE.WebGLRenderer({alpha: true});
		J.Renderer.setClearColor(0xffffff, 0);
		J.Renderer.setSize(window.innerWidth, window.innerHeight);
		document.getElementById("itemProjector").appendChild(J.Renderer.domElement);

		var geometry = new THREE.BoxGeometry(1, 1, 1);
		var material = new THREE.MeshBasicMaterial({color: 0x00ff00});
		var cube = new THREE.Mesh(geometry, material);
		//J.Scene.add(cube);

		//J.Camera.position.x = 3;
		//J.Camera.position.y = 4;
		J.Camera.position.z = 5;
		//J.Camera.lookAt(new THREE.Vector3(1, 0, 0));
		
		var geometry = new THREE.CircleGeometry(1, 32);
		var material = new THREE.MeshBasicMaterial({color: 0xffff00});
		var circle = new THREE.Mesh(geometry, material);
		J.Scene.add(circle);

		var render = function ()
		{
			requestAnimationFrame(render);

			cube.rotation.x += 0.1;
			cube.rotation.y += 0.1;

			J.Renderer.render(J.Scene, J.Camera);
		};

		render();
		
		J.isProjectionInitialized = true;
	}

};
T = {
/* =============================================================================
 * @@Time utilities, schedule, daily, and numeric functions
 * ========================================================================== */
	Daily: GW2T_DAILY_DATA,
	DailyAssociation: GW2T_DAILY_ASSOCIATION,
	DailyToday: null,
	DailyTomorrow: null,
	ResetToday: null,
	ResetTomorrow: null,
	Schedule: {},
	DryTopSets: {},
	DryTopCodes: {},
	
	DST_IN_EFFECT: 0, // Will become 1 and added to the server offset if DST is on
	SECONDS_TILL_DAILY: 0,
	SECONDS_TILL_WEEKLY: 0,
	TIMESTAMP_UNIX_SECONDS: 0,
	cUTC_OFFSET_USER: 0,
	cUTC_OFFSET_SERVER: -8, // Server is Pacific Time, 8 hours behind UTC
	cUTC_OFFSET_HAWAII: -10,
	cUTC_OFFSET_EASTERN: -4,
	// Natural constants
	cMSECONDS_IN_SECOND: 1000,
	cMSECONDS_IN_MINUTE: 60000,
	cMSECONDS_IN_DAY: 86400000,
	cSECONDS_IN_MINUTE: 60,
	cSECONDS_IN_HOUR: 3600,
	cSECONDS_IN_DAY: 86400,
	cSECONDS_IN_WEEK: 604800,
	cSECONDS_IN_MONTH: 2592000,
	cSECONDS_IN_YEAR: 31536000,
	cMINUTES_IN_HOUR: 60,
	cMINUTES_IN_2_HOURS: 120,
	cMINUTES_IN_DAY: 1440,
	cHOURS_IN_MERIDIEM: 12,
	cHOURS_IN_DAY: 24,
	cDAYS_IN_WEEK: 7,
	cDAYS_IN_BIWEEK: 14,
	cDAYS_IN_MONTH: 30,
	cDAYS_IN_YEAR: 365,
	cMONTHS_IN_YEAR: 12,
	cSECONDS_IN_TIMEFRAME: 900,
	cMINUTES_IN_TIMEFRAME: 15,
	cMINUTES_IN_MINIFRAME: 5,
	cNUM_TIMEFRAMES_IN_HOUR: 4,
	cSECS_MARK_0: 0,
	cSECS_MARK_1: 900,
	cSECS_MARK_2: 1800,
	cSECS_MARK_3: 2700,
	cSECS_MARK_4: 3599,
	cBASE_10: 10,
	cBASE_16: 16,
	cPERCENT_100: 100,
	// Geometry and velocity constants
	cCIRCLE_RIGHT_DEGREE: 90,
	cCIRCLE_HALF_DEGREE: 180,
	cCIRCLE_FULL_DEGREE: 360,
	cRADIAN_TO_DEGREE: 180 / Math.PI,
	cUNITS_TO_POINTS: 1 / 24, // Map coordinates "points" versus game range "units"
	cPOINTS_TO_UNITS: 24, // 1 game "unit" is 1 "inch"
	cUNITS_TO_METERS: 0.0254,
	cMETERS_TO_UNITS: 1 / 0.0254,
	cUNITS_PER_SECOND: 386, // Units traveled in one second while on swiftness buff
	// Game constants
	cWEEKLY_RESET_SECONDS: 113400, // Monday 07:30 UTC, seconds since Sunday 00:00 UTC
	cDAYTIME_DAY_MINUTES: 80,
	cDAYTIME_NIGHT_MINUTES: 40,
	cDAYTIME_DAY_START: 25,
	cDAYTIME_NIGHT_START: 45,
	cDAYTIME_TRANSITION_MINUTES: 5,
	ReferenceEnum:
	{
		UTC: 0,
		Local: 1,
		Server: 2
	},
	UnitEnum:
	{
		Milliseconds: 0,
		Seconds: 1,
		Minutes: 2,
		Hours: 3
	},
	DayEnum:
	{
		Sunday: 0,
		Monday: 1,
		Tuesday: 2,
		Wednesday: 3,
		Thursday: 4,
		Friday: 5,
		Saturday: 6
	},
	isTimeOutOfSync: false,
	secondsTillResetWeekly: -1,
	isChecklistCountdownsStarted: false,
	
	/*
	 * Gets a clipboard text of the current Dry Top events.
	 * @param int pOffset frames from the current.
	 * @returns string of events for that event frame.
	 */
	getCurrentDryTopEvents: function(pOffset)
	{
		return T.DryTopCodes[T.getDryTopMinute(pOffset)].chat + I.siteTagCurrent;
	},
	getCurrentDryTopColor: function(pOffset)
	{
		return T.DryTopCodes[T.getDryTopMinute(pOffset)].color;
	},
	
	/*
	 * Gets the minute in the current event frame.
	 * @param int pOffset from current.
	 * @returns string minute.
	 */
	getDryTopMinute: function(pOffset)
	{
		pOffset = pOffset || 0;
		var now = new Date();
		var min = now.getUTCMinutes();
		var minute = (~~(min / T.cMINUTES_IN_MINIFRAME) * T.cMINUTES_IN_MINIFRAME) + (pOffset * T.cMINUTES_IN_MINIFRAME);
		minute = T.wrapInteger(minute, T.cMINUTES_IN_HOUR);
		if (minute < T.cBASE_10)
		{
			minute = "0" + minute;
		}
		return minute;
	},
	
	/*
	 * Initializes Dry Top event sets to be used in clipboard text.
	 */
	initializeDryTopStrings: function()
	{
		var getDryTopSet = function(pSet)
		{
			var events = T.DryTopSets[pSet];
			var str = "";
			for (var i in events)
			{
				str += D.getObjectName(events[i]) + "@" + events[i].wp + " ";
			}
			return str.trim();
		};

		T.DryTopSets = GW2T_DRYTOP_SETS;
		T.DryTopCodes = GW2T_DRYTOP_CODES;
		for (var i in T.DryTopCodes) // Initialize chatcodes
		{
			T.DryTopCodes[i].chat += getDryTopSet(T.DryTopCodes[i].set);
		}
		
		K.updateDryTopClipboard();
		$("#itemDryTopClip").show();
	},
	
	/*
	 * Initializes a slot in the schedule. All units are in minutes since UTC midnight.
	 * @param int pTime minute.
	 * Example of expected schedule:
	 *	T.Schedule =
	 *	{
	 *	   "0": {SchedTime: 0 SchedChains: [C.Taidha, C.Tequatl]},
	 *	  "15": {SchedTime: 15, SchedChains: [C.Maw]},
	 *	  "30": {SchedTime: 30, SchedChains: [C.Megades]},
	 *	  "45": {SchedTime: 45, SchedChains: [C.FE]},
	 *		...
	 *	}
	 */
	initializeScheduleSlot: function(pTime)
	{
		if (T.Schedule[pTime] === undefined)
		{
			T.Schedule[pTime] = {SchedTime: pTime, SchedChains: []};
		}
	},
	
	/*
	 * Inserts a chain into the schedule.
	 * @param object pChain.
	 * @param array/object pTime array of strings of HH:MM format,
	 * or an object with the timing pattern:
	 * hourInitial: the first UTC hour the chain starts on.
	 * hourMultiplier: the repetition on every so hours.
	 * minuteOffset: the UTC minutes from those hours.
	 */
	insertChainToSchedule: function(pChain)
	{
		var utcminute = 0;
		var timing = pChain.timing;
		// If given an array of start times
		if (Array.isArray(timing))
		{
			for (var i in timing)
			{
				utcminute = T.parseChainTime(timing[i]);
				T.initializeScheduleSlot(utcminute);
				T.Schedule[utcminute].SchedChains.push(pChain);
			}
		}
		// If given a pattern of the start times
		else
		{
			for (utcminute = (timing.hourInitial * T.cMINUTES_IN_HOUR) + timing.minuteOffset;
				utcminute < T.cMINUTES_IN_DAY;
				utcminute += timing.hourMultiplier * T.cMINUTES_IN_HOUR)
			{
				T.initializeScheduleSlot(utcminute);
				T.Schedule[utcminute].SchedChains.push(pChain);
			}
		}
	},
	
	/*
	 * Initializes the schedule used by chains, clock, and timeline.
	 */
	initializeSchedule: function()
	{
		var i, ii, iii;
		var slot;
		
		// Initialize Living Story events, if available
		if (H.Story.isEnabled)
		{
			if (T.isTimely(H.Story, new Date()))
			{
				H.isStoryEnabled = true;
				// Determine living story placement
				if (I.isProgramEmbedded
					|| I.ModeCurrent !== I.ModeEnum.Website
					|| O.Options.bol_showHUD === false
					|| O.Options.bol_showDashboard === false)
				{
					H.isStoryDashboard = false;
				}
			}
		}
		
		// Initialize chains
		if (D.isLanguageLogographic)
		{
			C.cEventCharLimit = C.cEventCharLimitLogographic;
		}
		X.initializeChecklist(X.Checklists.Chain, C.Chains.length + C.UnscheduledChainsLength);
		X.initializeChecklist(X.Checklists.ChainSubscription, C.Chains.length + C.UnscheduledChainsLength);
		C.initializeScheduledChains();
		I.initializeChainsUI();
		// Initial recoloring of chain titles
		$("#sectionChains_Scheduled .chnBar h1, #sectionChains_Drytop .chnBar h1, #dsbStory .chnBar h1")
			.addClass("chnTitleFutureFar");
		
		// Every scheduled chain gets an array of schedule keys (UTC minutes) of where it is in the schedule
		for (i in C.ScheduledChains)
		{
			T.insertChainToSchedule(C.ScheduledChains[i]);
		}
		for (i in T.Schedule)
		{
			slot = T.Schedule[i];
			for (ii in C.ScheduledChains)
			{
				for (iii in slot.SchedChains)
				{
					if (C.ScheduledChains[ii].nexus === slot.SchedChains[iii].nexus)
					{
						C.ScheduledChains[ii].scheduleKeys.push(i);
						break;
					}
				}
			}
		}
		
		// Initialize for the touring function to access current active event
		C.CurrentChainSD = T.getStandardChain();
	},
	
	/*
	 * Gets the minutes for specified slot.
	 * @param int pKey of schedule slot.
	 * @returns int minutes.
	 */
	getScheduleSlotTime: function(pKey)
	{
		return T.Schedule[pKey].SchedTime;
	},
	
	/*
	 * Gets the chain array in schedule by specified key.
	 * @param string pKey of schedule slot.
	 * @returns array chains.
	 */
	getScheduleSlotChainsByKey: function(pKey)
	{
		return T.Schedule[pKey].SchedChains;
	},
	
	/*
	 * Gets the earliest minutes since UTC midnight that is divisible by the
	 * timeframe minutes.
	 * @returns int minutes.
	 */
	getCurrentTimeframe: function()
	{
		var minutes = T.getTimeSinceMidnight(T.ReferenceEnum.UTC, T.UnitEnum.Minutes);
		return minutes - (minutes % T.cMINUTES_IN_TIMEFRAME);
	},
	
	/*
	 * Gets the minutes since midnight UTC corresponding to a schedule slot
	 * divisible by the timeframe minutes.
	 * @param int pOffset number of timeframes from the current.
	 * @returns int minutes.
	 */
	getTimeframe: function(pOffset)
	{
		pOffset = pOffset || 0;
		var frameminute = T.getCurrentTimeframe() + (pOffset * T.cMINUTES_IN_TIMEFRAME);
		return T.wrapInteger(frameminute, T.cMINUTES_IN_DAY);
	},
	
	/*
	 * Gets an array of chains for specified timeframe.
	 * @param int pOffset number of timeframes from the current.
	 * @returns array chains, current active chains if offset is 0.
	 */
	getTimeframeChains: function(pOffset)
	{
		return T.Schedule[T.getTimeframe(pOffset)].SchedChains;
	},
	
	/*
	 * Gets a chain of particular series for specified timeframe.
	 * @param int pOffset number of timeframes from the current.
	 * @param string pSeries to filter the chains array.
	 */
	getTimeframeChainBySeries: function(pOffset, pSeries)
	{
		var chains = T.getTimeframeChains(pOffset);
		
		for (var i in chains)
		{
			if (chains[i].series === pSeries)
			{
				return chains[i];
			}
		}
		return null;
	},
	getTimeframeChainsBySeries: function(pOffset, pSeries)
	{
		var chains = T.getTimeframeChains(pOffset);
		var retchains = [];
		
		for (var i in chains)
		{
			if (chains[i].series === pSeries)
			{
				retchains.push(chains[i]);
			}
		}
		return retchains;
	},
	getStandardChain: function(pOffset)
	{
		return T.getTimeframeChainBySeries(pOffset, C.ChainSeriesEnum.Standard);
	},
	getHardcoreChain: function(pOffset)
	{
		/*
		 * Because there are gaps in the "hardcore schedule", the return needs
		 * to be checked before using since it can be null.
		 */
		return T.getTimeframeChainBySeries(pOffset, C.ChainSeriesEnum.Hardcore);
	},
	getLivingStoryChain: function(pOffset)
	{
		return T.getTimeframeChainBySeries(pOffset, C.ChainSeriesEnum.LivingStory);
	},
	getMiscellaneousChains: function(pOffset)
	{
		return T.getTimeframeChainsBySeries(pOffset, C.ChainSeriesEnum.Miscellaneous);
	},
	
	/*
	 * Gets the key from current timeframe offset.
	 * @param int pOffset number of timeframes from the current.
	 * @returns string key for the schedule slot.
	 */
	getTimeframeKey: function(pOffset)
	{
		return (T.getTimeframe(pOffset)).toString();
	},
	
	/*
	 * Gets the local time in seconds for when a chain starts in the schedule.
	 * @param string pKey in the schedule.
	 * @returns int seconds since midnight local time.
	 */
	convertScheduleKeyToLocalSeconds: function(pKey)
	{
		var time = (T.getScheduleSlotTime(pKey) * T.cSECONDS_IN_MINUTE)
			- ((new Date()).getTimezoneOffset() * T.cSECONDS_IN_MINUTE);
		return T.wrapInteger(time, T.cSECONDS_IN_DAY);
	},
	convertScheduleKeyToUTCMinutes: function(pKey)
	{
		// Removes the time prefix from the key to get the minutes
		return parseInt(pKey);
	},
	
	/*
	 * Gets the time the current chain has been running.
	 * @returns int seconds or minutes elapsed since chain started.
	 */
	getCurrentTimeframeElapsedTime: function(pUnit)
	{
		var now = new Date();
		var min = now.getUTCMinutes();
		var sec = now.getUTCSeconds();
		
		if (pUnit === T.UnitEnum.Minutes)
		{
			return min % T.cMINUTES_IN_TIMEFRAME;
		}
		return ((min % T.cMINUTES_IN_TIMEFRAME) * T.cSECONDS_IN_MINUTE) + sec;
	},
	
	/*
	 * Gets the seconds until a chain start by subtracting the current time from
	 * the chain start time; both of which are seconds since midnight. Because
	 * the timer uses the 24 hour cyclical system, this function faces the
	 * design problem of deciding whether the chain start time is ahead or
	 * behind the local time when past midnight.
	 * @param object pChain to get start time.
	 * @returns int seconds remaining, negative if it started already.
	 * @pre Chain's scheduleKeys array was refreshed with the earliest start
	 * time at the first index.
	 */
	getSecondsUntilChainStarts: function(pChain)
	{
		var secondschain = (T.convertScheduleKeyToLocalSeconds(pChain.scheduleKeys[0]));
		var secondscurrent = T.getTimeSinceMidnight(T.ReferenceEnum.Local, T.UnitEnum.Seconds);
		var rolloverthreshold = (T.cSECONDS_IN_TIMEFRAME * T.cNUM_TIMEFRAMES_IN_HOUR); // This is 3600 seconds
		
		/*
		 * It is known that the program looks at most 4 chains ahead of the
		 * current to display the clock icons. Deal with the midnight problem by
		 * enforcing a one hour threshold before and after midnight, so for
		 * example the current time is 23:00:00 and the target chain starts at
		 * 00:15:00, it would return 01:15:00 (in seconds). Without the
		 * threshold, it would return -22:45:00.
		 */
		if (secondschain >= (T.cSECONDS_IN_DAY - rolloverthreshold)
			&& secondscurrent <= rolloverthreshold)
		{
			return (T.cSECONDS_IN_DAY - secondschain) + secondscurrent;
		}
		if (secondscurrent >= (T.cSECONDS_IN_DAY - rolloverthreshold)
			&& secondschain <= rolloverthreshold)
		{
			return (T.cSECONDS_IN_DAY - secondscurrent) + secondschain;
		}
		
		return secondschain - secondscurrent;
	},
	
	/*
	 * Gets a readable string of minutes and hours until a chain starts.
	 * @param object pChain to tell time.
	 * @param string pFormat of the time words.
	 * @returns string time string.
	 */
	getTimeTillChainFormatted: function(pChain, pFormat)
	{
		var secondsleft = T.getSecondsUntilChainStarts(pChain);
		var min = ~~(secondsleft / T.cSECONDS_IN_MINUTE) % T.cSECONDS_IN_MINUTE;
		var hour = ~~(secondsleft / T.cSECONDS_IN_HOUR);
		var minword = D.getTranslation("m");
		var hourword = D.getTranslation("h");
		
		if (pFormat === "speech")
		{
			minword = " " + D.getSpeechWord("minute");
			hourword = " " + D.getSpeechWord("hour");
			if (Math.abs(min) > 1)
			{
				minword = " " + D.getSpeechWord("minutes");
			}
			if (Math.abs(hour) > 1)
			{
				hourword = " " + D.getSpeechWord("hours");
			}
			if (hour === 0 && Math.abs(min) === 30)
			{
				min = D.getTranslation("half an hour");
				minword = "";
				hourword = "";
			}
		}
		hourword += " ";

		min = min + minword;
		if (Math.abs(secondsleft) >= T.cSECONDS_IN_HOUR)
		{
			hour = hour + hourword;
		}
		else
		{
			hour = "";
		}
		
		if (secondsleft < 0)
		{
			return " " + hour + min + " " + D.getTranslation("ago");
		}
		return " " + D.getTranslation("in") + " " + hour + min;
	},
	
	/*
	 * Gets a random integer between inclusive range.
	 * @param int pMin value.
	 * @param int pMax value.
	 * @returns int random.
	 */
	getRandomIntRange: function(pMin, pMax)
	{
		return Math.floor(Math.random() * (pMax - pMin + 1)) + pMin;
	},
	
	/*
	 * Gets the lowest and highest value inside an array.
	 * @param array pArray.
	 * @param string pProperty of array if the value is a property.
	 * @returns object contains min and max values, and their key/index.
	 */
	getMinMax: function(pArray, pProperty)
	{
		var hasprop = !(pProperty === undefined);
		var min = Number.POSITIVE_INFINITY;
		var max = Number.NEGATIVE_INFINITY;
		var minkey = null;
		var maxkey = null;
		var ith;
		for (var i in pArray)
		{
			ith = hasprop ? (pArray[i])[pProperty] : pArray[i];
			if (ith < min)
			{
				min = ith;
				minkey = i;
			}
			if (ith > max)
			{
				max = ith;
				maxkey = i;
			}
		}
		return {
			oMin: min,
			oMax: max,
			oMinKey: minkey,
			oMaxKey: maxkey
		};
	},
	
	/*
	 * Adjusts an integer so that it is within 0 to the specified limit. Example:
	 * Integer 26 with Limit 24 returns 2. Integer -4 with Limit 24 returns 20.
	 * For use in circular arrays.
	 * @param int pInteger to readjust within limit.
	 * @param int pMax limit of the quantity.
	 * @param boolean pIsInclusive whether Integer 24 with Limit 24 returns 24 or 0, optional.
	 * @returns int natural number rolled over.
	 */
	wrapInteger: function(pInteger, pMax, pIsInclusive)
	{
		var i = pInteger;
		// Inclusive case
		if (pIsInclusive && (pInteger / pMax === 0))
		{
			return pInteger;
		}
		// Rollover
		i = i % pMax;
		
		// Adjust for negative
		if (i < 0)
		{
			i = pMax + i;
		}
		return i;
	},
	
	/*
	 * Constraints a number to the min or max value if it is out of those bounds.
	 * @param int pNumber.
	 * @param int pMin.
	 * @param int pMax.
	 * @returns int.
	 */
	clampInteger: function(pNum, pMin, pMax)
	{
		if (pNum < pMin)
		{
			return pMin;
		}
		if (pNum > pMax)
		{
			return pMax;
		}
		return pNum;
	},
	clampFloor: function(pNum, pMin)
	{
		return T.clampInteger(pNum, pMin, Number.POSITIVE_INFINITY);
	},
	clampCeil: function(pNum, pMax)
	{
		return T.clampInteger(pNum, Number.NEGATIVE_INFINITY, pMax);
	},
	
	/*
	 * Gets a stepped output of a linear equation.
	 * @param int pX
	 * @param int pDivisor
	 * @param int pMin
	 * @param int pMax
	 * @param int pMultiplier
	 * @returns int y, or pMin or pMax if out of these range.
	 */
	stepFunction: function(pX, pDivisor, pMin, pMax, pMultiplier)
	{
		var result = (~~(pX / pDivisor) * pMultiplier) + pMin;
		return (result > pMax) ? pMax : result;
	},
	
	/*
	 * Parses a counting number.
	 * @param number or string pQuantity.
	 * @param number pDefault value.
	 * @returns cleaned quantity.
	 */
	parseQuantity: function(pQuantity, pDefault)
	{
		if (pDefault === undefined)
		{
			pDefault = 1;
		}
		var quantity = parseInt(pQuantity);
		if ( ! isFinite(quantity)) { quantity = pDefault; }
		return quantity;
	},
	
	/*
	 * Parses a quotient.
	 * @param number pRatio.
	 * @param int pDigits of decimals to show.
	 * @returns cleaned decimal.
	 */
	parseRatio: function(pRatio, pDigits)
	{
		if (pRatio === 0 || isNaN(pRatio))
		{
			return 0;
		}
		else if (pRatio === 1 || pRatio === Number.POSITIVE_INFINITY || pRatio === Number.NEGATIVE_INFINITY)
		{
			return 1;
		}
		return (pDigits !== undefined) ? pRatio.toFixed(pDigits) : pRatio;
	},
	
	/*
	 * Converts a time string to seconds.
	 * @param string pTime in X:XX:XX or X:XX or 0 format.
	 * @returns int seconds totaled.
	 * @pre Time string contains at most 1 "~" and at most 2 ":".
	 */
	parseEventTime: function(pTime)
	{
		/*
		 * Time string with the ~ are preformatted as the minimum time plus the
		 * window time (two time strings), for example "1:30:00~30:00" is 1.5 hour
		 * wait, and 0.5 hour window during which the next event can happen.
		 */
		var time = [];
		if (pTime.indexOf("~") !== -1)
		{
			time = pTime.split("~");
			// Sum the minimum wait with the expected (half) time of the window
			return T.parseEventTime(time[0]) + ~~(T.parseEventTime(time[1]) / 2);
		}
		if (pTime === "*")
		{
			return 0;
		}
		// If just a number without colons, assume it is already seconds
		if (pTime.indexOf(":") === -1)
		{
			return parseInt(pTime, T.cBASE_10);
		}

		time = pTime.split(":");
		if (time.length === 2)
		{
			return parseInt(time[0], T.cBASE_10) * T.cSECONDS_IN_MINUTE
				+ parseInt(time[1], T.cBASE_10);
		}
		if (time.length === 3)
		{
			return parseInt(time[0]) * T.cSECONDS_IN_HOUR
				+ parseInt(time[1], T.cBASE_10) * T.cSECONDS_IN_MINUTE
				+ parseInt(time[2], T.cBASE_10);
		}
		return NaN;
	},
	
	/*
	 * Converts "XX:XX" (hours:minutes) to minutes.
	 * @param string pTime to convert.
	 * @returns int minutes totaled.
	 */
	parseChainTime: function(pTime)
	{
		var time = pTime.split(":");
		return parseInt(time[0], T.cBASE_10) * T.cMINUTES_IN_HOUR
				+ parseInt(time[1], T.cBASE_10);
	},

	/*
	 * The DST global integer is added to the server hour, which is incremented if
	 * DST is in effect. The code is from http://javascript.about.com/library/bldst.htm
	 */
	checkDST: function()
	{
		Date.prototype.stdTimezoneOffset = function()
		{
			var jan = new Date(this.getFullYear(), 0, 1);
			var jul = new Date(this.getFullYear(), 6, 1);
			return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
		};
		Date.prototype.dst = function()
		{
			return this.getTimezoneOffset() < this.stdTimezoneOffset();
		};

		var now = new Date();
		T.DST_IN_EFFECT = (now.dst() && O.Options.bol_detectDST) ? 1 : 0;
	},

	/*
	 * Gets a formatted time string, arguments are taken as key-value pairs.
	 * @objparam string aReference place to offset the time, default is local.
	 * @objparam boolean aWant24 to format as 24 hour or not (AM/PM).
	 * @objparam boolean aWantSeconds to include the seconds.
	 * @objparam boolean aWantHours to include the hours.
	 * @objparam boolean aWantLetters to format #h #m #s instead of colons. Overrides want24.
	 * @objparam boolean aWantNegative allow negative time.
	 * @objparam Date aCustomTimeInDate to convert to time string.
	 * @objparam int aCustomTimeInSeconds to convert to a time string, will use
	 * current time if undefined.
	 * @returns 23:59:59 or 11:59:59 PM or 23h 59m 59s time string.
	 */
	getTimeFormatted: function(pSettings)
	{
		var Settings = $.extend({
			aReference: T.ReferenceEnum.Local,
			aWant24: O.Options.bol_use24Hour,
			aWantSeconds: true,
			aWantHours: true,
			aWantLetters: false
		}, pSettings);
		
		var sec, min, hour;
		var negsym = "";
		var now = (Settings.aCustomTimeInDate === undefined) ? (new Date()) : Settings.aCustomTimeInDate;
		if (Settings.aCustomTimeInSeconds === undefined)
		{
			switch (Settings.aReference)
			{
				case T.ReferenceEnum.Local:
				{
					sec = now.getSeconds();
					min = now.getMinutes();
					hour = now.getHours();
				} break;
				case T.ReferenceEnum.Server:
				{
					sec = now.getSeconds();
					min = now.getMinutes();
					hour = now.getUTCHours() + T.cUTC_OFFSET_SERVER + T.DST_IN_EFFECT;
					hour = T.wrapInteger(hour, T.cHOURS_IN_DAY);
				} break;
				case T.ReferenceEnum.UTC:
				{
					sec = now.getUTCSeconds();
					min = now.getUTCMinutes();
					hour = now.getUTCHours();
				} break;
			}
		}
		else
		{
			// Regard negative input
			var cust = Settings.aCustomTimeInSeconds;
			if (Settings.aWantNegative)
			{
				if (cust < 0)
				{
					cust = Math.abs(cust);
					negsym = I.Symbol.Negative;
				}
			}
			else
			{
				cust = T.wrapInteger(Settings.aCustomTimeInSeconds, T.cSECONDS_IN_DAY);
			}
			
			/*
			 * Convert specified seconds to time units. The ~~ gets rid of the
			 * decimal so / behaves like integer divide.
			 */
			sec = cust % T.cSECONDS_IN_MINUTE;
			min = ~~(cust / T.cSECONDS_IN_MINUTE) % T.cMINUTES_IN_HOUR;
			hour = ~~(cust / T.cSECONDS_IN_HOUR);
		}
		
		var minsec = "";
		// Include the seconds else don't
		if (Settings.aWantSeconds)
		{
			if (Settings.aWantLetters)
			{
				if (hour === 0 && min === 0)
				{
					minsec = sec + D.getWord("s");
				}
				else
				{
					minsec = min + D.getWord("m") + " " + sec + D.getWord("s");
				}
			}
			else if (Settings.aWantHours === false)
			{
				minsec = min + ":" + ((sec < T.cBASE_10) ? "0" + sec : sec);
			}
			else
			{
				minsec = ((min < T.cBASE_10) ? "0" + min : min) + ":" + ((sec < T.cBASE_10) ? "0" + sec : sec);
			}
		}
		else
		{
			if (Settings.aWantLetters)
			{
				minsec = min + D.getWord("m");
			}
			else
			{
				minsec = ((min < T.cBASE_10) ? "0" + min : min);
			}
		}
		
		// Possible returns
		if (Settings.aWantLetters)
		{
			if (hour === 0 || Settings.aWantHours === false)
			{
				return negsym + minsec;
			}
			return negsym + hour + D.getWord("h") + " " + minsec;
		}
		if (Settings.aWant24)
		{
			if (Settings.aWantHours === false)
			{
				return minsec;
			}
			return ((hour < T.cBASE_10) ? "0" + hour : hour) + ":" + minsec;
		}
		// Else shift the hour and suffix the meridiem
		var period = " AM";
		if (hour >= T.cHOURS_IN_MERIDIEM)
		{
			if (hour > T.cHOURS_IN_MERIDIEM)
			{
				hour = hour % T.cHOURS_IN_MERIDIEM;
			}
			period = " PM";
		}
		else if (hour === 0)
		{
			hour = T.cHOURS_IN_MERIDIEM;
		}
		return hour + ":" + minsec + period;
	},
	
	/*
	 * Gets a "0m" "1m" "59m" "1.0h" "25.9h" single unit approximated time string.
	 * @param int pMilliseconds of time.
	 * @returns string shorthand.
	 */
	getShorthandTime: function(pMilliseconds)
	{
		var seconds = ~~(pMilliseconds / T.cMSECONDS_IN_SECOND);
		// Return minutes
		if (seconds < T.cSECONDS_IN_MINUTE)
		{
			return 0 + D.getWord("m");
		}
		if (seconds < T.cSECONDS_IN_HOUR)
		{
			return (~~(seconds / T.cSECONDS_IN_MINUTE) % T.cMINUTES_IN_HOUR) + D.getWord("m");
		}
		// Return hours
		return (seconds / T.cSECONDS_IN_HOUR).toFixed(1) + D.getWord("h");
	},
	
	/*
	 * Gets a "Days:Hours:Minutes:Seconds" string from seconds.
	 * @param int pMilliseconds of time.
	 * @returns string formatted time.
	 */
	formatTimeColon: function(pMilliseconds, pWantDeciseconds)
	{
		var signstr = "";
		var ms = pMilliseconds;
		if (ms < 0)
		{
			ms *= -1;
			signstr = I.Symbol.Negative;
		}
		var seconds = ~~(ms / T.cMSECONDS_IN_SECOND);
		var day, hour, min, sec;
		var daystr = "";
		var hourstr = "";
		var minstr = "";
		var secstr = "";
		var msstr = "";
		
		if (seconds >= T.cSECONDS_IN_DAY)
		{
			day = ~~(seconds / T.cSECONDS_IN_DAY);
			daystr = day + "::";
		}
		if (seconds >= T.cSECONDS_IN_HOUR)
		{
			hour = ~~(seconds / T.cSECONDS_IN_HOUR) % T.cHOURS_IN_DAY;
			hourstr = hour + ":";
			if (daystr !== "" && hour < T.cBASE_10)
			{
				hourstr = "0" + hourstr;
			}
		}
		if (seconds >= T.cSECONDS_IN_MINUTE)
		{
			min = ~~(seconds / T.cSECONDS_IN_MINUTE) % T.cMINUTES_IN_HOUR;
			minstr = min + ":";
			if (hourstr !== "" && min < T.cBASE_10)
			{
				minstr = "0" + minstr;
			}
		}
		else
		{
			minstr = "0:";
		}
		sec = seconds % T.cSECONDS_IN_MINUTE;
		secstr = sec.toString();
		if (sec < T.cBASE_10)
		{
			secstr = "0" + secstr;
		}
		if (pWantDeciseconds)
		{
			var deciseconds = ~~((ms % T.cMSECONDS_IN_SECOND) / T.cBASE_10);
			msstr = "." + deciseconds;
			if (deciseconds < T.cBASE_10)
			{
				msstr = ".0" + deciseconds;
			}
		}
		
		return signstr + daystr + hourstr + minstr + secstr + msstr;
	},
	
	/*
	 * Gets a "1w 6d 23h 59m 59s" string from seconds.
	 * Months instead of weeks if duration >= 30 days.
	 * Years and days instead of lower denominations if duration >= 365 days.
	 * @param int pSeconds of time.
	 * @returns string formatted time.
	 */
	formatTimeLetter: function(pSeconds, pWantSeconds, pWantShort)
	{
		var seconds = pSeconds;
		var year, month, week, day, hour, min, sec;
		var yearstr = "";
		var monthstr = "";
		var weekstr = "";
		var daystr = "";
		var hourstr = "";
		var minstr = "";
		var secstr = "";
		var signstr = "";
		var daydivisor = T.cDAYS_IN_YEAR;
		
		// Case zero
		if (pSeconds === 0)
		{
			return "0" + D.getWord("s");
		}
		
		// Sign string
		if (seconds < 0)
		{
			seconds = seconds * -1;
			signstr = I.Symbol.Negative;
		}
		// Year, month, and week string
		if (seconds < T.cSECONDS_IN_YEAR)
		{
			if (seconds >= T.cSECONDS_IN_MONTH)
			{
				month = ~~(seconds / T.cSECONDS_IN_MONTH);
				monthstr = month + D.getWord("mo") + " ";
				daydivisor = T.cDAYS_IN_MONTH;
			}
			else
			{
				if (seconds >= T.cSECONDS_IN_WEEK)
				{
					week = ~~(seconds / T.cSECONDS_IN_WEEK);
					weekstr = week + D.getWord("w") + " ";
				}
				daydivisor = T.cDAYS_IN_WEEK;
			}
		}
		else
		{
			year = ~~(seconds / T.cSECONDS_IN_YEAR);
			yearstr = year + D.getWord("y") + " ";
		}
		// Day string
		if (seconds >= T.cSECONDS_IN_DAY)
		{
			if (pWantShort)
			{
				return ~~(seconds / T.cSECONDS_IN_DAY) + D.getWord("d");
			}
			day = ~~(seconds / T.cSECONDS_IN_DAY) % daydivisor;
			daystr = day + D.getWord("d") + ((seconds < T.cSECONDS_IN_YEAR) ? " " : "");
		}
		// Include hms only if duration is less than a year
		if (seconds < T.cSECONDS_IN_YEAR)
		{
			if (seconds >= T.cSECONDS_IN_HOUR)
			{
				hour = ~~(seconds / T.cSECONDS_IN_HOUR) % T.cHOURS_IN_DAY;
				hourstr = hour + D.getWord("h") + " ";
			}
			if (seconds >= T.cSECONDS_IN_MINUTE)
			{
				min = ~~(seconds / T.cSECONDS_IN_MINUTE) % T.cMINUTES_IN_HOUR;
				minstr = min + D.getWord("m") + ((pWantSeconds || seconds < T.cSECONDS_IN_MINUTE) ? " " : "");
			}
			if (pWantSeconds || seconds < T.cSECONDS_IN_MINUTE)
			{
				sec = seconds % T.cSECONDS_IN_MINUTE;
				secstr = sec.toString() + D.getWord("s");
			}
		}
		
		return signstr + yearstr + monthstr + weekstr + daystr + hourstr + minstr + secstr;
	},
	formatMilliseconds: function(pMilliseconds)
	{
		return T.formatTimeLetter(~~(pMilliseconds / T.cMSECONDS_IN_SECOND));
	},
	formatMinutes: function(pMinutes)
	{
		return T.formatTimeLetter(pMinutes * T.cSECONDS_IN_MINUTE);
	},
	formatISO: function(pDate)
	{
		return pDate.toISOString().split(".")[0]; // "YYYY-MM-DDTHH:mm:ss.sssZ" so milliseconds is excluded
	},
	
	/*
	 * Formats the succinct time format of ingame tooltips. Example: "59 s", "59 m", "23 h", "1 d"
	 * @param int pMilliseconds
	 * @returns string.
	 */
	formatTooltipTime: function(pSeconds, pWantSpace)
	{
		var sec = pSeconds;
		var space = (pWantSpace) ? " " : "";
		var divisors = [T.cSECONDS_IN_MINUTE, T.cSECONDS_IN_HOUR, T.cSECONDS_IN_DAY, T.cSECONDS_IN_YEAR];
		var units = ["m", "h", "d"];
		if (sec < T.cSECONDS_IN_MINUTE)
		{
			return sec + space + D.getWord("s");
		}
		for (var i = 0; i < units.length; i++)
		{
			if (sec < divisors[i+1])
			{
				return ~~(sec / divisors[i]) + space + D.getWord(units[i]);
			}
		}
		return "";
	},
	formatTooltipTimeMS: function(pMilliseconds, pWantSpace)
	{
		return T.formatTooltipTime(~~(pMilliseconds / T.cMSECONDS_IN_SECOND), pWantSpace);
	},
	
	/*
	 * Gets standard localized time string with weekday word included.
	 * @param Date pDate object.
	 * @param boolean pWantTime to include other time units.
	 * @returns string.
	 */
	formatWeektime: function(pDate, pWantTime)
	{
		var date = (pDate instanceof Date) ? pDate : (new Date(pDate));
		var options = {year: "numeric", month: "numeric", day: "numeric", weekday: "long"};
		if (pWantTime)
		{
			options.hour = "numeric";
			options.minute = "numeric";
		}
		return date.toLocaleString(window.navigator.language, options);
	},
	formatLocal: function(pDate, pOptions)
	{
		return pDate.toLocaleString(window.navigator.language, pOptions);
	},
	
	/*
	 * Checks a time sensitive object if its Start and Finish date objects fits
	 * the provided time instant.
	 * @param object pObject to check.
	 * @param Date pDate time to compare with, such as now.
	 * @param int pGracePeriod seconds to add to the finish time, optional.
	 */
	isTimely: function(pObject, pDate, pGracePeriod)
	{
		var comparedate = pDate || new Date(); // If comparison and start time is not provided then use now time
		var start = pObject.Start || comparedate;
		var finish = (pGracePeriod === undefined)
			? pObject.Finish : (new Date(pObject.Finish.getTime() + pGracePeriod * T.cMSECONDS_IN_SECOND));
		if (comparedate >= start && comparedate <= finish)
		{
			return true;
		}
		return false;
	},
	
	/*
	 * Tells if current UTC time is daytime in game or not (night).
	 * @returns true if daytime.
	 */
	isDaylight: function()
	{
		var now = new Date();
		var hour = now.getUTCHours();
		var min = now.getUTCMinutes();
		if (hour % 2 === 0) // If hour is even
		{
			if (min >= T.cDAYTIME_DAY_START)
			{
				return true;
			}
		}
		else // If hour is odd
		{
			if (min < T.cDAYTIME_NIGHT_START)
			{
				return true;
			}
		}
		return false;
	},
	
	/*
	 * Gets a preformatted string of the minutes of daylight or night remaining.
	 * Also sets the clock's background dimming.
	 * @returns string.
	 */
	getDayPeriodRemaining: function()
	{
		var now = new Date();
		var hour = now.getUTCHours();
		var min = now.getUTCMinutes();
		var minremain = ""; // Dim the clock background
		if (hour % 2 === 0)
		{
			if (min >= T.cDAYTIME_DAY_START) // Day
			{
				minremain = (T.cDAYTIME_DAY_START + T.cDAYTIME_DAY_MINUTES - min);
				// Light transitions only happen during day time, night is always fully dimmed
				if (minremain > T.cDAYTIME_TRANSITION_MINUTES)
				{
					if (minremain >= T.cDAYTIME_DAY_MINUTES - T.cDAYTIME_TRANSITION_MINUTES)
					{
						K.setDimming((T.cDAYTIME_DAY_MINUTES - minremain + 1) / T.cDAYTIME_TRANSITION_MINUTES, true);
					}
					else
					{
						K.setDimming(1);
					}
				}
				else
				{
					K.setDimming(minremain / T.cDAYTIME_TRANSITION_MINUTES, true);
				}
				// Is transitioning to day
				if (min === T.cDAYTIME_DAY_START && O.Options.bol_alertDaylight)
				{
					D.speak(D.getPhrase("approaching day"));
				}
			}
			else // Night
			{
				minremain = (T.cDAYTIME_DAY_START - min);
				K.setDimming(0.1);
			}
		}
		else
		{
			if (min < T.cDAYTIME_NIGHT_START) // Day
			{
				minremain = (T.cDAYTIME_NIGHT_START - min);
				if ((minremain > T.cDAYTIME_TRANSITION_MINUTES))
				{
					K.setDimming(1);
				}
				else
				{
					K.setDimming((minremain / T.cDAYTIME_TRANSITION_MINUTES), true);
				}
			}
			else // Night
			{
				minremain = (T.cDAYTIME_NIGHT_START + T.cDAYTIME_NIGHT_MINUTES - min);
				K.setDimming(0.1);
				// Is transitioning to night
				if (min === T.cDAYTIME_NIGHT_START && O.Options.bol_alertDaylight)
				{
					D.speak(D.getPhrase("approaching night"));
				}
			}
		}
		return minremain + D.getWord("m");
	},
	
	/*
	 * Gets a Date object of the previous UTC midnight
	 * @returns Date.
	 */
	getUTCMidnight: function()
	{
		return (new Date()).setUTCHours(0, 0, 0, 0);
	},

	/*
	 * Gets the time in units since midnight at the point of reference.
	 * @param string pTimeUnit time unit to convert from.
	 * @param string pReference place to offset the time, default is UTC.
	 * @returns number seconds, minutes, or hours.
	 */
	getTimeSinceMidnight: function(pReference, pTimeUnit)
	{
		pTimeUnit = pTimeUnit || T.UnitEnum.Seconds;
		pReference = pReference || T.ReferenceEnum.UTC;
		
		var now = new Date();
		var hour = now.getUTCHours();
		var min = now.getUTCMinutes();
		var sec = now.getUTCSeconds();
		
		switch (pReference)
		{
			case T.ReferenceEnum.UTC: break;
			case T.ReferenceEnum.Server: hour = hour + T.cUTC_OFFSET_SERVER + T.DST_IN_EFFECT; break;
			case T.ReferenceEnum.Local:
			{
				 hour = now.getHours();
				 min = now.getMinutes();
				 sec = now.getSeconds();
			} break;
		}
		hour = T.wrapInteger(hour, T.cHOURS_IN_DAY);

		if (pTimeUnit === T.UnitEnum.Hours)
		{ 
			return hour;
		}
		if (pTimeUnit === T.UnitEnum.Minutes)
		{
			return (hour * T.cMINUTES_IN_HOUR) + min;
		}
		// Default return seconds
		return (hour * T.cSECONDS_IN_HOUR) + (min * T.cSECONDS_IN_MINUTE) + sec;
	},
	
	/*
	 * Gets the number of days between two dates.
	 * @param Date pStart.
	 * @param Date pFinish.
	 * @returns int.
	 */
	getDaysSince: function(pStart, pFinish)
	{
		return ~~(Math.abs((pStart.getTime() - pFinish.getTime()) / T.cMSECONDS_IN_DAY));
	},
	
	/*
	 * Gets the seconds since Sunday 00:00 UTC.
	 */
	getSecondsSinceWeekstart: function(pSecondsSinceMidnight)
	{
		return ((new Date()).getUTCDay() * T.cSECONDS_IN_DAY) + pSecondsSinceMidnight;
	},
	
	/*
	 * Gets the seconds since 1970 January 1 00:00:00 UTC.
	 * @returns int seconds.
	 */
	getUNIXSeconds: function()
	{
		return ~~((new Date()).getTime() / T.cMSECONDS_IN_SECOND);
	},
	
	/*
	 * Increments a Date object by number of days.
	 * @param object pDate.
	 * @param int pDays to increment. Can be negative.
	 * @returns object Date.
	 */
	addDaysToDate: function(pDate, pDays)
	{
		var newdate = new Date(pDate);
		newdate.setDate(pDate.getDate() + pDays);
		return newdate;
	},
	
	/*
	 * Gets the number of days in a month.
	 * @param object pDate
	 * @returns int days
	 * Source: http://stackoverflow.com/questions/1184334/get-number-days-in-a-specified-month-using-javascript
	 */
	getDaysInMonth: function(pDate)
	{
		return (new Date(pDate.getUTCFullYear(), pDate.getUTCMonth() + 1, 0)).getUTCDate();
	},
	
	/*
	 * Gets the minutes elapsed in the current even hour of UTC.
	 * Example: 14:00 = 0, 14:20 = 20, 15:59 = 119, 16:00 = 0
	 * @returns int minutes.
	 */
	getCurrentBihourlyMinutesUTC: function()
	{
		var now = new Date();
		return ((now.getUTCHours() % 2) * T.cMINUTES_IN_HOUR) + now.getUTCMinutes();
	},
	
	/*
	 * Gets the timestamp for the current two-hour period.
	 * @param int pOffset minutes since the start of the current even hour.
	 * @returns string timestamp.
	 */
	getCurrentBihourlyTimestampLocal: function(pOffset)
	{
		var now = new Date();
		var hour = now.getUTCHours();
		var evenhour = (hour % 2 === 0) ? hour : (hour - 1);
		
		var time = ((evenhour * T.cMINUTES_IN_HOUR)) - now.getTimezoneOffset();
		time = T.wrapInteger(time, T.cMINUTES_IN_DAY);
		return T.getTimeFormatted({
			aCustomTimeInSeconds: ((time + pOffset) * T.cSECONDS_IN_MINUTE),
			aWantSeconds: false
		});
	},
	
	/*
	 * Gets the seconds until a time within a week.
	 * @param int pWeekTime the target time in seconds since Sunday 00:00 UTC.
	 * @param int pCurrentTimestamp UNIX seconds.
	 * @param int pSecondsSinceMidnight UTC.
	 * @returns int seconds.
	 */
	getSecondsTillWeektime: function(pWeekTime, pSecondsSinceMidnight)
	{
		var secondssinceweekstart = T.getSecondsSinceWeekstart(pSecondsSinceMidnight);
		return (secondssinceweekstart > pWeekTime) ?
			((T.cSECONDS_IN_WEEK - secondssinceweekstart) + pWeekTime) :
			(pWeekTime - secondssinceweekstart);
	},
	
	/*
	 * Counts down till weekly reset. For use by the personal checklist.
	 */
	updateChecklistCountdowns: function()
	{
		var dstr = T.formatTimeLetter(T.SECONDS_TILL_DAILY, true);
		var wstr = T.formatTimeLetter(T.SECONDS_TILL_WEEKLY, true);
		$(".jsCountdownToDaily").text(dstr);
		$(".jsCountdownToWeekly").text(wstr);
	},
	
	/*
	 * Converts an API daily object to a nickname based object with similar structure.
	 * @param object pObj from API.
	 * @returns object reformatted.
	 */
	convertDailyObject: function(pObj)
	{
		var dailyobj = {
			pve: [],
			pvp: [],
			wvw: [],
			fractals: []
		};
		var a = T.DailyAssociation;
		var newpve = [];
		for (var i = 0; i < pObj.pve.length; i++)
		{
			var ithdaily = pObj.pve[i];
			// Only allow max level and max expansion access dailies
			if (ithdaily.level.max === Q.GameLimit.LevelMax)
			{
				for (var ii = 0; ii < ithdaily.required_access.length; ii++)
				{
					if (ithdaily.required_access[ii] === T.Daily.AccessEnum.Max)
					{
						newpve.push(ithdaily);
						break;
					}
				}
			}
		}
		var sets = {
			pve: newpve,
			pvp: pObj.pvp,
			wvw: pObj.wvw
		};
		
		// Turn the achievement IDs into achievement nicknames
		for (var i in sets)
		{
			var ithset = sets[i];
			for (var ii in ithset)
			{
				if (a[(ithset[ii].id)])
				{
					// First keyword in the daily string is the achievement ID
					dailyobj[i].push(ithset[ii].id + " " + a[(ithset[ii].id)]);
				}
				else
				{
					dailyobj[i].push("0 unknown");
				}
			}
		}
		
		// Flatten API's fractal array of objects into an array of IDs
		for (var i in pObj.fractals)
		{
			var id = pObj.fractals[i].id;
			dailyobj.fractals.push(id);
		}
		
		return dailyobj;
	},
	
	/*
	 * Extracts the daily world boss from a daily object.
	 * @param object pDaily that was converted from the API object.
	 * @returns object chain or null if invalid boss.
	 */
	extractDailyChain: function(pDaily)
	{
		if (pDaily && pDaily.pve)
		{
			for (var i in pDaily.pve)
			{
				var dcode = pDaily.pve[i].split(" ");
				if (dcode[1] === "Boss")
				{
					return C.getChainByAlias(dcode[2].toLowerCase());
				}
			}
		}
		return null;
	},
	
	/*
	 * Initializes the daily object and the today chain object.
	 * @objparam boolean aWantGetTomorrow whether to get tomorrow's daily object instead.
	 * @objparam boolean aWantSetTomorrow whether to set today's daily object as tomorrow's.
	 * @objparam boolean aIsReset whether to also do daily reset related functions.
	 * @returns jqXHR object.
	 */
	getDaily: function(pSettings)
	{
		var Settings = pSettings || {};
		var retrywaitminutes = 3;
		var url = (Settings.aWantGetTomorrow || Settings.aWantSetTomorrow) ? U.URL_API.Tomorrow : U.URL_API.Daily;
		
		return $.getJSON(url, function(pData)
		{
			if (Settings.aWantGetTomorrow) // Get tomorrow
			{
				T.DailyTomorrow = T.convertDailyObject(pData);
				C.ChainTomorrow = T.extractDailyChain(T.DailyTomorrow);
			}
			else // Get today
			{
				T.DailyToday = T.convertDailyObject(pData);
				// Initialize today chain object
				var dailychain = T.extractDailyChain(T.DailyToday);
				var currentmins = T.getTimeSinceMidnight(T.ReferenceEnum.UTC, T.UnitEnum.Minutes);
				var startmins;

				if (dailychain !== null)
				{
					startmins = T.convertScheduleKeyToUTCMinutes(dailychain.scheduleKeys[0]);
					
					if (Settings.aWantSetTomorrow)
					{
						C.ChainToday = dailychain; // SUCCESS SET TOMORROW
					}
					else
					{
						/*
						 * If the today chain object was already parsed, make sure that
						 * the retrieved API daily object is different from it, in case
						 * the API server was not updated immediately at reset time.
						 */
						if (C.ChainToday !== null && Settings.aIsReset)
						{
							var previousalias = C.ChainToday.alias;
							C.ChainToday = null; // Single recursion base case
							C.refreshChainDailyIcon();
							if (dailychain.alias === previousalias)
							{
								// Wait a while and retrieve the daily object hoping it is updated
								setTimeout(function()
								{
									T.getDaily({aIsReset: true});
								},  retrywaitminutes * T.cMSECONDS_IN_MINUTE);
								return;
							}
						}

						// Make sure today's boss can still spawn before server reset at UTC midnight
						if (startmins + T.cMINUTES_IN_TIMEFRAME >= currentmins)
						{
							C.ChainToday = dailychain; // SUCCESS SET TODAY
						}
						// Else get tomorrow's boss
						else
						{
							T.getDaily({aWantSetTomorrow: true});
						}
					}
				}
				else
				{
					// No boss for this day
					C.ChainToday = null;
				}

				/*
				 * If successfully retrieved today chain object.
				 */
				if (C.ChainToday)
				{
					// Update daily icons
					C.refreshChainDailyIcon();
					if (Settings.aIsReset === true)
					{
						if (O.isServerReset)
						{
							// Tell today's world boss closest scheduled time if server resetted
							var dailybossstr = D.getModifiedWord("boss", "daily", U.CaseEnum.Sentence) + " "
								+ D.getObjectName(C.ChainToday) + " " + D.getTranslation("will start") + " " + D.getTranslation("at") + " "
								+ T.getTimeFormatted(
								{
									aWantSeconds: false,
									aCustomTimeInSeconds: T.convertScheduleKeyToLocalSeconds(C.ChainToday.scheduleKeys[0])
								}) + " " + D.getTranslation("in") + " "
								+ T.getTimeFormatted(
								{
									aWantLetters: true,
									aWantSeconds: false,
									aCustomTimeInSeconds: T.getSecondsUntilChainStarts(C.ChainToday)
								});
							I.greet(dailybossstr, 15);
						}

						// Subscribe to daily chain
						if (O.Options.bol_alertAutosubscribe &&
							O.Options.int_setAlarm === O.IntEnum.Alarm.Subscription)
						{
							var subscriptionbutton = $("#chnTime_" + C.ChainToday.nexus);
							if ( ! subscriptionbutton.hasClass("chnTimeSubscribed"))
							{
								subscriptionbutton.trigger("click");
							}
						}
					}
				}
				if (Settings.aIsReset === true && O.isServerReset)
				{
					// Mention special dailies if appropriate
					if (T.DailyToday.pve && T.DailyToday.pve[1].indexOf("Forger") !== -1)
					{
						var dailyspecialstr = U.convertExternalString(H.Announcement.Messages.Forger);
						I.greet(dailyspecialstr, 25);
						if (O.Options.bol_alertMystic)
						{
							setTimeout(function()
							{
								D.speak(U.toText(dailyspecialstr));
							}, 5000);
						}
					}
				}
			}
		});
	}
	
};
H = {
/* =============================================================================
 * @@Horologe dashboard, timeline, and time sensitive content
 * ========================================================================== */

	Announcement: GW2T_DASHBOARD_DATA.Announcement,
	Countdown: GW2T_DASHBOARD_DATA.Countdown,
	Story: GW2T_DASHBOARD_DATA.Story,
	Faux: GW2T_DASHBOARD_DATA.Faux,
	Sale: GW2T_SALE_DATA,
	Pact: GW2T_DASHBOARD_DATA.Pact,
	SaleCountdowns: null, // Will contain expiration date in UNIX seconds, accessed by Items array index number
	GemSubscription: null,
	isDashboardEnabled: true,
	isAnnouncementEnabled: false,
	isCountdownEnabled: false,
	isCountdownTickEnabled: false,
	isStoryEnabled: false,
	isStoryDashboard: true,
	isDailyEnabled: true,
	isSaleEnabled: false,
	isSaleOpened: false,
	isGemPaused: false,
	isPactEnabled: true,
	isVertical: true,
	
	Timeline: GW2T_TIMELINE,
	isTimelineEnabled: true,
	isTimelineGenerated: false,
	minutesInTimelineSpacing: null, // Must be a divisor of 120 minutes

	/*
	 * Initializes dashboard components.
	 * Must be executed before the clock tick function executes.
	 */
	initializeDashboard: function()
	{
		var now = new Date();
		// Verify countdown: if at least one countdown has not expired
		for (var i = 0; i < H.Countdown.Events.length; i++)
		{
			if (H.Countdown.Events[i].Finish && now < H.Countdown.Events[i].Finish)
			{
				H.isCountdownEnabled = true;
				break;
			}
		}
		
		// Verify announcement: if announcement exists
		var announcement = H.getAnnouncement(H.Announcement.NewsPVE);
		if (announcement)
		{
			var annprefix = "<strong>" + D.getWordCapital("new") + ": </strong>";
			var announcementlinks = $("#dsbAnnouncement").show().html(annprefix + announcement).find("a");
			U.convertExternalLink(announcementlinks);
			U.convertInternalLink(announcementlinks);
			M.bindMapLinks("#dsbAnnouncement");
			H.isAnnouncementEnabled = true;
		}
		
		// Verify sale: if sale exists and has not expired
		if (H.Sale.Items.length - H.Sale.numPaddingItems > 0 && T.isTimely(H.Sale, now))
		{
			H.isSaleEnabled = true;
		}
		
		// Make sure at least one component of the dashboard is enabled, else disable the dashboard
		if ((H.isCountdownEnabled === false
				&& H.isAnnouncementEnabled === false
				&& H.isSaleEnabled === false
				&& H.isPactEnabled === false)
			|| H.isDashboardEnabled === false)
		{
			H.isDashboardEnabled = false;
			return;
		}
		else
		{
			if (O.Options.bol_showDashboard === false)
			{
				H.toggleDashboard(true);
			}
			H.isCountdownTickEnabled = true;
		}
		
		// Button to toggle the dashboard
		$("#dsbToggle").click(function()
		{
			$("#opt_bol_showDashboard").trigger("click");
		});
		
		// Initialize countdown entries
		if (H.isCountdownEnabled)
		{
			$("#dsbCountdown").show();
			var urlkey = D.getURLKey();
			var ctd;
			var countdownname;
			var url;
			
			// Initialize countdowns
			for (var i = 0; i < H.Countdown.Events.length; i++)
			{
				// Initialize countdown properties
				ctd = H.Countdown.Events[i];
				ctd.isTimely = true;
				ctd.StartStamp = T.formatWeektime(ctd.Start, true);
				ctd.FinishStamp = T.formatWeektime(ctd.Finish, true);
				// Use default name if available, or use the translated name
				countdownname = (ctd.name === undefined) ? D.getObjectName(ctd) : ctd.name;
				// If available: set the URL as the official news page, the translated url, or a regular url
				url = (ctd.official === undefined) ? ctd[urlkey] : U.getGW2OfficialLink(ctd.official);
				url = (url === undefined) ? ctd.url : url;
				if (url.indexOf(I.cSiteURL) !== -1)
				{
					// Don't externalize URL if self link
					ctd.Anchor = "<a href='" + url + "'>" + countdownname + "</a>";
				}
				else
				{
					ctd.Anchor = "<a" + U.convertExternalAnchor(url) + ">" + countdownname + "</a>";
				}
				
				/*
				 * code: the colored bullet point for activity status
				 * time: the countdown time
				 * abbr: the up or down arrow for start or finish start
				 * var: the start or finish time
				 */
				$("#dsbCountdown").append(
					"<div id='dsbCountdown_" + i + "' class='dsbCountdownEntry'>"
						+ "<div class='dsbCountdownSide0'><code></code>" + ctd.Anchor + "</div> "
						+ "<div class='dsbCountdownSide1'>"
							+ "<time id='dsbCountdownTime_" + i + "'></time> "
							+ "<span class='dsbCountdownDate'><abbr></abbr> <var></var></span>"
						+ "</div>"
					+ "</div>");
			}
			I.qTip.init("#dsbCountdown");
			H.refreshDashboard(now);
		}
		
		// Initialize Living Story
		if (H.isStoryEnabled && H.isStoryDashboard)
		{
			var storytitle = D.getObjectName(H.Story);
			var storystr = (H.Story.url.length) ? "<a" + U.convertExternalAnchor(H.Story.url) + ">" + storytitle + "</a>" : storytitle;
			$("#dsbStory").prepend("<div id='dsbStoryTitle'>" + storystr + "</div>").show();
		}
		
		// Initialize sale
		if (H.isSaleEnabled)
		{
			H.generateDashboardSaleHeader();
		}
		
		// Initialize vendor
		if (H.isPactEnabled)
		{
			H.generateDashboardPactHeader();
		}
		
		// Initialize daily
		if (H.isDailyEnabled)
		{
			H.generateDashboardDailyHeader(now);
		}
		
		I.toggleToggleIcon(".dsbToggleIcon", false, false);
	},
	
	/*
	 * Gets an announcement string if its object has timely content.
	 * @param object pAnnouncement
	 * @returns boolean
	 */
	getAnnouncement: function(pAnnouncement, pDate)
	{
		if (pAnnouncement && pAnnouncement.content.length > 0 && T.isTimely(pAnnouncement, pDate))
		{
			return pAnnouncement.content;
		}
		return null;
	},
	getUrgent: function(pAnnouncement, pDate)
	{
		var announcement = H.getAnnouncement(pAnnouncement, pDate);
		if (announcement)
		{
			I.urge(announcement);
		}
	},
	
	/*
	 * Generates the header for the sale feature.
	 */
	generateDashboardSaleHeader: function()
	{
		var item;
		var gemarray = [];
		var isdiscounted = false;
		// Determine price range and whether a discount exists
		for (var i = 0; i < H.Sale.Items.length; i++)
		{
			item = H.Sale.Items[i];
			if (item.side === undefined) // Skip padding items which are headers
			{
				if (item.discount && (isFinite(item.discount) || (item.discount.length && item.discount[0].length > 2)))
				{
					isdiscounted = true;
				}
				if (item.p && item.p.gem)
				{
					gemarray.push(item.p.gem);
				}
			}
		}
		var range = T.getMinMax(gemarray);
		var rangestr = (range.oMin === range.oMax) ? range.oMax : (range.oMin + "-" + range.oMax);
		// Create "button" to toggle list of items on sale
		$("#dsbMenuSale").append("<div><kbd id='dsbSaleHeader' class='curToggle'>"
			+ "<img id='dsbSaleSymbol' src='img/ui/placeholder.png' /><img id='dsbSaleToggleIcon' class='dsbToggleIcon' src='img/ui/toggle.png' />"
			+ "<var>" + (H.Sale.Items.length - H.Sale.numPaddingItems) + " " + D.getWordCapital("promotions") + "</var> "
			+ "<span class='dsbSalePriceCurrent'>" + rangestr + "<ins class='s16 s16_gem'></ins></span></kbd>"
		+ "</div>").addClass("dsbTabEnabled");
		$("#dsbSale").append("<div id='dsbSaleTable' class='jsScrollable'></div>");
		// Determine if the current sale has price reduction
		$("#dsbSaleSymbol").attr("src", "img/ui/" + ((isdiscounted) ? "gemstore_special" : "gemstore") + I.cPNG);
		// Bind buttons
		$("#dsbMenuSale").click(function()
		{
			H.generateDashboardSale();
		});
	},
	generateDashboardSale: function()
	{
		var getPercentOffString = function(pPriceNew, pPriceOld)
		{
			return "<span class='dsbSalePercent'>" + U.convertRatioToPercent(-1 * (1 - (pPriceNew / pPriceOld)), 0) + "</span> ";
		};
		var getOldPriceString = function(pPriceNew, pPriceOld, pPriceOldBulk)
		{
			var oldpricestr = (pPriceOldBulk === undefined) ? pPriceOld : pPriceOldBulk;
			return getPercentOffString(pPriceNew, pPriceOld) + "<span class='dsbSalePriceOld'>" + oldpricestr + "</span> ";
		};
		var animationspeed = 200;
		var table = $("#dsbSaleTable");
		if (H.isVertical)
		{
			table.addClass("dsbSaleVertical");
		}
		
		var doGenerate = function()
		{
			I.toggleToggleIcon("#dsbSaleToggleIcon", true);
			table.empty();
			if (H.Sale.note.length > 0)
			{
				table.append("<div class='dsbNote'>Note: " + U.convertExternalString(H.Sale.note) + "</div>");
			}
			table.append("<div id='dsbSaleSide0'></div><div id='dsbSaleSide1'></div>");

			var gemstr = "<ins class='s16 s16_gem'></ins>";
			// Include the exchange rate "items" after determining range
			H.SaleCountdowns = {};
			var idstofetch = [];
			var side = 0;
			for (var i = 0; i < H.Sale.Items.length; i++)
			{
				// Initialize variables
				var item = H.Sale.Items[i];
				var itemid = item.i;
				var itemname = item.n;
				var itemprice = E.getPaymentAmount(item);
				var itemdiscount = item.discount;
				var url = item.url || U.getWikiSearchDefault(itemname);
				var video = U.getYouTubeLink(itemname);
				side = (item.side !== undefined) ? item.side : side;
				if (item.Finish)
				{
					// Skip expired items, if has expiration
					if (T.isTimely(item) === false)
					{
						continue;
					}
					H.SaleCountdowns[i] = ~~(item.Finish.getTime() / T.cMSECONDS_IN_SECOND);
				}

				var oldprice = null;
				// Old price also includes percent off by dividing the new with the old
				oldprice = (U.isInteger(itemdiscount)) ? itemdiscount : oldprice;
				oldprice = (Array.isArray(itemdiscount) && itemdiscount[0].length > 2) ? ((itemdiscount[0])[2]) : oldprice;
				var oldpricestr = (oldprice !== null) ? getOldPriceString(itemprice, oldprice) : "";
				// Write bulk discount hover information if available
				var discountstr = "";
				if (itemdiscount && Array.isArray(itemdiscount))
				{
					discountstr += "<span class='dsbDiscount'>";
					for (var ii = 0; ii < itemdiscount.length; ii++)
					{
						var disc = itemdiscount[ii];
						var priceper = Math.ceil(disc[1] / disc[0]);
						// Percent off for bulk discount comes from the price per item in the bulk--divided by the old price for a single (non-bulk) item
						var oldpriceinner = (disc.length > 2) ? getOldPriceString(priceper, (itemdiscount[0])[2], disc[2]) : getPercentOffString(priceper, (itemdiscount[0])[1]);
						var divisorstr = (disc[0] > 1) ? ("/" + disc[0] + " = " + Math.ceil(disc[1] / disc[0]) + gemstr) : "";
						discountstr += oldpriceinner + "<span class='dsbSalePriceCurrent'>" + " " + E.formatGemToCoin(disc[1]) + I.Symbol.ArrowRight + disc[1] + gemstr + divisorstr + "</span>"
							+ " " + "<br />";
					}
					discountstr += "</span>";
				}
				// Price display
				var pricestr = "";
				if (item.p["gem"])
				{
					pricestr = "<span class='dsbSalePriceCoin'>" + E.formatGemToCoin(itemprice) + " " + I.Symbol.ArrowRight + " </span>"
						+ "<span class='dsbSalePriceMoney'>" + E.formatGemToMoney(itemprice) + " = </span>"
						+ "<span class='dsbSalePriceCurrent'>" + itemprice + gemstr + "</span>";
					
				}
				else if (item.p["coin"])
				{
					pricestr = "<span class='dsbSalePriceCurrent'>" + E.formatGemString(E.convertCoinToGem(itemprice)) + "</span> " + I.Symbol.ArrowRight + " "
						+ "<span class='dsbSalePriceCoin'>" + E.formatCoinStringShort(itemprice) + "</span>"
						+ "<span class='dsbSalePriceMoney'> = " + E.formatGemToMoney(E.convertCoinToGem(itemprice)) + "</span>";
				}
				else if (item.p["blticket"])
				{
					pricestr = "<span class='dsbSalePriceCurrent'>" + E.PaymentFormat["blticket"](itemprice) + "</span>";
				}
				// Format the presentation of this item
				var idisimg = isNaN(itemid) && Q.Boxes.Items[itemid] === undefined;
				if (idisimg === false)
				{
					idstofetch.push(itemid);
				}
				var idprop = (idisimg) ? "" : ("id='dsbSaleEntry_" + itemid + "'");
				var imgsrc = (idisimg) ? itemid : "img/ui/placeholder.png";
				$("#dsbSaleSide" + side).append("<div class='dsbSaleEntry' " + idprop + ">"
					+ "<div class='dsbSaleItem'>"
						+ "<a" + U.convertExternalAnchor(url) + "><img class='dsbSaleIcon' src='" + imgsrc + "' /></a> "
						+ "<span class='dsbSaleVideo'> <a" + U.convertExternalAnchor(video) + "'><ins class='s16 s16_youtube'></ins></a> </span>"
						+ "<var class='dsbSaleName'>" + itemname + "</var>"
					+ "</div>"
					+ "<div class='dsbSaleInfo'>"
						+ "<span id='dsbSaleCountdown_" + i + "' class='dsbSaleCountdown'></span>"
						+ pricestr
						+ oldpricestr
						+ discountstr
					+ "</div>"
				+ "</div>");
			}

			var height = table.height();
			table.css({height: 0}).animate({height: height}, animationspeed, function()
			{
				$(this).css({height: "auto"});
			});
			// Retrieve item info
			Q.getItems(idstofetch, function()
			{
				for (var i in idstofetch)
				{
					var item = Q.getCachedItem(idstofetch[i]);
					if (item)
					{
						var entry = $("#dsbSaleEntry_" + idstofetch[i]);
						Q.scanItem(item, {aElement: entry.find(".dsbSaleIcon").attr("src", item.icon)});
						entry.find(".dsbSaleName").html(item.name).addClass(Q.getRarityClass(item.rarity));
					}
				}
			});
		};
		
		// Dashboard tab functionality
		if (table.is(":empty") === false)
		{
			H.isSaleOpened = false;
			I.toggleToggleIcon("#dsbSaleToggleIcon", false);
			table.animate({height: 0}, animationspeed, function()
			{
				$(this).css({height: "auto"}).empty();
				$("#dsbSale").hide();
				$("#dsbMenuSale").removeClass("dsbTabActive");
			});
		}
		else
		{
			H.isSaleOpened = true;
			$("#dsbSale").show();
			$("#dsbMenuSale").addClass("dsbTabActive");
			table.append(I.cThrobber);
			Q.initializeFaux();
			H.updateSaleData(function()
			{
				if (I.isAPIEnabled)
				{
					doGenerate();
				}
				else
				{
					Q.loadItemsSubdatabase("gem", function()
					{
						doGenerate();
					});
				}
			});
		}
	},
	updateDashboardSaleCountdown: function()
	{
		for (var i in H.SaleCountdowns)
		{
			var sec = H.SaleCountdowns[i] - T.TIMESTAMP_UNIX_SECONDS;
			if (sec > T.cSECONDS_IN_DAY)
			{
				$("#dsbSaleCountdown_" + i).html("<span class='dsbSaleCountdownFar'>" + T.formatTimeLetter(sec, true, true) + "</span>");
				delete H.SaleCountdowns[i]; // These will be restored when the gem dashboard is reopened
			}
			else
			{
				$("#dsbSaleCountdown_" + i).html(T.formatTimeLetter(sec, true));
			}
		}
	},
	
	/*
	 * Macro function for redownloading the sale data and exchange rates.
	 * @param function pCallback
	 */
	updateSaleData: function(pCallback)
	{
		U.getScript(U.URL_DATA.Sale, function()
		{
			H.Sale = GW2T_SALE_DATA;
			E.updateExchangeRatios(function()
			{
				pCallback();
			});
		}, false);
	},
	
	/*
	 * Initializes the gem store subscription object.
	 * @param boolean pWantClear whether to wipe all subscriptions.
	 * @returns object
	 */
	initializeGemSubscription: function(pWantClear)
	{
		var key = O.Utilities.GemSubscription.key;
		H.GemSubscription = {};
		if (localStorage[key] === undefined || pWantClear)
		{
			localStorage[key] = JSON.stringify(H.GemSubscription);
		}
		if (pWantClear !== true)
		{
			try
			{
				var tempsubs = JSON.parse(localStorage[key]);
				// Convert legacy format of two arrays into one assoc
				if (Array.isArray(tempsubs.Available) && Array.isArray(tempsubs.Discounted))
				{
					tempsubs.Available.forEach(function(iID)
					{
						H.subscribeGemAvailable(iID);
					});
					tempsubs.Discounted.forEach(function(iID)
					{
						H.subscribeGemDiscounted(iID);
					});
					H.saveGemSubscription();
				}
				else if (typeof tempsubs === "object")
				{
					H.GemSubscription = tempsubs;
				}
			}
			catch (e) {}
		}
	},
	subscribeGemAvailable: function(pID)
	{
		H.GemSubscription[pID] = X.ChecklistEnum.Tracked;
	},
	subscribeGemDiscounted: function(pID)
	{
		H.GemSubscription[pID] = X.ChecklistEnum.Found;
	},
	isGemSubscribedForAvailable: function(pID)
	{
		if (H.GemSubscription[pID] === X.ChecklistEnum.Tracked)
		{
			return true;
		}
		return false;
	},
	isGemSubscribedForDiscounted: function(pID)
	{
		if (H.GemSubscription[pID] === X.ChecklistEnum.Found)
		{
			return true;
		}
		return false;
	},
	isGemSubscribed: function(pID)
	{
		if (H.GemSubscription[pID])
		{
			return true;
		}
		return false;
	},
	unsubscribeGem: function(pID)
	{
		delete H.GemSubscription[pID];
	},
	saveGemSubscription: function()
	{
		localStorage[O.Utilities.GemSubscription.key] = JSON.stringify(H.GemSubscription);
	},
	
	/*
	 * Downloads the gem record and checks against subscription for alerts.
	 * @param function pCallback if and for generating the gem store gallery.
	 * If no callback is provided then assume it is a checkup call.
	 */
	updateGemSubscription: function(pCallback)
	{
		var section = "Gem";
		var getUnsubscribeLink = function(pID)
		{
			return "<a class='jsGemUnsubscribe' data-item='" + pID + "'>" + D.getPhraseOriginal("Unsubscribe this item") + "?</a>";
		};
		var checkSubscriptions = function()
		{
			if (H.GemSubscription === null)
			{
				H.initializeGemSubscription();
			}
			// Initialize price assoc
			var issalecurrent = T.isTimely(H.Sale);
			for (var i = 0; i < H.Sale.Items.length; i++)
			{
				var item = H.Sale.Items[i];
				// Allow integer IDs or faux IDs and ignore expired
				if (item.side === undefined && (T.isTimely(item) || (item.Finish === undefined && issalecurrent)))
				{
					// An item may have its own expiration, otherwise the entire sale's expiration is used for comparison
					H.Sale.Values[item.i] = E.getPaymentAmount(item);
				}
			}
			
			// Execute gem store gallery callback
			if (pCallback)
			{
				pCallback();
				return;
			}
			
			// Do the subscription alerts if gallery callback not provided
			var record = U.getRecordData(section);
			var isavailable = false;
			var isdiscounted = false;
			var alertstr = D.getWord("alarm");
			var availablestr = D.getPhraseOriginal(" gem item is available");
			var discountstr = D.getPhraseOriginal(" gem item discount");
			A.iterateRecord(record, function(pEntry)
			{
				var id = pEntry.i;
				var value = E.getPaymentAmount(pEntry);
				var salevalue = H.Sale.Values[id];
				var isavailableinrecord = false;
				var isavailableinsale = false;
				var isdiscountedinsale = false;
				if (value > 0)
				{
					isavailableinrecord = true;
				}
				if (salevalue >= 0)
				{
					isavailableinsale = true;
					value = Math.abs(value); // If exists in promotions then consider as available in the record
				}
				if (salevalue < value || salevalue === 0)
				{
					isdiscountedinsale = true;
				}
				
				// Check for available
				if (H.isGemSubscribedForAvailable(id) && (isavailableinsale || isavailableinrecord))
				{
					I.print(pEntry.n + availablestr + "! " + getUnsubscribeLink(id));
					isavailable = true;
				}
				// Check for discount
				if (H.isGemSubscribedForDiscounted(id))
				{
					if (isdiscountedinsale)
					{
						I.print(pEntry.n + discountstr + "! " + E.formatGemString(value) + " − "
							+ E.formatGemString(value - salevalue) + " = " + E.formatGemString(salevalue) + " " + getUnsubscribeLink(id));
						isdiscounted = true;
					}
					// If item is no longer available, then convert the discount subscription to an availability subscription
					else if (salevalue === undefined && isavailableinrecord === false)
					{
						H.subscribeGemAvailable(id);
						H.saveGemSubscription();
					}
				}
			});
			
			// Bind the printed unsubscribe link
			$(".jsGemUnsubscribe").each(function()
			{
				var id = $(this).removeClass("jsGemUnsubscribe").attr("data-item");
				if (id)
				{
					$(this).click(function()
					{
						H.unsubscribeGem(id);
						H.saveGemSubscription();
						I.print(D.getWordCapital("done") + ".");
					});
				}
			});
			
			// Speak the alert
			if (O.Options.bol_alertGem)
			{
				if (isavailable)
				{
					D.speak(alertstr + "! " + availablestr);
				}
				if (isdiscounted)
				{
					D.speak(alertstr + "! " + discountstr);
				}
			}
			if (isavailable || isdiscounted)
			{
				I.print("<a data-page='Gem'>" + D.getPhraseOriginal("View Gem Wishlist") + "</a> - "
					+ "<a id='dsbGemPause_" + T.TIMESTAMP_UNIX_SECONDS + "'>" + D.getPhraseOriginal("Pause alarm") + "</a> - "
					+ "<a href='http://gw2timer.com/?bol_alertGem=false'>" + D.getPhraseOriginal("Disable alarm") + "</a>");
				I.bindConsoleLink();
				$("#dsbGemPause_" + T.TIMESTAMP_UNIX_SECONDS).click(function()
				{
					H.isGemPaused = true;
					I.clear();
				});
			}
		};
		
		// Retrieve data first
		U.getScript(U.URL_DATA.Gem, function()
		{
			H.updateSaleData(function()
			{
				checkSubscriptions();
			});
		}, false);
	},
	
	/*
	 * Generates the header for the vendor feature.
	 */
	generateDashboardPactHeader: function(pIsReset)
	{
		var weekdaylocation = H.getDashboardPactWeekday();
		var vendorname = D.getObjectName(H.Pact);
		var vendorcodes = "";
		for (var i in H.Pact.Codes)
		{
			vendorcodes += i + "@" + (H.Pact.Codes[i])[weekdaylocation] + " ";
		}
		vendorcodes += "- " + vendorname;
		var menubutton = $("#dsbMenuPact");
		menubutton.empty().append("<div><kbd id='dsbPactHeader' class='curToggle'>"
			+ "<img src='img/map/vendor_karma.png' /><img id='dsbPactToggleIcon' class='dsbToggleIcon' src='img/ui/toggle.png' />"
			+ "<var>" + vendorname + "</var></kbd></div>").addClass("dsbTabEnabled");
		$("#dsbPact").empty().append("<div id='dsbPactMenu'>"
			+ "<img data-src='img/map/waypoint.png' style='width:32px;height:32px;' /><input id='dsbPactCodes' class='cssInputText jsTitle' type='text' value='" + vendorcodes + "' "
				+ "title='<dfn>Copy and paste</dfn> this into game chat to follow.' /> "
			+ ((I.isMapEnabled) ? "<img data-src='img/map/path.png' /><dfn class='curZoom' id='dsbPactDraw'>" + D.getPhrase("draw route", U.CaseEnum.Every) + "</dfn> " : "")
			+ "<a class='jsTitle'" + U.convertExternalAnchor("http://wiki.guildwars2.com/wiki/Pact_Supply_Network_Agent")
				+ "title='New items at daily reset.<br />New vendor locations 8 hours after that.<br />Limit 1 purchase per vendor per day.'>"
				+ "<img data-src='img/ui/menu/info.png' />" + D.getWordCapital("info") + "</a> "
			+ "<a id='dsbPactHistoryLink' class='jsTitle' data-page='Pact' title='Previous recipes and frequency statistics.'>"
				+ "<img data-src='img/ui/tradingpost.png' />" + D.getWordCapital("history") + "</a> "
			+ "<a class='jsTitle'" + U.convertExternalAnchor(H.Pact.SpreadsheetEdit)
				+ "title='Update and verify the collaborative daily offers list.'>"
				+ "<img data-src='img/ui/import.png' />" + D.getWordCapital("update") + "</a>"
			+ "</div><div id='dsbPactTable' class='jsScrollable'></div>").hide();
		I.qTip.reinit();
		U.convertInternalLink("#dsbPactHistoryLink");

		// Bind buttons
		var vendorcopy = I.bindInputSelect("#dsbPactCodes");
		I.bindClipboard(vendorcopy, vendorcodes);
		if (pIsReset)
		{
			menubutton.unbind("click");
		}
		menubutton.click(function()
		{
			H.generateDashboardPact();
		});
		$("#dsbPactDraw").click(function()
		{
			if ($(this).data("hasDrawn") !== true)
			{
				var coords = [];
				for (var i in H.Pact.Coords)
				{
					var coord = (H.Pact.Coords[i])[weekdaylocation];
					if (coord !== undefined)
					{
						coords.push(coord);
					}
				}
				M.redrawPersonalPath(P.getGreedyPath(coords), "default");
				$(this).data("hasDrawn", true);
			}
			else
			{
				M.clearPersonalPins();
				$(this).data("hasDrawn", false);
			}
		});
	},
	generateDashboardPact: function()
	{
		var animationspeed = 200;
		var weekdaylocation = H.getDashboardPactWeekday();
		var defaultcoords = H.Pact.Coords[H.Pact.DefaultVendor];
		var table = $("#dsbPactTable");
		
		var finalizePactTable = function(pUpdateTime)
		{
			var height = table.height();
			table.css({height: 0}).animate({height: height}, animationspeed, function()
			{
				$(this).css({height: "auto"});
			});
			I.removeThrobber(table);
			// Insert timestamp of daily offers
			var timestamp = "";
			var expiredstr = "";
			if (pUpdateTime)
			{
				var updatetime = new Date(pUpdateTime);
				var now = new Date();
				timestamp = T.formatWeektime(pUpdateTime, true) + " (" + T.formatMilliseconds(now - updatetime) + " " + D.getWord("ago") + ")";
				expiredstr = (updatetime > T.ResetToday && updatetime < T.ResetTomorrow) ? "" : D.getWordCapital("expired") + ". ";
			}
			table.append("<div id='dsbPactNote'>This daily recipes list is user contributed. "
				+ "Please correct items using the <a" + U.convertExternalAnchor(H.Pact.SpreadsheetEdit) + ">Update</a> link."
				+ "<br />" + expiredstr + "<time id='dsbPactTime'>" + timestamp + "</time></div>");
		};
		
		var doGenerate = function(pData)
		{
			var updatetime;
			var list = {};
			var iserror = true;
			try
			{
				var data = pData.feed.entry[0];
				for (var i in H.Pact.OffersAssoc)
				{
					var id = parseInt(data["gsx$" + i.toLowerCase()].$t);
					if (id || H.Pact.Products[id])
					{
						list[i] = id;
						iserror = false;
					}
				}
				updatetime = pData.feed.updated.$t;
			}
			catch (e) {}
			if (iserror)
			{
				I.removeThrobber(table);
				I.write("Error parsing external data. Please collaboratively update the list.");
				return;
			}
			
			var idstofetch = [];
			for (var i in H.Pact.OffersAssoc)
			{
				var recipeid = list[i];
				var productid = H.Pact.Products[recipeid] || recipeid;
				idstofetch.push(recipeid);
				idstofetch.push(productid);
			}
			Q.getPricedItems(idstofetch, function()
			{
				for (var i in H.Pact.OffersAssoc)
				{
					var recipeid = list[i];
					if (recipeid === undefined)
					{
						continue;
					}
					var productid = H.Pact.Products[recipeid] || recipeid;
					var recipe = Q.getCachedItem(recipeid) || Q.getCachedItem(productid);
					var product = Q.getCachedItem(productid);
					if (recipe === null)
					{
						continue;
					}
					var wikiquery = (D.isLanguageDefault) ? recipe.name : recipeid.toString();
					$("<div id='dsbPactEntry_" + i + "' class='dsbPactEntry'></div>").appendTo(table).html(
						"<div class='dsbPactItem'>"
							+ "<a" + U.convertExternalAnchor(U.getWikiSearchDefault(wikiquery)) + "><img id='dsbPactIcon_" + i + "' class='dsbPactIcon' src='img/ui/placeholder.png' /></a> "
							+ "<span id='dsbPactName_" + i + "' class='dsbPactName curZoom " + Q.getRarityClass(recipe.rarity)
								+ "' data-coord='" + (H.Pact.Coords[i] || defaultcoords)[weekdaylocation] + "'>" + product.name + "</span> "
							+ "</div>"
						+ "<div class='dsbPactInfo'>"
							+ "<span class='dsbPactPriceCoin' id='dsbPactPriceCoin_" + i + "'></span> "
							+ "<span class='dsbPactVendor'>" + i + "</span> "
							+ "<span class='dsbPactPriceKarma'>" + E.formatKarmaString(H.Pact.Prices[recipeid] || H.Pact.PriceDefault) + "</span>"
						+ "</div>");
					// Get TP prices also
					var recipeprice = E.getCachedPrice(recipeid);
					var recipepricestr = (recipeprice) ? (E.formatCoinStringColored(recipeprice.oPriceSell)) : E.formatCoinStringColored(0);
					$("#dsbPactPriceCoin_" + i).html(recipepricestr);
					M.bindMapLinkBehavior($("#dsbPactName_" + i), M.ZoomEnum.Ground, M.Pin.Program);
					// Get the product that the recipe crafts
					var icon = $("#dsbPactIcon_" + i);
					icon.attr("src", product.icon);
					Q.scanItem(product, {aElement: icon});
				}
				finalizePactTable(updatetime);
			});
		};
		
		// Collapse and empty the table if currently expanded, else generate
		if ($("#dsbPactMenu").is(":visible"))
		{
			I.toggleToggleIcon("#dsbPactToggleIcon", false);
			table.animate({height: 0}, animationspeed, function()
			{
				$(this).css({height: "auto"}).empty();
				$("#dsbPact").hide();
				$("#dsbMenuPact").removeClass("dsbTabActive");
			});
		}
		else
		{
			$("#dsbPact").show();
			$("#dsbMenuPact").addClass("dsbTabActive");
			I.loadImg($("#dsbPactMenu"));
			I.toggleToggleIcon("#dsbPactToggleIcon", true);
			table.empty();
			
			if (H.Pact.isEnabled)
			{
				table.append(I.cThrobber);
				U.getJSON(H.Pact.SpreadsheetData, function(pData)
				{
					if (I.isAPIEnabled)
					{
						doGenerate(pData);
					}
					else
					{
						Q.loadItemsSubdatabase("pact", function()
						{
							doGenerate(pData);
						});
					}
				}, false);
			}
			else
			{
				for (var i in H.Pact.OffersAssoc)
				{
					var elm = $("<dfn id='dsbPactName_" + i + "' class='dsbPactName' data-coord='"
						+ (H.Pact.Coords[i] || defaultcoords)[weekdaylocation] + "'>" + i + "</dfn>").appendTo(table);
					M.bindMapLinkBehavior(elm, M.ZoomEnum.Ground, M.Pin.Program);
				}
			}
		}
	},
	getDashboardPactWeekday: function()
	{
		var now = new Date();
		var weekday = now.getUTCDay();
		var hour = now.getUTCHours();
		return (hour < H.Pact.resetHour) ? T.wrapInteger(weekday - 1, T.cDAYS_IN_WEEK) : weekday;
	},
	
	/*
	 * Generates the header for the daily feature.
	 */
	generateDashboardDailyHeader: function(pDate)
	{
		var headername = (I.ModeCurrent === I.ModeEnum.Overlay) ? D.getWordCapital("daily") : D.getModifiedWord("achievements", "daily", U.CaseEnum.Every);
		$("#dsbMenuDaily").empty().append("<div><kbd id='dsbDailyHeader' class='curToggle'>"
			+ "<img src='img/ui/daily.png' /><img id='dsbDailyToggleIcon' class='dsbToggleIcon' src='img/ui/toggle.png' />"
			+ "<var>" + headername + "</var></kbd>"
		+ "</div>").addClass("dsbTabEnabled").click(function()
		{
			H.generateDashboardDaily();
		}).one("click", function()
		{
			I.loadStylesheet("features");
		});
	},
	generateDashboardDaily: function()
	{
		var animationspeed = 200;
		var table = $("#dsbDaily");
		var now = new Date();
		
		// Collapse and empty the table if currently expanded, else generate
		if (table.is(":empty") === false)
		{
			I.toggleToggleIcon("#dsbDailyToggleIcon", false);
			table.animate({height: 0}, animationspeed, function()
			{
				$(this).css({height: "auto"}).empty();
				table.hide();
				$("#dsbMenuDaily").removeClass("dsbTabActive");
			});
		}
		else
		{
			table.show();
			$("#dsbMenuDaily").addClass("dsbTabActive");
			I.loadImg($("#dsbDailyMenu"));
			I.toggleToggleIcon("#dsbDailyToggleIcon", true);
			var calendar = $("<div class='dlyCalendar'></div>").appendTo(table);
			G.fillDailyCalendar(calendar, now, H.isVertical);
		}
	},
	
	/*
	 * Updates the countdown time in each countdown entries.
	 * Called by the clock tick function every 1 second.
	 * @param Date pDate for getting time.
	 */
	updateDashboardCountdown: function(pDate)
	{
		for (var i = 0; i < H.Countdown.Events.length; i++)
		{
			var ctd = H.Countdown.Events[i];
			if (ctd.isTimely)
			{
				var ithtime = (ctd.isIndefinite) ? I.Symbol.Infinity : T.formatTimeLetter(~~((ctd.DesiredTime.getTime() - pDate.getTime()) / T.cMSECONDS_IN_SECOND), true);
				document.getElementById("dsbCountdownTime_" + i).innerHTML = ithtime;
			}
		}
	},
	
	/*
	 * Refreshes timely components in the dashboard.
	 * Called by the clock tick function every 5 minutes.
	 * @param Date pDate to compare with deadlines.
	 */
	refreshDashboard: function(pDate)
	{
		var hour = pDate.getUTCHours();
		var minute = pDate.getUTCMinutes();
		
		// Update countdown text elements, or deactivate a countdown entry if expired
		for (var i in H.Countdown.Events)
		{
			var ctd = H.Countdown.Events[i];
			if (ctd.isTimely)
			{
				var countdownhtml = $("#dsbCountdown_" + i);
				var bulletclass;
				var arrow;
				var stamp;
				// Don't generate countdown for those that are past the start time
				if (pDate < ctd.Start)
				{
					ctd.DesiredTime = ctd.Start;
					bulletclass = "cssStateInactive";
					arrow = I.Symbol.ArrowUp + "@";
					stamp = ctd.StartStamp;
				}
				else if (pDate < ctd.Finish)
				{
					ctd.DesiredTime = ctd.Finish;
					bulletclass = "cssStateActive";
					arrow = I.Symbol.ArrowDown + "@";
					stamp = ctd.FinishStamp;
				}
				else
				{
					ctd.isTimely = false;
					countdownhtml.remove();
				}
				if (ctd.isIndefinite)
				{
					bulletclass = "cssStateWaiting";
					stamp = I.Symbol.Infinity;
				}

				if (ctd.isTimely)
				{
					countdownhtml.find("code").removeClass().addClass("cssState " + bulletclass);
					countdownhtml.find("abbr").text(arrow);
					countdownhtml.find("var").text(stamp);
				}
			}
		}
		
		// Deactivate outdated Living Story
		if (T.isTimely(H.Story, pDate) === false)
		{
			H.isStoryEnabled = false;
			$("#dsbStory").hide();
		}
		
		// Deactivate outdated sale
		if (T.isTimely(H.Sale, pDate) === false)
		{
			H.isSaleEnabled = false;
			$("#dsbSale").hide();
		}
		
		// Refresh vendor header at its specific time
		if (hour === H.Pact.resetHour && minute === 0)
		{
			H.generateDashboardPactHeader(true);
		}
	},
	
	/*
	 * Shows or hides the dashboard.
	 */
	toggleDashboard: function(pIsInitial)
	{
		I.toggleElement("#dsbContainer", O.Options.bol_showDashboard, "fast", pIsInitial);
	},
	
	/*
	 * Generates the timeline HTML.
	 */
	generateTimeline: function()
	{
		H.isTimelineGenerated = true;
		$("#tmlTitle").text(D.getWordCapital("timeline"));
		// Container for all the timelines
		var container = $("#tmlContainer").append("<div class='tmlLine curToggle' id='tmlHeader'></div>");
		$("#tmlHeader").click(function()
		{
			$("#opt_bol_condenseTimelineHeader").trigger("click");
		});
		// Initialize "checklist" so collapsed lines are remembered as so
		X.initializeChecklist(X.Checklists.Timeline, H.Timeline.length);
		// Create timeline
		for (var i = 0; i < H.Timeline.length; i++)
		{
			var chain = H.Timeline[i];
			var name = U.escapeHTML((chain.zone === undefined) ? D.getObjectName(chain) : M.getZoneName(chain.zone));
			// Container for segments of a timeline (chain)
			var linetitle = (chain.isWB) ? "" : ("title='<dfn>" + name + "</dfn>'");
			var lineclass = (chain.isWB) ? "tmlLineWB" : "tmlLineStandard";
			var line = $("<div class='tmlLine " + lineclass + "' " + linetitle + "></div>").appendTo(container);
			for (var ii = 0; ii < chain.Segments.length; ii++)
			{
				// Segments of a timeline (event)
				var event = chain.Segments[ii];
				var segmentprefix = "";
				var segmentname = (D.getObjectName(event) || "");
				var emptyclass = (event.primacy < C.EventPrimacyEnum.Primary) ? "tmlTimesliceEmpty" : "";
				var wbclass = (chain.isWB) ? "tmlTimesliceWB" : "";
				var wbdata = (chain.isWB) ? "data-offset='" + ii + "'" : "";
				var bossclass = (event.primacy === C.EventPrimacyEnum.Boss) ? "tmlSegmentNameBoss" : "";
				switch (event.primacy)
				{
					case C.EventPrimacyEnum.Normal: segmentprefix = I.Symbol.Ellipsis; break;
					case C.EventPrimacyEnum.Boss: segmentprefix = I.Symbol.Star + " "; break;
				}
				event.duration = T.parseChainTime(event.duration);
				event.time = T.parseChainTime(event.time);
				var width = (event.duration / T.cMINUTES_IN_2_HOURS) * T.cPERCENT_100;
				line.append(
				"<div class='tmlSegment tmlTimeslice " + wbclass + " " + emptyclass + "' style='width:" + width + "%' "
				+ "data-start='" + event.time + "' data-finish='" + (event.time + event.duration) + "' " + wbdata + ">"
					+ "<div class='tmlSegmentContent'>"
						+ "<span class='tmlSegmentName " + bossclass + "'>" + segmentprefix + segmentname + "</span>"
						+ "<span class='tmlSegmentCountdown'></span>"
						+ "<var class='tmlSegmentSpecial'></var>"
					+ "</div>"
				+ "</div>");
			}
			// Line collapse behavior
			(function(iLine, iIndex)
			{
				$("<kbd class='tmlLineCollapse jsSleepable' title='" + D.getWordCapital("hide") + " <dfn>" + name + "</dfn>'></kbd>").appendTo(iLine).click(function()
				{
					iLine.hide("fast");
					X.setChecklistItem(X.Checklists.Timeline, iIndex, X.ChecklistEnum.Disabled);
				});
			})(line, i);
			if (X.getChecklistItem(X.Checklists.Timeline, i) === X.ChecklistEnum.Disabled)
			{
				line.hide();
			}
		}
		
		// Bind window buttons
		$("#tmlToggle").click(function()
		{
			$("#opt_bol_showTimeline").trigger("click");
		});
		$("#tmlCondense").click(function()
		{
			$("#opt_bol_condenseTimelineLine").trigger("click");
		});
		$("#tmlOpaque").click(function()
		{
			$("#opt_bol_opaqueTimeline").trigger("click");
		});
		
		// Initialize
		O.Enact.bol_condenseTimelineHeader(true);
		O.Enact.bol_condenseTimelineLine(true);
		H.toggleTimeline(true);
		H.opaqueTimeline();
		I.qTip.init(".tmlLine");
		$("#itemTimeline").show();
	},
	
	/*
	 * Moves the "minute hand" and updates countdowns. Should be called every 1 minute.
	 */
	updateTimelineIndicator: function()
	{
		if (H.isTimelineGenerated === false)
		{
			return;
		}
		var cycleminutes = T.cMINUTES_IN_2_HOURS;
		var currentminute = T.getCurrentBihourlyMinutesUTC();
		var offsetpercent = (currentminute / cycleminutes) * T.cPERCENT_100;
		$("#tmlIndicator").css({left: offsetpercent + "%"});
		$(".tmlLineName").css({left: offsetpercent + "%"});
		
		// Update the countdowns next to the segment names
		$(".tmlTimeslice").each(function()
		{
			// Show the time until event start
			var isactive = $(this).hasClass("tmlSegmentActive");
			var countdown = $(this).find(".tmlSegmentCountdown");
			var minutesremaining = $(this).data("start") - currentminute;
			minutesremaining = (minutesremaining === 0) ? cycleminutes : T.wrapInteger(minutesremaining, cycleminutes);
			if (($(this).hasClass("tmlTimesliceWB") && isactive) || $(this).hasClass("tmlTimesliceEmpty"))
			{
				// If timeslice is for active world bosses
				countdown.html("");
			}
			else
			{
				countdown.html(T.formatMinutes(minutesremaining));
			}
		});
		
		// Update current time
		if (I.ModeCurrent === I.ModeEnum.Overlay)
		{
			// If on overlay then change the current active timestamp
			$(".tmlTimestampActive").find(".tmlSegmentTimestamp").text(K.currentDaytimeString);
		}
		else
		{
			// Otherwise change the indicator's text
			$("#tmlIndicatorTime").html(K.currentDaytimeText);
		}
		
		// Reposition the indicator's time text if outside of screen
		var indtime = $("#tmlIndicatorTime");
		var indtimepadding = 12;
		if (offsetpercent > 90)
		{
			indtime.css({marginLeft: -(indtime.width() + indtimepadding) + "px"});
		}
		else
		{
			indtime.css({marginLeft: 0});
		}
	},
	
	/*
	 * Highlights the active segments. Should be called every 5 minutes.
	 */
	updateTimelineSegments: function(pForceWB)
	{
		if (H.isTimelineGenerated === false)
		{
			return;
		}
		var numwbslices = T.cMINUTES_IN_2_HOURS / T.cMINUTES_IN_TIMEFRAME;
		var wbcurrentoffset = 0;
		var currentminute = T.getCurrentBihourlyMinutesUTC();
		var currenttimestamp = currentminute - (currentminute % H.minutesInTimelineSpacing);
		
		// Refresh the header if approached new bihour
		if (currentminute === 0)
		{
			H.updateTimelineHeader();
		}
		else
		{
			// Update the timestamp just behind the indicator with future time
			var previoustimestamp = currentminute - H.minutesInTimelineSpacing;
			$("#tmlSegmentTimestamp_" + previoustimestamp)
				.html(T.getCurrentBihourlyTimestampLocal(previoustimestamp + T.cMINUTES_IN_2_HOURS))
				.removeClass("tmlSegmentTimestampCurrent").addClass("tmlSegmentTimestampFutureFar")
				.parent().css({opacity: 0}).animate({opacity: 1}, 1000)
				.closest(".tmlSegment").removeClass("tmlTimestampActive");
		}
		
		// Highlight active segments
		$("#tmlSegmentTimestamp_" + currenttimestamp).closest(".tmlSegment").addClass("tmlTimestampActive");
		$(".tmlTimeslice").each(function()
		{
			if (currentminute >= $(this).data("start") && currentminute < $(this).data("finish"))
			{
				if ( ! $(this).hasClass("tmlSegmentActive"))
				{
					$(this).addClass("tmlSegmentActive");
				}
				if ($(this).hasClass("tmlTimesliceWB"))
				{
					wbcurrentoffset = parseInt($(this).attr("data-offset"));
				}
			}
			else
			{
				$(this).removeClass("tmlSegmentActive");
			}
		});
		
		// Update the world boss slices, executes every 15 minutes
		if (currentminute % T.cMINUTES_IN_TIMEFRAME === 0 || pForceWB)
		{
			var wbcounteroffset = 0;
			$(".tmlTimesliceWB").each(function()
			{
				var inner = $(this).find(".tmlSegmentName").empty();
				var innerspecial = $(this).find(".tmlSegmentSpecial").empty();
				var bossicon, bossstripe;
				var thisoffset = parseInt($(this).attr("data-offset"));
				var timeframeoffset;
				if (thisoffset >= wbcurrentoffset)
				{
					timeframeoffset = wbcounteroffset;
					wbcounteroffset++;
				}
				else
				{
					timeframeoffset = (numwbslices - wbcurrentoffset) + thisoffset;
				}
				var wbchains = T.getTimeframeChains(timeframeoffset);
				for (var i in wbchains)
				{
					if (wbchains[i].series !== C.ChainSeriesEnum.DryTop)
					{
						(function(iChain)
						{
							var innersegment = (iChain.flags.isSpecial) ? innerspecial : inner;
							bossicon = $("<img class='tmlIcon curZoom chnSlot_" + iChain.nexus + "' src='" + iChain.iconSrc + "' />").appendTo(innersegment);
							bossicon.attr("title", "<dfn>" + D.getObjectName(iChain) + "</dfn>").click(function()
							{
								C.viewChainFinale(iChain);
							}).contextmenu(function(pEvent)
							{
								pEvent.preventDefault();
								C.viewChainFinale(iChain);
							}).dblclick(function()
							{
								$("#chnCheck_" + iChain.nexus).trigger("click");
							});
							I.preventMapPropagation(bossicon);
							bossstripe = $("<span class='tmlStripe'>" + D.getObjectName(iChain) + "<span>").insertAfter(bossicon);
							X.reapplyChainIconState(iChain, bossicon, true);
							I.bindClipboard(bossicon, iChain.waypointText);
						})(wbchains[i]);
					}
				}
			});
			I.qTip.init(".tmlIcon");
		}
	},
	
	/*
	 * Fills the top header line with timestamps. Should be called every 120 minutes.
	 */
	updateTimelineHeader: function()
	{
		if (H.isTimelineGenerated === false)
		{
			return;
		}
		var currentminute = T.getCurrentBihourlyMinutesUTC();
		var line = $("#tmlHeader").empty();
		var divisions = T.cMINUTES_IN_2_HOURS / H.minutesInTimelineSpacing;
		var ithminute, timestamp;
		for (var i = 0; i < divisions; i++)
		{
			var width = T.cPERCENT_100 / divisions;
			var condensedclass = (O.Options.bol_condenseTimelineHeader) ? "tmlSegmentTimestampCondensed" : "";
			var tenseclass = "";
			ithminute = H.minutesInTimelineSpacing * i;
			if (ithminute < currentminute - H.minutesInTimelineSpacing)
			{
				// Timestamps behind the current minute indicator becomes two hours ahead
				timestamp = T.getCurrentBihourlyTimestampLocal(ithminute + T.cMINUTES_IN_2_HOURS);
				tenseclass = "tmlSegmentTimestampFutureFar";
			}
			else
			{
				timestamp = T.getCurrentBihourlyTimestampLocal(ithminute);
			}
			line.append("<div class='tmlSegment' style='width:" + width + "%'><div class='tmlSegmentContent'>"
				+ "<span id='tmlSegmentTimestamp_" + ithminute + "' class='tmlSegmentTimestamp "
					+ condensedclass + " " + tenseclass + "'>" + timestamp + "</span></div></div>");
		}
	},
	
	/*
	 * Toggles timeline icons for special chains.
	 * @param boolean pBoolean.
	 */
	toggleSpecialIcons: function(pBoolean)
	{
		$(".tmlSegmentSpecial").css({visibility: ((pBoolean) ? "visible" : "hidden")});
		$(".tmlLineWB").toggleClass("tmlLineSpecial", pBoolean);
	},
	
	/*
	 * Shows or hides the timeline.
	 */
	toggleTimeline: function(pIsInitial)
	{
		I.toggleElement("#tmlContainer", O.Options.bol_showTimeline, "fast", pIsInitial);
		$("#tmlTitle").toggle(!O.Options.bol_showTimeline);
	},
	opaqueTimeline: function()
	{
		I.toggleHUDOpacity("#itemTimeline", "tml", O.Options.bol_opaqueTimeline);
	}
};
K = {
/* =============================================================================
 * @@Klock analog and by-the-second and frame refreshes
 * ========================================================================== */

	isClockStyled: false,
	tickerFrequency: 250, // Must be a divisor of 1000 milliseconds
	tickerSecondPrevious: null,
	stopwatchFrequency: 50,
	awakeTimestampPrevious: 0,
	awakeTimestampTolerance: 5,
	currentFrameOffsetMinutes: 0,
	currentPredictionColor: "",
	currentDaytimeSymbol: "",
	currentDaytimeWord: "",
	currentDaytimeString: "",
	currentDaytimeText: "",
	oldQuadrantAngle: 0,
	paneSizePrevious: 0,
	
	// Clock DOM elements
	handSecond: {}, handMinute: {}, handHour: {},
	clockBackground: {}, clockCircumference: {}, timeProgress0: {}, timeProgress1: {},
	timeDaylight: {}, timeLocal: {}, timeDaytime: {}, timeDirectory: {}, timeSimple: {}, timeMap: {}, timeWvW: {}, timeLog: {}, countdownWvW: {},
	timestampUTC: {}, timestampLocal: {}, timestampServer: {}, timestampReset: {},
	stopwatchUp: {}, stopwatchDown: {},
	
	// These will be DOM elements
	WpChain0: {}, WpChain1: {}, WpChain2: {}, WpChain3: {},
	// These will be jQuery "elements"
	IconSD0: {}, IconSD1: {}, IconSD2: {}, IconSD3: {},
	IconHC0: {}, IconHC1: {}, IconHC2: {}, IconHC3: {},
	IconsStandard: [],
	IconsHardcore: [],
	lsClipboards: [],
	TickerTimeout: {},
	
	// Stopwatch properties
	StopwatchTimeout: {},
	StopwatchTimestamp: 0,
	StopwatchTimesleep: 0,
	isStopwatchPaused: false,
	StopwatchTimerStart: 0,
	StopwatchTimerFinish: 0,
	
	/*
	 * Starts the clock.
	 */
	initializeClock: function()
	{
		// Create directory and dashboard beforehand
		H.generateTimeline();
		H.updateTimelineSegments(true);
		H.initializeDashboard();
		I.initializeDirectory();
		// Remember frequently accessed elements
		K.handSecond = $("#clkSecondHand")[0];
		K.handMinute = $("#clkMinuteHand")[0];
		K.handHour = $("#clkHourHand")[0];
		K.clockBackground = $("#paneClockBackground")[0];
		K.clockCircumference = $("#clkCircumference")[0];
		K.timeProgress0 = $("#chnProgress0")[0];
		K.timeProgress1 = $("#chnProgress1")[0];
		K.timeLocal = $("#itemTimeLocalActual")[0];
		K.timeDaytime = $("#itemTimeDayTime")[0];
		K.timeDirectory = $("#dirHeaderClock")[0];
		K.timeSimple = $("#itemSimpleTime")[0];
		K.timeMap = $("#mapTime")[0];
		K.timeWvW = $("#wvwTime")[0];
		K.timeLog = $("#logTime")[0];
		K.countdownWvW = $("#lboCountdown")[0];
		K.timestampUTC = $("#optTimestampUTC")[0];
		K.timestampReset = $("#optTimeTillReset")[0];
		K.stopwatchUp = $("#watUp")[0];
		K.stopwatchDown = $("#watDown")[0];
		
		K.updateTimeFrame(new Date()); // This also calls the server reset check function
		T.getDaily();
		K.updateDaytimeIcon();
		K.tickFrequent();
		K.updateDigitalClockMinutely();
		K.initializeClipboard();
		K.refreshFestival();
		
		// Hide chain progress bar for main mode
		if (I.ModeCurrent === I.ModeEnum.Website && O.Options.int_setClock !== O.IntEnum.Clock.None)
		{
			$("#chnProgressBar").hide();
		}
		
		// Other clickable elements
		$("#itemTimeLocalActual").click(function()
		{
			$("#opt_bol_use24Hour").trigger("click");
		});
		
		// Toggle clock pane shortcut button
		$("#clkToggle").click(function()
		{
			if (O.Options.int_setClock !== O.IntEnum.Clock.None)
			{
				K.paneSizePrevious = O.Options.int_setClock;
				X.setFieldsetState("int_setClock", O.IntEnum.Clock.None);
			}
			else
			{
				X.setFieldsetState("int_setClock", K.paneSizePrevious);
			}
		});
	},
	
	/*
	 * Sets the clock's background image, and custom if during festival.
	 * The clock is not visible when viewed on the website's main page, so don't
	 * load its images until shown.
	 */
	styleClock: function()
	{
		if (K.isClockStyled === false)
		{
			K.isClockStyled = true;
			//$("#clkWaypoints .cssWaypoint").css({"background-image": "url('img/map/halloween.png')"});
			//$("#clkWaypoints .cssWaypoint").css({"background-image": "url('img/map/wintersday.png')"});
			$("#paneClockBackground").addClass("paneClockBackground");
			//$("#paneClockBackground").css({"background": "url('img/background/globe_halloween.jpg') no-repeat center}"});
			//$("#paneClockBackground").css({"background": "url('img/background/globe_wintersday.jpg') no-repeat center}"});
			$("#paneClockFace").addClass("paneClockFace");
		}
	},
	
	/*
	 * Sets the clock pane's dimension and element positions according to options.
	 */
	setClock: function()
	{
		var animationspeed = 200;
		var clockpaneheight = 0;

		switch (O.Options.int_setClock)
		{
			case O.IntEnum.Clock.Compact:
			{
				$("#paneClock").show();
				$("#itemTimeLocal, #itemTimeDaytime").show();
				// Reposition clock items
				I.bulkAnimate([
					{s: "#itemClock", p: {top: "0px", left: "70px", width: "220px", height: "220px"}},
					{s: "#paneClockFace", p: {width: "360px", height: "360px", top: "-70px", left: "0px"}},
					{s: "#paneClockIcons .iconSD", p: {"border-radius": "32px"}},
					{s: "#paneClockIcons .iconHC", p: {"border-radius": "24px"}},
					{s: "#clkIconSD0", p: {top: "4px", left: "290px"}},
					{s: "#clkIconSD1", p: {top: "148px", left: "290px"}},
					{s: "#clkIconSD2", p: {top: "148px", left: "4px"}},
					{s: "#clkIconSD3", p: {top: "4px", left: "4px"}},
					{s: "#clkIconHC0", p: {top: "52px", left: "306px"}},
					{s: "#clkIconHC1", p: {top: "132px", left: "306px"}},
					{s: "#clkIconHC2", p: {top: "132px", left: "20px"}},
					{s: "#clkIconHC3", p: {top: "52px", left: "20px"}},
					{s: "#clkWaypoint0", p: {top: "24px", left: "274px"}},
					{s: "#clkWaypoint1", p: {top: "164px", left: "274px"}},
					{s: "#clkWaypoint2", p: {top: "164px", left: "52px"}},
					{s: "#clkWaypoint3", p: {top: "24px", left: "52px"}}
				], animationspeed);
				$("#paneClockIcons .iconHC").css({width: "32px", height: "32px"});
				// Restyle text items
				$("#itemTimeLocal").css({
					width: "100%",
					right: "auto", bottom: "90px",
					"text-align": "center",
					opacity: 0.5
				});
				$("#itemTimeDaytime").css({
					width: "100%",
					top: "90px", bottom: "auto", left: "auto",
					"text-align": "center",
					opacity: 0.5
				});

				clockpaneheight = I.cPANE_CLOCK_HEIGHT_COMPACT;
			} break;

			case O.IntEnum.Clock.Full:
			{
				$("#paneClock").show();
				$("#itemTimeLocal, #itemTimeDaytime").show();
				// Reposition clock items
				I.bulkAnimate([
					{s: "#itemClock", p: {top: "70px", left: "70px", width: "220px", height: "220px"}},
					{s: "#paneClockFace", p: {width: "360px", height: "360px", top: "0px", left: "0px"}},
					{s: "#paneClockIcons .iconSD", p: {"border-radius": "12px"}},
					{s: "#paneClockIcons .iconHC", p: {"border-radius": "12px"}},
					{s: "#clkIconSD0", p: {top: "4px", left: "148px"}},
					{s: "#clkIconSD1", p: {top: "148px", left: "290px"}},
					{s: "#clkIconSD2", p: {top: "290px", left: "148px"}},
					{s: "#clkIconSD3", p: {top: "148px", left: "4px"}},
					{s: "#clkIconHC0", p: {top: "12px", left: "212px"}},
					{s: "#clkIconHC1", p: {top: "212px", left: "298px"}},
					{s: "#clkIconHC2", p: {top: "298px", left: "100px"}},
					{s: "#clkIconHC3", p: {top: "100px", left: "12px"}},
					{s: "#clkWaypoint0", p: {top: "52px", left: "164px"}},
					{s: "#clkWaypoint1", p: {top: "164px", left: "274px"}},
					{s: "#clkWaypoint2", p: {top: "274px", left: "164px"}},
					{s: "#clkWaypoint3", p: {top: "164px", left: "52px"}}
				], animationspeed);
				$("#paneClockIcons .iconHC").css({width: "48px", height: "48px"});
				// Restyle text items
				$("#itemTimeLocal").css({
					width: "auto",
					right: "10px", bottom: "10px",
					"text-align": "left",
					opacity: 1
				});
				$("#itemTimeDaytime").css({
					width: "auto",
					top: "auto", bottom: "10px", left: "10px",
					"text-align": "left",
					opacity: 1
				});

				clockpaneheight = I.cPANE_CLOCK_HEIGHT;
			} break;

			case O.IntEnum.Clock.Bar:
			{
				$("#paneClock").show();
				$("#itemTimeLocal, #itemTimeDaytime").hide();
				// Reposition clock items
				I.bulkAnimate([
					{s: "#itemClock", p: {top: "0px", left: "0px", width: "85px", height: "85px"}},
					{s: "#paneClockFace", p: {width: "132px", height: "132px", top: "-24px", left: "-24px"}},
					{s: "#paneClockIcons .iconSD", p: {"border-radius": "32px"}},
					{s: "#paneClockIcons .iconHC", p: {"border-radius": "24px"}},
					{s: "#clkIconSD0", p: {top: "0px", left: "82px"}},
					{s: "#clkIconSD1", p: {top: "0px", left: "152px"}},
					{s: "#clkIconSD2", p: {top: "0px", left: "222px"}},
					{s: "#clkIconSD3", p: {top: "0px", left: "292px"}},
					{s: "#clkIconHC0", p: {top: "48px", left: "98px"}},
					{s: "#clkIconHC1", p: {top: "48px", left: "168px"}},
					{s: "#clkIconHC2", p: {top: "48px", left: "238px"}},
					{s: "#clkIconHC3", p: {top: "48px", left: "308px"}},
					{s: "#clkWaypoint0", p: {top: "-8px", left: "98px"}},
					{s: "#clkWaypoint1", p: {top: "-8px", left: "168px"}},
					{s: "#clkWaypoint2", p: {top: "-8px", left: "238px"}},
					{s: "#clkWaypoint3", p: {top: "-8px", left: "308px"}}
				], animationspeed);
				$("#paneClockIcons .iconHC").css({width: "32px", height: "32px"});

				clockpaneheight = I.cPANE_CLOCK_HEIGHT_BAR;
			} break;

			case O.IntEnum.Clock.None:
			{
				/*
				 * There are three panes on the right panel: Clock, Menu, and Content
				 * all absolutely positioned, so to move them the CSS "top" attribute
				 * needs to be changed: less to go up, more to go down.
				 */
				$("#plateMenu").animate({top: 0}, animationspeed);
				$("#paneContent").animate({top: I.cPANE_MENU_HEIGHT,
					"min-height": I.cPANEL_HEIGHT_MIN - (I.cPANE_MENU_HEIGHT) + "px"}, animationspeed,
					function()
					{
						$("#paneClock").hide();
					});
			} break;
		}
		
		// Height for repositioning the beam menu, which is fixed position
		I.CLOCK_AND_MENU_HEIGHT = clockpaneheight + I.cPANE_MENU_HEIGHT;

		// Readjust panes to new height if showing clock
		if (O.Options.int_setClock !== O.IntEnum.Clock.None)
		{
			// Resize panes by animation
			$("#plateMenu").animate({top: clockpaneheight}, animationspeed);
			$("#paneClock, #paneClockWall, #paneClockBackground, #paneClockIcons, #paneClockCanvas")
				.animate({height: clockpaneheight}, animationspeed);

			// Readjust content pane
			$("#paneContent").animate({top: clockpaneheight + I.cPANE_MENU_HEIGHT,
				"min-height": I.cPANEL_HEIGHT_MIN - (clockpaneheight + I.cPANE_MENU_HEIGHT) + "px"}, animationspeed);
		}
	},
	
	/*
	 * Sets the clock's background dimming opacity.
	 * @param float pPercent.
	 */
	setDimming: function(pPercent, pWantAnimate)
	{
		if (O.Options.int_setDimming === 0 && I.ModeCurrent !== I.ModeEnum.Simple)
		{
			if (pWantAnimate)
			{
				$(K.clockBackground).animate({opacity: pPercent});
			}
			else
			{
				K.clockBackground.style.opacity = pPercent;
			}
		}
	},

	/*
	 * Sets a marker (small spikes at clock circumference) to specified angle.
	 * @param object pElement element to set angle.
	 * @param int pSeconds seconds from the hour.
	 */
	setMarkerAngle: function(pElement, pSeconds)
	{
		$(pElement).attr("transform", "rotate(" + pSeconds/10 + ", 50, 50)");
	},

	/*
	 * Sets a clock element by angle.
	 * @param object pElement to set angle.
	 * @param int pAngle angle 0-360.
	 */
	rotateClockElement: function(pElement, pAngle)
	{
		pElement.setAttribute("transform", "rotate(" + pAngle + ", 50, 50)");
	},
	
	/*
	 * Removes the filter attribute from SVG elements that have them (as in
	 * the shadow effect), then re-adds the filter. Workaround for a Firefox bug
	 * https://bugzilla.mozilla.org/show_bug.cgi?id=652991
	 */
	reapplyFilters: function()
	{
		if (I.BrowserCurrent === I.BrowserEnum.Firefox)
		{
			var c = $("#clkCircumference");
			var h = $("#clkHands");
			var f1 = "url(#clkFilterShadowOuter)";
			var f2 = "url(#clkGradientCircumference)";
			var f3 = "url(#clkFilterShadowHand)";
			c.removeAttr("filter").attr("filter", f1);
			c.css("stroke", f2);
			h.removeAttr("filter").attr("filter", f3);
		}
	},
	
	/*
	 * Initializes array of clock items for iteration and binds the clock chain
	 * icons to view map event when clicked, or check off when double clicked.
	 * @pre data attribute of icon was updated to get associated chain object.
	 */
	initializeClockItems: function()
	{
		K.IconsStandard = null;
		K.IconsHardcore = null;
		K.IconsStandard = new Array(K.IconSD0, K.IconSD1, K.IconSD2, K.IconSD3);
		K.IconsHardcore = new Array(K.IconHC0, K.IconHC1, K.IconHC2, K.IconHC3);
		
		// Change behavior of overlay mode because the user uses the clock more
		var checkbossbehavior = "click";
		var zoombossbehavior = "dblclick";
		if (I.ModeCurrent === I.ModeEnum.Website && I.isProgramEmbedded === false)
		{
			checkbossbehavior = "dblclick";
			zoombossbehavior = "click";
		}
		
		// Bind behavior
		for (var i = 0; i < T.cNUM_TIMEFRAMES_IN_HOUR; i++)
		{
			$([K.IconsStandard[i], K.IconsHardcore[i]]).each(function()
			{
				$(this).unbind(zoombossbehavior).on(zoombossbehavior, function()
				{
					C.viewChainFinale(C.Chains[$(this).data(C.cIndexSynonym)]);
				}).unbind(checkbossbehavior).on(checkbossbehavior, function()
				{
					$("#chnCheck_" + C.Chains[$(this).data(C.cIndexSynonym)].nexus).trigger("click");
				});
			});
		}
	},
	
	/*
	 * Called when the user checks a chain on the checklist, this will see if
	 * that chain is on the clock, and if it is, change visual based on the
	 * check state.
	 * @param string pIndex of the chain to check off in the clock.
	 * @pre Icons jQuery objects array was initialized and icons are in
	 * proper clock position.
	 */
	checkoffChainIcon: function(pIndex)
	{
		var i;
		var chain = C.Chains[pIndex]; // Chain that is clicked on checklist
		var ithchain; // Chain that is on the clock
		var iconchain;
		
		if (chain.series === C.ChainSeriesEnum.Standard
			|| chain.series === C.ChainSeriesEnum.Hardcore)
		{
			for (i = 0; i < T.cNUM_TIMEFRAMES_IN_HOUR; i++)
			{
				switch (chain.series)
				{
					case C.ChainSeriesEnum.Standard:
					{
						ithchain = T.getStandardChain(i);
						iconchain = K.IconsStandard[i];
					} break;
					case C.ChainSeriesEnum.Hardcore:
					{
						ithchain = T.getHardcoreChain(i);
						iconchain = K.IconsHardcore[i];
					} break;
				}

				// If clicked chain is on the clock
				if (ithchain && pIndex === ithchain.nexus)
				{
					X.reapplyChainIconState(ithchain, iconchain);
				}
			}
		}
	},
	
	/*
	 * Colors the minute hand and chain progress bar depending on current chain's prediction.
	 * @param string pColor.
	 */
	colorPrediction: function(pColor)
	{
		if (pColor !== K.currentPredictionColor)
		{
			K.currentPredictionColor = pColor;
			K.handMinute.style.stroke = pColor;
			K.timeProgress0.style.background = "linear-gradient(to right, transparent 0%, " + pColor + " 100%)";
		}
	},

	/*
	 * Although the tick effects are supposed to happen every 1 second, the
	 * function is actually ran multiple times per second so setTimeout
	 * is in sync with the Date object.
	 */
	tickFrequent: function()
	{
		var now = new Date();
		var sec = now.getSeconds();
		if (K.tickerSecondPrevious === sec)
		{
			// If the Date second has not changed, then don't do the effects
			K.TickerTimeout = setTimeout(K.tickFrequent, K.tickerFrequency);
			return;
		}
		else
		{
			// Else update the second variable and do the effects
			K.tickerSecondPrevious = sec;
			K.tickSecond(now);
		}
	},
	
	/*
	 * Clock ticker runs every second to update the hands and do effects to the
	 * clock when appropriate, like when a chain starts at 15 minute mark.
	 */
	tickSecond: function(pDate)
	{
		/*
		 * Things in this outer block runs every second, so core JS is used
		 * instead of jQuery for performance.
		 */
		var localtime = T.getTimeFormatted();
		var sec = pDate.getSeconds();
		var secondssincemidnight = T.getTimeSinceMidnight();
		T.TIMESTAMP_UNIX_SECONDS = T.getUNIXSeconds();
		T.SECONDS_TILL_DAILY = T.cSECONDS_IN_DAY - secondssincemidnight;
		T.SECONDS_TILL_WEEKLY = T.getSecondsTillWeektime(T.cWEEKLY_RESET_SECONDS, secondssincemidnight);
		var min = pDate.getMinutes();
		var hour = pDate.getHours() % T.cHOURS_IN_MERIDIEM;
		var secinhour = min * T.cSECONDS_IN_MINUTE + sec;
		var secangle = sec * 6; // 6 degrees per second
		var minangle = min * 6 + (sec / 10); // 1/10 degrees per second
		var hourangle = hour * 30 + (min / 2); // 1/240 degrees per second
		// Simulates mechanical recoil movement for second hand
		var vibrateSecond = function(pPattern, pCounter)
		{
			if (pCounter === undefined)
			{
				pCounter = 0;
			}
			setTimeout(function()
			{
				K.rotateClockElement(K.handSecond, secangle + pPattern[pCounter]);
				if (pCounter < pPattern.length - 1)
				{
					vibrateSecond(pPattern, pCounter + 1);
				}
			}, 50);
		};
		K.rotateClockElement(K.clockCircumference, minangle);
		K.rotateClockElement(K.handMinute, minangle);
		K.rotateClockElement(K.handHour, hourangle);
		if (O.Options.bol_showSecondHand)
		{
			vibrateSecond([-0.5, 1, -0.5, 0.25, 0]);
		}
		
		// Value 0.0 through 1.0 based on how far into the 15 minutes frame
		var timeframeprogress = 1 - ((min % T.cMINUTES_IN_TIMEFRAME)*60 + sec) / (T.cSECONDS_IN_TIMEFRAME);
		// Progress bar over chains page to show how far in timeframe
		var percent = (T.cPERCENT_100 * timeframeprogress);
		K.timeProgress0.style.width = (100 - percent) + "%";
		K.timeProgress1.style.width = percent + "%";
		
		/*
		 * If crossing a 15 minute mark (IMPORTANT).
		 */
		if (min % T.cMINUTES_IN_TIMEFRAME === 0 && sec === 0)
		{
			$(K.timeProgress0).css({width: "100%"}).animate({width: "0%"}, 800);
			$(K.timeProgress1).css({width: "0%"}).animate({width: "100%"}, 800);
			K.updateTimeFrame(pDate);
			// Check gem store alerts if opted
			if (O.Options.bol_alertGem && H.isGemPaused === false)
			{
				H.updateGemSubscription();
			}
		}
		else // If crossing a 1 second mark and hasn't crossed the 15 minute mark
		{
			/*
			 * For devices that goes to sleep, check the UNIX timestamp (which
			 * is updated every second if the device is awake) to see if it's
			 * out of sync, and refresh the clock if so.
			 */
			var awaketimestampcurrent = T.TIMESTAMP_UNIX_SECONDS;
			if (K.awakeTimestampPrevious < (awaketimestampcurrent - K.awakeTimestampTolerance))
			{
				K.updateTimeFrame(pDate);
			}
			// Update the timestamp
			K.awakeTimestampPrevious = awaketimestampcurrent;
		}
		
		// If crossing a 1 second mark (given)
		C.CurrentChains.forEach(C.updateCurrentChainTimeHTML);
		
		if (sec === 0)
		{
			/*
			 * If crossing a 5 minute mark.
			 */
			if (min % T.cMINUTES_IN_MINIFRAME === 0)
			{
				K.updateDaytimeIcon();
				K.updateDryTopClipboard();
				H.updateTimelineSegments();
				if (H.isDashboardEnabled)
				{
					H.refreshDashboard(pDate);
				}
			}
			
			/*
			 * If crossing a 1 minute mark.
			 */
			K.refreshFestival();
			K.updateDigitalClockMinutely();
			// Refresh the chain time countdown opted
			C.updateChainsTimeHTML();
			K.updateWaypointsClipboard();
			
			// Alert subscribed chain
			if (O.Options.int_setAlarm === O.IntEnum.Alarm.Subscription)
			{
				K.doSubscribedSpeech(O.Options.int_alertSubscribedFirst);
				K.doSubscribedSpeech(O.Options.int_alertSubscribedSecond);
			}
			// Check new build
			if (O.Options.bol_alertBuild)
			{
				O.enforceBuildVersion();
			}
		}
		
		// Mode dependent repeated functions
		switch (I.ModeCurrent)
		{
			case I.ModeEnum.Simple:
			{
				// Tick the two digital clocks below the analog clock
				K.timeSimple.innerHTML =
				T.getTimeFormatted(
				{
					aWant24: true,
					aWantHours: false,
					aWantLetters: true,
					aCustomTimeInSeconds: T.cSECONDS_IN_TIMEFRAME - T.getCurrentTimeframeElapsedTime()
				});
			} break;
			
			case I.ModeEnum.Overlay:
			{
				P.switchMapCheck();
			} break; 
		}
		
		K.timeLocal.innerHTML = localtime;
		K.timeDirectory.innerHTML = localtime;
		// Times in the Options page Debug section
		K.timestampUTC.innerHTML = T.TIMESTAMP_UNIX_SECONDS;
		K.timestampReset.innerHTML = T.getTimeFormatted(
		{
			aCustomTimeInSeconds: T.SECONDS_TILL_DAILY,
			aWant24: true
		});
		
		// Change the minute hand if passing colored marker
		if (secinhour >= K.currentFrameOffsetMinutes
			&& secinhour < (K.currentFrameOffsetMinutes + C.CurrentChainSD.minFinish))
		{
			K.colorPrediction("lime");
		}
		else if (secinhour >= (K.currentFrameOffsetMinutes + C.CurrentChainSD.minFinish)
			&& secinhour < (K.currentFrameOffsetMinutes + C.CurrentChainSD.avgFinish))
		{
			K.colorPrediction("orange");
		}
		else if (secinhour >= (K.currentFrameOffsetMinutes + C.CurrentChainSD.avgFinish))
		{
			K.colorPrediction("red");
		}
		
		// Trigger other ticking functions
		if (T.isChecklistCountdownsStarted)
		{
			T.updateChecklistCountdowns();
		}
		if (H.isCountdownTickEnabled)
		{
			H.updateDashboardCountdown(pDate);
		}
		if (H.isSaleOpened)
		{
			H.updateDashboardSaleCountdown();
		}
		if (K.StopwatchTimerStart !== 0)
		{
			K.tickStopwatchDown();
		}
		if (W.isObjectiveTimerTickEnabled)
		{
			K.timeLog.innerHTML = localtime;
			W.updateObjectiveTimers();
			if (W.MatchFinishTimeMS !== null)
			{
				K.countdownWvW.innerHTML = T.formatTimeLetter(W.secTillWvWReset--, true);
			}
			if (sec === 0)
			{
				W.updateAllObjectiveAge();
			}
		}
		
		// Loop this function, can use variable to halt it
		K.TickerTimeout = setTimeout(K.tickFrequent, K.tickerFrequency);
	},
	
	/*
	 * Macro function to get a speech if the subscribed boss is within the opted time
	 * @param int pMinutes before a chain starts as set by the user.
	 */
	doSubscribedSpeech: function(pMinutes)
	{
		if (pMinutes > 0)
		{
			var minutestill = T.cMINUTES_IN_TIMEFRAME - T.getCurrentTimeframeElapsedTime(T.UnitEnum.Minutes);
			var chainsd = C.NextChainSD1;
			var chainhc = C.NextChainHC1;
			var chainls = C.NextChainLS1;
			var wantsd = false;
			var wanthc = false;
			var wantls = false;
			var wantms = false;
			var speechwb = "";
			var speechms = "";

			// If alarm minutes is beyond the timeframe range, check the chains beyond
			if (pMinutes > T.cMINUTES_IN_TIMEFRAME)
			{
				chainsd = C.NextChainSD2;
				chainhc = C.NextChainHC2;
				chainls = C.NextChainLS2;
				minutestill += T.cMINUTES_IN_TIMEFRAME;
			}
			
			if (pMinutes === minutestill)
			{
				// Make sure the chain is not null/undefined (if it does not exist in the time slot)
				var conjunction = " " + D.getSpeechWord("and") + " ";
				var timephrase = " " + D.getSpeechWord("will start") + D.getPluralTime(minutestill, "minute");
				
				speechwb = D.getSpeechWord(D.orderModifier(D.orderModifier("boss", "world"), "subscribed")) + " ";
				wantsd = U.objToBool(chainsd) && (C.isChainSubscribed(chainsd) && C.isChainUnchecked(chainsd));
				wanthc = U.objToBool(chainhc) && (C.isChainSubscribed(chainhc) && C.isChainUnchecked(chainhc));
				wantls = U.objToBool(chainls) && (C.isChainSubscribed(chainls) && C.isChainUnchecked(chainls));
				
				if (wantsd || wanthc)
				{
					if (wantsd && wanthc)
					{
						speechwb += D.getChainPronunciation(chainsd) + conjunction + D.getChainPronunciation(chainhc);
					}
					else if (wantsd)
					{
						speechwb += D.getChainPronunciation(chainsd);
					}
					else if (wanthc)
					{
						speechwb += D.getChainPronunciation(chainhc);
					}
					D.speak(speechwb);
					D.speak(timephrase);
				}

				// Miscellaneous chains can happen simultaneously in a timeframe
				var chainms;
				var chainsms = (pMinutes > T.cMINUTES_IN_TIMEFRAME) ? C.NextChainsMS2 : C.NextChainsMS1;
				if (chainsms.length > 0)
				{
					speechms = D.getSpeechWord("event", "subscribed") + " ";
					for (var i = 0; i < chainsms.length; i++)
					{
						chainms = chainsms[i];
						if (U.objToBool(chainms) && (C.isChainSubscribed(chainms) && C.isChainUnchecked(chainms)))
						{
							speechms += D.getChainPronunciation(chainms);
							// Append a conjunction between names
							if (i+1 < chainsms.length && chainsms.length > 1)
							{
								speechms += conjunction;
							}
							wantms = true;
						}
					}
					if (wantms)
					{
						speechms += timephrase;
						D.speak(speechms);
					}
				}

				// Living Story chain
				if (H.isStoryEnabled && wantls)
				{
					D.speak(D.getSpeechWord("event", "subscribed") + " " + D.getChainPronunciation(chainls));
					D.speak(timephrase);
				}
			}
		}
	},

	/*
	 * The megaserver world bosses are spaced by 15 minutes between chain starts
	 * beginning at the hour, so time calculation can be conveniently spaced into
	 * the four quadrants of an analog clock. Most chains last much shorter than that.
	 * Q1: X:00-X:15 (or 12-3 o'clock)
	 * Q2: X:15-X:30 (or 3-6 o'clock)
	 * Q3: X:30-X:45 (or 6-9 o'clock)
	 * Q4: X:45-X:00 (or 9-12 o'clock)
	 * @param Date pTime to determine the current timeframe.
	 */
	updateTimeFrame: function(pDate)
	{
		// Check if server reset happened
		O.checkResetTimestamps(pDate);
		
		// Remember current chain to reference variable
		C.CurrentChainSD = T.getStandardChain();
		C.NextChainSD1 = T.getStandardChain(1);
		C.NextChainSD2 = T.getStandardChain(2);
		C.NextChainSD3 = T.getStandardChain(3);
		C.NextChainSD4 = T.getStandardChain(4);
		C.CurrentChainsSD = [C.CurrentChainSD, C.NextChainSD1, C.NextChainSD2, C.NextChainSD3];
		
		C.CurrentChainHC = T.getHardcoreChain();
		C.NextChainHC1 = T.getHardcoreChain(1);
		C.NextChainHC2 = T.getHardcoreChain(2);
		C.NextChainHC3 = T.getHardcoreChain(3);
		C.NextChainHC4 = T.getHardcoreChain(4);
		
		if (H.isStoryEnabled)
		{
			// These are for subscription alarm reference
			C.NextChainLS1 = T.getLivingStoryChain(1);
			C.NextChainLS2 = T.getLivingStoryChain(2);
		}
		C.NextChainsMS1 = T.getMiscellaneousChains(1);
		C.NextChainsMS2 = T.getMiscellaneousChains(2);
		
		C.PreviousChains2 = T.getTimeframeChains(-2);
		C.PreviousChains1 = T.getTimeframeChains(-1);
		C.CurrentChains = T.getTimeframeChains();
		C.NextChains1 = T.getTimeframeChains(1);
		
		// Sort the chains list
		C.sortChainsListHTML();
		
		// Queue the highlighting of the current chain's events
		C.CurrentChains.forEach(C.queueEventsHighlight);
		
		// Update board in simple mode
		if (I.ModeCurrent === I.ModeEnum.Simple)
		{
			$("#itemSimpleCurrentSD").text(D.getObjectName(C.CurrentChainSD));
			$("#itemSimpleNextSD").text(D.getObjectName(C.NextChainSD1));
			$("#itemSimpleCurrentHC").text("");
			$("#itemSimpleNextHC").text("");
			if (C.CurrentChainHC || C.NextChainHC1)
			{
				$("#itemSimpleHC").show();
				if (C.CurrentChainHC)
				{
					$("#itemSimpleCurrentHC").text(D.getObjectName(C.CurrentChainHC));
				}
				if (C.NextChainHC1)
				{
					$("#itemSimpleNextHC").text(D.getObjectName(C.NextChainHC1));
				}
			}
			else
			{
				$("#itemSimpleHC").hide();
			}
		}
		
		// Alert current chain
		if (O.Options.int_setAlarm === O.IntEnum.Alarm.Checklist && O.Options.bol_alertAtEnd)
		{
			var checked = ", " + D.getSpeechWord("checked");
			var checkedcurrentsd = "";
			var checkednextsd = "";
			var checkedcurrenthc = "";
			var checkednexthc = "";
			var wantcurrentsd = U.objToBool(C.CurrentChainSD);
			var wantcurrenthc = U.objToBool(C.CurrentChainHC);
			var wantnextsd = U.objToBool(C.NextChainSD1);
			var wantnexthc = U.objToBool(C.NextChainHC1);
			var speech = D.getSpeechWord("world boss", "current") + " " + D.getSpeechWord("is") + " ";
			
			if (C.CurrentChainSD && ( ! C.isChainUnchecked(C.CurrentChainSD)))
			{
				checkedcurrentsd = checked;
			}
			if (C.CurrentChainHC && ( ! C.isChainUnchecked(C.CurrentChainHC)))
			{
				checkedcurrenthc = checked;
			}
			if (C.NextChainSD1 && ( ! C.isChainUnchecked(C.NextChainSD1)))
			{
				checkednextsd = checked;
			}
			if (C.NextChainHC1 && ( ! C.isChainUnchecked(C.NextChainHC1)))
			{
				checkednexthc = checked;
			}
			// Don't alert if current boss is checked off and user opted not to hear
			if (O.Options.bol_alertChecked === false)
			{
				if (checkedcurrentsd.length > 0) { wantcurrentsd = false; }
				if (checkedcurrenthc.length > 0) { wantcurrenthc = false; }
				if (checkednextsd.length > 0) { wantnextsd = false; }
				if (checkednexthc.length > 0) { wantnexthc = false; }
			}
			
			// Announce current bosses
			if (wantcurrentsd && wantcurrenthc)
			{
				D.speak(speech + D.getChainPronunciation(C.CurrentChainSD) + checkedcurrentsd, 5);
				D.speak(D.getSpeechWord("and") + ", " + D.getChainPronunciation(C.CurrentChainHC) + checkedcurrenthc, 4);
			}
			else if (wantcurrentsd)
			{
				D.speak(speech + D.getChainPronunciation(C.CurrentChainSD) + checkedcurrentsd, 5);
			}
			else if (wantcurrenthc)
			{
				D.speak(speech + D.getChainPronunciation(C.CurrentChainHC) + checkedcurrenthc, 5);
			}
			
			// Announce next bosses only if the current has been announced too
			if (wantcurrentsd || wantcurrenthc)
			{
				if (wantnextsd && wantnexthc)
				{
					D.speak(D.getSpeechWord("then") + ", " + D.getChainPronunciation(C.NextChainSD1) + checkednextsd, 4);
					D.speak(D.getSpeechWord("and") + ", " + D.getChainPronunciation(C.NextChainHC1) + checkednexthc, 4);
				}
				else if (wantnextsd)
				{
					D.speak(D.getSpeechWord("then") + ", " + D.getChainPronunciation(C.NextChainSD1) + checkednextsd, 4);
				}
				else if (wantnexthc)
				{
					D.speak(D.getSpeechWord("then") + ", " + D.getChainPronunciation(C.NextChainHC1) + checkednexthc, 4);
				}
			}
		}
		
		var sec = pDate.getSeconds();
		var min = pDate.getMinutes();
		var secinhour = min*60 + sec;
		// Blacken all markers
		$("#clkMarkers line").each(function()
		{
			$(this).attr("stroke", "black");
		});
		$("#paneClockIcons .iconSD").removeClass("clkIconCurrent clkIconNext");
		$("#paneClockIcons .iconHC").removeClass("clkIconCurrent clkIconNext");
		
		// Macro function for the following conditionals
		var repositionMarkers = function(pMarkerStart, pMarker0A, pMarker0B, pMarkerNext,
			pMarker1A, pMarker1B, pMarker2A, pMarker2B, pMarker3A, pMarker3B,
			pOffsetMark0, pOffsetMark1, pOffsetMark2, pOffsetMark3)
		{
			// Highlight active chain icon
			$([K.IconSD0, K.IconHC0]).each(function()
			{
				$(this).addClass("clkIconCurrent");
			});
			$([K.IconSD1, K.IconHC1]).each(function()
			{
				$(this).addClass("clkIconNext");
			});
			
			// Update chain markers
			K.setMarkerAngle(pMarker0A, C.CurrentChainSD.minFinish + pOffsetMark0);
			K.setMarkerAngle(pMarker0B, C.CurrentChainSD.avgFinish + pOffsetMark0);
			K.setMarkerAngle(pMarker1A, C.NextChainSD1.minFinish + pOffsetMark1);
			K.setMarkerAngle(pMarker1B, C.NextChainSD1.avgFinish + pOffsetMark1);
			K.setMarkerAngle(pMarker2A, C.NextChainSD2.minFinish + pOffsetMark2);
			K.setMarkerAngle(pMarker2B, C.NextChainSD2.avgFinish + pOffsetMark2);
			K.setMarkerAngle(pMarker3A, C.NextChainSD3.minFinish + pOffsetMark3);
			K.setMarkerAngle(pMarker3B, C.NextChainSD3.avgFinish + pOffsetMark3);
			// Update chain icons, fade if checked off
			var restyleIcon = function(pChain, pIcon)
			{
				if (pChain)
				{
					pIcon.show();
					pIcon.attr("src", pChain.iconSrc);
					pIcon.data(C.cIndexSynonym, pChain.nexus);
					pIcon.attr("title", "<dfn>" + D.getObjectName(pChain) + "</dfn>");
					I.qTip.init(pIcon);
					X.reapplyChainIconState(pChain, pIcon);
				}
				else
				{
					// Don't show icon if hardcore boss is not scheduled at that timeframe
					pIcon.hide();
				}
			};
			restyleIcon(C.CurrentChainSD, K.IconSD0);
			restyleIcon(C.NextChainSD1, K.IconSD1);
			restyleIcon(C.NextChainSD2, K.IconSD2);
			restyleIcon(C.NextChainSD3, K.IconSD3);
			restyleIcon(C.CurrentChainHC, K.IconHC0);
			restyleIcon(C.NextChainHC1, K.IconHC1);
			restyleIcon(C.NextChainHC2, K.IconHC2);
			restyleIcon(C.NextChainHC3, K.IconHC3);
			// Colorize the active chain's markers
			$(pMarkerStart).attr("stroke", "lime");
			$(pMarker0A).attr("stroke", "orange");
			$(pMarker0B).attr("stroke", "red");
			$(pMarkerNext).attr("stroke", "green");
		};
		
		// Macro function for styling various clock pane elements
		var restyleClock = function(pTimeframeMark)
		{
			var i0, i1, i2, i3;
			switch (pTimeframeMark)
			{
				case T.cSECS_MARK_0: { i0 = "0"; i1 = "1"; i2 = "2"; i3 = "3"; } break;
				case T.cSECS_MARK_1: { i0 = "1"; i1 = "2"; i2 = "3"; i3 = "0"; } break;
				case T.cSECS_MARK_2: { i0 = "2"; i1 = "3"; i2 = "0"; i3 = "1"; } break;
				case T.cSECS_MARK_3: { i0 = "3"; i1 = "0"; i2 = "1"; i3 = "2"; } break;
			}
			K.currentFrameOffsetMinutes = pTimeframeMark;

			K.WpChain0 = $("#clkWaypoint" + i0); K.IconSD0 = $("#clkIconSD" + i0);
			K.WpChain1 = $("#clkWaypoint" + i1); K.IconSD1 = $("#clkIconSD" + i1);
			K.WpChain2 = $("#clkWaypoint" + i2); K.IconSD2 = $("#clkIconSD" + i2);
			K.WpChain3 = $("#clkWaypoint" + i3); K.IconSD3 = $("#clkIconSD" + i3);
			K.IconHC0 = $("#clkIconHC" + i0);
			K.IconHC1 = $("#clkIconHC" + i1);
			K.IconHC2 = $("#clkIconHC" + i2);
			K.IconHC3 = $("#clkIconHC" + i3);
			
			C.refreshChainDailyIcon();
			
			repositionMarkers(
				$("#clkMarker" + i0), $("#clkMarker" + i0 + "A"), $("#clkMarker" + i0 + "B"),
				$("#clkMarker" + i1), $("#clkMarker" + i1 + "A"), $("#clkMarker" + i1 + "B"),
				$("#clkMarker" + i2 + "A"), $("#clkMarker" + i2 + "B"),
				$("#clkMarker" + i3 + "A"), $("#clkMarker" + i3 + "B"),
				T["cSECS_MARK_" + i0], T["cSECS_MARK_" + i1], T["cSECS_MARK_" + i2], T["cSECS_MARK_" + i3]
			);
	
			// Animate quadrant rotation
			var quad = document.getElementById("clkQuadrant");
			var newquadangle = parseInt(i0) * T.cCIRCLE_RIGHT_DEGREE;
			if (newquadangle === 0 && K.oldQuadrantAngle !== 0)
			{
				newquadangle = T.cCIRCLE_FULL_DEGREE;
			}
			
			$({angle: K.oldQuadrantAngle}).animate({angle: newquadangle}, {
				duration: 600,
				step: function() { K.rotateClockElement(quad, this.angle); },
				done: function() { K.rotateClockElement(quad, newquadangle); }
			});
			
			if (newquadangle === T.cCIRCLE_FULL_DEGREE)
			{
				newquadangle = 0;
			}
			K.oldQuadrantAngle = newquadangle;
		};
		
		// Recolor the active event's markers and rotate clock quadrant
		// Note that clock elements' IDs are suffixed with numbers 0-3 for easy iteration
		if (secinhour >= T.cSECS_MARK_0 && secinhour < T.cSECS_MARK_1)
		{
			restyleClock(T.cSECS_MARK_0);
		}
		else if (secinhour >= T.cSECS_MARK_1 && secinhour < T.cSECS_MARK_2)
		{
			restyleClock(T.cSECS_MARK_1);
		}
		else if (secinhour >= T.cSECS_MARK_2 && secinhour < T.cSECS_MARK_3)
		{
			restyleClock(T.cSECS_MARK_2);
		}
		else if (secinhour >= T.cSECS_MARK_3 && secinhour <= T.cSECS_MARK_4)
		{
			restyleClock(T.cSECS_MARK_3);
		}
		
		// Refresh waypoints because the icon's clock position changed
		K.updateWaypointsClipboard();
		K.updateDryTopClipboard();
		K.initializeClockItems();
	},

	/*
	 * Initializes the array containing Clipboard objects.
	 * Each clock waypoint icon (4 img tags) will have the data attribute set to
	 * a waypoint text by the time updater.
	 */
	initializeClipboard: function()
	{
		for (var i = 0; i < T.cNUM_TIMEFRAMES_IN_HOUR; i++)
		{
			I.bindClipboard("#clkWaypoint" + i);
		}
	},
	
	/*
	 * Updates the daytime icon based on current game daylight.
	 */
	updateDaytimeIcon: function()
	{
		var isdaylight = T.isDaylight();
		var symbol = (isdaylight) ? I.Symbol.Day : I.Symbol.Night;
		var word = (isdaylight) ? D.getWord("day") : D.getWord("night");
		K.currentDaytimeSymbol = symbol;
		K.currentDaytimeWord = word;
		$("#itemTimeDayIcon").text(symbol);
	},
	
	/*
	 * Updates the digital clock with minutely information.
	 */
	updateDigitalClockMinutely: function()
	{
		// Daytime clock updates time remaining
		var daytime = T.getDayPeriodRemaining();
		K.timeDaytime.innerHTML = daytime;
		K.currentDaytimeString = T.getTimeFormatted({aWantSeconds: false}) + " " + K.currentDaytimeSymbol + daytime;
		K.currentDaytimeText = K.currentDaytimeString + " " + K.currentDaytimeWord;
		// Clock on the map shown in overlay mode
		K.timeMap.innerHTML = K.currentDaytimeString;
		K.timeWvW.innerHTML = K.currentDaytimeString;
		// Local clock updates additional times in tooltip
		K.timeLocal.title =
			T.formatWeektime(new Date(), true) + "<br />" +
			"<dfn>Anet:</dfn> " + T.getTimeFormatted(
			{
				aReference: T.ReferenceEnum.Server,
				aWantSeconds: false
			}) + "<br />" +
			"<dfn>UTC:</dfn> " + T.getTimeFormatted(
			{
				aReference: T.ReferenceEnum.UTC,
				aWantSeconds: false,
				aWant24: true
			}) + "<br />" +
			"<dfn>Daily:</dfn> " + T.formatTimeLetter(T.SECONDS_TILL_DAILY, false) + "<br />" +
			"<dfn>Weekly:</dfn> " + T.formatTimeLetter(T.SECONDS_TILL_WEEKLY, false);
		K.timeDirectory.title = K.timeLocal.title;
		I.qTip.init(K.timeLocal);
		I.qTip.init(K.timeDirectory);
		// Also update timeline
		H.updateTimelineIndicator();
	},
	
	/*
	 * Updates waypoint icons' copy text.
	 * @pre The waypoint icon's position on the clock was updated.
	 * Standard bosses' schedule does not have gaps, hardcore may have gaps.
	 */
	updateWaypointsClipboard: function()
	{
		var updateWaypoint = function(pWaypoint, pChainSD, pChainHC, pChainSDAfter, pChainHCAfter)
		{
			var text = "";
			
			// Chains for the clicked timeframe
			text += pChainSD.waypoint + " " + D.getChainAlias(pChainSD);
			// If hardcore chain doesn't exist
			if ( ! pChainHC || pChainHC.flags.isClipped === false)
			{
				text += T.getTimeTillChainFormatted(pChainSD);
			}
			else if (pChainHC.flags.isClipped !== false)
			{
				text += " " + D.getTranslation("and") + " " + pChainHC.waypoint
					+ " " + D.getChainAlias(pChainHC)
					+ T.getTimeTillChainFormatted(pChainHC);
			}
			
			// Chains for the timeframe after that
			text += ", " + D.getTranslation("then") + " " + pChainSDAfter.waypoint
				+ " " + D.getChainAlias(pChainSDAfter);
			if ( ! pChainHCAfter || pChainHCAfter.flags.isClipped === false)
			{
				text += T.getTimeTillChainFormatted(pChainSDAfter);
			}
			else if (pChainHCAfter.flags.isClipped !== false)
			{
				text += " " + D.getTranslation("and") + " " + pChainHCAfter.waypoint
					+ " " + D.getChainAlias(pChainHCAfter)
					+ T.getTimeTillChainFormatted(pChainHCAfter);
			}
			
			text = text + I.siteTagCurrent;
			I.updateClipboard(pWaypoint, text);
		};
		
		updateWaypoint(K.WpChain0, C.CurrentChainSD, C.CurrentChainHC, C.NextChainSD1, C.NextChainHC1);
		updateWaypoint(K.WpChain1, C.NextChainSD1, C.NextChainHC1, C.NextChainSD2, C.NextChainHC2);
		updateWaypoint(K.WpChain2, C.NextChainSD2, C.NextChainHC2, C.NextChainSD3, C.NextChainHC3);
		updateWaypoint(K.WpChain3, C.NextChainSD3, C.NextChainHC3, C.NextChainSD4, C.NextChainHC4);
	},
	
	/*
	 * Updates the current and next Dry Top events icons' clipboard text.
	 */
	updateDryTopClipboard: function()
	{
		if (C.isDryTopGenerated)
		{
			var s0 = T.getCurrentDryTopEvents();
			var s1 = T.getCurrentDryTopEvents(1);
			I.updateClipboard("#chnDryTopWaypoint0", s0);
			I.updateClipboard("#chnDryTopWaypoint1", s1);
			var clip0 = $("#mapDryTopClip0");
			var clip1 = $("#mapDryTopClip1");
			if (C.isDryTopIconsShown)
			{
				clip0.val(s0);
				clip1.val(s1);
			}
			I.updateClipboard(clip0, s0);
			I.updateClipboard(clip1, s1);
		}
	},
	
	/*
	 * Initializes the stopwatch and egg timer on the chains page options popup.
	 */
	initializeStopwatch: function()
	{
		// Bind toggle button on top of the digits
		$("#watToggle").click(function()
		{
			$("#itemStopwatch").toggle("fast");
		});
		
		// Start button acts as Start/Pause/Resume
		$("#watStart").click(function()
		{
			$("#watToggle").show();
			$("#itemStopwatch").show().css("font-size", O.Options.int_sizeStopwatchFont);
			var nowms = (new Date()).getTime();
			// Start the first time
			if (K.StopwatchTimestamp === 0)
			{
				var offsetminutes = parseInt($("#watOffsetMinutes").val()) * T.cMSECONDS_IN_MINUTE;
				var offsetseconds = parseInt($("#watOffsetSeconds").val()) * T.cMSECONDS_IN_SECOND;
				K.StopwatchTimestamp = (new Date()).getTime() - (offsetminutes + offsetseconds);
				K.tickStopwatchUp();
			}
			// Resume after pause
			else if (K.isStopwatchPaused)
			{
				K.isStopwatchPaused = false;
				K.StopwatchTimestamp = K.StopwatchTimestamp + (nowms - K.StopwatchTimesleep);
				K.tickStopwatchUp();
			}
			// Pause
			else
			{
				window.clearTimeout(K.StopwatchTimeout);
				K.StopwatchTimesleep = nowms;
				K.isStopwatchPaused = true;
			}
		});
		
		// Stop button resets the countup
		$("#watStop").click(function()
		{
			if (K.StopwatchTimerStart === 0)
			{
				// Only the toggle button if the personal timer isn't running also
				$("#watToggle").hide();
			}
			window.clearTimeout(K.StopwatchTimeout);
			K.isStopwatchPaused = false;
			K.StopwatchTimestamp = 0;
			K.stopwatchUp.innerHTML = "";
		});
		
		// Lap button prints the current moment
		$("#watLap").click(function()
		{
			if (K.StopwatchTimestamp !== 0)
			{
				I.print(K.stopwatchUp.innerHTML);
			}
			else
			{
				I.write("Stopwatch must be running to lap time.");
			}
		});
		
		/*
		 * Egg timer.
		 */
		$("#watTimerStart").click(function()
		{
			$("#watToggle").show();
			$("#itemStopwatch").show().css("font-size", O.Options.int_sizeStopwatchFont);
			var offsetseconds = parseInt($("#watOffsetSeconds").val()) * T.cMSECONDS_IN_SECOND;
			K.StopwatchTimerStart = (new Date()).getTime();
			K.StopwatchTimerFinish = K.StopwatchTimerStart + (O.Options.int_minStopwatchAlert * T.cMSECONDS_IN_MINUTE) + offsetseconds;
			I.write("Alert set for " + (new Date(K.StopwatchTimerFinish)).toLocaleString());
			// Initial call to the update function
			D.verifyNativeTTS();
			K.tickStopwatchDown();
		});
		$("#opt_int_minStopwatchAlert").onEnterKey(function()
		{
			// Pressing enter on the minute input triggers the egg timer start button
			$(this).trigger("change");
			$("#watTimerStart").trigger("click");
		});
		$("#watTimerStop").click(function()
		{
			if (K.StopwatchTimestamp === 0)
			{
				// Only the toggle button if the stopwatch isn't running also
				$("#watToggle").hide();
			}
			K.StopwatchTimerStart = 0;
			K.stopwatchDown.innerHTML = "";
		});
		I.bindInputSelect("#mapAlarmStopwatchUp input, #mapAlarmStopwatchDown input");
	},
	
	/*
	 * Updates the stopwatch countup.
	 */
	tickStopwatchUp: function()
	{
		var elapsedms = (new Date()).getTime() - K.StopwatchTimestamp;
		K.stopwatchUp.innerHTML = T.formatTimeColon(elapsedms, true);
		K.StopwatchTimeout = setTimeout(function()
		{
			K.tickStopwatchUp();
		}, K.stopwatchFrequency);
	},
	
	/*
	 * Updates the personal countdown timer.
	 * To be called by the clock tick second function.
	 */
	tickStopwatchDown: function()
	{
		var now = new Date();
		var msec = K.StopwatchTimerFinish - now.getTime();
		if (msec > 0)
		{
			K.stopwatchDown.innerHTML = T.formatTimeLetter(~~(msec / T.cMSECONDS_IN_SECOND), true);
		}
		else
		{
			// If negative then timer has finished
			$("#watTimerStop").trigger("click");
			var speech = O.Options.str_textStopwatchAlert;
			I.print(now.toLocaleString() + ": " + U.escapeHTML(speech));
			D.speak(speech);
		}
	},
	
	/*
	 * Festival decorative function.
	 */
	refreshFestival: function()
	{
		return;
		var numsnowflakes = 144;
		var canvas = document.getElementById("paneClockCanvas");
		var context = canvas.getContext("2d");
		// Erase previous snowflakes
		context.clearRect(0, 0, canvas.width, canvas.height);
		// Sprinkle new snowflakes
		var x, y;
		for (var i = 0; i < numsnowflakes; i++)
		{
			x = T.getRandomIntRange(0, canvas.width);
			y = T.getRandomIntRange(0, canvas.height);
			context.fillStyle = "rgba(255,255,255,255)";
			context.fillRect(x, y, 1, 1);
		}
	}
};
I = {
/* =============================================================================
 * @@Interface HTML and CSS content manipulation
 * ========================================================================== */

	cSiteName: "GW2Timer.com",
	cSiteLink: "gw2timer.com/",
	cSiteURL: "http://gw2timer.com/",
	cSiteExternal: "http://gw2timer.com/out/?u=",
	cSiteTitle: "",
	cImageHost: "http://i.imgur.com/",
	cGameName: "Guild Wars 2",
	cGameNick: "GW2",
	cErrorAPI: "ArenaNet API server may be down.",
	cAJAXGlobalTimeout: 30000, // milliseconds
	cPNG: ".png", // Almost all used images are PNG
	cJSON: ".json", // Format of API files
	cTXT: ".txt", // Plain text and test files
	cThrobber: "<div class='itemThrobber'><em></em></div>",
	cChatcodePrefix: "[&",
	cChatencodedPrefix: "%255B%2526",
	cChatcodeSuffix: "]",
	cTextDelimiterChar: "|",
	cTextDelimiterRegex: /[|]/g,
	cTextReplace: "{0}",
	cOptionsDelimiter: ": ",
	cClipboardAttribute: "data-clipboard-text",
	cClipboardSuccessText: "Text copied to clipboard :)<br />",
	cTooltipAttribute: "data-tip",
	cPageAttribute: "data-page",
	consoleTimeout: {},
	siteTagDefault: " - gw2timer.com",
	siteTagCurrent: " - gw2timer.com",
	Symbol:
	{
		Filler: "&zwnj;", // Place this inside empty elements to give them dimension
		Unicode: "中",
		ArrowUp: "⇑",
		ArrowDown: "⇓",
		ArrowLeft: "⇐",
		ArrowRight: "⇒",
		ArrowClockwise: "↻",
		ArrowCounterwise: "↺",
		Horizontal: "⇄",
		Vertical: "⇅",
		TriUp: "▲",
		TriDown: "▼",
		TriRight: "►",
		TriLeft: "◄",
		Block: "■",
		Star: "☆",
		Wait: "⏳",
		Infinity: "∞",
		Approx: "≈",
		Negative: "−",
		Quantity: "×",
		Ellipsis: "…",
		Day: "☀",
		Night: "☽",
		Expand: "◢",
		Collapse: "◣",
		External: "↗",
		Help: "[?]",
		StateActive: "<span class='cssState cssStateActive'></span>",
		StateInactive: "<span class='cssState cssStateInactive'></span>",
		StateWaiting: "<span class='cssState cssStateWaiting'></span>"
	},
	
	// HTML/CSS pixel units
	cOUT_OF_VIEW: -9999,
	cPANEL_WIDTH: 360,
	cPANEL_HEIGHT_MIN: 220,
	cPANE_CLOCK_HEIGHT: 360,
	cPANE_CLOCK_HEIGHT_COMPACT: 220,
	cPANE_CLOCK_HEIGHT_BAR: 85,
	cPANE_MENU_HEIGHT: 48,
	cTOOLTIP_MOUSEMOVE_MS: 20,
	cTOOLTIP_NUM_RERENDER: 8, // Times to trigger the tooltip move function so the tooltip resizes to its ultimate size
	cTOOLTIP_OFFSET_ADD_X: 0,
	cTOOLTIP_OFFSET_ADD_Y: 56,
	cTOOLTIP_OVERFLOW_ADD_X: 16,
	cTOOLTIP_OVERFLOW_ADD_Y: 38,
	cTOOLTIP_PADDING_ADD_Y: 12,
	CLOCK_AND_MENU_HEIGHT: 0,
	posX: 0, // Mouse position
	posY: 0,
	// Overlay sleep detector
	isSleeping: false,
	cMSECONDS_SLEEP: 3000,
	SleepTimeout: {},
	Scrl: { // Autoscroll
		Anchor: {},
		Interval: {},
		Container: {},
		isOn: false,
		posX: 0,
		posY: 0
	},
	
	isProgramLoaded: false,
	isProgramEmbedded: false,
	isProgramExternal: false, // If is embedded in another site rather self-embedded
	isProgramFocused: true, // Whether the user's current browser tab is this site
	isAPIEnabled: true, // This will be changed asynchronously by the populate map function
	isMapEnabled: true,
	isTouchEnabled: false,
	isCustomScrollEnabled: true,
	isSpeechSynthesisEnabled: false,
	isSpeechNativeEnabled: false,
	isSpeechNativeLoaded: false,
	isProjectionEnabled: false,
	ModeCurrent: null,
	// Content-Plate-Page and Section-Header
	ModeEnum:
	{
		Website: "Website",
		Mobile: "Mobile",
		Simple: "Simple",
		Tile: "Tile",
		Overlay: "Overlay",
		Projection: "Projection"
	},
	cPlatePrefix: "#plate",
	cPlateMenuPrefix: "#plateMenu_",
	PageInitial: "",
	PageCurrent: "",
	PagePrevious: "",
	PlateEnum: // The pages displayed by the side app panel
	{
		Directory: "Directory",
		Chains: "Chains",
		Map: "Map",
		Help: "Help",
		Options: "Options"
	},
	isMapPlateInitialized: false,
	isAccountPanelInitialized: false,
	SpecialPageEnum:
	{
		Account: "Account",
		Audit: "Audit",
		WvW: "WvW",
		Leaderboard: "Leaderboard"
	},
	LoadedStylesheets: {}, // Holds names of stylesheets to not download again
	/*
	 * Enumeration for opening a valid page or section (subpage) upon site load, if URL provided.
	 * Page names must be unique, and may be in sentence case or all caps.
	 */
	PageEnum:
	{
		Chains:
		{
			Scheduled: "Scheduled",
			Special: "Special",
			Drytop: "Drytop",
			Legacy: "Legacy",
			Temple: "Temple",
			Timetable: "Timetable"
		},
		Map:
		{
			Daily: "Daily",
			Resource: "Resource",
			JP: "JP",
			Collectible: "Collectible",
			Guild: "Guild",
			TP: "TP",
			Notepad: "Notepad",
			Personal: "Personal"
		},
		Help:
		{
			FAQ: "FAQ",
			About: "About",
			Embed: "Embed",
			Schedules: "Schedules",
			Legacies: "Legacies",
			Temples: "Temples",
			Contested: "Contested"
		},
		Account:
		{
			Manager: "Manager",
			Bank: "Bank",
			Materials: "Materials",
			Vault: "Vault",
			Wardrobe: "Wardrobe",
			Outfits: "Outfits",
			Gliders: "Gliders",
			Dyes: "Dyes",
			Minis: "Minis",
			Carriers: "Carriers",
			Champions: "Champions",
			Finishers: "Finishers",
			Nodes: "Nodes",
			Cats: "Cats",
			Achievements: "Achievements",
			Masteries: "Masteries",
			Raids: "Raids",
			Dungeons: "Dungeons",
			
			Characters: "Characters",
			Hero: "Hero",
			Possessions: "Possessions",
			Ascended: "Ascended",
			Inventory: "Inventory",
			Catalog: "Catalog",
			Cleanup: "Cleanup",
			Recipes: "Recipes",
			Crafting: "Crafting",
			SAB: "SAB",
			
			Trading: "Trading",
			Gem: "Gem",
			Museum: "Museum",
			Pact: "Pact",
			Buying: "Buying",
			Selling: "Selling",
			Bought: "Bought",
			Sold: "Sold"
			
			/*PVP: "PVP",
			Guilds: "Guilds",
			Achievements: "Achievements"*/
		}
	},
	/*
	 * Outline of the directory menu. Format:
	 * Grouping: {Page: "Translatable Name"}
	 */
	Directory:
	{
		Directory:
		{
			Scheduled: "Boss Timers",
			Map: "World Map",
			Leaderboard: "WvW Leaderboard",
			Manager: "Account Manager",
			Gem: "Gem Alarm",
			Options: "Options"
		},
		Timers:
		{
			Tile: "Timers Only",
			Timetable: "Full Timetable",
			Special: "Special Bosses",
			DryTop: "Dry Top",
			Help: "Boss Guides",
			Forum: "Forum"
		},
		Map:
		{
			Resource: "Resource Nodes",
			JP: "Jumping Puzzles",
			Collectible: "Collectible Items",
			Guild: "Guild Missions"
		},
		Checklist:
		{
			Personal: "Personal",
			Notepad: "Notepad",
			Daily: "Dailies",
			Raids: "Raids",
			Dungeons: "Dungeons"
		},
		Account:
		{
			Audit: "Audit",
			Characters: "Characters",
			Hero: "Hero",
			Achievements: "Achievements",
			Masteries: "Masteries",
			Recipes: "Recipes"
		},
		Inventory:
		{
			Inventory: "Inventory",
			Bank: "Bank",
			Materials: "Materials",
			Vault: "Vault",
			Possessions: "Possessions",
			Catalog: "Catalog",
			Cleanup: "Cleanup",
			Ascended: "Ascended"
		},
		Wardrobe:
		{
			Wardrobe: "Skins",
			Outfits: "Outfits",
			Gliders: "Gliders",
			Dyes: "Dyes",
			Minis: "Minis",
			Carriers: "Carriers",
			Champions: "Champions",
			Finishers: "Finishers",
			Nodes: "Nodes",
			Cats: "Cats",
			SAB: "SAB"
		},
		Trading:
		{
			TP: "Tracker",
			Trading: "Exchange",
			Buying: "Buying",
			Selling: "Selling",
			Bought: "Bought",
			Sold: "Sold",
			Museum: "Museum",
			Pact: "Pact"
		}
	},
	DirectoryExternal: // Associative array of URL that opens a new window
	{
		Forum: U.URL_META.Forum
	},
	DirectoryCompound: // Associative array of compound translation buttons
	{
		Special: true,
		Timetable: true,
		DryTop: true
	},
	/*
	 * Number used to open a section's subcontent, written as 1-indexed via
	 * query string, but used as 0-indexed.
	 */
	SectionCurrent: {},
	ArticleCurrent: null,
	contentCurrentPlate: "", // This is cContentPrefix + contentCurrent
	isContentLoaded_Map: false,
	isContentLoaded_Help: false,
	isSectionLoaded_Daily: false,
	cHeaderPrefix: "#header",
	
	// User information
	BrowserCurrent: -1,
	BrowserEnum:
	{
		Unknown: -1,
		IE: 0,
		Opera: 1,
		Firefox: 2,
		Chrome: 3
	},
	ClickEnum:
	{
		Left: 1,
		Middle: 2,
		Right: 3
	},
	// Screen width in pixels, for determining map zoom values
	ScreenWidth:
	{
		Huge: 2560,
		Large: 1024,
		Medium: 640
	},
	
	/*
	 * Does things that need to be done before everything else.
	 * @pre This function is ran before any initialization functions.
	 */
	initializeFirst: function()
	{
		// Manually clear the TTS iframe to prevent old sound from playing
		D.stopSpeech();

		// Detect iFrame embedding
		if (window !== window.top)
		{
			I.isProgramEmbedded = true;
			try
			{
				// If self-embedded
				parent.document;
			}
			catch (e)
			{
				// If embedded in another website
				I.isProgramExternal = true;
			}
		}
		
		// Get URL arguments and do appropriate changes
		U.enforceURLArgumentsFirst();
		I.enforceProgramMode();
		U.updateLanguageLinks();
		
		// Tell if DST is in effect
		T.checkDST();
		// If user lives in the Americas then use AM/PM time format by default
		T.cUTC_OFFSET_USER = -((new Date()).getTimezoneOffset() / T.cMINUTES_IN_HOUR);
		if (T.cUTC_OFFSET_USER <= T.cUTC_OFFSET_EASTERN
			&& T.cUTC_OFFSET_USER >= T.cUTC_OFFSET_HAWAII)
		{
			O.Options.bol_use24Hour = false;
		}
		
		// Initialize timestamps
		var currenttimestamp = T.getUNIXSeconds();
		O.initializeTimestamp(O.Utilities.timestampDaily);
		O.initializeTimestamp(O.Utilities.timestampWeekly);
		
		// Initial sync of the sleep detection variable
		K.awakeTimestampPrevious = currenttimestamp;
		
		// Tailor the initial zoom for WvW so all borderlands fit in the screen
		if (screen.height >= 800)
		{
			O.Options.int_setInitialZoomWvW = 3;
		}
		else if (screen.height >= 480)
		{
			O.Options.int_setInitialZoomWvW = 2;
		}
		else
		{
			O.Options.int_setInitialZoomWvW = 1;
		}
		// Pre-set account bank width
		if (screen.width < 1200)
		{
			O.Options.bol_condenseBank = true;
		}
		
		// Remember user's browser maker
		var useragent = navigator.userAgent;
		if (useragent.indexOf("MSIE") !== -1 || useragent.indexOf("Trident") !== -1)
		{
			I.BrowserCurrent = I.BrowserEnum.IE;
		}
		else if (useragent.indexOf("Chrome") !== -1)
		{
			I.BrowserCurrent = I.BrowserEnum.Chrome;
		}
		else if (useragent.indexOf("Firefox") !== -1)
		{
			I.BrowserCurrent = I.BrowserEnum.Firefox;
		}
		else if (useragent.indexOf("Opera") !== -1)
		{
			I.BrowserCurrent = I.BrowserEnum.Opera;
		}
		
		// Detect TTS capability
		try {
			if (window.speechSynthesis && I.BrowserCurrent === I.BrowserEnum.Chrome && I.ModeCurrent !== I.ModeEnum.Overlay)
			{
				I.isSpeechSynthesisEnabled = true;
				// Automatically reload the asynchronous voices
				window.speechSynthesis.onvoiceschanged = function()
				{
					window.speechSynthesis.getVoices();
				};
			}
		}
		catch (e) {}
		
		// Set the maximum wait time for all non-custom AJAX requests, such as getJSON
		$.ajaxSetup({ timeout: I.cAJAXGlobalTimeout });
		
		// Initialize first interfaces
		I.Scrl.Anchor = $("#itemAutoscroll");
		I.qTip.start();
		
		// Temporary transfer of old named compasses
		if (localStorage["obj_utlStoredWeapons"])
		{
			localStorage["obj_utlStoredCompasses"] = localStorage["obj_utlStoredWeapons"];
		}
		if (localStorage["obj_utlStoredWeaponsWvW"])
		{
			localStorage["obj_utlStoredCompassesWvW"] = localStorage["obj_utlStoredWeaponsWvW"];
		}
	},
	
	/*
	 * Does things that need to be done after everything was initially loaded
	 * (does not count AJAX loaded content).
	 */
	initializeLast: function()
	{
		// Initializes all UI
		I.initializeTooltip();
		I.bindHelpButtons("#plateOptions");
		I.bindWindowReadjust();
		I.initializePlateMenu();
		I.initializeHUD();
		I.styleContextMenu("#mapContext");
		$("#mapHUDContainer").toggle(O.Options.bol_showHUD);
		// Bind switch map buttons
		$("#mapSwitchButton").click(function()
		{
			I.switchMap();
		});
		$("#wvwSwitchButton").click(function()
		{
			I.switchMap();
		});
		$(".mapDisplayButton").click(function()
		{
			$("#opt_bol_showPanel").trigger("click");
		});
		// Bind account button
		$("#mapAccountButton, #wvwAccountButton").one("click", function()
		{
			I.loadAccountPanel();
		}).click(function()
		{
			I.toggleAccount();
		});
		
		// Do special commands from the URL
		U.enforceURLArgumentsLast();
		// Open Chains section if on that page
		if (I.PageCurrent === I.PlateEnum.Chains)
		{
			U.openSectionFromURL();
		}
		
		// Clear the non-load warning after everything succeeded
		$("#itemWarning").remove();
		// Bind console buttons
		$("#cslClose").click(function()
		{
			I.clear();
		});
		$("#cslSelect").click(function()
		{
			I.selectConsole();
		});
		$("#cslToggle").click(function()
		{
			I.getConsole().toggle("fast");
		});
		$(".hudItem").one("mouseenter", function()
		{
			$(this).find("img").each(function()
			{
				$(this).attr("src", $(this).attr("data-src"));
			});
		});
		// Initialize the elements in the chain options popup
		$("#mapAlarmPopup").one("mouseenter", function()
		{
			I.loadImg($(this));
			K.initializeStopwatch();
			$("#optAlarmSpeaker").click(function()
			{
				D.speak(D.getWord("alarm"));
			});
			$("#optMute").click(function()
			{
				D.stopSpeech();
			});
		});
		// Make all links to other sites open a new tab
		U.convertExternalLink(".linkExternal");
		
		// Cursors on these Leaflet elements cause slowdown in IE, only add them for other browsers
		if (I.BrowserCurrent !== I.BrowserEnum.IE)
		{
			$("head").append("<style>.leaflet-clickable{cursor: url('img/cursor/pointer.cur'), pointer;}</style>");
		}
		
		// Bind browser tab focus
		$(window).focus(function()
		{
			I.isProgramFocused = true;
		}).blur(function()
		{
			I.isProgramFocused = false;
		});
		
		// Bind special popup elements that can be removed if user clicks anywhere not on it
		$(document).mouseup(function(iEvent)
		{
			$(".jsRemovable, .jsHidable").each(function()
			{
				if ( ! $(this).is(iEvent.target) && $(this).has(iEvent.target).length === 0)
				{
					if ($(this).hasClass("jsHidable"))
					{
						$(this).hide();
					}
					if ($(this).hasClass("jsRemovable"))
					{
						$(this).remove();
					}
				}
			});
		}).onEscapeKey(function()
		{
			// Handler for escape key
			if (I.isConsoleShown())
			{
				I.clear();
			}
		});
		// Stop autoscrolling if user moves the scroll wheel
		if (I.isCustomScrollEnabled)
		{
			$(document).on("ps-scroll-y", function()
			{
				I.clearAutoscroll();
			});
		}

		// Initialize scroll bars for pre-loaded plates
		if (I.isMapEnabled)
		{
			I.bindScrollbar("#cslContent, #plateDirectory, #plateChains, #plateOptions");
		}
		
		// Clean the localStorage of unrecognized variables
		O.cleanLocalStorage();
		
		// Update and notify user of version change
		O.enforceProgramVersion();
		
		// Post translations
		D.translateAfter();
		U.initializeLanguageButton();
		
		// View map event or map center
		if (P.wantTourPrediction())
		{
			$("#chnEvent_" + C.CurrentChainSD.nexus + "_"
				+ C.CurrentChainSD.CurrentPrimaryEvent.num).trigger("click");
		}
		else if (I.isMapEnabled)
		{
			// Initialize the "current moused zone" variable for showing waypoints
			M.showCurrentZone(M.getZoneCenter(M.cInitialZone));
			M.goToDefault(O.Options.int_setInitialZoom);
			if (I.ModeCurrent === I.ModeEnum.Overlay)
			{
				P.updateCharacter(0);
			}
		}
		
		// Set tile after viewing the coordinate so it downloads the tiles last
		if (I.isMapEnabled)
		{
			if (I.isProjectionEnabled)
			{
				M.toggleFloor(false);
			}
			else
			{
				if (I.PageInitial === "wvw")
				{
					$("#wvwSwitchButton").one("click", function()
					{
						M.toggleFloor(true);
					});
				}
				M.toggleFloor(true);
			}
		}
		
		// Check gem store alerts if opted
		if (O.Options.bol_alertGem)
		{
			H.updateGemSubscription();
		}
		
		// Finally
		I.isProgramLoaded = true;
	},
	
	/*
	 * Binds chains list expansion behavior.
	 */
	initializeChainsUI: function()
	{
		/*
		 * Chains list collapsible headers.
		 */
		$("#plateChains header").click(function()
		{
			var section = U.getSubstringFromHTMLID($(this));
			
			$(this).next().slideToggle("fast", function()
			{
				var headerid = $(this).attr("id");
				// Change the toggle icon after finish toggling
				if ($(this).is(":visible"))
				{
					// EXPANDED
					I.updateScrollbar();
					var container = $(I.cPlatePrefix + I.PlateEnum.Chains);
					var header = $(this).prev();
					header.find("kbd").html(I.Symbol.Collapse);
					// Automatically scroll to the clicked header
					I.scrollToElement(header, {aContainer: container, aSpeed: "fast"});
					
					// View the map at Dry Top if it is that chain list
					switch (headerid)
					{
						case "sectionChains_Drytop": 
						{
							if (I.isMapEnabled)
							{
								M.goToZone("dry", M.ZoomEnum.Bird);
								P.toggleDryTopIcons(true);
							}
							$("#mapHUDContainerInner").hide();
						} break;
						case "sectionChains_Special":
						{
							H.toggleSpecialIcons(true);
						} break;
					}
					// Update current section variable, ignore if on Scheduled section of Chains page
					I.SectionCurrent[I.PlateEnum.Chains] = (section === I.PageEnum.Chains.Scheduled) ? "" : section;
				}
				else
				{
					// COLLAPSED
					I.updateScrollbar();
					$(this).prev().find("kbd").html(I.Symbol.Expand);
					// Reset Dry Top page variable
					switch (headerid)
					{
						case "sectionChains_Drytop": 
						{
							P.toggleDryTopIcons(false);
							$("#mapHUDContainerInner").show();
						} break;
						case "sectionChains_Special":
						{
							H.toggleSpecialIcons(false);
						} break;
					}
					// Nullify current section variable
					I.SectionCurrent[I.PlateEnum.Chains] = "";
				}
				U.updateQueryString();
			});
		});
		
		// Add collapse text icon to headers; first one is pre-expanded
		$("#plateChains header:not(:first)").each(function()
		{
			$(this).next().toggle(0);
			$(this).find("kbd").html(I.Symbol.Expand);
		});
		$("#plateChains header:first").each(function()
		{
			$(this).find("kbd").html(I.Symbol.Collapse);
		});

		// Create chain bars for unscheduled chains only when manually expanded the header
		if (I.ModeCurrent === I.ModeEnum.Tile)
		{
			$("#headerChains_Drytop").hide();
			$("#sectionChains_Scheduled .chnDetails").hide();
		}
		else
		{
			$("#headerChains_Drytop").one("click", function()
			{
				P.generateDryTop();
			});
		}
		$("#headerChains_Legacy").one("click", function()
		{
			C.initializeUnscheduledChains(C.LegacyChains);
			I.readjustTile();
		});
		$("#headerChains_Temple").one("click", function()
		{
			C.initializeUnscheduledChains(C.TempleChains);
			I.readjustTile();
		});
		
		// Button to toggle the chain bar expand option
		$("#chnToggle").click(function()
		{
			$("#opt_bol_expandWB").trigger("click");
		});

		// Generate a full timetable of the chains when clicked on that header
		$("#headerChains_Timetable").one("click", function(){
			C.isTimetableGenerated = true;
			C.initializeTimetableHTML();
			I.readjustTile();
		});
		I.readjustTile();
	},
	openChainsSection: function(pSection)
	{
		// Collapse all currently expanded sections
		$("#plateChains section").each(function()
		{
			var section = U.getSubstringFromHTMLID($(this));
			if ($(this).is(":visible") && section !== pSection)
			{
				$(this).prev().trigger("click");
			}
		});
		// Expand the requested section if not already
		if (pSection)
		{
			if ($("#sectionChains_" + pSection).is(":visible") === false)
			{
				$("#headerChains_" + pSection).trigger("click");
			}
		}
	},
	
	/*
	 * Gets the console content element for appending.
	 * @returns jqobject
	 */
	getConsole: function(pWantShow)
	{
		if (pWantShow)
		{
			$("#itemConsole").show();
		}
		return $("#cslContent");
	},
	
	/*
	 * Writes an HTML string to the "console" area in the top left corner of
	 * the website that disappears after a while.
	 * @param string pString to write.
	 * @param float pSeconds to display the console with that string. 0 for infinite.
	 * @param boolean pClear to empty the console before printing.
	 * @param boolean pWantBreak to insert break at the end.
	 * @pre If input was from an outside source it must be escaped first!
	 */
	write: function(pString, pSeconds, pClear, pWantBreak)
	{
		$("#itemConsole").show();
		var content = $("#cslContent").show();
		var characterspersecond = 18;
		
		if (pString === undefined)
		{
			pString = "undefinedstring";
		}
		else if (pString === null)
		{
			pString = "nullstring";
		}
		else
		{
			pString = pString.toString();
		}
		if (pClear === undefined)
		{
			pClear = false;
		}
		if (pClear === true)
		{
			content.empty();
		}
		if (isFinite(pSeconds) === false)
		{
			/*
			 * If seconds to display was not specified, set display time
			 * based on how long the string is.
			 */
			pSeconds = 3 + parseInt(pString.length / characterspersecond);
		}
		var breakstr = (pWantBreak !== false) ? "<br />" : "";
		content.append(pString + breakstr);
		I.updateScrollbar(content);
		
		// Ignore previous display time, which is how long before the console is cleared
		window.clearTimeout(I.consoleTimeout);
		// Only queue to clear the console if seconds is not set as so
		if (pSeconds !== 0)
		{
			I.consoleTimeout = setTimeout(function()
			{
				content.css({opacity: 1}).animate({opacity: 0}, 600, function()
				{
					$(this).empty().css({opacity: 1});
					$("#itemConsole").hide();
				});
			}, pSeconds * T.cMSECONDS_IN_SECOND);
		}
	},
	greet: function(pString, pSeconds, pClear)
	{
		// For messages that are shown when the program has just loaded
		if (I.isProgramEmbedded === false && I.PageInitial !== "wvw")
		{
			I.write(pString, pSeconds, pClear);
		}
	},
	
	/*
	 * Writes HTML into the console without disappearing, with fast DOM implementation.
	 * @param string pString to write.
	 * @param boolean pClear to empty the console before printing.
	 * @param boolean pWantBreak to insert break at the end.
	 */
	print: function(pString, pClear, pWantBreak)
	{
		if (pClear)
		{
			I.clear();
		}
		window.clearTimeout(I.consoleTimeout);
		var console = document.getElementById("itemConsole");
		var content = document.getElementById("cslContent");
		var breakstr = (pWantBreak !== false) ? "<br />" : "";
		console.style.display = "block";
		content.insertAdjacentHTML("beforeend", pString + breakstr);
	},
	
	/*
	 * Writes a textarea to the console that autocopies its contents.
	 * @param string pString
	 */
	paste: function(pString)
	{
		I.print("Click the box below to auto-copy:");
		$("<textarea class='cssInputText cslText'></textarea>").appendTo(I.getConsole()).val(pString);
		I.print("");
		I.bindConsoleInput();
	},
	
	/*
	 * Writes HTML into the console in a slim window format.
	 * @param string pString to write.
	 */
	help: function(pString)
	{
		I.print("<div class='cslModal cntComposition'>" + pString + "</div>", true);
		U.convertExternalLink("#cslContent a");
	},
	
	/*
	 * Prints a warning message of API retrieval failure.
	 * @param string pFeature that was failed to be retrieved.
	 * @param boolean pWantPrint so the message stays on.
	 */
	warn: function(pFeature, pWantPrint)
	{
		var msg = "Unable to retrieve " + pFeature + ". " + I.cErrorAPI;
		if (pWantPrint)
		{
			I.print(msg);
		}
		else
		{
			I.write(msg);
		}
	},
	
	/*
	 * Prints an urgent message with high visibility
	 * @param string pString
	 */
	urge: function(pString, pSeconds)
	{
		var str = "<div class='cslUrgent'>" + pString + "</div>";
		I.write(str, pSeconds, false, false);
		I.bindConsoleLink();
	},
	
	/*
	 * Clears the console of all previous text.
	 */
	clear: function()
	{
		window.clearTimeout(I.consoleTimeout);
		$("#itemConsole").hide();
		$("#cslContent").empty();
	},
	selectConsole: function()
	{
		I.selectText("#cslContent");
	},
	
	/*
	 * Alternative for print but used for testing and easier to find and remove.
	 */
	log: function(pString, pClear)
	{
		if (typeof pString === "string")
		{
			I.print(pString, pClear);
		}
		else
		{
			I.prettyJSON(pString, pClear);
		}
	},
	
	/*
	 * Prints an object in JSON format.
	 * @param object pObject.
	 */
	printJSON: function(pObject)
	{
		I.print(U.escapeJSON(pObject));
	},
	prettyJSON: function(pObject)
	{
		I.print("<pre>" + U.escapeJSON(pObject) + "</pre>");
	},
	
	/*
	 * Tells if the console is shown and autoclears it if showing.
	 * @returns boolean.
	 */
	isConsoleShown: function()
	{
		var isshown = $("#itemConsole").is(":visible");
		if (isshown)
		{
			I.clear();
		}
		return isshown;
	},
	
	/*
	 * Makes any input element in the console autoselect when clicked on.
	 */
	bindConsoleInput: function()
	{
		I.getConsole().find(".cssInputText").each(function()
		{
			I.bindClipboard($(this), $(this).val(), false);
			$(this).unbind("click").click(function()
			{
				$(this).select();
			});
		});
	},
	bindConsoleLink: function()
	{
		var links = I.getConsole().find("a");
		if (links.length)
		{
			U.convertExternalLink(links);
			U.convertInternalLink(links);
		}
	},
	
	/*
	 * Selects text from an element (as if the user clicked on text and dragged
	 * mouse to select text).
	 * @param string pSelector DOM to get the element with text.
	 */
	selectText: function(pSelector)
	{
		var element = document.querySelector(pSelector);
		var selection = window.getSelection();
		var range = document.createRange();
		range.selectNodeContents(element);
		selection.removeAllRanges();
		selection.addRange(range);
	},
	
	/*
	 * Scrolls to an element at specified rate, or the top if specified no element.
	 * @param string pElement selector to scroll to.
	 * @objparam string aContainer selector container with the scroll bar, optional.
	 * @objparam function aCallback to execute after scrolling, optional.
	 * @objparam int or string aSpeed duration to animate, optional.
	 * @objparam int aOffset from scroll point, optional.
	 */
	scrollToElement: function(pElement, pSettings)
	{
		var Settings = pSettings || {};
		
		var elm = $(pElement);
		var container;
		// Mobile mode webpage height is dynamic
		switch (I.ModeCurrent)
		{
			case I.ModeEnum.Mobile: {
				$("body").scrollTop(elm.offset().top);
			} break;
			
			case I.ModeEnum.Tile: {
				$("#windowMain").animate(
				{
					scrollTop: elm.offset().top - $("#windowMain").offset().top
						+ $("#windowMain").scrollTop()
				}, Settings.aSpeed || 0);
			} break;
			
			default: {
				Settings.aContainer = Settings.aContainer || elm.closest(".jsScrollable");
				if (Settings.aContainer)
				{
					container = $(Settings.aContainer);
					container.animate(
					{
						scrollTop: elm.offset().top - container.offset().top
							+ container.scrollTop() + (Settings.aOffset || 0)
					}, Settings.aSpeed || 0, function()
					{
						if (Settings.aCallback)
						{
							Settings.aCallback();
						}
					});
				}
				else
				{
					// Scroll to top of element without animation
					elm.scrollTop(0);
					if (Settings.aCallback)
					{
						Settings.aCallback();
					}
				}
			}
		}
	},
	
	/*
	 * Finds throbber elements (spinning icon used before AJAX content is loaded)
	 * and removes it.
	 * @param string pContainer selector.
	 */
	removeThrobber: function(pContainer)
	{
		$(pContainer).find(".itemThrobber").remove();
	},
	
	/*
	 * Gets standard HTML for displaying a small static progress bar.
	 * @param float pPercentage.
	 * @param boolean pWantRight whether to align the progress fill to the right.
	 */
	getBar: function(pPercentage, pWantRight, pWantMarker)
	{
		var percentage = (pPercentage > 100) ? 100 : pPercentage;
		return "<samp>"
			+ "<s class='" + (pWantRight ? "cssRight" : "") + "' style='width:" + percentage + "%'>"
				+ (pWantMarker ? "<mark></mark>" : "")
			+ "</s>"
		+ "</samp>";
	},
	
	/*
	 * Animates multiple elements simultaneously.
	 * @param array pRequests array of objects.
	 *	@objparam string s selector for elements.
	 *	@objparam object p properties to animate.
	 * @param int pSpeed of animation.
	 */
	bulkAnimate: function(pRequests, pSpeed)
	{
		for (var i = 0; i < pRequests.length; i++)
		{
			var r = pRequests[i];
			$(r.s).animate(r.p, {duration: pSpeed, queue: false});
		}
	},
	
	/*
	 * Toggles an HTML element.
	 * @param jqobject or string pElement
	 * @param boolean pBoolean
	 * @param string pSpeed
	 * @param boolean pIsInitial to not animate on initial call.
	 */
	toggleElement: function(pElement, pBoolean, pSpeed, pIsInitial)
	{
		var elm = $(pElement);
		if (pIsInitial)
		{
			elm.toggle(pBoolean);
		}
		else
		{
			if (pBoolean)
			{
				elm.show(pSpeed);
			}
			else
			{
				elm.hide(pSpeed);
			}
		}
	},
	
	/*
	 * Toggles the opacity of a HUD window element by toggling a CSS class.
	 * @param jqboject pElement.
	 * @param string pSuffix for getting the associated CSS class.
	 * @param boolean pBoolean.
	 * @pre CSS class was defined in the stylesheet.
	 */
	toggleHUDOpacity: function(pElement, pPrefix, pBoolean)
	{
		var elm = $(pElement);
		if (pBoolean)
		{
			elm.addClass(pPrefix + "Opaque");
			elm.removeClass(pPrefix + "OpaqueNot");
		}
		else
		{
			elm.addClass(pPrefix + "OpaqueNot");
			elm.removeClass(pPrefix + "Opaque");
		}
	},
	
	/*
	 * Toggles a standard arrowhead icon by rotating it.
	 * @param string pSelector of the element.
	 * @param boolean pBoolean true is open state, false is closed state.
	 * @param boolean pWantAnimation
	 */
	toggleToggleIcon: function(pSelector, pBoolean, pWantAnimation)
	{
		if (pWantAnimation || pWantAnimation === undefined)
		{
			if (pBoolean)
			{
				$(pSelector).animate({rotation: 0}, 200);
			}
			else
			{
				$(pSelector).animate({rotation: -90}, 200);
			}
		}
		else
		{
			if (pBoolean)
			{
				$(pSelector).css({rotation: 0});
			}
			else
			{
				$(pSelector).css({rotation: -90});
			}
		}
	},
	
	/*
	 * Shows and hides an element to create a blinking effect.
	 * @param string pSelector of the element.
	 * @param int pDuration in milliseconds.
	 * @param int pSpeed in milliseconds.
	 * @post Element is shown at the final frame.
	 */
	blinkElement: function(pSelector, pDuration, pSpeed)
	{
		var times = parseInt(pDuration / pSpeed);
		// Have to have even numbered times so show and hide equals
		times = (times % 2 === 0) ? times : times + 1;
		var isshown = true;
		var counter = 1;
		var elm = $(pSelector);
		
		var interval = setInterval(function()
		{
			if (isshown)
			{
				elm.css({visibility: "hidden"});
			}
			else
			{
				elm.css({visibility: "visible"});
			}
			isshown = !isshown;
			if (counter === times)
			{
				clearInterval(interval);
			}
			counter++;
		}, pSpeed);
	},
	bloatElement: function(pSelector, pDuration, pSpeed)
	{
		var times = parseInt(pDuration / pSpeed);
		// Have to have even numbered times so show and hide equals
		times = (times % 2 === 0) ? times : times + 1;
		var isshown = true;
		for (var i = 0; i < times; i++)
		{
			if (isshown)
			{
				$(pSelector).hide(pSpeed);
			}
			else
			{
				$(pSelector).show(pSpeed);
			}
			isshown = !isshown;
		}
	},
	
	/*
	 * Executes a callback function over time.
	 * @param int pTarget the number "animate" from 0% to 100% of its value.
	 * @param function pStep to execute.
	 * @param int pDuration milliseconds.
	 */
	animateNumber: function(pTarget, pStep, pDuration, pEasing)
	{
		$({value: 0}).animate({value: T.cPERCENT_100}, {
			duration: pDuration || 3000,
			easing: pEasing || "swing",
			step: function(pCurrentPercent) {
				pStep(pTarget * (pCurrentPercent / T.cPERCENT_100));
			}
		});
	},
	
	/*
	 * Colors the text of an element depending on its numeric value.
	 * @param jqobject pElement.
	 * @param int pValue to compare.
	 * @param int pLimit to compare.
	 */
	colorizeValue: function(pElement, pValue, pLimit)
	{
		var elm = $(pElement);
		elm.removeClass("cssLimitEqual cssLimitWithin cssLimitExceed");
		var cssclass;
		
		if (pLimit === undefined)
		{
			cssclass = (pValue > 0) ? "cssLimitWithin" : ((pValue < 0) ? "cssLimitExceed" : "cssLimitEqual");
		}
		else
		{
			cssclass = (pValue <= pLimit) ? "cssLimitWithin" : "cssLimitExceed";
		}
		elm.addClass(cssclass);
		return elm;
	},
	
	/*
	 * Toggles a generic highlight class to an element.
	 * @param jqobject pElement to toggle.
	 * @param boolean pBoolean manual.
	 * @returns boolean new highlight state.b
	 */
	toggleHighlight: function(pElement, pBoolean)
	{
		if (pBoolean === undefined)
		{
			// Toggle
			if (pElement.hasClass("cssHighlight"))
			{
				pElement.removeClass("cssHighlight");
				return false;
			}
			else
			{
				pElement.addClass("cssHighlight");
				return true;
			}
		}
		else
		{
			// Use boolean
			if (pBoolean)
			{
				pElement.addClass("cssHighlight");
				return true;
			}
			else
			{
				pElement.removeClass("cssHighlight");
				return false;
			}
		}
	},
	
	/*
	 * Makes an element unclickable and have the appearance of so.
	 * @param jqobject pElement.
	 * @param boolean pBoolean to suspend or reactivate.
	 */
	suspendElement: function(pElement, pBoolean)
	{
		if (pBoolean === undefined || pBoolean === true)
		{
			$(pElement).addClass("jsSuspended");
		}
		else
		{
			$(pElement).removeClass("jsSuspended");
		}
	},
	
	/*
	 * Styles and translates a custom context menu.
	 * @param string pMenu name of the menu.
	 */
	styleContextMenu: function(pMenu)
	{
		$(pMenu).addClass("jsHidable").find("li").each(function()
		{
			if ($(this).hasClass("jsIgnore"))
			{
				return;
			}
			// If it is a menu item
			if ($(this).hasClass("itemContextSubmenu") === false)
			{
				if (D.isLanguageDefault === false)
				{
					$(this).text(D.getPhraseOriginal($(this).text()));
				}
			}
			// If it is a label for a submenu
			else
			{
				var label = $(this).find("> span");
				label.html(D.getPhraseOriginal(label.text())).append(" <kbd>" + I.Symbol.TriRight + "</kbd>");
			}
			// Add bullet point decoration
			$(this).prepend("<ins class='s16 s16_bullet'></ins> ");
		});
		
		// Repositions the submenus when they appear outside of screen
		$(pMenu).find(".itemContextSubmenu").each(function()
		{
			$(this).mouseenter(function()
			{
				var parent = $(this);
				var submenu = $(this).find("ul").first();
				var offset = parent.offset();
				var addX = (parent.width() / 2);
				var addY = 6;
				var posX = offset.left + addX;
				var posY = offset.top;
				var width = submenu.width();
				var height = submenu.height();
				var winwidth = $(window).width();
				var winheight = $(window).height();
				var adjustX = (posX + width > winwidth) ? -(width - addX) + "px" : "50%";
				var adjustY = (posY + height > winheight) ? (winheight - (posY + height + addY)) + "px" : "auto";
				submenu.css({left: adjustX});
				submenu.css({marginTop: adjustY});
			});
		});
	},
	
	/*
	 * Shows a context menu element while respecting screen edges.
	 * @param string pID of context menu.
	 */
	showContextMenu: function(pID)
	{
		var elm = $(pID);
		var menuwidth = elm.width();
		var menuheight = elm.height();
		var winwidth = $(window).width();
		var winheight = $(window).height();
		var offsetX = 0;
		var offsetY = 0;
		var padding = 4;
		
		if (I.posX + menuwidth > winwidth)
		{
			offsetX = (I.posX + menuwidth + padding) - winwidth;
		}
		if (I.posY + menuheight > winheight)
		{
			offsetY = (I.posY + menuheight + padding) - winheight;
		}
		
		elm.css({
			top: I.posY - offsetY,
			left: I.posX - offsetX
		}).show();
	},
	
	/*
	 * Binds a search input to filter in matching keywords.
	 * @param jqobject pContainer to create search bar.
	 * @param jqobject pElements to filter.
	 * @param string pParentSelector to filter container of elements, optional.
	 * @pre Each element must have its data "keywords" assigned for the matching.
	 */
	createFilterBar: function(pContainer, pElements, pParentSelector)
	{
		var container = $(pContainer);
		var elements = $(pElements);
		var searchbar = $("<input class='cntSearch cssInputText' type='text' />").appendTo(container);
		I.bindInputBarText(searchbar);
		searchbar.on("input", $.throttle(Q.cSEARCH_LIMIT, function()
		{
			var query = $(this).val().toLowerCase();
			var queries = [];
			var keywords = "";
			if (query.length > 0)
			{
				queries = query.split(" ");
				// Search for every substring in the user's query, which is space separated
				elements.each(function()
				{
					keywords = $(this).data("keywords") || $(this).val();
					var ismatch = true;
					if (keywords)
					{
						for (var i = 0; i < queries.length; i++)
						{
							// If at least one substring of the search query isn't found, then hide that item
							if (keywords.indexOf(queries[i]) === -1)
							{
								if (pParentSelector)
								{
									$(this).closest(pParentSelector).hide();
								}
								else
								{
									$(this).hide();
								}
								ismatch = false;
								break;
							}
						}
						// The boolean is only true if every substrings were found
						if (ismatch)
						{
							$(this).show();
						}
					}
				});
			}
			else
			{
				elements.each(function()
				{
					if (pParentSelector)
					{
						$(this).closest(pParentSelector).show();
					}
					else
					{
						$(this).show();
					}
				});
			}
		})).click(function(pEvent)
		{
			pEvent.stopPropagation();
			$(this).select();
		});
	},
	
	/*
	 * Creates and binds a search bar.
	 * @param jqobject pContainer to append the search bar.
	 * @param object pSettings for the bind search function.
	 * @objparam string aBarClass class of the search bar, optional.
	 * @objparam string aBarID ID of the search bar, optional.
	 * @returns jqobject search bar.
	 */
	createSearchBar: function(pContainer, pSettings)
	{
		var Settings = pSettings || {};
		var idstr = (Settings.aBarID) ? "id='" + Settings.aBarID + "'" : "";
		var searchbar = $("<input " + idstr + " class='cntSearch cssInputText " + (Settings.aBarClass || "") + "' type='text' />").appendTo($(pContainer));
		Q.bindItemSearch(searchbar, pSettings);
		return searchbar;
	},
	
	/*
	 * Binds an input bar to have a "default text" that disappears after the user
	 * have clicked on it, but reappears after the user clears their input text.
	 * @param jqobject pInput to bind.
	 * @param string pText default.
	 */
	bindInputBarText: function(pInput, pText)
	{
		var onclass = "cssSearchActive";
		var offclass = "cssSearchPassive";
		var fillertext = pText || D.getWordCapital("search") + "...";
		var bar = $(pInput).val(fillertext).data("isfiller", true).addClass(offclass);
		bar.click(function()
		{
			if ($(this).data("isfiller"))
			{
				$(this).val("")
					.removeClass(offclass).addClass(onclass);
			}
		}).change(function()
		{
			if ($(this).val().length === 0)
			{
				$(this).val(fillertext).data("isfiller", true)
					.removeClass(onclass).addClass(offclass);
			}
			else
			{
				$(this).data("isfiller", false)
					.removeClass(offclass).addClass(onclass);
			}
		}).focusout(function()
		{
			if ($(this).val().length === 0)
			{
				$(this).val(fillertext).data("isfiller", true)
					.removeClass(onclass).addClass(offclass);
			}
		});
	},
	
	/*
	 * Makes an input autoselect its text when clicked on.
	 * @param jqobject pElement
	 * @returns jqobject
	 */
	bindInputSelect: function(pElement)
	{
		return $(pElement).click(function()
		{
			$(this).select();
		});
	},
	
	/*
	 * Stops map DOM events from interfering with an element.
	 * @param string pSelector of elements to be protected.
	 */
	preventMapPropagation: function(pSelector)
	{
		return $(pSelector).each(function()
		{
			var elm = L.DomUtil.get($(this)[0]);
			if ( ! L.Browser.touch)
			{
				L.DomEvent.disableClickPropagation(elm);
				L.DomEvent.on(elm, "mousewheel", L.DomEvent.stopPropagation);
				L.DomEvent.on(elm, "contextmenu", L.DomEvent.stopPropagation);
			}
			else
			{
				L.DomEvent.on(elm, "click", L.DomEvent.stopPropagation);
			}
		});
	},
	
	/*
	 * Binds an element for clipboard behavior.
	 * @param string or DOM element pSelector for selecting the element.
	 * @param string pText to set element's initial clipboard text, optional.
	 * @returns object Clipboard.
	 */
	bindClipboard: function(pSelector, pText, pWantMessage)
	{
		var elm = (pSelector instanceof jQuery) ? pSelector[0] : pSelector;
		var cb = new Clipboard(elm);
		var wantmessage = pWantMessage || pWantMessage === undefined;
		if (wantmessage)
		{
			cb.on("success", function(pEvent)
			{
				I.write(I.cClipboardSuccessText + pEvent.text, 5);
			});
		}
		if (pText)
		{
			I.updateClipboard(elm, pText);
		}
		return cb;
	},
	
	/*
	 * Sets the text to be copied for that clipboard element.
	 * @param string or jqobject pSelector.
	 * @param string pText to copy.
	 */
	updateClipboard: function(pSelector, pText)
	{
		$(pSelector).attr(I.cClipboardAttribute, pText);
	},
	
	/*
	 * Binds a custom scroll bar for specified element using defined settings.
	 * Container requirements: position relative, overflow hidden.
	 * @param jqobject pElement to initialize.
	 */
	bindScrollbar: function(pSelector, pWantHorizontal)
	{
		if (I.isCustomScrollEnabled)
		{
			try
			{
				var container = $(pSelector).addClass("jsScrollable");
				var wheelspeed = 1;
				switch (I.BrowserCurrent)
				{
					case I.BrowserEnum.Opera: wheelspeed = 5; break;
					case I.BrowserEnum.Firefox: wheelspeed = 3; break;
				}

				container.perfectScrollbar({
					wheelSpeed: wheelspeed,
					suppressScrollX: ((pWantHorizontal === undefined) ? true : !pWantHorizontal)
				});
				container.one("mouseenter", function()
				{
					// Show the scrollbar when hovered over the first time
					container.perfectScrollbar("update");
				});
				I.bindAutoscroll(container);
			}
			catch (e) {}
		}
	},
	
	/*
	 * Updates the scroll bar of a container.
	 * @param jqobject pElement of or container that was initialized with the scroll plugin.
	 */
	updateScrollbar: function(pElement)
	{
		if (I.isCustomScrollEnabled)
		{
			var element = $(pElement);
			if (I.isMapEnabled)
			{
				try
				{
					// Update the pages if element is not specified
					if (pElement === undefined)
					{
						$("#plateDirectory").perfectScrollbar("update");
						$("#plateChains").perfectScrollbar("update");
						$("#plateMap").perfectScrollbar("update");
						$("#plateHelp").perfectScrollbar("update");
						$("#plateOptions").perfectScrollbar("update");
					}
					else
					{
						// If the provided element is not a scroll container then find the closest parent that is
						if (element.hasClass("ps-container") === false)
						{
							element = element.closest(".ps-container");
						}
						if (element)
						{
							element.perfectScrollbar("update");
						}
					}
				}
				catch (e) {}
			}
			else
			{
				$("#windowMain").perfectScrollbar("update");
			}
		}
	},
	
	/*
	 * Binds autoscrolling functionality for a custom scrollbar initialized container.
	 * @param jqobject pContainer.
	 */
	bindAutoscroll: function(pContainer)
	{
		pContainer.mousedown(function(pEvent)
		{
			if (pEvent.which === I.ClickEnum.Middle)
			{
				clearInterval(I.Scrl.Interval);
				if (I.Scrl.isOn)
				{
					I.clearAutoscroll();
				}
				else
				{
					I.Scrl.isOn = true;
					I.Scrl.Anchor.css({
						top: I.posY,
						left: I.posX,
						backgroundImage: "url('img/cursor/autoscroll.png')"
					}).show();
					I.Scrl.posX = I.posX;
					I.Scrl.posY = I.posY;
					I.Scrl.Container = $(this);
					I.tickAutoscroll();
				}
			}
			else if (pEvent.which === I.ClickEnum.Left || pEvent.which === I.ClickEnum.Right)
			{
				if (I.Scrl.isOn)
				{
					I.clearAutoscroll();
				}
			}
		});
	},
	
	/*
	 * Hides the autoscroll anchor and stops the scrolling.
	 */
	clearAutoscroll: function()
	{
		clearInterval(I.Scrl.Interval);
		I.Scrl.isOn = false;
		I.Scrl.Anchor.hide();
	},
	
	/*
	 * Continuously scrolls the current container depending on the cursor's
	 * position away from the autoscroll anchor.
	 */
	tickAutoscroll: function()
	{
		if (I.Scrl.isOn)
		{
			I.Scrl.Interval = setInterval(function()
			{
				var mindistance = 5;
				var maxdistance = 720;
				var difference = I.posY - I.Scrl.posY;
				var initialstrength = 32;
				var strengthdispersion = 32;
				var sign = (difference < 0) ? -1 : 1;
				difference = Math.abs(difference);
				// Scroll rate function
				var scrolldistance = Math.pow(2, (difference + initialstrength) / strengthdispersion);
				// Do not scroll farther than the max distance allowed (per tick)
				if (scrolldistance > maxdistance)
				{
					scrolldistance = maxdistance;
				}
				// Begin scrolling if outside of the anchor threshold distance
				if (difference > mindistance)
				{
					I.Scrl.Container.scrollTop(I.Scrl.Container.scrollTop() + (sign * scrolldistance));
				}
			}, 50);
		};
	},
	
	/*
	 * Binds an HTML table to have its <th></th> elements clickable to sort
	 * the table's elements with "data-value" attribute initialized.
	 * @param jqobject pTable
	 * @objparam boolean aIsList whether the "table" is just one column of <li></li>, optional.
	 * @objparam int aPresortColumn 0 indexed number of column to presort, optional.
	 */
	bindSortableTable: function(pTable, pSettings)
	{
		var table = $(pTable);
		var Settings = pSettings || {};
		var islist = Settings.aIsList;
		
		var sortTable = function(pColumn, pOrder)
		{
			var sortable = [];
			// Loop every row, except the first which should be the header
			var rows = (islist) ? table.find("li") : table.find("tr");
			rows.slice(1).each(function()
			{
				var value = (islist) ? $(this).attr("data-value") : $(this).find("td:eq(" + pColumn + ")").attr("data-value");
				sortable.push({
					item: $(this),
					value: isNaN(value) ? value : parseFloat(value)
				});
			});
			U.sortObjects(sortable, {aKeyName: "value", aIsDescending: pOrder});

			for (var i = 0; i < sortable.length; i++)
			{
				(sortable[i].item).appendTo(table);
			}
		};
		
		// Bind the headers
		var column = 0;
		var headers = (islist) ? table.find("li:first") : table.find("th");
		headers.each(function()
		{
			(function(iHeader, iColumn)
			{
				iHeader.addClass("curToggle").append("&nbsp;<span class='jsSortableHeaderSymbol'>" + I.Symbol.TriDown + "</span>")
					.click(function()
				{
					I.toggleSortableHeader($(this));
					sortTable(iColumn, $(this).data("isdescending"));
				});
			})($(this), column);
			column++;
		});
		
		// Trigger click on header to presort if requested
		if (Settings.aPresortColumn)
		{
			headers.eq(Settings.aPresortColumn).trigger("click");
		}
	},
	
	/*
	 * Toggles the order symbol and boolean data value of a sortable table's header.
	 * @param jqobject pHeader to bind.
	 */
	toggleSortableHeader: function(pHeader)
	{
		var header = $(pHeader);
		// Sort and toggle the boolean
		var isdescending = header.data("isdescending");
		if (isdescending === undefined)
		{
			isdescending = false;
		}
		header.data("isdescending", !isdescending);
		// Change symbol
		var symbol = (isdescending) ? I.Symbol.TriUp : I.Symbol.TriDown;
		header.find(".jsSortableHeaderSymbol").html(symbol);
	},
	
	/*
	 * Binds headers with the jsSection class to toggle display of its sibling
	 * container element. Creates a submenu as an alternate for clicking
	 * the headers; also creates another button-like text at the bottom of the
	 * container to collapse it again.
	 * Example: <header class="jsSection">Example Title</header><div></div>
	 * That container div should contain everything that needs to be collapsed/expanded
	 * by clicking that header tag.
	 * @param string pPlate HTML ID of plate in the content pane.
	 */
	generateSectionMenu: function(pPlate)
	{
		// Don't bind unless there exists
		if ($(pPlate + " header.jsSection").length <= 0)
		{
			return;
		}
		var plate = pPlate.substring(I.cPlatePrefix.length, pPlate.length);
		
		$(pPlate + " header.jsSection").each(function()
		{
			var header = $(this);
			var section = U.getSubstringFromHTMLID($(this));
			var sectioncontent = header.next().addClass("cntSection");
			var headercontent = $(this).children("var").first();
			// Translate header if available
			var headertext = (headercontent.length && D.isLanguageDefault === false)
				? D.getModifiedPhrase(header.text().toLowerCase(), U.CaseEnum.Title) : header.text();
			headercontent.text(headertext);
			// Hide the entire collapsible div tag next to the header tag
			sectioncontent.hide();
			header.wrapInner("<span></span>");
			header.append("<sup>" + I.Symbol.Expand + "</sup>");
			
			// Bind click the header to toggle the sibling collapsible container
			header.click(function()
			{
				var istobeexpanded = false;
				if ($(this).next().is(":visible"))
				{
					// TO BE COLLAPSED
					$(this).children("sup").text(I.Symbol.Expand);
					
					I.displaySectionMarkers(section, false); // Hide this section's map icons
					I.SectionCurrent[plate] = ""; // Nullify current section variable
					
					// Show all headers again
					$(pPlate + " header.jsSection").show();
					$(pPlate + " header.cntHeader").show();
				}
				else
				{
					// TO BE EXPANDED
					istobeexpanded = true;
					$(this).children("sup").text(I.Symbol.Collapse);
					$(pPlate + " .plateBeamIcon[data-section='" + section + "']")
						.addClass("plateBeamIconActive");
					
					I.displaySectionMarkers(section, true); // Show associated map icons
					I.SectionCurrent[plate] = section;
					
					// If clicked from beam menu then hide the other headers to save space
					if ($(this).data("beamclicked") === true)
					{
						$(pPlate + " header.jsSection").not(this).hide();
						$(pPlate + " header.cntHeader").hide();
						$(this).removeData("beamclicked");
					}
					// Default the map view if the header has this CSS class
					if ($(this).hasClass("jsMapDefault"))
					{
						M.goToDefault();
					}
				}
				U.updateQueryString();
				
				// Do the collapse/expand
				if ($(this).data("donotanimate") !== true)
				{
					if (I.ModeCurrent === I.ModeEnum.Website)
					{
						$(this).next().toggle("fast", function()
						{
							I.updateScrollbar(pPlate);
						});
					}
					else
					{
						$(this).next().toggle();
						I.updateScrollbar(pPlate);
					}
				}
				else
				{
					$(this).next().toggle();
				}
				$(this).removeData("donotanimate");
				
				// Scroll to header if expanding, top of page if collapsing
				if (istobeexpanded)
				{
					I.scrollToElement($(this), {aContainer: pPlate, aSpeed: "fast", aOffset: -12});
				}
			});
			
			// Opening the section the first time will load that section's img tags
			header.one("click", function()
			{
				I.loadImg($(this).next());
			});
			
			// Create and bind the additional bottom header to collapse the container
			$("<div class='curClick jsSectionDone'><img src='img/ui/close.png' />" + headertext + "</div>")
			.appendTo(sectioncontent).click(function()
			{
				$(this).parent().prev().trigger("click");
			});
			
			/*
			 * Side menu icons as alternative for headers. Clicking an icon
			 * shows the associated header's sibling container (section) by
			 * triggering that header's handler.
			 */
			if (I.isMapEnabled || header.hasClass("mapOnly") === false)
			{
				header.find("img").attr("id", "plateBeamIcon_" + section).addClass("plateBeamIcon curClick").click(function(pEvent)
				{
					pEvent.stopPropagation();
					// Hide all the collapsible sections
					$(pPlate + " header.jsSection").each(function()
					{
						if ($(this).next().is(":visible") && $(this).attr("id") !== header.attr("id"))
						{
							// Don't animate so the scrolling to the section-to-be-opened works properly
							$(this).data("donotanimate", true);
							$(this).trigger("click");
						}
					});
					// Show the requested section
					header.data("beamclicked", true);
					header.trigger("click");
				});
			}
		});

		// Side menu icon to close all the sections
		$("<img id='plateBeamIconCollapse_" + plate + "' class='plateBeamIcon plateBeamIconCollapse curClick' src='img/ui/adjust_minus.png' "
			+ "title='&lt;dfn&gt;" + D.getPhraseTitle("collapse all section") + "&lt;/dfn&gt;' />")
		.prependTo(pPlate).click(function()
		{
			$(pPlate + " header.jsSection").each(function()
			{
				if ($(this).next().is(":visible"))
				{
					$(this).trigger("click");
				}
			});
			$(pPlate + " .plateBeamIcon").removeClass("plateBeamIconActive");
		});
		
		// Make tooltips for the beam menu icons
		I.qTip.init(pPlate + " .plateBeamIcon");
	},
	
		
	/*
	 * Shows or hides a section's map icons by triggering its toggle button.
	 * Whether the button will hide or show icons depends on its boolean data attribute.
	 * @param string pSection name.
	 * @param boolean pWantShow to show or hide its icons.
	 */
	displaySectionMarkers: function(pSection, pWantShow)
	{
		var button = $("#mapToggle_" + pSection);
		var isshown;
		var wanthideonly;
		if (button.length)
		{
			isshown = button.data("checked");
			wanthideonly = button.data("hideonly");
			
			// If toggle button only serves to hide icons
			if (wanthideonly)
			{
				if ( ! pWantShow)
				{
					button.trigger("click");
				}
			}
			// If toggle button is two-states
			else
			{
				if (pWantShow)
				{
					if ( ! isshown)
					{
						button.trigger("click");
						button.data("checked", true);
					}
				}
				else
				{
					if (isshown)
					{
						button.trigger("click");
						button.data("checked", false);
					}
				}
			}
		}
	},
	
	/*
	 * Loads a stylesheet file from the default directory.
	 * @param string pName filename without extension.
	 */
	loadStylesheet: function(pName)
	{
		if (pName === I.ModeEnum.Website)
		{
			return;
		}
		if (I.LoadedStylesheets[pName] === undefined)
		{
			$("head").append("<link rel='stylesheet' type='text/css' href='style/" + pName.toLowerCase() + ".css' />");
			I.LoadedStylesheets[pName] = true;
		}
	},
	
	/*
	 * Converts img tags with the data-src attribute to src, thereby loading the image.
	 * @param jqobject pContainer to find img tags tag.
	 */
	loadImg: function(pContainer)
	{
		var elms = (typeof pContainer === "string") ? $(pContainer) : pContainer.find("img");
		elms.each(function()
		{
			if ($(this).attr("data-src"))
			{
				$(this)[0].src = $(this).data("src");
			}
		});
	},
	
	/*
	 * Bind tooltip or expand collapsible behavior for [?] "buttons".
	 * @param string pPlate HTML ID of plate in the content pane.
	 */
	bindHelpButtons: function(pPlate)
	{
		// These buttons expand its sibling container which is initially hidden
		$(pPlate + " .jsHelpCollapsible").each(function()
		{
			$(this).text("[?+]").attr("title", "<dfn>More Info</dfn>");
			
			$(this).next().hide();
			$(this).click(function()
			{
				$(this).next().toggle();
				
				if ($(this).next().is(":visible"))
				{
					$(this).text("[?-]");
				}
				else
				{
					$(this).text("[?+]");
				}
			});
		});
		
		// These buttons show a tooltip with description when hovered
		$(pPlate + " .jsHelpTooltip").each(function()
		{
			var title = "<dfn>Info:</dfn> " + $(this).attr("title");
			$(this).text(I.Symbol.Help).attr("title", title);
		});
		
		I.qTip.init(pPlate + " .jsHelpCollapsible");
		I.qTip.init(pPlate + " .jsHelpTooltip");
	},
	
	/*
	 * Toggles the data attribute "checked state" of a button, which basically functions as a checkbox.
	 * @param jqobject pElement to bind.
	 * @returns boolean new toggled state.
	 */
	toggleButtonState: function(pElement)
	{
		var bool = !(pElement.data("checked"));
		pElement.data("checked", bool);
		return bool;
	},
	
	/*
	 * Makes an element have a checkbox change appearance behavior, but does not
	 * actually write to any checklist.
	 * @param string pSelector to bind.
	 * @param float pOpacity when the element is checked.
	 */
	bindPseudoCheckbox: function(pSelector, pOpacity)
	{
		if (pOpacity === undefined)
		{
			pOpacity = 0.3;
		}
		$(pSelector).click(function()
		{
			if ($(this).data("checked") !== true)
			{
				$(this).css({opacity: pOpacity});
				$(this).data("checked", true);
			}
			else
			{
				$(this).css({opacity: 1});
				$(this).data("checked", false);
			}
		});
	},
	
	/*
	 * Generates the front page directory on the app panel.
	 */
	initializeDirectory: function()
	{
		var dir = $("#dirContent");
		var isnondefaultlang = !D.isLanguageDefault;
		var group, groupname, groupheader, headerclass, grouplist, pagename, pagebutton;
		var index = 0;
		// Initialize the checklist storing which directory group was collapsed
		X.initializeChecklist(X.Checklists.Directory, U.getObjectLength(I.Directory));
		// Generate the directory groups
		for (var i in I.Directory)
		{
			group = $("<div class='dirGroup'></div>").appendTo(dir);
			groupname = i.toLowerCase();
			headerclass = (index === 0) ? "dirHeaderPrimary" : "dirHeaderSecondary curToggle";
			groupheader = $("<h2 class='dirHeader " + headerclass + "'>"
				+ "<ins class='dirHeaderIcon mnu mnu_" + groupname + "'></ins><var class='dirHeaderName'>"
				+ ((isnondefaultlang) ? D.getWordCapital(groupname) : i) + "</var></h2>").appendTo(group);
			grouplist = $("<ul id='dirList_" + index + "' class='dirList'></ul>").appendTo(group);
			// Only create a dashboard container (first group) for mobile, and nothing else
			if (I.ModeCurrent === I.ModeEnum.Mobile)
			{
				break;
			}
			// Bind header collapsible behavior
			if (index !== 0)
			{
				groupheader.click(function()
				{
					var thisgrouplist = $(this).next();
					X.setChecklistItem(X.Checklists.Directory, U.getSubintegerFromHTMLID(thisgrouplist),
						thisgrouplist.is(":visible") ? X.ChecklistEnum.Checked : X.ChecklistEnum.Unchecked);
					thisgrouplist.toggle();
				});
				if (X.getChecklistItem(X.Checklists.Directory, index) === X.ChecklistEnum.Checked)
				{
					grouplist.hide();
				}
			}
			// Generate page links for this group
			for (var ii in I.Directory[i])
			{
				// Page translation
				pagename = (I.Directory[i])[ii];
				if (I.DirectoryCompound[ii])
				{
					pagename = D.getTranslation(pagename);
				}
				else if (isnondefaultlang)
				{
					pagename = D.getModifiedPhrase(pagename.toLowerCase(), U.CaseEnum.Title);
				}
				// Page action
				pagebutton = $("<li class='curClick'>" + pagename + "</li>").appendTo(grouplist);
				(function(iPage)
				{
					pagebutton.click(function(pEvent)
					{
						if (pEvent.which === I.ClickEnum.Left)
						{
							if (I.DirectoryExternal[iPage])
							{
								U.openExternalURL(I.DirectoryExternal[iPage]);
							}
							else
							{
								U.interpretPage(iPage);
							}
						}
					});
				})(ii);
			}
			index++;
		}
		
		// First group is for dashboard and general pages
		var primaryheader = $(".dirHeaderPrimary").first();
		primaryheader.find(".dirHeaderName").addClass("curToggle").attr("id", "dirHeaderClock").click(function()
		{
			$("#opt_bol_use24Hour").trigger("click");
		});
		
		// Move the dashboard to a group now that the directory is generated
		if (I.ModeCurrent !== I.ModeEnum.Tile)
		{
			$("#itemDashboard").insertAfter(primaryheader);
		}
	},
	
	/*
	 * Menu event handlers and UI postchanges.
	 */
	initializePlateMenu: function()
	{
		/*
		 * Menu click icon to show respective content plate (page).
		 */
		$(".plateMenuButton").each(function()
		{
			$(this).click(function()
			{
				var plate = $(this).attr("id");
				$(".plateMenuButton").removeClass("plateMenuButtonActive");
				$(this).addClass("plateMenuButtonActive");
				I.PageCurrent = plate.substring(I.cPlateMenuPrefix.length - 1, plate.length);
				I.contentCurrentPlate = I.cPlatePrefix + I.PageCurrent;
				if (P.MapSwitchWebsite === P.MapEnum.Mists)
				{
					I.PagePrevious = I.PageCurrent;
				}
				switch (I.PageCurrent)
				{
					case I.PlateEnum.Directory:
					{
						if (O.Options.bol_hideHUD)
						{
							$("#mapHUDContainerInner").show();
						}
						C.isTouringManual = false;
						if (I.ModeCurrent === I.ModeEnum.Website)
						{
							// Hide any opened chains sections
							I.openChainsSection();
							// Hide any opened map sections
							$("#plateBeamIconCollapse_Map").trigger("click");
						}
					} break;
					case I.PlateEnum.Chains:
					{
						if (O.Options.bol_hideHUD)
						{
							$("#mapHUDContainerInner").show();
						}
						C.isTouringManual = false;
					} break;
					case I.PlateEnum.Map:
					{
						if (I.isMapEnabled)
						{
							M.movePin(M.Pin.Event);
						}
					} break;
				}
				$("#paneContent article").hide(); // Hide all plates
				if ((I.PageCurrent !== I.PlateEnum.Chains && I.PageCurrent !== I.PlateEnum.Directory) && O.Options.bol_hideHUD)
				{
					$("#mapHUDContainerInner").hide();
				}
				
				// App panel page animation
				if (I.isCustomScrollEnabled)
				{
					$(I.contentCurrentPlate + " .cntHeader").css({opacity: 0}).animate( // Fade page title
					{
						opacity: 1
					}, 400);
					$(I.contentCurrentPlate).animate( // Show requested page
					{
						width: "show"
					}, 200);
				}
				$(I.contentCurrentPlate).show();
				
				// Update the address bar URL with the current page name
				U.updateQueryString();
				
				// Also hide chain paths if on the map page
				if (I.isMapEnabled)
				{
					M.toggleLayer(M.ZoneCurrent.Layers.Path, P.isChainPathsAllowed());
				}
			}).one("click", K.styleClock);
		});

		/*
		 * AJAX load the separate HTML files into the content plate when user
		 * clicks on respective menu icon. Most content are not generated until
		 * the user expand a section of the content.
		*/
		// Map plate
		$(I.cPlateMenuPrefix + "Map").one("click", I.loadMapPlate);
		// Help plate
		$(I.cPlateMenuPrefix + "Help").one("click", I.loadHelpPlate);
		
	}, // End of menu initialization
	
	/*
	 * Switches between the API continents, and update associated variables.
	 */
	switchMap: function(pPage)
	{
		// When first switching to the WvW, do initializations
		if (P.MapSwitchWebsite === P.MapEnum.Tyria && W.isWvWPrepped === false)
		{
			W.isWvWPrepped = true;
			I.loadStylesheet("wvw");
			I.loadImg("#wvwHUDPane .hudButton");
			$("#lboCurrent").append(I.cThrobber);
			/*
			 * WvW requires CSS to be loaded first before scripts execute.
			 * To know that the CSS has been loaded, a CSS property is checked,
			 * and this property must be changed here also if it was changed in
			 * the stylesheet.
			 */
			var waitForWvWStylesheet = setInterval(function()
			{
				if ($("#wvwLeaderboard").css("position") === "absolute")
				{
					window.clearInterval(waitForWvWStylesheet);
					U.getScript(U.URL_DATA.WvW, function()
					{
						W.initializeWvW(pPage);
					});
				}
			}, 100);
		}
		
		// Execute map switch
		switch (P.MapSwitchWebsite)
		{
			case P.MapEnum.Tyria: {
				$("#mapPane").hide();
				$("#wvwPane").show();
				if (W.isMapInitialized)
				{
					W.refreshMap();
				}
				I.PagePrevious = I.PageCurrent;
				I.PageCurrent = I.SpecialPageEnum.WvW;
				P.MapSwitchObject = W;
				P.MapSwitchWebsite = P.MapEnum.Mists;
				P.MapSwitchSuffix = W.OptionSuffix;
			} break;
			
			case P.MapEnum.Mists: {
				$("#wvwPane").hide();
				$("#mapPane").show();
				M.refreshMap();
				I.PageCurrent = I.PagePrevious;
				I.PagePrevious = I.SpecialPageEnum.WvW;
				P.MapSwitchObject = M;
				P.MapSwitchWebsite = P.MapEnum.Tyria;
				P.MapSwitchSuffix = M.OptionSuffix;
			} break;
		}
		U.updateQueryString();
	},
	
	/*
	 * Shows or hides the account panel.
	 */
	toggleAccount: function()
	{
		var panel = $("#panelAccount");
		var content = $("#accContent");
		if (panel.is(":visible")) // Hide
		{
			content.hide();
			A.reinitializePanel();
			panel.css({width: "100%"}).animate({width: 0}, "fast", function()
			{
				$(this).hide();
				if (I.isMapEnabled)
				{
					$("#panelMap").show();
					switch (P.MapSwitchWebsite)
					{
						case P.MapEnum.Tyria: {
							$("#mapPane").show();
							M.refreshMap();
						} break;

						case P.MapEnum.Mists: {
							$("#wvwPane").show();
							if (W.isMapInitialized)
							{
								W.refreshMap();
							}
						} break;
					}
				}
			});
			I.PageCurrent = I.PagePrevious;
			I.PagePrevious = I.SpecialPageEnum.Account;
		}
		else // Show
		{
			panel.show().css({width: 0}).animate({width: "100%"}, "fast", function()
			{
				content.show();
				A.adjustAccountPanel();
			});
			I.PagePrevious = I.PageCurrent;
			I.PageCurrent = I.SpecialPageEnum.Account;
			$("#panelMap").hide();
		}
		U.updateQueryString();
	},
	
	/*
	 * Loads the account page into its panel.
	 */
	loadAccountPanel: function(pPage)
	{
		if (A.isAccountInitialized === false && I.isAccountPanelInitialized === false)
		{
			I.isAccountPanelInitialized = true;
			I.loadStylesheet("account");
			$("#panelAccount").load(U.getPageSrc("account"), function()
			{
				U.getScript(U.URL_DATA.Account, function()
				{
					A.initializeAccount(pPage);
				});
			});
		}
	},
	
	/*
	 * Macro function for various written content added functionality. Must be
	 * run at the beginning of any load function's done block.
	 */
	bindAfterAJAXContent: function(pPlateEnum)
	{
		var plate = I.cPlatePrefix + pPlateEnum;
		I.generateSectionMenu(plate);
		if (I.isMapEnabled)
		{
			I.bindScrollbar(plate);
		}
		I.bindHelpButtons(plate);
		M.bindMapLinks(plate);
		// Open links on new window
		U.convertExternalLink(plate + " a");
		I.qTip.init("button");
		
		// Expand a header if requested in the URL
		U.openSectionFromURL();
		D.translateElements();
	},
	
	/*
	 * Loads the map HTML into the map content plate.
	 */
	loadMapPlate: function(pPage)
	{
		if (I.isMapPlateInitialized)
		{
			return;
		}
		I.isMapPlateInitialized = true;
		if (pPage)
		{
			$(I.cPlateMenuPrefix + "Map").trigger("click");
		}
		I.loadStylesheet("features");
		$("#plateMap").append(I.cThrobber).load(U.getPageSrc("map"), function()
		{
			I.bindAfterAJAXContent(I.PlateEnum.Map);
			
			// Hide map dependent sections in mobile mode
			if (I.ModeCurrent === I.ModeEnum.Mobile)
			{
				$(".mapOnly").remove();
			}
			
			// Create daily markers
			$("#headerMap_Daily").one("click", function()
			{
				G.generateAndInitializeDailies();
				I.isSectionLoaded_Daily = true;
			});
			// Create node markers and checkboxes
			$("#headerMap_Resource").one("click", function()
			{
				G.generateAndInitializeResources();
			});
			// Create JP checklist
			$("#headerMap_JP").one("click", function()
			{
				G.generateAndInitializeJPs();
			});
			// Create custom checklists
			$("#headerMap_Personal").one("click", function()
			{
				X.initializePersonalChecklist();
			});
			// Create trading calculator
			$("#headerMap_TP").one("click", function()
			{
				E.initializeCalculator();
				E.initializeTrading();
				E.initializeExchange();
			});
			// Create notepad
			$("#headerMap_Notepad").one("click", function()
			{
				X.initializeNotepad();
			});
			// Create collectible markers and checkboxes
			$("#headerMap_Collectible").one("click", function()
			{
				G.generateCollectiblesUI();
			});
			// Create guild mission subsections
			$("#headerMap_Guild").one("click", function()
			{
				G.generateGuildUI();
			});
			I.qTip.init("#plateMap label");
			
			// Open a section if initially requested
			if (typeof pPage === "string")
			{
				$("#plateBeamIcon_" + pPage).trigger("click");
			}
		});
	},
	
	/*
	 * Loads the help HTML into the help content plate.
	 */
	loadHelpPlate: function()
	{
		$("#plateHelp").append(I.cThrobber).load(U.getPageSrc("help"), function()
		{
			I.bindAfterAJAXContent(I.PlateEnum.Help);
			I.bindInputSelect(".jsCopyCode");
		});
	},
	
	/*
	 * Binds Map pane special effects on HUD GUI elements.
	 */
	initializeHUD: function()
	{
		U.convertModeLink(".hudHelpColumn a");
		U.convertExternalLink(".hudHelpColumn a");
		I.bindScrollbar(".hudHelpScroll");
		$(".hudPeripheral").css({visibility: "visible"});
	},
	
	/*
	 * Shows an icon link to the main site without URL parameters.
	 */
	showHomeLink: function()
	{
		var home = $("#itemHome").css({display: "table"});
		$("<a id='itemHomeButton' title='&lt;dfn&gt;Switch back to full site.&lt;/dfn&gt;' href='./'>"
			+ " <img id='iconSimpleHome' src='img/ui/about.png' /></a>").appendTo(home);
		I.qTip.init(home);
	},
	
	/*
	 * Changes program look based on mode.
	 */
	enforceProgramMode: function()
	{
		// Projection mode is overlay mode but tailored for full view over the game
		if (I.ModeCurrent === I.ModeEnum.Projection)
		{
			var gamebuttonsheight = 32;
			I.ModeCurrent = I.ModeEnum.Overlay;
			I.isProjectionEnabled = true;
			$("#panelMap, #windowMain").css({background: "transparent"});
			$("#itemVignette").remove();
			$("#itemProjector, #prjController").show();
			// Move the timeline lower so it doesn't block the game buttons on top left
			$("#itemTimeline").css({top: gamebuttonsheight + "px"});
			// Bind special buttons
			$("#prjController").contextmenu(function(pEvent)
			{
				pEvent.preventDefault();
				var htmlidprefix = "#" + P.MapSwitchWebsite;
				I.showContextMenu(htmlidprefix + "Context");
			});
			$("#prjToggleTerrain").click(function()
			{
				P.MapSwitchObject.toggleFloor();
			});
			$("#prjToggleHUD").click(function()
			{
				$("#opt_bol_showHUD" + P.MapSwitchSuffix).trigger("click");
			});
			$("#prjTogglePanel").click(function()
			{
				$("#opt_bol_showPanel").trigger("click");
			});
			// Initialize this submode
			if (false) // Temporary disable
			{
				U.getScript(U.URL_API.ThreeDimensional, function()
				{
					J.initializeProjection();
				});
			}
		}
		
		// Load respective stylesheet
		I.loadStylesheet(I.ModeCurrent);
		
		// Structural and behavioral changes
		switch (I.ModeCurrent)
		{
			case I.ModeEnum.Website:
			{
				$("head").append("<link rel='alternate' media='only screen and (max-width: 640px)' href='http://gw2timer.com/?mode=Mobile'>");
			} break;
			case I.ModeEnum.Overlay:
			{
				I.cPANE_MENU_HEIGHT = 32;
				I.loadImg("#mapGPSIcon");
				$(".hudSelect").removeAttr("title");
				K.styleClock();
				// Manually assign F5 key browser reload functionality
				$(document.body).on("keydown", this, function (event)
				{
					if (event.keyCode === 116)
					{
						window.location.reload(true);
					}
				});
			} break;
			case I.ModeEnum.Simple:
			{
				I.isMapEnabled = false;
				I.showHomeLink();
				// Readjust panels
				$("#itemTimeline").appendTo("#panelApp");
				$("#itemLanguage").insertAfter("#itemHome");
				I.readjustSimple();
				K.styleClock();
			} break;
			case I.ModeEnum.Mobile:
			{
				I.isMapEnabled = false;
				I.isCustomScrollEnabled = false;
				I.showHomeLink();
				$("head").append("<meta name='viewport' content='width=device-width, initial-scale=1' />")
					.append("<link rel='canonical' href='http://gw2timer.com' />");
				$("#itemLanguage").insertAfter("#itemHome");
			} break;
			case I.ModeEnum.Tile:
			{
				I.isMapEnabled = false;
				H.isVertical = false;
				I.showHomeLink();
				$("#itemLanguage").prependTo("#plateChains");
				$("#itemLanguage").insertAfter("#itemHome");
				// Show the timeline if the website is not embedded
				if (I.isProgramEmbedded)
				{
					// Less whitespace for embedded window
					$("<style type='text/css'>.chnBar, .chnSlot {margin-bottom:4px !important; margin-right: 4px !important;}</style>").appendTo("head");
				}
				else
				{
					var timelinemargintop = parseInt($("#chnProgressBar").css("margin-top"));
					$("#itemTimeline").prependTo("#panelApp");
					// Move the chain progress bar to the top of the screen if scrolled past the timeline
					$("#windowMain").scroll(function(){
						if ($("#itemTimeline").is(":visible"))
						{
							$("#chnProgressBar").css("margin-top", Math.max(
								-$("#itemTimeline").outerHeight(true) + timelinemargintop,
								-$("#windowMain").scrollTop())
							);
						}
						else
						{
							$("#chnProgressBar").css("margin-top", timelinemargintop);
						}
					});
					// Dashboard
					var dashboard = $("#itemDashboard");
					var dashboardcontainer = $("<div id='dsbContainerOuter'></div>").appendTo("#plateChains");
					dashboard.appendTo(dashboardcontainer);
					$(".dsbTab").click(function()
					{
						setTimeout(function()
						{
							I.updateScrollbar("#windowMain");
							I.scrollToElement(dashboard);
						}, 600); // Time for the dashboard section to animate toggle
					});
				}
				I.bindScrollbar("#windowMain");
			} break;
		}
		if (I.isMapEnabled === false)
		{
			$("#itemDisplayButton").remove();
		}
		
		// Change CSS for overlay specific
		if (I.ModeCurrent === I.ModeEnum.Website && I.isProgramEmbedded === false)
		{
			$("#paneClockIcons img").addClass("curZoom");
		}
		else
		{
			$("#paneClockIcons img").addClass("curClick");
		}
		
		// Also streamline other UI elements if website is embedded in another website
		if (I.isProgramEmbedded)
		{
			$("#itemWarning, .hudTitle").remove();
			$(".btnSite, .hudLinks").hide();
		}
		
		// Disable dashboard for non-using modes
		if (I.ModeCurrent === I.ModeEnum.Simple)
		{
			if (I.ModeCurrent !== I.ModeEnum.Overlay)
			{
				H.isDashboardEnabled = false;
			}
		}
		
		// Set the initial plate on the app panel
		if (I.isProgramEmbedded || I.ModeCurrent === I.ModeEnum.Mobile || I.ModeCurrent === I.ModeEnum.Tile)
		{
			I.setInitialPlate(I.PlateEnum.Chains);
			if (I.isMapEnabled === false)
			{
				// Move the alarm options from the map popup to the app panel
				$("#mapAlarmPopup").appendTo("#chnAlarm").removeClass("hudPopup").addClass("cntPopup");
				I.loadImg($("#chnAlarm"));
			}
			if (I.ModeCurrent !== I.ModeEnum.Tile)
			{
				K.styleClock();
			}
		}
		else
		{
			I.setInitialPlate(I.PlateEnum.Directory);
		}
	},
	getMode: function()
	{
		return (I.isProjectionEnabled) ? I.ModeEnum.Projection : I.ModeCurrent;
	},
	setInitialPlate: function(pPlate)
	{
		// Default content plate
		I.PageCurrent = pPlate;
		$("#plate" + pPlate).show();
		$(I.cPlateMenuPrefix + pPlate).addClass("plateMenuButtonActive");
	},
	
	/*
	 * Changes appearance after program inactivity, to be called repeatedly.
	 */
	sleepOverlay: function()
	{
		if (I.isSleeping)
		{
			I.isSleeping = false;
			$(".jsSleepable, .hudPeripheral, .btnWindow").removeClass("jsSleeped");
		}
		window.clearTimeout(I.SleepTimeout);
		I.SleepTimeout = setTimeout(function()
		{
			if (!M.isMouseOnHUD && !W.isMouseOnHUD)
			{
				var filterclass = (I.isProjectionEnabled) ? ".mapDisplayButton" : "";
				I.isSleeping = true;
				$(".jsSleepable, .hudPeripheral, .btnWindow").not(filterclass).addClass("jsSleeped");
			}
		}, I.cMSECONDS_SLEEP);
	},
	
	/*
	 * Binds functions that activate when the user resizes the browser/screen/window.
	 */
	bindWindowReadjust: function()
	{
		$(window).on("resize", $.throttle(200, function()
		{
			// Resize elements' CSS properties to be more legible in the current window size
			switch (I.ModeCurrent)
			{
				case I.ModeEnum.Simple: I.readjustSimple(); break;
				case I.ModeEnum.Tile: I.readjustTile(); break;
			}
			
			// Resize elements that may have overflowed when the user resized the browser
			if (W.isWvWLoaded)
			{
				W.readjustLeaderboard();
				W.readjustLog();
			}
			if (A.isAccountInitialized)
			{
				A.adjustAccountPanel();
			}
		}));
	},
	
	/*
	 * Centers the clock in the browser window.
	 */
	readjustSimple: function()
	{
		var height = $(window).height() / 2;
		var width = $(window).width() / 2;
		var half = I.cPANE_CLOCK_HEIGHT / 2;
		$("#paneSimple").css({
			"margin-top": height - half - 72
		});
		$("#paneClock").css(
		{
			"margin-top": height - half,
			"margin-left": width - half
		});
	},
	readjustTile: function()
	{
		if (I.ModeCurrent !== I.ModeEnum.Tile)
		{
			return;
		}
		var result = T.stepFunction($(window).width(), 200, 14, 22, 1);
		$(".chnTitle h1, .chnTitle time").css({fontSize: result + "px"});
	},
	
	/*
	 * Initializes custom tooltips and sets mouse-tooltip behavior.
	 */
	initializeTooltip: function()
	{
		// Bind these tags with the title attribute for tooltip
		I.qTip.init("#mapAlarm img, a, ins, kbd, span, time, fieldset, label, input, button");
	},
	
	/*
	 * qTip tooltip plugin by Craig Erskine http://qrayg.com (modified from 2008 version)
	 */
	qTip:
	{
		name: "qTip",
		offsetX: 0,
		offsetY: 0,
		TipElm: null,
		/*
		 * Binds matched elements with title attribute to show a popup div with
		 * that title as content when hovered over the element.
		 * @param string s jQuery selector.
		 */
		start: function()
		{
			this.TipElm = document.createElement("div");
			this.TipElm.setAttribute("id", this.name);
			document.body.appendChild(this.TipElm);
			document.onmousemove = $.throttle(I.cTOOLTIP_MOUSEMOVE_MS, function(pEvent)
			{
				I.qTip.move(pEvent);
			});
		},
		init: function(pSelector)
		{
			var elm, content;
			$(pSelector).each(function()
			{
				elm = $(this)[0];
				content = elm.getAttribute("title");
				if (elm && content)
				{
					elm.setAttribute(I.cTooltipAttribute, content);
					elm.removeAttribute("title");
					elm.removeAttribute("alt");
					elm.onmouseenter = function()
					{
						I.qTip.show(this.getAttribute(I.cTooltipAttribute));
					};
					elm.onmouseleave = function()
					{
						I.qTip.hide();
					};
				}
			});
		},
		reinit: function()
		{
			$(".jsTitle").each(function()
			{
				$(this).removeClass("jsTitle");
				I.qTip.init($(this));
			});
		},
		move: function(pEvent)
		{
			if (pEvent)
			{
				I.posX = pEvent.pageX;
				I.posY = pEvent.pageY;
			}
			var tipwidth = $("#qTip").width();
			var tipheight = $("#qTip").height();
			var tipwidthplus = tipwidth + I.cTOOLTIP_OVERFLOW_ADD_X;
			var tipheightplus = tipheight + I.cTOOLTIP_OVERFLOW_ADD_Y;
			var winwidth = $(window).width();
			var winheight = $(window).height();
			
			// Mouse movement as detector for program use
			if (I.ModeCurrent === I.ModeEnum.Overlay)
			{
				I.sleepOverlay();
			}
			
			/*
			 * Make the tooltip appear within the visible window by detecting current
			 * tooltip size and mouse position.
			 */
			this.offsetX = I.cTOOLTIP_OFFSET_ADD_X;
			this.offsetY = -(tipheight + I.cTOOLTIP_OFFSET_ADD_Y);
			// Tooltip overflows top edge
			if (I.posY + this.offsetY < 0)
			{
				if (I.posY + tipheightplus < winheight)
				{
					this.offsetY = I.cTOOLTIP_OVERFLOW_ADD_Y;
				}
				else
				{
					this.offsetY = winheight - (tipheight + I.posY + I.cTOOLTIP_PADDING_ADD_Y);
				}
			}
			// Tooltip overflows right edge threshold
			if ((I.posX + tipwidthplus > winwidth) || (I.posX + I.cPANEL_WIDTH > winwidth))
			{
				// For case when window is too small and tooltip overflows left edge
				if (I.posX - tipwidthplus < 0)
				{
					this.offsetX = -I.posX;
				}
				else
				{
					this.offsetX = -tipwidthplus;
				}
			}
			
			this.TipElm.style.left = I.posX + this.offsetX + "px";
			this.TipElm.style.top = I.posY + this.offsetY + "px";
		},
		show: function(pAttributeName)
		{
			this.TipElm.innerHTML = pAttributeName;
			this.TipElm.style.display = "block";
			this.TipElm.classList.add("cssFadeIn");
			for (var i = 0; i < I.cTOOLTIP_NUM_RERENDER; i++)
			{
				I.qTip.move();
			}
		},
		hide: function()
		{
			this.TipElm.innerHTML = "";
			this.TipElm.style.display = "none";
			this.TipElm.classList.remove("cssFadeIn");
		}
	}
};

/* =============================================================
 * Executions, the order matters!
 * ============================================================= */
I.initializeFirst(); // initialize variables that need to be first
O.initializeOptions(); // load stored or default options to the HTML input
T.initializeSchedule(); // compute event data and write HTML
P.initializeMap(); // instantiate the map and populate it
K.initializeClock(); // start the clock and infinite loop
I.initializeLast(); // bind event handlers for misc written content




});//]]>// END OF JQUERY NEST